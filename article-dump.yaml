---
- :slug: method-lookup-1
  :title: Ruby's method lookup path, Part 1
  :summary: Discover the complicated, multi-step dance that is the Ruby method lookup
    path.
  :published: 2010-11-09 00:00:00.000000000 Z
  :issue_number: '1.1'
  :volume: 1
  :body: "I decided to start off this newsletter with one of the most basic but essential
    pieces of knowledge you can have about Ruby's object model: the way it looks up
    methods. Let's do a little exploration by working through a few examples.\r\n\r\nBelow
    we have a simple report class tasked with performing some basic data manipulations
    and then producing some text output.\r\n\r\n```ruby\r\nclass Report\r\n  def initialize(ledger)\r\n
    \   @balance          = ledger.inject(0) { |sum, (k,v)| sum + v }\r\n    @credits,
    @debits = ledger.partition { |k,v| v > 0 }\r\n  end\r\n\r\n  attr_reader :credits,
    :debits, :balance\r\n\r\n  def formatted_output\r\n    \"Current Balance: #{balance}\\n\\n\"
    +\r\n    \"Credits:\\n\\n#{formatted_line_items(credits)}\\n\\n\" +\r\n    \"Debits:\\n\\n#{formatted_line_items(debits)}\"\r\n
    \ end\r\n\r\n  def formatted_line_items(items)\r\n    items.map { |k, v| \"#{k}:
    #{'%.2f' % v.abs}\" }.join(\"\\n\")\r\n  end\r\nend\r\n```\r\n\r\nThe following
    example demonstrates how we'd make use of this class.\r\n\r\n```ruby\r\nledger
    = [ [\"Deposit Check #123\", 500.15],\r\n           [\"Fancy Shoes\",       -200.25],\r\n
    \          [\"Fancy Hat\",          -54.40],\r\n           [\"ATM Deposit\",       1200.00],\r\n
    \          [\"Kitteh Litteh\",       -5.00] ]\r\n\r\nreport = Report.new(ledger)\r\nputs
    report.formatted_output\r\n```\r\n\r\nAnd for those who don't want to take the
    time to copy and paste this code and run it locally, the actual output is shown
    below.\r\n\r\n```\r\nCurrent Balance: 1440.5\r\n\r\nCredits:\r\n\r\nDeposit Check
    #123: 500.15\r\nATM Deposit: 1200.00\r\n\r\nDebits:\r\n\r\nFancy Shoes: 200.25\r\nFancy
    Hat: 54.40\r\nKitteh Litteh: 5.00\r\n```\r\n\r\nWhile not particularly pretty,
    this report is mostly what we'd expect to see. You can probably imagine how this
    information might be embedded within another report, such as an email-based form
    letter with some header and footer information. One possible way to do this would
    be through class inheritance, as in the example below.\r\n\r\n```ruby\r\nrequire
    \"date\"\r\n\r\nclass EmailReport < Report\r\n  def header\r\n    \"Dear Valued
    Customer,\\n\\n\"+\r\n    \"This report shows your account activity as of #{Date.today}\\n\"\r\n
    \ end\r\n\r\n  def banner\r\n    \"\\n............................................................\\n\"\r\n
    \ end\r\n\r\n  def formatted_output\r\n    header + banner + super + banner +
    footer\r\n  end\r\n\r\n  def footer\r\n    \"\\nWith Much Love,\\nYour Faceless
    Banking Institution\"\r\n  end\r\nend\r\n```\r\n\r\nWe only need to make a minor
    change to our calling code to make use of this new class.\r\n\r\n```ruby\r\nledger
    = [ [\"Deposit Check #123\", 500.15],\r\n           [\"Fancy Shoes\",       -200.25],\r\n
    \          [\"Fancy Hat\",          -54.40],\r\n           [\"ATM Deposit\",       1200.00],\r\n
    \          [\"Kitteh Litteh\",       -5.00] ]\r\n\r\nreport = EmailReport.new(ledger)\r\nputs
    report.formatted_output\r\n```\r\n\r\nBelow you can see what the new output ends
    up looking like.\r\n\r\n```\r\nDear Valued Customer,\r\n\r\nThe following report
    shows your account activity as of 2010-11-09\r\n\r\n............................................................\r\nCurrent
    Balance: 1440.5\r\n\r\nCredits:\r\n\r\nDeposit Check #123: 500.15\r\nATM Deposit:
    1200.00\r\n\r\nDebits:\r\n\r\nFancy Shoes: 200.25\r\nFancy Hat: 54.40\r\nKitteh
    Litteh: 5.00\r\n............................................................\r\n\r\nWith
    Much Love,\r\nYour Faceless Banking Institution\r\n```\r\n\r\nLooking back at
    the `EmailReport` code, it's easy to see what we've done to produce this new output.
    We've defined a new `formatted_output` method which adds the headers and footers,
    and combined this new behavior with the original behavior of our `Report` class
    by calling `super`. This is the same extension by inheritance pattern that you'll
    learn in any basic computer science course or encounter in any of the reasonably
    traditional object oriented languages out there.\r\n\r\nBut before you go asking
    for a refund and start telling your friends that this newsletter is painfully
    dull, consider this: While many languages have a method lookup path which is based
    on inheritance alone, that isn't even close to being true about Ruby.\r\n\r\nBecause
    Ruby allows for module mixins and per-object behavior, the `super` keyword takes
    on a whole new life in which an object's superclass is the last stop on a five
    part journey through Ruby's object model. The following example proves the point
    by composing a simple string which demonstrates the order in which methods are
    resolved in Ruby.\r\n\r\n```ruby\r\nmodule W\r\n  def foo\r\n    \"- Mixed in
    method defined by W\\n\" + super\r\n  end\r\nend\r\n\r\nmodule X\r\n  def foo\r\n
    \   \"- Mixed in method defined by X\\n\" + super\r\n  end\r\nend\r\n\r\nmodule
    Y\r\n  def foo\r\n    \"- Mixed in method defined by Y\\n\" + super\r\n  end\r\nend\r\n\r\nmodule
    Z\r\n  def foo\r\n    \"- Mixed in method defined by Z\\n\" + super\r\n  end\r\nend\r\n\r\nclass
    A\r\n  def foo\r\n    \"- Instance method defined by A\\n\"\r\n  end\r\nend\r\n\r\nclass
    B < A\r\n  include W\r\n  include X\r\n\r\n  def foo\r\n    \"- Instance method
    defined by B\\n\" + super\r\n  end\r\nend\r\n\r\nobject = B.new\r\nobject.extend(Y)\r\nobject.extend(Z)\r\n\r\ndef
    object.foo\r\n  \"- Method defined directly on an instance of B\\n\" + super\r\nend\r\n\r\nputs
    object.foo\r\n```\r\n\r\nWhen we run this code, we see the following output, which
    traces the `super` calls all the way up from the method defined directly on our
    object to its superclass.\r\n\r\n```\r\n- Method defined directly on an instance
    of B\r\n- Mixed in method defined by Z\r\n- Mixed in method defined by Y\r\n-
    Instance method defined by B\r\n- Mixed in method defined by X\r\n- Mixed in method
    defined by W\r\n- Instance method defined by A\r\n```\r\n\r\nAs promised, it's
    a five step journey. Particularly, the above is a demonstration that Ruby methods
    are looked up in the following order:\r\n\r\n1. Methods defined in the object's
    singleton class (i.e. the object itself)\r\n1. Modules mixed into the singleton
    class in reverse order of inclusion\r\n1. Methods defined by the object's class\r\n1.
    Modules included into the object's class in reverse order of inclusion\r\n1. Methods
    defined by the object's superclass.\r\n\r\nThis process is then repeated all the
    way up the inheritance chain until `BasicObject` is reached. Now that we know
    the basic order, we should stop and consider a few questions about what we've
    discussed so far.\r\n\r\n### Open Questions / Things To Explore\r\n\r\n* Why would
    we want or need five distinct places to define methods? Do these other options
    really gain us anything over ordinary inheritance?\r\n\r\n* Does this change the
    way that classic object oriented design principles apply to Ruby? For example,
    how well do you think direct translations of design patterns map to Ruby?\r\n\r\n*
    Think of each place you can define a method in Ruby, and consider which ones are
    important for every day use, and which ones are edge cases. Is per-object behavior
    really that useful?\r\n\r\n* It is rare to use all of these options at once, and
    the only reason it was done in this exercise was for demonstration purposes. But
    taken individually, can you think of a practical use for each way of defining
    Ruby methods?\r\n\r\n* What are some disadvantages for each technique shown here?\r\n\r\nI
    will address these points and also go over some practical applications in the
    next issue, but please share your own thoughts in the comments section below.\r\n\r\n>
    **NOTE:** This article has also been published on the Ruby Best Practices blog.
    There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/030-issue-1-method-lookup.html#disqus_thread)
    \r\nover there worth taking a look at."
- :slug: method-lookup-2
  :title: Ruby's method lookup path, Part 2
  :summary: Use your knowledge of Ruby's lookup path to determine where to add methods
    in a program.
  :published: 2010-11-11 00:00:00.000000000 Z
  :issue_number: '1.2'
  :volume: 1
  :body: "In [Issue #1](http://practicingruby.com/articles/29) we discussed Ruby's
    lookup\r\npath and proved by example that class inheritance is only a small part
    of the \r\npicture. To recap, Ruby methods are looked up in the following order:\r\n\r\n1.
    Methods defined in the object's singleton class (i.e. the object itself)\r\n1.
    Modules mixed into the singleton class in reverse order of inclusion\r\n1. Methods
    defined by the object's class\r\n1. Modules included into the object's class in
    reverse order of inclusion\r\n1. Methods defined by the object's superclass, i.e.
    inherited methods\r\n\r\nThe example we looked at in the previous issue just showed
    the mechanics of how the above process plays out, it didn't really hint at practical
    use cases. Today, we'll look at a scenario for each of these options and discuss
    some of the up and downs that come along with them. Rather than presenting the
    examples in method lookup order, I'll try to start with the most common ones and
    work my way out to the more special purpose ones.\r\n\r\n> **NOTE:** In a comment
    on issue #1, <a href=\"http://twitter.com/jeg2\">@JEG2</a> correctly pointed out
    that this roadmap doesn't account for what happens after the whole class hierarchy
    is walked. Once `BasicObject` is reached, Ruby starts from the bottom again calling
    the `method_missing` hook, which is essentially an implicit step 6. I left this
    detail out for the sake of simplicity, but it's very important to at least be
    aware of.\r\n\r\n### When to use ordinary class definitions\r\n\r\nThe following
    code implements a simple timer that can write out a timestamp to a file and read
    it back later to determine elapsed time. Study it and consider its design.\r\n\r\n```ruby\r\nclass
    Timer\r\n  MissingTimestampError = Class.new(StandardError)\r\n\r\n  def initialize(dir=Turbine::Application.config_dir)\r\n
    \   @file = \"#{dir}/timestamp\"\r\n  end\r\n\r\n  def write_timestamp\r\n    File.open(@file,
    \"w\") { |f| f << Time.now.utc.to_s }\r\n  end\r\n  \r\n  def timestamp\r\n    raise
    MissingTimestampError unless running?\r\n    Time.parse(File.read(@file)).localtime\r\n
    \ end\r\n  \r\n  def elapsed_time\r\n    (Time.now.utc - timestamp.utc) / 60.0
    / 60.0\r\n  end\r\n\r\n  def clear_timestamp\r\n    FileUtils.rm_f(@file)\r\n
    \ end\r\n\r\n  def running?\r\n    File.exist?(@file)\r\n  end\r\nend \r\n```\r\n\r\nWhen
    deciding if just a plain old class definition will do, I often ask myself several
    questions.\r\n\r\n* Is it likely is that I'll need to customize this code later
    for another purpose? \r\n* Is this code meant to be interacted with and extended
    by third party code? \r\n* Are there any common behaviors in this code I'd want
    to extract and use elsewhere?\r\n\r\nBecause this `Timer` class definition comes
    from a real project of mine, I can tell you that the answer to all of the above
    questions in the context this code is intended to be used is a simple 'no'. What
    this indicates to me is that while extension might be necessary at some point
    down the line, there is no immediate need to design for extensibility, and so
    we go with the most simple option that could possibly work.\r\n\r\nAnother indicator
    that a plain class definition might be appropriate here is the fact that most
    of the functionality in this class is centered around manipulating a particular
    bit of state, the <i>timestamp</i> file. The problem we are trying to solve is
    quite a narrow one, and a single-minded class definition reflects that.\r\n\r\nThe
    downside to designing code this way is that it does make third-party modification
    harder. If for example, you wanted to add some behavior around the `timestamp()`
    method, you have three options, none of them great:\r\n\r\n * You can create a
    subclass of `Timer`, but your new class won't be used by the application that
    defined `Timer` without modification.\r\n\r\n * You can create an instance of
    `Timer` and then add per-object behavior, but this has the same problem as subclassing.\r\n\r\n
    * You can use `alias_method` to create a monkeypatch to `Timer`, which will inject
    your code into the original application, but runs risks of naming clashes and
    other nasty things.\r\n\r\nWhile it ultimately depends on how the calling code
    uses this `Timer` class, and what features are provided for making extensions,
    it's not going to be trivial to modify systems built in this fashion. But because
    we already determined this was a narrow bit of functionality designed to be used
    internally within a larger application, it isn't a problem that it isn't super
    extendable.\r\n\r\nMany of the rules that apply to defining your own classes also
    apply to inheritance based designs, so let's investigate that now.\r\n\r\n###
    When Inheritance Makes Sense\r\n\r\nFor those working with Rails, you already
    encounter class inheritance on a daily basis, through the ActiveRecord ORM. Despite
    the terrible choice of name, `ActiveRecord::Base` is a reasonable example of when
    class inheritance is a decent option.\r\n\r\nConsider the typical ActiveRecord
    model, which is often extremely simple:\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base
    \r\n  has_many :comments\r\n\r\n  validates_presence_of :name, :email\r\nend\r\n```\r\n\r\nWhile
    it's true that in most interesting applications, models do become more complex,
    implementing intricate business logic, the amount of functionality added by the
    user is dwarfed by what ActiveRecord provides.\r\n\r\nOne key thing to notice
    about a subclass of `ActiveRecord::Base` is that by design, there is really no
    incentive to manage your own state. All state manipulation is passed upwards to
    the parent class to handle, which typically involves using a pre-configured database
    connection also managed by the parent class to persist whatever state is required.\r\n\r\nInheritance
    makes sense in situations where complex state manipulations are handled by the
    parent class. This is especially true if the parent class provides a boat-load
    of functionality which dwarfs the customization needs of the child class. Since
    both things are true about a typical ActiveRecord model, the design is certainly
    a reasonable choice.\r\n\r\nHowever, before you start modeling your own projects
    after this pattern, you should take a look at the great pains that go into designing
    an extensible parent class. It's outside the scope of this article, but I'd recommend
    reading what <a href=\"http://is.gd/gW558 \">Yehuda Katz has to say about ActiveModel</a>,
    which provides the bulk of ActiveRecord's functionality under the hood.\r\n\r\nBefore
    we move on to other topics, I'd like to offer another example outside of the Rails
    world, just to help further illuminate the pattern.\r\n\r\nThe PDF generation
    library <a href=\"http://prawn.majesticseacreature.com\">Prawn</a> provides a
    class that's designed to be inherited from, `Prawn::Document`. I made use of this
    functionality recently to build a small typesetting library for formatting technical
    articles. While I won't go into much detail here, you can check out the <a href=\"http://github.com/madriska/jambalaya\">implementation
    and example code</a>.\r\n\r\nWhat you'll find in <a href=\"https://github.com/madriska/jambalaya/blob/master/lib/jambalaya.rb\">lib/jambalaya.rb</a>
    is that except for a custom factory method for generating the document, Jambalaya
    introduces no new state, relying on calls to `Prawn::Document` to do all the heavy
    lifting. You can also see that <a href=\"https://github.com/madriska/jambalaya/blob/master/example/rbp_ch1.rb\">examples/rbp_ch1.rb</a>
    gives the illusion of a new special purpose DSL, but that in truth, almost all
    the work is being done by Prawn under the hood.\r\n\r\nUnfortunately, the disadvantages
    of class inheritance become clear the farther away you get from these scenarios
    in which the subclass truly is analogous to its parent class. You get only one
    parent class, and chaining to it is a commitment that you must be willing to respect
    all the way up the hierarchy. For the scenarios we've shown, the benefits outweigh
    the drawbacks, but for many others, they do not.\r\n\r\nIn Issue #1, I asked the
    question of which techniques are special cases, and which are meant to be used
    commonly. While not rare by any means, inheritance falls closer to being a special
    case than it does to being the first tool you should reach for. If this comes
    as a surprise to you, it's about time for us to talk about modules.\r\n\r\n###
    Mixing modules into a class\r\n\r\nIf you want to see the power of mixins, you
    need to look no farther than Ruby's\r\n`Enumerable` module. Rather than relying
    on a common base class to provide\r\niterators for collections, Ruby mixes in
    the `Enumerable` module into its core structures, \r\nincluding `Array` and `Hash`.
    This is where a whole host of useful methods come from, \r\nincluding `map`, `select`,
    and `inject`.\r\n\r\nThe beauty of this design is that it imposes a much lighter
    contract than the rigid is-a relationship enforced by class inheritance. Instead,
    mixins focuses on what you can do with an object rather than what that object
    is. It makes perfect sense to say both `Hash` and `Array` objects have elements
    that can be enumerated over. As far as Ruby is concerned, the same can be true
    about any object which defines an `each()` method.\r\n\r\nLet's take a look at
    a custom Ruby class which implements each and mixes in\r\n`Enumerable`. It is
    a simple file-backed numerical queue, from the same project \r\nour `Timer` came
    from.\r\n\r\n```ruby\r\nclass Queue \r\n  include Enumerable\r\n\r\n  def initialize(file)\r\n
    \   @file = file\r\n  end\r\n\r\n  def entries\r\n    return [] if empty?\r\n\r\n
    \   File.read(@file).split(\"\\n\").map { |e| e.to_f }\r\n  end\r\n\r\n  def each\r\n
    \   entries.each { |e| yield(e) }\r\n  end\r\n\r\n  # additional unrelated methods
    omitted\r\nend\r\n```\r\n\r\nThe data file this queue wraps looked something similar
    to the data shown below.\r\n\r\n```\r\n125.75\r\n100.25\r\n300.50\r\n700\r\n```\r\n\r\nGiven
    a properly formatted input file, it's possible to interact with the `Queue` like
    any other `Enumerable` object.\r\n\r\n```ruby\r\nqueue = Queue.new(\"queue.txt\")\r\np
    queue.map { |x| \"Amount: #{x}\" }\r\np queue.inject { |x,y| x + y }\r\n```\r\n\r\nIf
    you go ahead and try this yourself, you'll find that it will work identically
    if you simply replace the first line with an array, as shown below.\r\n\r\n```ruby\r\nqueue
    = [125.75, 100.25, 300.50, 700]\r\np queue.map { |x| \"Amount: #{x}\" }\r\np queue.inject
    { |x,y| x + y }\r\n```\r\n\r\nThis simple example hints at the real beauty of
    `Enumerable` in particular, and the mixin technique in general. In reality, my
    `Queue` object and Ruby's `Array` class have very little in common. But in the
    context of how you can iterate over the two objects, they can share a matching
    interface for the things they do have in common.\r\n\r\nThis is where modules
    shine. They allow some of the benefits of inheritance in that they allow implementation
    sharing, but without the requirement of organizing things into a rigid class hierarchy.
    Things get even more interesting when you remember to tie your understanding of
    how modules work back to the way Ruby looks up methods.\r\n\r\n### Exploiting
    the lookup order of mixins\r\n\r\nMethods are looked up in mixins in reverse order
    of their inclusion, giving the last module you mixed in a priority spot in the
    lookup path. A pleasant effect that arises naturally from this rule is that it
    provides an elegant technique for monkey patching that does not rely on method
    aliasing. Let's look at a patch that uses method aliasing, and how it could be
    written differently.\r\n\r\nBelow is the code that Rubygems uses to patch `require`
    to add in gem loading functionality. Since `require` is just a method in Ruby,
    and not a keyword, the patch is relatively straightforward in pure Ruby.\r\n\r\n```ruby\r\nmodule
    Kernel\r\n  alias gem_original_require require\r\n\r\n  def require(path) # :doc:\r\n
    \   gem_original_require path\r\n  rescue LoadError => load_error\r\n    if load_error.message.end_with?(path)\r\n
    \     if Gem.try_activate(path)\r\n        return gem_original_require(path)\r\n
    \     end\r\n    end\r\n\r\n    raise load_error\r\n  end\r\nend \r\n```\r\n\r\nAt
    the time this code was written, using method aliasing was the standard way of
    changing the behavior of an existing method. Aliases are used to make a copy of
    an existing method before modifying it, which allows customized code to delegate
    to the original method. This permits re-using the parts of the original method
    that are needed while (hopefully) preventing issues with backwards compatibility.
    The general approach works well, but it increases the chances that the copied
    methods will clash with each other as the chain gets longer, and also adds a number
    of superfluous methods to objects that are really just implementation details.\r\n\r\nTaking
    advantage of Ruby's method lookup order in modules, we can get around the issues
    with aliasing by writing a patch similar to the one shown below.\r\n\r\n```ruby\r\nmodule
    GemCustomRequire\r\n  def require(path) # :doc:\r\n    super\r\n  rescue LoadError
    => load_error\r\n    if load_error.message.end_with?(path)\r\n      if Gem.try_activate(path)\r\n
    \       return super\r\n      end\r\n    end\r\n\r\n    raise load_error\r\n  end
    \  \r\nend \r\n\r\nclass Object\r\n  include GemCustomRequire\r\nend\r\n```\r\n\r\nBecause
    the original `require()` method is defined within the `Kernel` module and not
    on `Object` itself, we can include our `GemCustomRequire` module and then use
    `super` to call the original require. The result is code that looks more natural
    and ordinary, reducing the amount of magic you need to know in order to understand
    it. It also completely avoids the possible issue of copied methods clashing with
    one another.\r\n\r\nThis ability to do safe monkeypatching that modules affords
    us has been picking up steam within popular Ruby projects. Rails 3 was in a large
    extent designed to afford this sort of modularity, for the express purpose of
    making it easier for third party plugins to hook into the system in a more graceful
    way than method aliasing. Other projects that require a high degree of extensibility
    are quickly following in its footsteps, which is a good thing.\r\n\r\nWhile you're
    less likely to run into this question in application code than you are in library
    or framework code, knowing what mixins can gain you in terms of extensibility
    can really come in handy. There are tons of other good things to say about modules,
    but we'll need to save those for another day.\r\n\r\n### Per Object Behavior\r\n\r\nI
    was originally going to go into detail about mixing modules into individual objects
    as well as defining singleton methods. However, I think that can be a topic all
    of it's own, and I want to give it a proper treatment rather than tacking it on
    to the end of an already lengthy newsletter.\r\n\r\nI promise we'll revisit it
    soon, but for those who absolutely want to explore potential uses of these techniques
    right away, I offer two small challenges.\r\n\r\n1) Rather than using a framework
    for testing stubs, experiment with something like the code below next time you're
    writing tests.\r\n\r\n```ruby\r\nobj = Object.new\r\n\r\nclass << obj\r\n  def
    my_stubbed_method\r\n\r\n  end\r\nend\r\n```\r\n\r\n2) Rather than re-opening
    a class to add some extra behavior, experiment with mixing modules into individual
    objects to get the extra features you need.\r\n\r\n```ruby\r\nmodule MathHelpers\r\n
    \ def sum\r\n    inject { |x,y| x + y }\r\n  end\r\n\r\n  def average\r\n    sum.to_f
    / length\r\n  end\r\nend\r\n\r\narray = [1,2,3]\r\narray.extend(MathHelpers)\r\np
    array.average\r\n```\r\n\r\nIf you try these ideas out, you'll almost certainly
    find uses for them in other\r\ncontexts, too.\r\n\r\n### Reflections\r\n\r\nHopefully
    you've learned something new about Ruby's method lookup rules, or at least been
    given some new things to think about and explore. If you've come from a background
    in which inheritance has been your only tool, you will likely have to retrain
    yourself a bit to make full use of what Ruby has to offer.\r\n\r\nWhenever you
    compare one of these options to the other, consider your context\r\nand how much
    the advantages and disadvantages of each technique affect your\r\nparticular situation.
    The correct approach always depends on that context, and\r\nif in doubt, experiment
    and see what works best.\r\n\r\nMore discussion on this topic is welcome in the
    comments section below. While I wrote this article a while ago, I am happy to
    jump back into the topic as long as folks have interesting ideas and questions
    to share.\r\n  \r\n> **NOTE:** This article has also been published on the Ruby
    Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/031-issue-2-method-lookup.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: configurable-applications-1
  :title: Writing Configurable Applications, Part 1
  :summary: Learn what not to do when configuring applications, then explore a simple
    YAML-based configuration.
  :published: 2010-11-16 00:00:00.000000000 Z
  :issue_number: '1.3'
  :volume: 1
  :body: "Ruby developers tend to prefer convention over configuration, but that doesn't
    mean our applications are configuration-free.  If you're doing serious software
    development, it's likely that at least some of your projects depend on some sort
    of configuration data. Whether you simply need to store database credentials,
    an API key, or something much more complicated, it's important to know how to
    do so in a way that is flexible without introducing too much administrative overhead.\r\n\r\nIn
    this two part article series, we'll be talking about the many options Ruby provides
    us for working with configuration data, and what techniques work best in various
    common scenarios. We'll start by showing a single example of a problem and one
    way to solve it, and then go on to discuss various other options in Issue #4.\r\n\r\n###
    Configuration Done Wrong\r\n\r\nThe worst way to work with configuration data
    is to embed it directly within your application. The simple Sinatra application
    shown below is a nice example of what *not* to do.\r\n\r\n```ruby\r\nrequire \"rubygems\"\r\nrequire
    \"sinatra\"\r\nrequire \"active_record\"\r\n\r\nclass User < ActiveRecord::Base;
    end\r\n\r\nconfigure do\r\n  ActiveRecord::Base.establish_connection(\r\n    :adapter
    \ => \"mysql\",\r\n    :host     => \"myhost\",\r\n    :username => \"myuser\",\r\n
    \   :password => \"mypass\",\r\n    :database => \"somedatabase\"\r\n  )\r\nend\r\n\r\nget
    \"/users\" do\r\n  @users = User.all\r\n  haml :user_index\r\nend\r\n```\r\n\r\nThe
    code above establishes a connection to the database on application startup and
    then proceeds to implement a rather simple call to get a full user listing and
    then render a Haml template. With an application this simple, the configuration
    data seems a bit harmless. But with just a moment's thought, it is easy to see
    numerous flaws with this sort of design.\r\n\r\nThe first and most obvious issue
    with this sort of code is security, everyone who looks at its source needs to
    be trusted, as the credentials for the database connection are embedded directly
    within it. Now, this may or may not be a concern depending on who is involved
    with the project, and what other systems are in place to restrict access to production
    systems, but it is important to think about nonetheless.\r\n\r\nIn a field in
    which revision control is a key part of our practices, it's not as simple as removing
    this sensitive information when you decide you no longer want to share it with
    others. Rewriting the history of a repository is straightforward on its own, but
    mixing application and configuration code makes it tricky to do this without jumping
    through a bunch of hoops. This is where the security concerns overlap with maintenance
    issues.\r\n\r\nSuppose you want to share this trivial sinatra application with
    a friend, or even use it on another machine. The in-application configuration
    forces everyone to set up an identical database environment, even if the needs
    of the application may not really call for that. Any change to this configuration
    information would lead to merge conflicts when you try to pull in changes across
    machines, which could become annoying quite fast.\r\n\r\nFortunately, Ruby makes
    writing proper configuration systems easy enough where the only valid reason for
    writing code this way is if you're doing a throwaway spike. Let's see how easily
    we can emulate the way Rails solves this problem in their own framework.\r\n\r\n###
    YAML Based Configurations\r\n\r\nWith slight modifications, we can move our configuration
    out of our application and into a YAML file. We'd like to end up with a database.yml
    file looking quite similar to a standard Rails configuration file, such as the
    one below:\r\n\r\n```\r\ndevelopment:\r\n  adapter: mysql\r\n  database: mydatabase\r\n
    \ username: myuser\r\n  password: mypass\r\n  host: myhost\r\n```\r\n\r\nThrough
    the standard YAML library, we can easily access this data by parsing it into a
    nested hash, as shown in the irb session below.\r\n\r\n```\r\n>> require \"yaml\"\r\n=>
    true\r\n>> YAML.load_file(\"config/database.yml\")\r\n=> {\"development\"=>{\"username\"=>\"myuser\",
    \"adapter\"=>\"mysql\", \r\n   \"database\"=>\"mydatabase\", \"host\"=>\"myhost\",
    \"password\"=>\"mypass\"}}\r\n```\r\n\r\nIf we compare this output to our original
    example of calling `establish_connection()` directly with an explicit configuration
    hash, the following code should be very easy to follow.\r\n\r\n```ruby\r\nrequire
    \"rubygems\"\r\nrequire \"yaml\"\r\nrequire \"sinatra\"\r\nrequire \"active_record\"\r\n\r\nclass
    User < ActiveRecord::Base; end\r\n\r\nconfigure do\r\n  database_config = YAML.load_file(\"config/database.yml\")\r\n
    \ ActiveRecord::Base.establish_connection(database_config)\r\nend\r\n\r\nget \"/users\"
    do\r\n  @users = User.all\r\n  haml :user_index\r\nend\r\n```\r\n\r\nBy removing
    the configuration data from the application code, we have made it so that the
    application code no longer needs to be modified everywhere it runs, provided the
    configuration data is properly set up. We can now safely tell our revision control
    system to ignore the configuration file without it causing many problems.\r\n\r\nNow
    that we've seen a simple problem and a reasonable fix for it, let's ponder a few
    questions so that we can hit some more subtle topics in Issue #4\r\n\r\n### Questions
    and Discussion Points\r\n\r\n* YAML is a nice readable data format with good Ruby
    support, but it can only represent data, which does not allow you to make dynamic
    configuration systems with it. Rails runs its YAML files through ERB to address
    this issue, but what other ways could this problem be solved?\r\n\r\n* How would
    you handle configuration for something like a command line application which may
    be run anywhere on your system? How might you build per-user and per-project configuration
    systems?\r\n\r\n* Suppose you have a project that is mirrored to both Github and
    Heroku, and that you want to run directly from your public sources while providing
    some configuration options in your production environment. How should you handle
    this?\r\n\r\n* What are some important practices to follow when implementing configuration
    systems, regardless of the underlying context and what approach you choose?\r\n\r\nPlease
    feel free to include your answers to these questions in the comments section below,
    along with any other thoughts or questions you might wish to share. I promise
    to reply personally to anyone who leaves a comment!\r\n  \r\n> **NOTE:** This
    article has also been published on the Ruby Best Practices blog. There [may be
    additional commentary](http://blog.rubybestpractices.com/posts/gregory/032-issue-3-configurable.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: configurable-applications-2
  :title: Writing Configurable Applications, Part 2
  :summary: Build dynamic Ruby-based configuration objects.
  :published: 2010-11-18 00:00:00.000000000 Z
  :issue_number: '1.4'
  :volume: 1
  :body: "In [Issue #3](http://practicingruby.com/articles/31), we looked at the downsides\r\nof
    mixing configuration code with application code. We discussed how storing\r\nconfiguration
    data in YAML files can solve many of those issues, but not\r\nall of them. In
    this article, we will explore the limitations of the YAML \r\nformat, and then
    consider the tradeoffs involved in using various \r\nalternative solutions.\r\n\r\n###
    Dynamic Configuration\r\n\r\nIn response to the questions posed by Issue #3, Franklin
    Webber demonstrated\r\nhow YAML's aliasing functionality can be used to reduce
    duplication in\r\na configuration file:\r\n\r\n```\r\ndefault: &DEFAULT\r\n  host:\r\n
    \   name: testsystem\r\n    http_port: '8080'\r\n    username: defaultuser\r\n
    \ database:\r\n    host: db01/db01\r\n    username:\r\n    password:\r\n  test:\r\n
    \   browser: FIREFOX\r\n\r\nwindows_default: &WIN_DEFAULT\r\n  <<: *DEFAULT\r\n
    \ test:\r\n    browser: IE\r\n```\r\n\r\nIn this example, the `default` and `windows_default`
    configurations share almost\r\nthe same attributes, except that browsers differ
    in test mode. Franklin uses\r\naliasing to merge the `DEFAULT` data into the `WIN_DEFAULT`
    entry, solving his\r\nduplication problem. This is a neat way to keep your YAML
    configurations well\r\norganized.\r\n\r\nWhile Franklin shared this example of
    aliasing to illustrate that some dynamic\r\nfunctionality does exist within YAML,
    he acknowledged that the format was still\r\nmostly suited for static data. Even
    though it is possible to reference\r\nvarious entries within the data structure,
    they cannot be manipulated. \r\nThat means that the following concatenation example
    cannot be done in pure \r\nYAML, and would require some additional processing:\r\n\r\n```\r\nhost:\r\n
    \ name: localhost\r\n  port: 3000\r\nweb:\r\n  login_url: #{name}:#{port}/login
    \r\n```\r\n\r\nThis is where we cross the line from problems solved by a data
    format to those\r\nsolved by programming languages. Franklin suggests that running
    the YAML data\r\nthrough Ruby's `eval` method is an option, which is similar to
    how Rails\r\npasses its YAML files through `ERB`. This approach would work, but
    once we \r\nstart going down that road, we need to ask what it would take to implement
    \r\nthe entire configuration in pure Ruby. As you can see in the following example,
    \r\nthe answer is 'not much':\r\n\r\n```ruby\r\nmodule MyApp\r\n  module Config\r\n
    \   HOST = { :name => 'localhost', :port => 3000 }\r\n    WEB  = { :login_url
    =>  \"#{HOST[:name]}:#{HOST[:port]}/login\" }\r\n  end\r\nend\r\n```\r\n\r\nIf
    we drop this snippet into our application code, we run into the same problems\r\nthat
    we saw in the first example in Issue #3. But by defining this module\r\nin its
    own file and requiring that file, those issues are avoided:\r\n\r\n```ruby\r\nrequire
    \"config/my_app_config\"\r\nrequire \"rest_client\"\r\n\r\nmodule MyApp\r\n  module
    Client\r\n    extend self\r\n\r\n    def authenticate(user, password)\r\n      RestClient.post(MyApp::Config::WEB[:login_url],
    \r\n        :user => user, :password => password)\r\n    end\r\n  end\r\nend\r\n\r\nMyApp::Client.authenticate('my_user',
    'seekrit')\r\n```\r\n\r\nUsing ordinary Ruby constants is no more complicated
    than referring to data\r\nstored in a YAML file, but gives you the full power
    of Ruby in your\r\nconfiguration scripts. In more complex configurations, you
    may even build\r\na mini-DSL, as shown in the following example:\r\n\r\n```ruby\r\nAccessControl.configure
    do\r\n  role \"basic\", \r\n    :permissions => [:read_answers, :answer_questions]\r\n
    \ \r\n  role \"premium\", \r\n    :parent      => \"basic\",\r\n    :permissions
    => [:hide_advertisements]\r\n\r\n  role \"manager\", \r\n    :parent      => \"premium\",\r\n
    \   :permissions => [:create_quizzes, :edit_quizzes]\r\n\r\n  role \"owner\",\r\n
    \   :parent      => \"manager\",\r\n    :permissions => [:edit_users, :deactivate_users]\r\nend\r\n```\r\n\r\nWhile
    this looks like vanilla configuration code on the surface, we can see that what
    we're working with are full blown Ruby objects. Here are some examples of how
    this system is used:\r\n\r\n```ruby\r\n>> AccessControl.roles_with_permission(:create_quizzes)\r\n=>
    [\"manager\", \"owner\"]\r\n>> AccessControl[\"premium\"].permissions\r\n=> [:hide_advertisements,
    :read_answers, :answer_questions]\r\n>> AccessControl[\"owner\"].allows?(:edit_users)\r\n=>
    true\r\n>> AccessControl[\"basic\"].allows?(:edit_users)\r\n=> false\r\n```\r\n\r\nThis
    is an advanced configuration system that not only encapsulates some configuration
    data, but also makes it possible to query that data in useful ways. The following
    implementation code illustrates how little magic is involved in building such
    a system.\r\n\r\n```ruby\r\nmodule AccessControl\r\n  extend self\r\n \r\n  def
    configure(&block)\r\n    instance_eval(&block)\r\n  end\r\n\r\n  def definitions\r\n
    \   @definitions ||= Hash.new\r\n  end\r\n\r\n  def role(level, options={})  \r\n
    \   definitions[level] = Role.new(level, options)\r\n  end\r\n\r\n  def roles_with_permission(permission)\r\n
    \   definitions.select { |k,v| v.allows?(permission) }.map { |k,_| k }\r\n  end\r\n\r\n
    \ def [](level)\r\n    definitions[level]\r\n  end\r\n\r\n  class Role\r\n    def
    initialize(name, options)\r\n      @name        = name\r\n      @permissions =
    options[:permissions]\r\n      @parent      = options[:parent]\r\n    end\r\n\r\n
    \   attr_reader :parent\r\n\r\n    def permissions\r\n      return @permissions
    unless parent\r\n      \r\n      @permissions + AccessControl[parent].permissions\r\n
    \   end\r\n\r\n    def allows?(permission)\r\n      permissions.include?(permission)\r\n
    \   end\r\n    \r\n    def to_s\r\n      @name\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nBecause
    doing configuration in pure Ruby is so easy, I often lean towards it rather than
    using YAML or some other external file format. I find configuration files written
    in Ruby to be just as readable as YAML, but far more flexible.\r\n\r\nThere are
    some situations in which external data formats make more sense than Ruby based
    configurations. Using YAML might be a better idea than the approach shown above
    if any of the following apply to your application:\r\n\r\n * You need to integrate
    with other programs that will either read or write your configuration files. It
    is easier for a program written in another language to produce and consume YAML
    than it is for it to work with arbitrary Ruby code\r\n\r\n * You don't want users
    to be able to execute arbitrary code in your application's runtime environment.
    This can either be for security reasons, or for protecting users from their own
    stupidity by restricting the range of possible mistakes they can make.\r\n\r\n
    * You want configuration data that can easily be passed over a network and then
    executed remotely.\r\n\r\nWhile these are all good reasons to avoid Ruby based
    configurations, frankly they are not common scenarios. The reason Ruby has had
    such a widespread adoption of YAML is almost certainly not because of it being
    the best tool for the job, but instead due to an early design decision made in
    Rails that people have emulated in their own projects without further thought.
    While either technique may get the job done, I'd argue that Ruby based configurations
    are a better default choice due to their inherent flexibility.\r\n\r\nBut sometimes,
    neither Ruby nor YAML does what we need them to do. In certain situations, configuration
    data isn't made available until the application is invoked. For those scenarios,
    we can take advantage of how well Ruby is integrated with the shell by making
    use of environment variables.\r\n\r\n### Using the Shell Environment for Configuration\r\n\r\nEvery
    Ruby application has a fairly primitive but useful configuration system built
    into it through direct access to shell environment variables. As you can see in
    the code below, Ruby provides a top level constant that turns the environment
    variable mappings into a plain old Hash object.\r\n\r\n```\r\n$ TURBINE_API_KEY=\"saf3t33553\"
    ruby -e \"puts ENV['TURBINE_API_KEY']\"\r\nIqxPfasfasasfasfgqNm\r\n```\r\n\r\nThe
    fact that I mention API keys in the above contrived example is no coincidence.
    The area I first made use of environment variables in my own applications was
    in a command line application which acted as a client to a web service I needed
    to interact with. Each distinct user needed to use a different API key, but I
    didn't want to rely on fragile home directory lookup code to provide per-user
    configuration. By using environment variables, it was possible to write a line
    like the following in my <i>.bash_profile</i> which would ensure that this information
    was available whenever my command line program ran.\r\n\r\n```\r\nexport TURBINE_API_KEY=\"IqxPfasfasasfasfgqNm\"\r\n```\r\n\r\nSince
    most modern shell implementations support environment variables, they're a good
    choice for this sort of semi-global configuration data. You'll also find environment
    variables used in places where you don't have much control over the system where
    your application is destined to run. The Ruby web application deployment service
    Heroku is a good example of that sort of environment.\r\n\r\nOn Heroku, you aren't
    given direct shell access and aren't even given any guarantees about where on
    the filesystem your application is destined to run. On top of that, if you want
    to run an open source application on Heroku while actively mirroring your changes
    to Github or some other public git host, you can't simply check in configuration
    files which may contain sensitive information, whether written in Ruby, YAML,
    or anything else.\r\n\r\nThe way Heroku solves these problems is with a configuration
    system based on, you guessed it, environment variables. The following example
    from the Heroku website shows how these set via the heroku command line app.\r\n\r\n```\r\n$
    cd myapp\r\n$ heroku config:add S3_KEY=8N029N81 S3_SECRET=9s83109d3+583493190\r\nAdding
    config vars:\r\n  S3_KEY    => 8N029N81\r\n  S3_SECRET => 9s83109d3+583493190\r\nRestarting
    app...done.\r\n```\r\n\r\nIn the application, these variables are accessed in
    a similar fashion to our\r\nprevious example:\r\n\r\n```ruby\r\nAWS::S3::Base.establish_connection!(\r\n
    \ :access_key_id     => ENV['S3_KEY'],\r\n  :secret_access_key => ENV['S3_SECRET']\r\n)\r\n```\r\n\r\nWhile
    hardly the first tool you should reach for, environment variables make sense in
    situations in which you do not want to store sensitive information within your
    application. They also come in handy when you don't want to assume anything about
    your user's file system in order to locate user-wide configuration settings.\r\n\r\nBefore
    we wrap up with some general tips that are relevant to all configurable applications,
    I'd like to quickly visit one more trick that involves project-wide configurations.\r\n\r\n###
    Per-project configurations for command line apps\r\n\r\nSome command line applications
    need to be context aware in order to do their jobs. Two such examples are rake
    and git. Both tools know how to locate their own configuration information so
    that they do the right thing when running their commands.\r\n\r\nFor example,
    git knows which repository to interact with because it knows how to work backwards
    to find the <i>.git/</i> configuration folder at the project root. Likewise, running
    `rake test` from anywhere within your project causes rake to look backwards recursively
    until it finds the nearest <i>Rakefile</i> to run. This general pattern can be
    seen in many other applications, and is worth knowing about in case you ever need
    to make use of it yourself.\r\n\r\nWhile I don't want to go into much detail about
    this topic, I will say that it seemed a bit magical to me until I needed to implement
    this sort of functionality in my own projects. The basic idea is no more complicated
    than working backwards from your current directory until you find the file or
    folder than you need to interact with, which is something Ruby's pathname library
    can make quick work of.\r\n\r\nHere's an example pulled directly out of a project
    of mine which illustrates a reverse search from the current working directory
    back to the filesystem's root directory.\r\n\r\n```ruby\r\nrequire 'pathname'\r\n\r\ndef
    config_dir(dir = Pathname.new(\".\"))\r\n  app_config_dir = dir + \".myappconfigfolder\"\r\n
    \ if dir.children.include?(app_config_dir)\r\n    app_config_dir.expand_path\r\n
    \ else\r\n    return nil if dir.expand_path.root?\r\n    config_dir(dir.parent)\r\n
    \ end\r\nend\r\n```\r\n\r\nA bit of code like this combined with ordinary `require`
    calls for Ruby configurations or `YAML.load_file` calls for YAML configurations
    can be used to implement exactly the sort of context sensitive behavior you find
    in rake and git. I'll leave the exact methods of doing that as something for you
    to explore on your own, but hopefully this bit of code will come in handy if you
    ever run into that sort of situation.\r\n\r\nThis article turned out to be longer
    than I expected it to be, but hopefully was still quite useful to you. Before
    we part, let's review a few key points to keep in mind when building any sort
    of configuration system.\r\n\r\n### Configuration Best Practices \r\n\r\n* Convention
    often is better than configuration. Always provide sensible defaults where possible.
    For example, if you're interacting with a service that has a common default port,
    don't force the user to define a port to use unless they wish to deviate from
    the default.\r\n\r\n* Don't put your real configuration files into your application's
    code repository, since this can expose sensitive data and also makes it hard for
    others to submit patches without merge conflicts on configuration settings.\r\n\r\n*
    Include a sample configuration file filled with reasonable defaults with your
    application. For example, in Rails, people often check in a <i>config/database.yml.example</i>
    for this purpose. The goal should be to make it as easy for your user to make
    a copy of the sample file and then customize it as needed to get their systems
    up and running\r\n\r\n* Raise an appropriate error message when a config file
    is missing. You can do this by doing a `File.exist?` check before loading your
    configuration file, or by rescuing the error a failed load causes and then re-raising
    a more specific error that instructs the user on where to set up their configuration
    file.\r\n\r\n* Make it very easy for users to override defaults by merging their
    overrides rather than forcing them to replace whole configuration structures in
    order to make a small change.\r\n\r\n### Reflections \r\n\r\nWhat do you think
    of what we've covered here? Feel free to leave your questions, comments and suggestions
    in the comments section below.\r\n  \r\n> **NOTE:** This article has also been
    published on the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/033-issue-4-configurable.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: testing-private-methods
  :title: Testing Private Methods
  :summary: Understand why testing private methods can be a code smell.
  :published: 2010-11-25 00:00:00.000000000 Z
  :issue_number: '1.5'
  :volume: 1
  :body: "If you are using `send` to test private methods in your tests, you are almost
    certainly doing it wrong. Most private methods tend to fall into one of the following
    categories, none of which require `send` to test:\r\n\r\n* A method that does
    not have behavior of its own (a helper function) \r\n* A method that actually
    deserves to be public on the current object \r\n* A method that is only private
    to hide a design flaw\r\n\r\nTake a look at the three objects below and try to
    match them to the patterns listed above.\r\n\r\n```ruby\r\nclass Book\r\n  def
    initialize(name)\r\n    @name = name\r\n  end\r\n\r\n  def available_for_purchase?\r\n
    \   copies_remaining > 0     \r\n  end\r\n\r\n  private\r\n\r\n  def copies_remaining\r\n
    \   Inventory.count(:book, @name)\r\n  end\r\nend\r\n\r\nmodule Inventory\r\n
    \ extend self\r\n\r\n  def count(item_type, name)\r\n    item_class(item_type).find_by_name(name).quantity\r\n
    \ end\r\n\r\n  def receive(item_type, name, quantity)\r\n    item_class(item_type).create(name,
    quantity)\r\n  end\r\n\r\n  private\r\n\r\n  def item_class(item_type)\r\n    case
    item_type\r\n    when :book\r\n      InStockBook\r\n    when :video\r\n      InStockVideo\r\n
    \   end\r\n  end\r\nend\r\n\r\nclass InStockBook\r\n  def self.titles\r\n    @titles
    ||= {}\r\n  end\r\n  \r\n  def self.find_by_name(name)\r\n    titles[name]\r\n
    \ end\r\n\r\n  def self.create(name, quantity)\r\n    titles[name] = new(name,
    quantity)\r\n  end\r\n\r\n  def initialize(name, quantity)\r\n    @title     =
    name\r\n    @quantity  = quantity\r\n  end\r\n\r\n  attr_reader :title, :quantity\r\n\r\n
    \ def isbn\r\n    @isbn ||= isbn_from_service\r\n  end\r\n\r\n  private\r\n\r\n
    \ def isbn_from_service\r\n    isbn_service_connect\r\n\r\n    isbn = @isbn_service.find_isbn_for(@title)\r\n\r\n
    \   isbn_service_disconnect\r\n\r\n    return isbn\r\n  end\r\n\r\n  def isbn_service_connect\r\n
    \   @isbn_service = IsbnService.new\r\n    @isbn_service.connect\r\n  end\r\n\r\n
    \ def isbn_service_disconnect\r\n    @isbn_service.disconnect\r\n  end\r\nend\r\n```\r\n\r\nIf
    you guessed that `Inventory` was the object which demonstrated a private method
    that doesn't implement an external behavior, you guessed right. The sole purpose
    of `Inventory#item_class` is just to make the code in `Inventory#count` and `Inventory#receive`
    a bit cleaner to read. Therefore, it'd be wasteful to write an explicit test such
    as the one below.\r\n\r\n```ruby\r\ndef test_item_class\r\n  assert_equal InStockBook,
    Inventory.send(:item_class, :book)\r\nend\r\n```\r\n\r\nThe following tests implicitly
    cover the functionality of `Inventory#item_class` while focusing on actual interactions
    through the public interface.\r\n\r\n```ruby\r\ndef test_stocking_a_book\r\n  Inventory.receive(:book,
    \"Ruby Best Practices\", 100)\r\n  assert_equal 100, Inventory.count(:book, \"Ruby
    Best Practices\")\r\nend\r\n```\r\n\r\nBecause indirectly testing a private method
    will result in the same code coverage results as testing the method directly,
    you won't silently miss out on a failure if `Inventory#item_class` does not work
    as expected. However, by writing your tests this way, you focus primarily on what
    can be done to the object via its external interface. This leads to clearer, more
    maintainable tests. If a user is expected to add books through `Inventory#receive`,
    they should not need to know about `InStockBook`, so it can be regarded as an
    implementation detail. Changing the definition of `Inventory#item_class` or even
    removing it entirely will not require a change to these tests as long as you maintain
    the signature of the objects public API.\r\n\r\nNow that we've identified the
    approach for testing `Inventory`, we are left with `Book` and `InStockBook` to
    discuss. Of the two, the problem with `Book` is a little more obvious, so we'll
    tackle it first.\r\n\r\nBook implements a method called `available_for_purchase?`,
    which relies on a private method called `copies_remaining` to operate. The following
    code demonstrates a poorly implemented test.\r\n \r\n```ruby\r\ndef test_copies_remaining\r\n
    \ book = Book.new(\"Ruby Best Practices\")\r\n  Inventory.receive(book.name, 10)\r\n
    \r\n  assert_equal book.send(:copies_remaining), 10 \r\nend\r\n```\r\n\r\nThe
    reason why this is poor is because once again, we are relying on `send` to call
    a private method in our tests. Our theory from the previous example is that private
    methods do not need to be tested because they don't actually implement behavior.
    However, `Book#copies_remaining` seems like something you might want to actually
    make use of. If you imagine a web front-end for an e-commerce site, it's easy
    to visualize both an indicator of whether an item is in stock, as well as how
    many of that item are still available.\r\n\r\nThe rule of thumb here is that if
    a method provides a sensible behavior that fits the context of your object, it's
    better off to just make it public. The following test seems very natural to me.\r\n\r\n```ruby\r\ndef
    test_copies_remaining\r\n  book = Book.new(\"Ruby Best Practices\")\r\n  Inventory.receive(book.name,
    10)\r\n  \r\n  assert_equal book.copies_remaining, 10 \r\nend\r\n```\r\n\r\nSo
    far we've seen two extremes: Private methods that are rightfully private and do
    not need to be tested explicitly, and private methods that ought to be public
    so that they can be tested explicitly. We will now examine the space between these
    two opposite ends of the spectrum.  \r\n\r\nLet's think a bit about how we could
    test the `InStockBook#isbn` shown below.\r\n\r\n```ruby\r\nclass InStockBook\r\n\r\n
    \ # .. other features omitted\r\n\r\n  def isbn\r\n    @isbn ||= isbn_from_service\r\n
    \ end\r\n\r\nend\r\n```\r\n\r\nOne way to do it the would be to mock out the call
    to `isbn_from_service` as we do in the following tests.\r\n\r\n```ruby\r\ndef
    test_retreive_isbn\r\n  book = InStockBook.new(\"Ruby Best Practices\", 10)\r\n
    \ book.expects(:isbn_from_service).once.returns(\"978-0-596-52300-8\")\r\n\r\n
    \ # Verify caching by calling isbn twice but expecting only one service\r\n  #
    call to be made\r\n  2.times { assert_equal \"978-0-596-52300-8\", @book.isbn
    }\r\nend\r\n```\r\n\r\nThe downside of this approach is that by mocking out the
    call to `isbn_from_service`, we're bypassing all of the following code, leaving
    it untested.\r\n\r\n```ruby\r\ndef isbn_from_service\r\n  isbn_service_connect\r\n\r\n
    \ isbn = @isbn_service.find_isbn_for(@title)\r\n\r\n  isbn_service_disconnect\r\n\r\n
    \ return isbn\r\nend\r\n\r\ndef isbn_service_connect\r\n  @isbn_service = IsbnService.new\r\n
    \ @isbn_service.connect\r\nend\r\n\r\ndef isbn_service_disconnect\r\n  @isbn_service.disconnect\r\nend\r\n```\r\n\r\nMaking
    these methods public on `InStockBook` doesn't make much sense, but we also can't
    say that these are mere implementation details that can be ignored. In these situations,
    typically some redesign is necessary, and in this case, a simple shift of this
    functionality upstream to the `IsbnService` class makes the most sense.\r\n\r\n```ruby
    \r\nclass IsbnService\r\n\r\n  def self.find_isbn_for(title)\r\n    service =
    new\r\n\r\n    service.connect\r\n    isbn = service.find_isbn_for(title) # delegate
    to instance\r\n    service.disconnect\r\n\r\n    return isbn\r\n  end\r\n\r\n
    \ # .. other functionality\r\n\r\nend\r\n```\r\n\r\nThis functionality can now
    easily be tested as a public behavior of the `IsbnService` class, where it won't
    get jumbled up with `InStockBook`'s logic. All that's left to do is rewrite our
    `InStockBook#isbn` method so that it delegates to this new class.\r\n\r\n```ruby\r\nclass
    InStockBook\r\n\r\n  # .. other features omitted\r\n\r\n  def isbn\r\n    @isbn
    ||= IsbnService.find_isbn_for(@title)\r\n  end\r\n\r\nend\r\n```\r\n\r\nOur updated
    `isbn` tests only need to change slightly to accommodate this\r\nchange:\r\n\r\n```ruby\r\ndef
    test_retreive_isbn\r\n  book = InStockBook.new(\"Ruby Best Practices\", 10)\r\n
    \ IsbnService.expects(:find_isbn_for).with(book.title).once.\r\n              returns(\"978-0-596-52300-8\")\r\n\r\n
    \ # Verify caching by calling isbn twice but expecting only one service\r\n  #
    call to be made\r\n  2.times { assert_equal \"978-0-596-52300-8\", @book.isbn
    }\r\nend\r\n```\r\n\r\nNow, when reading the tests for `InStockBook`, the developer
    can safely gloss\r\nover `IsbnService`'s implementation until its contract changes.
    With this\r\ndilemma solved, we've now comprehensively categorized the strategies
    that allow\r\nyou to avoid testing private methods without sacrificing the clarity
    and\r\ncoverage of your test suite.\r\n\r\n### Reflections\r\n\r\nWe've now seen
    examples of how to deal with all of the following situations that might tempt
    us to use `send` in our tests unnecessarily:\r\n\r\n1. A method that does not
    have behavior of its own (a helper function) \r\n1. A method that actually deserves
    to be public on the current object \r\n1. A method that is only private to hide
    a design flaw\r\n\r\nCan you think of a situation where none of these approaches
    seem to work? Please feel free to share them in the comments section below.\r\n
    \ \r\n> **NOTE:** This article has also been published on the Ruby Best Practices
    blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/034-issue-5-testing-antipatterns.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: meditations-on-bad-and-good-code-1
  :title: Meditations on Bad and Good Code, Part 1
  :summary: Build an ugly tic-tac-toe game by writing the entire implementation as
    a single procedural script.
  :published: 2010-12-01 00:00:00.000000000 Z
  :issue_number: '1.6'
  :volume: 1
  :body: "In this issue and the next one, I'd like to demonstrate one of my favorite
    learning exercises while inviting you to follow along at home. It's something
    I usually do while teaching in a one-on-one setting, but I think we can adapt
    it for a broader audience and still get a lot out of it.\r\n\r\nIn this exercise,
    the goal is to first produce some bad code, and then steadily improve it while
    explaining why each change is an improvement. I usually start with a very simple
    problem but then add some twists about how to implement it to make sure it comes
    out pretty bad.\r\n\r\nOne surefire way of writing bad code without resorting
    to intentionally writing things worse than they should be is to eliminate a few
    of Ruby's key organizational tools. In particular, if you want to write ugly code
    without it seeming fake, it is easy to do so if you never write any user defined
    functions, classes, or modules. So we'll do exactly that!\r\n\r\n### Implementing
    Tic-Tac-Toe as a single procedure.\r\n\r\nI've chosen the game [Tic-Tac-Toe](http://en.wikipedia.org/wiki/Tic-Tac-Toe)
    as the problem to focus on, because it only involves a few simple rules and can
    be implemented by anyone who has basic programming skills.\r\n\r\nIn fact, if
    you ignore end game conditions and error handling, you can get a simple prompt
    for a two player game with just a few lines of Ruby.\r\n\r\n```ruby\r\nboard =
    [[nil,nil,nil],\r\n         [nil,nil,nil],\r\n         [nil,nil,nil]]\r\n\r\nplayers
    = [:X, :O].cycle\r\n\r\nloop do\r\n  current_player = players.next\r\n  puts board.map
    { |row| row.map { |e| e || \" \" }.join(\"|\") }.join(\"\\n\")\r\n  print \"\\n>>
    \"\r\n  row, col = gets.split.map { |e| e.to_i }\r\n  puts\r\n  board[row][col]
    = current_player\r\nend\r\n```\r\n\r\nBut of course, the devil is in the details.
    To get a fully playable game, you need some basic error checking to ensure that
    you can't play out of bounds or on top of another player's marker. You also need
    to figure out when a player has won, and when the game has ended in a draw. While
    this doesn't sound like a lot of work, you'll see in the code below how much complexity
    these simple changes add.\r\n\r\n```ruby\r\nboard   = [[nil,nil,nil],\r\n           [nil,nil,nil],\r\n
    \          [nil,nil,nil]]\r\n\r\nleft_diagonal  = [[0,0],[1,1],[2,2]]\r\nright_diagonal
    = [[2,0],[1,1],[0,2]]\r\n\r\nplayers = [:X, :O].cycle\r\n\r\ncurrent_player =
    players.next\r\n\r\nloop do\r\n  puts board.map { |row| row.map { |e| e || \"
    \" }.join(\"|\") }.join(\"\\n\")\r\n  print \"\\n>> \"\r\n  row, col = gets.split.map
    { |e| e.to_i }\r\n  puts\r\n\r\n  begin\r\n    cell_contents = board.fetch(row).fetch(col)\r\n
    \ rescue IndexError\r\n    puts \"Out of bounds, try another position\"\r\n    next\r\n
    \ end\r\n\r\n  if cell_contents\r\n    puts \"Cell occupied, try another position\"\r\n
    \   next\r\n  end\r\n\r\n  board[row][col] = current_player\r\n\r\n  lines = []\r\n\r\n
    \ [left_diagonal, right_diagonal].each do |line|\r\n    lines << line if line.include?([row,col])\r\n
    \ end\r\n\r\n  lines << (0..2).map { |c1| [row, c1] }\r\n  lines << (0..2).map
    { |r1| [r1, col] }\r\n\r\n  win = lines.any? do |line|\r\n    line.all? { |row,col|
    board[row][col] == current_player }\r\n  end\r\n\r\n  if win\r\n    puts \"#{current_player}
    wins!\"\r\n    exit\r\n  end\r\n\r\n  if board.flatten.compact.length == 9\r\n
    \   puts \"It's a draw!\"\r\n    exit\r\n  end\r\n\r\n  current_player = players.next\r\nend\r\n```\r\n\r\nWhile
    relatively short, you need to read through the whole script to really understand
    how any part of it operates. Of course, this script did not spring together fully
    formed, there was a thought process that drove it to this final implementation.
    For those curious, you can [follow my stream of consciousness notes](https://gist.github.com/24ef3c8209877c1946bb)
    about what I was building and why in a step by step fashion.\r\n\r\nSeeing these
    notes will hopefully give you a bit of a sense of how this process might have
    gone if we were pair programming on this project, working in tiny iterations to
    push forward just a little bit farther each time. If so, you might already be
    catching a glimpse of what this exercise is all about. Otherwise, there is still
    more for us to do!\r\n\r\n### What Happens Next?\r\n\r\nI've placed my bad tictactoe
    example in a [repository on github](https://github.com/sandal/tictactoe/tree/7fd72a33aec33f75909d8c9d59a43423b0f66b24).
    If you'd like to participate, please fork this repository and make one change
    to the code at a time, leaving detailed reasoning in each commit message as to
    why you're making the change. Once you're happy with what you've got, post a link
    in the comments section on this post so others can check out what you have done.\r\n\r\nIn
    the next issue, I will post my own iterative set of improvements, as well as links
    to some reader submissions. I will also summarize the lessons that can be learned
    from using this technique, and provide a few suggestions for other problems to
    attempt in this fashion.\r\n\r\n### Reflections\r\n\r\nPlease leave any questions,
    thoughts, or suggestions in the comments section below. These articles are much
    better when they're treated as discussions rather than monologues. \r\n  \r\n>
    **NOTE:** This article has also been published on the Ruby Best Practices blog.
    There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/035-issue-6-good-and-bad-code.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: meditations-on-bad-and-good-code-2
  :title: Meditations on Bad and Good Code, Part 2
  :summary: Read through a cleaned up version of the ugly "Tic Tac Toe" game created
    in Issue 1.5
  :published: 2010-12-03 00:00:00.000000000 Z
  :issue_number: '1.7'
  :volume: 1
  :body: "In Issue #6, you got to see my intentionally bad implementation of Tic Tac
    Toe. For today, I have promised to show you some better code and the steps I took
    to get there. But before we move forward, let's take a quick look back at where
    we started.\r\n\r\nTo start this exercise, I had challenged myself to implement
    this simple game without using any user defined classes or methods. Given that
    I wanted to make sure I produced *bad* code to start with, I got a little nervous
    when my back-of-the-napkin proof of concept didn't come out looking that bad.
    Here it is again below, for those who forgot about it.\r\n\r\n```ruby\r\nboard
    = [[nil,nil,nil],\r\n         [nil,nil,nil],\r\n         [nil,nil,nil]]\r\n\r\nplayers
    = [:X, :O].cycle\r\n\r\nloop do\r\n  current_player = players.next\r\n  puts board.map
    { |row| row.map { |e| e || \" \" }.join(\"|\") }.join(\"\\n\")\r\n  print \"\\n>>
    \"\r\n  row, col = gets.split.map { |e| e.to_i }\r\n  puts\r\n  board[row][col]
    = current_player\r\nend\r\n```\r\n\r\nThe above code is good demo-ware, as long
    as you type really carefully and conveniently forget to finish a game before hitting
    ctrl+c. But to make a real, playable implementation, some end game conditions
    and basic validations are necessary. To my great joy, adding those new features
    caused this tight little script to explode into a hot mess of intertwined logic
    and nasty little hacks. Check out [the source tree](https://github.com/sandal/tictactoe/tree/7fd72a33aec33f75909d8c9d59a43423b0f66b24)
    that we ended up with at the end of Issue #6 to see how things turned.\r\n\r\nWhile
    concise at less than 60 lines of code, it's pretty easy to see that this isn't
    the kind of software we should aspire to be writing. So the challenge was to start
    here and end up somewhere better.\r\n\r\nWhenever I do this exercise with my students,
    there is a roadmap I follow that tends to lead to some decent insights. It roughly
    goes like this:\r\n\r\n* Get some basic file structures and namespaces in place
    so that you get yourself out of the global namespace and open the doors for scripting
    some examples or running things in irb without firing off a procedure automatically.\r\n\r\n*
    Break down the procedure into some separable chunks so that you can think about
    smaller parts of the problems, and more easily see the dependencies between the
    steps in the procedure.\r\n\r\n* Re-think the design by identifying areas where
    objects can put an abstraction barrier between different layers of data and logic.
    Strive to have each bit of code do one thing and one thing well.\r\n\r\n* Identify
    the leaky abstractions and dangly bits that didn't get ironed out by the last
    step. Aim for beautiful solutions, but be skeptical of over-engineering at this
    point. No problem can be modeled perfectly\r\n\r\n* Reflect on the exercise, and
    ask yourself whether you've gone far enough with your cleanup. If you feel like
    so, then be sure to think about whether you've gone *too* far!\r\n\r\nThis is
    the approach I took as I worked on this problem myself, and you'll be able to
    see it step by step in the git logs. I tried to write good log messages, so I
    will link to them rather than repeat what was said, but I'll also share some more
    big-picture oriented thoughts as I walk you through my work.\r\n\r\n### Basic
    organization first\r\n\r\nHere is my [first commit](https://github.com/sandal/tictactoe/commit/5af96941d74f8014a3276b77fe67c17e0ed5e2df)
    of the evening. And this is the [source tree](https://github.com/sandal/tictactoe/tree/5af96941d74f8014a3276b77fe67c17e0ed5e2df).\r\n\r\nTiny
    changes really, but it's the first thing I do as soon as I've exited 'spike\r\nmode'
    on any project, no matter how small. I've used a standard structure, and\r\nit
    does two things for me:\r\n\r\n1. Allows me to load my whole library with a single
    require. (See app.rb for example and note how it doesn't change throughout this
    walkthrough)\r\n\r\n1. Places 100% of what I build under a single constant's namespace
    (i.e. `TicTacToe`)\r\n\r\nThese two points pretty much guarantee me that I won't
    have any naming clashes or unexpected collisions with other people's code unless
    I plan on loading a library that might clobber the name `TicTacToe` or the `require`
    path of <i>\"tictactoe/*\"</i>. It also makes it easy for me to start interacting
    with my code from scripts I write, from irb, and from unit tests. For so little
    work, we get a ton of benefit, and this is a great place to start when doing any
    sort of cleanup.\r\n\r\n### Basic Slicing and Dicing\r\n\r\nMy next goal is to
    start breaking my monolithic procedure into some smaller chunks so I can get a
    sense of what parts go well together and how they need to interact with each other.\r\n\r\nI
    start by realizing that using a singleton pattern for `Game`, while possible,
    isn't a great idea. A function bag approach in which we pass board and player
    information around like crazy also wouldn't be great, so I decide to make `Game`
    an ordinary class in this [commit](https://github.com/sandal/tictactoe/commit/2579626bd73fc7ad9e7d0a87419d5ecab2aacdda).\r\n\r\nRead
    the message, and then if you'd like, have a look at the [updated source tree](https://github.com/sandal/tictactoe/tree/2579626bd73fc7ad9e7d0a87419d5ecab2aacdda).\r\n\r\nI
    immediately make use this refactoring by breaking down the original game procedure
    into several smaller, simpler methods. ([commit](https://github.com/sandal/tictactoe/commit/286724de5328fda779caa500ccc76a0ad5de2bd7),
    [source](https://github.com/sandal/tictactoe/tree/286724de5328fda779caa500ccc76a0ad5de2bd7))\r\n\r\nAt
    this point, it's not uncommon for folks to think they're done refactoring. By
    giving things nicer names and distributing the pain points so that they're not
    all crammed together in one place, the code feels cleaner. But upon further investigation
    of this code, while perhaps understandability and organization have improved,
    flexibility and abstraction have not. This is what I like to call 'procedural
    programming with objects', and we can do better than this.\r\n\r\nThe good news
    is, with the code cleaned up a bit, we see where some of the pain points are.
    When it seems like a large amount of your code is dedicated to handling a particular
    concept, that means you have an object begging to be born. Our handling of the
    game board logic in this code is a prime example.\r\n\r\n### Sneaking in Domain
    Models\r\n\r\nA key principle of object oriented design is to do one thing and
    do it well. But what does that mean? Hopefully, this refactored `Board` class
    gives you an idea!\r\n([commit](https://github.com/sandal/tictactoe/commit/efcbf51bcc1f7d4d094c671b60761229aec3dded),
    [source](https://github.com/sandal/tictactoe/tree/efcbf51bcc1f7d4d094c671b60761229aec3dded))\r\n\r\nIf
    you look at the `Board` class, you'll see that it takes the concept of a Tic Tac
    Toe board and solidifies it so that when `Game` works with it, `Board` does the
    heavy lifting and `Game` mostly just calls the methods it needs to get its job
    done. This lets `Game` forget about some of the finer points like what the individual
    kinds of illegal moves are, or how to compute the intersecting lines that cross
    through a given point. This sort of black box effect gives us some real abstraction,
    which is exactly why object oriented programming is as good as they say it is.\r\n\r\nWith
    this complex board logic out of the way and some updates to the way flow is handled
    in game, it's obvious that `Game` is now something like a controller, and `Board`
    is a model. But there are still some loose ends in `Game`, things that actually
    look like logic rather than just flow control and dispatch. The majority of the
    code you see in this class has to do with implementing a user interface and basic
    event loop. So, methods like `check_move`, `check_win`, and `check_draw` feel
    a little bit out of place, since they implement actual logic about the rules of
    the game rather than just how players interact with it.\r\n\r\nSometimes, little
    leaks like this aren't a big deal. In fact, the code looks reasonable to me at
    this point and if I were doing this for my day job and wasn't trying to get in
    the record books for 'World's Best Tic Tac Toe Implementation', I'd probably stop
    here.\r\n\r\nBut we're already cruising now, so why don't we try to shoot for
    the stars?\r\n\r\n### Grail Quests\r\n\r\nI really wanted to find a way to rip
    that last bit of domain logic out of `Game`, and after wrestling a little bit,
    I came up with something.\r\n([commit](https://github.com/sandal/tictactoe/commit/0fef18d320af2bd1a08f5115a2b94e552205f218),
    [source](https://github.com/sandal/tictactoe/tree/0fef18d320af2bd1a08f5115a2b94e552205f218))\r\n\r\nThe
    thing I kept wrestling with was how to manage the screen output stuff. I wrestled
    with a bunch of ideas, including defining a simply `display()` method on `Game`
    like this:\r\n\r\n```ruby\r\ndef display(message)\r\n  puts message\r\nend\r\n```\r\n\r\nThe
    reason why I wanted this is so my Rules mixin could rely on a method that `Game`
    provided for display rather than directly assuming console output. But I think
    that what I ended up with is better.\r\n\r\nImagine that my `check_draw` method
    in Rules was written like this:\r\n\r\n```ruby\r\ndef check_draw\r\n  if @board.covered?\r\n
    \    display \"It's a draw\"\r\n     game_over\r\n  end\r\nend\r\n```\r\n\r\nIt's
    almost a trivial difference *except* that now we have a leak on the Rules side.
    If `TicTacToe::Game` is now meant to exclusively be a UI event loop, having the
    messages that are displayed to the user caught up in some module seems a bit ugly.\r\n\r\nBut
    instead, I chose to let `Game` fill in the blanks with an implementation like
    this:\r\n\r\n```ruby\r\ndef check_draw\r\n  if @board.covered?\r\n     yield\r\n
    \    game_over\r\n  end\r\nend\r\n```\r\n\r\nThis allows the draw logic to live
    in `Rules`, with calling code in `Game`\r\nthat looks like this:\r\n\r\n```ruby\r\ncheck_draw
    { puts \"It's a draw\" }\r\n```\r\n\r\nA place for everything and everything in
    its place! Time to go hang some banners on aircraft carriers, because well, Mission
    Accomplished.\r\n\r\n### Fear, Uncertainty, and Doubt\r\n\r\nIs this final implementation
    an example of good Ruby code? Yeah, probably. Is it excellent? I really have no
    idea. At the very least, it's almost certainly not 'The Best Tic Tac Toe Implementation
    Ever'.\r\n\r\nBut really, the kind of perfection I was trying to seek in this
    exercise is not really what we should be looking for in our day to day work. Right
    now I have the amps cranked up to 11, when 7 or 8 would really do fine. But as
    I said before, this is one of my favorite exercises for learning and teaching.
    Here's why: It really gets me thinking.\r\n\r\nI'm still trying to decide on whether
    extracting out the `Rules` module was really necessary, and I also have some areas
    about this I still don't like. For example, I'm not sure whether `Board` should
    know more about the rules of the game, or even less. I don't like the hard coding
    I did of all the parameters of the game in there, but I can't put my finger on
    why. After all, it's very unlikely that Tic Tac Toe is suddenly going to become
    Chess and need to expand to an NxN board. Even if it did, wouldn't it need to
    change a whole lot to accommodate it?\r\n\r\nStill, I don't like things like these
    constants:\r\n\r\n```ruby\r\nLEFT_DIAGONAL_POSITIONS  = [[0,0],[1,1],[2,2]]\r\nRIGHT_DIAGONAL_POSITIONS
    = [[2,0],[1,1],[0,2]]\r\nSPAN                     = (0..2)\r\nCELL_COUNT               =
    9\r\n```\r\n\r\nThere is a natural connascence between all four of these values,
    but the code to generalize their creation would be longer and much uglier to read
    than the above. So maybe it's a good choice to do it this way, but it makes the
    mathematician in me uneasy.\r\n\r\nAnother thing I don't like about my design
    is `Board#to_s`, because putting presentation logic on domain logic is nasty.
    But to make a view object or otherwise promote one line of code to something more
    complex seems to be a cure that is worse than the disease.\r\n\r\nBut on the bright
    side of things, I really like the callback scheme for doing the bits of game logic
    like `check_win` and `check_draw` and passing in a block with the rendering code.
    This is actually a formal design pattern just hiding in a line of code, and things
    like that remind me of why Ruby is so beautiful.\r\n\r\nAlso, I've never used
    `throw` / `catch` before in real code. Never really saw why I'd need it. But at
    a glance, my use of it here actually seems pretty expressive and appropriate given
    the situation. But because I've never used it before, I'm still glancing at it
    sideways with considerable doubt. I even had to wrap it in a method called `game_over`
    to hide the throw keyword to get over my fear of its relative novelty. But now,
    my `game_over` method is like some sort of crazy goto call... and that makes me
    not so sure that this was a good idea afterall.\r\n\r\nOh yeah, and I also didn't
    write any tests while working on this code. I thought about writing them, but
    I felt that it'd cause me to think about the tests themselves more than the coding
    practices I was experimenting with. But then again, maybe if I wrote tests, I
    wouldn't be pondering the relative merits of my fancy `game_over()` goto.\r\n\r\nAnd
    this is how this exercise always ends. It doesn't come together in a beautiful
    blossom of Ruby awesomeness, it just kind of falls off a cliff. But really, that's
    okay! Not every question needs to be answered, and as I said before, if this were
    something I was working on just to get a job done, I would happily make concessions
    where needed to avoid letting perfect become the enemy of the good.\r\n\r\nStill,
    this sort of practice gnaws on your subconscious, and I've seen it lead to great
    progress in my own studies and in my students as well. Hopefully you've enjoyed
    seeing this process in action, and will give it a try soon if you weren't able
    to try it out this week.\r\n\r\n### Submissions from our readers\r\n\r\nI haven't
    had a chance to review them in depth, but a few readers did share\r\ntheir own
    explorations with us. Check out the [github network graph](https://github.com/sandal/tictactoe/network)
    to see what others have done.\r\n\r\nLooking forward to hearing your thoughts
    on this exercise, and whether it seems like something you could make good use
    of. Until next time, happy hacking!\r\n\r\n  \r\n> **NOTE:** This article has
    also been published on the Ruby Best Practices blog. There [may be additional
    commentary](http://blog.rubybestpractices.com/posts/gregory/036-issue-7-good-and-bad-code.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: uses-for-modules-1
  :title: Uses for Modules, Part 1
  :summary: Use modules as namespaces for your libraries and applications.
  :published: 2010-12-08 00:00:00.000000000 Z
  :issue_number: '1.8'
  :volume: 1
  :body: "> Note: This article series on modules is also available as a [PDF download].
    The\r\n> PDF version has been revised and is more up-to-date than what you see
    here.\r\n\r\n[PDF download]:https://github.com/elm-city-craftworks/pr-monthly/blob/gh-pages/b5e5a89847701c4aa7c170cf/sept-2012-modules.pdf?raw=true\r\n\r\nModules
    are part of what makes Ruby's design beautiful. However, since they do not have
    a direct analogy in any mainstream programming language, it is easy to get a bit
    confused about what they should be used for. While most folks quickly encounter
    at least some of their use cases, typically only very experienced Ruby developers
    know their true versatilty.\r\n\r\nIn this four part article series, I aim to
    demystify Ruby modules by showing many practical use cases, explaining some tricky
    details along the way. We'll work through some of the fundamentals in the first
    two issues, and move into more advanced examples in the second two. Today we'll
    kick off this series by looking at the most simple, but perhaps most important
    ability modules offer us, the creation of namespaces.\r\n\r\n### Modules for Namespacing\r\n\r\nImagine
    that you are writing an XML generation library, and in it, you have a class to
    generate your XML documents. Perhaps uncreatively, you choose the name `Document`
    for your class, creating something similar to what is shown below.\r\n\r\n```ruby\r\nclass
    Document\r\n  def generate\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nOn its own,
    this seems to make a lot of sense; a user could do something simple like the following
    to make use of your library.\r\n\r\n```ruby\r\nrequire \"your_xml_lib\"\r\ndocument
    = Document.new\r\n# do something with document\r\nputs document.generate\r\n```\r\n\r\nBut
    imagine that you were using another library that generates PDF documents, which
    happens to use similar uncreative naming for its class that does the PDF document
    generation. Then, the following code would look equally valid.\r\n\r\n```ruby\r\nrequire
    \"their_pdf_lib\"\r\ndocument = Document.new\r\n# do something with document\r\nputs
    document.generate\r\n```\r\n\r\nAs long as the two libraries were never loaded
    at the same time, there would be no issue. But as soon as someone loaded both
    libraries, some quite confusing behavior would happen. One might think that defining
    two different classes with the same name would lead to some sort of error being
    raised by Ruby, but with open classes, that is not the case. Ruby would actually
    apply the definitions of `Document` one after the other, with whatever file was
    required last taking precedence. The end result would in all likelihood be a very
    broken `Document` class that could generate neither XML nor PDF.\r\n\r\nBut there
    is no reason for this to happen, as long as both libraries take care to namespace
    things. Shown below is an example of two `Document` classes that could co-exist
    peacefully.\r\n\r\n```ruby\r\n# somewhere in your_xml_lib\r\n\r\nmodule XML\r\n
    \ class Document\r\n    # ...\r\n  end\r\nend\r\n\r\n# somewhere in their_pdf_lib\r\n\r\nmodule
    PDF\r\n  class Document\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nUsing both
    classes in the same application is as easy, as long as you explicitly include
    the namespace when referring to each library's `Document` class.\r\n\r\n```ruby\r\nrequire
    \"your_xml_lib\"\r\nrequire \"their_pdf_lib\"\r\n\r\n# this pair of calls refer
    to two completely different classes\r\npdf_document = PDF::Document.new\r\nxml_document
    = XML::Document.new\r\n```\r\n\r\nThe clash has been prevented because each library
    has nested its `Document` class within a module, allowing the class to be defined
    within that namespace rather than at the global level. While this is a relatively
    straightforward concept, it's important to note a few things about what is really
    going on here.\r\n\r\nFirstly, namespacing actually applies to the way constants
    are looked up in Ruby in general, not classes in particular. This means that it
    applies to modules nested within modules as well as ordinary constants as well.\r\n\r\n```ruby\r\nmodule
    A\r\n  module B\r\n  end\r\nend\r\n\r\np A::B\r\n\r\nmodule A\r\n  C = 10\r\nend\r\n\r\np
    A::C\r\n```\r\n\r\nSecondly, this same behavior of using modules as namespaces
    applies just as well to classes, as in the code below.\r\n\r\n```ruby\r\nclass
    Blog\r\n  class Comment\r\n    #...\r\n  end\r\nend\r\n```\r\n\r\nBe sure to note
    that in this example, nesting a class within a class does not in any way make
    it a subclass or establish any relationship between `Blog` and `Blog::Comment`
    except that `Blog::Comment` is within the `Blog` namespace. In the example below,
    you can see that a class nested within another class looks the same as a class
    nested within a module.\r\n\r\n```ruby\r\nblog = Blog.new\r\ncomment = Blog::Comment.new\r\n#
    ...\r\n```\r\n\r\nOf course, this technique is only really useful when you have
    a desired namespace for your library that also happens matches one of your class
    names. In all other situations, it makes sense to use a module for namespacing
    as it would prevent your users from creating instances of an empty and meaningless
    class.\r\n\r\nFinally, it is important to understand that constants are looked
    up from the innermost nesting to the outermost, finally searching the global namespace.
    This can be a bit confusing at times, especially when you consider some corner
    cases.\r\n\r\nFor example, examine the following code:\r\n\r\n```ruby\r\nmodule
    FancyReporter\r\n  class Document\r\n    def initialize\r\n       @output = String.new\r\n
    \   end\r\n\r\n    attr_reader :output\r\n  end\r\nend\r\n```\r\n\r\nIf you load
    this code into irb and play with a bit on its own, you can inspect an instance
    of Document to see that its output attribute is a core ruby `String` object, as
    shown below:\r\n\r\n```ruby\r\n>> FancyReporter::Document.new.output\r\n=> \"\"\r\n>>
    FancyReporter::Document.new.output.class\r\n=> String\r\n```\r\n\r\nWhile this
    seems fairly obvious, it is easy for a bit of unrelated code written elsewhere
    to change everything. Consider the following code:\r\n\r\n```ruby\r\nmodule FancyReporter\r\n
    \ module String\r\n    class Formatter\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhile
    the designer of `FancyReporter` was most likely trying to be well organized by
    offering `FancyReporter::String::Formatter`, this small change causes headaches
    because it changes the meaning of `String.new` in `Document`'s initialize method.
    In fact, you cannot even create an instance of `Document` before the following
    error is raised:\r\n\r\n```ruby\r\n?> FancyReporter::Document.new\r\nNoMethodError:
    undefined method `new' for FancyReporter::String:Module\r\n\tfrom (irb):35:in
    `initialize'\r\n\tfrom (irb):53:in `new'\r\n\tfrom (irb):53\r\n```\r\n\r\nThere
    are a number of ways this problem can be avoided. Often times, it's\r\npossible
    to come up with alternative names that do not clash with core objects,\r\nand
    when that's the case, it's preferable. In this particular case, `String.new`\r\ncan
    also be replaced with `\"\"`, as nothing can change what objects are created\r\nvia
    Ruby's string literal syntax. But there is also an approach that works\r\nindependent
    of context, and that is to use explicit constant lookups from the\r\nglobal namespace.
    You can see an example of explicit lookups in the following\r\ncode:\r\n\r\n```ruby\r\nmodule
    FancyReporter\r\n  class Document\r\n    def initialize\r\n       @output = ::String.new\r\n
    \   end\r\n\r\n    attr_reader :output\r\n  end\r\nend\r\n```\r\n\r\nPrepending
    any constant with `::` will force Ruby to skip the nested namespaces and bubble
    all the way up to the root. In this sense, the difference between `A::B` and `::A::B`
    is that the former is a sort of relative lookup whereas the latter is absolute
    from the root namespace.\r\n\r\nIn general, having to use absolute lookups may
    be a sign that there is an unnecessary name conflict within your application.
    But if upon investigation you find names that inheritently collide with one another,
    you can use this tool to avoid any ambiguity in your code.\r\n\r\nWhile we've
    mostly covered the mechanics of namespacing, all this talk about `::` compels
    me to share a cautionary tale of mass cargoculting before we wrap up for today.
    Please bear with me as I stroke my beard for a moment.\r\n\r\n### Abusing the
    Constant Lookup Operator (`::`)\r\n\r\nIn some older documentation, and some relatively
    recent code written by folks who learned from old documentation, you may see class
    methods being called in the manner shown below.\r\n\r\n```ruby\r\nYAML::load(File::read(\"foo.yaml\"))\r\n```\r\n\r\nWhile
    the above code runs fine, it's only a historical accident that it does. In fact,
    `::` was never meant for method invocation, class methods or otherwise. You can
    easily demonstrate that `::` can be used to execute instance methods as well,
    which eliminates any notion that `::` has some special 'class methods only' distinction
    to it.\r\n\r\n```ruby  \r\n\"foo\"::reverse #=> \"oof\"\r\n```\r\n\r\nAs far as
    I can tell, this style of method invocation actually came about as a documentation
    convention. In both formal documentation and in mailing list discussions, it can
    sometimes be difficult to discern whether someone is talking about a class method
    or instance method, since both can be called just as well with the dot operator.
    So, a convention was invented so that for a class `Foo`, the instance method `bar`
    would be referred to as `Foo#bar`, and the class method `bar` would be referred
    to as `Foo::bar`. This did away with the dot entirely, leaving no room for ambiguity.\r\n\r\nUnfortunately,
    this lead to a confusing situation. Beginners would often type `Foo#bar` to try
    to call instance methods, but were at least promptly punished for doing so because
    such code will not run at all. However, typing `Foo::bar` does work! Thus, an
    entire generation of Ruby developers were born thinking that `::` is some sort
    of special operator for calling class methods, and to an extent, others followed
    suit as a new convention emerged.\r\n\r\nThe fact that `::` will happily call
    methods for you has to do with internal implementation details of MRI, and so
    it's actually an undefined behavior, subject to change. As far as I know, there
    is no guarantee it will actually work as expected, and so it shouldn't be relied
    upon.\r\n\r\nIn your code, you should feel free to replace any method calls that
    use this style with ordinary `Foo.bar` calls. This actually reflects more of the
    true nature of Ruby, in that it doesn't emphasize the difference between class
    level calls and instance level calls, since that distinction isn't especially
    important. In documentation, things are a little trickier, but it is now generally
    accepted that `Foo.bar` refers to a class method and `Foo#bar` refers to an instance
    method. In cases where that distinction alone might be confusing, you could always
    be explicit, as in the example below.\r\n\r\n```ruby\r\nobj.bar # obj is an instance
    of Foo\r\n```\r\n\r\nIf this argument wasn't convincing enough, you should know
    that every time you replace a `Foo::bar` call with `Foo.bar`, a brand new baby
    unicorn is born beneath a magnificent double rainbow. That should be reason enough
    to reverse this outdated practice, right?\r\n\r\n### Reflections \r\n\r\nThis
    article probably gave you more details than you ever cared to know about namespacing.
    But future articles will be sure to blow your mind with what else modules can
    do. However, if you have any questions or thoughts about what we've discussed
    so far, feel free to leave them in the comments section below.\r\n  \r\n> **NOTE:**
    This article has also been published on the Ruby Best Practices blog. There [may
    be additional commentary](http://blog.rubybestpractices.com/posts/gregory/037-issue-8-uses-for-modules.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: uses-for-modules-2
  :title: Uses for Modules, Part 2
  :summary: Use mixins as an alternative to multiple inheritance to augment class
    definitions.
  :published: 2010-12-10 00:00:00.000000000 Z
  :issue_number: '1.9'
  :volume: 1
  :body: "> Note: This article series on modules is also available as a [PDF download].
    The\r\n> PDF version has been revised and is more up-to-date than what you see
    here.\r\n\r\n[PDF download]:https://github.com/elm-city-craftworks/pr-monthly/blob/gh-pages/b5e5a89847701c4aa7c170cf/sept-2012-modules.pdf?raw=true\r\n\r\n###
    Using Mix-ins to Augment Class Definitions\r\n\r\nAlthough knowing [how to use
    modules for namespacing](http://practicingruby.com/articles/36) is important,
    it's really only a small part of what you can do with modules. What modules do
    best is providing a convenient way to write code that can be mixed into other
    objects, augmenting their behaviors. Because modules facilitate code sharing in
    a way that is distinct from both the general OO concept of class inheritance and
    from things like Java's interfaces, they require you to think about your design
    in a way that's a bit different from most other object oriented programming languages.\r\n\r\nWhile
    I imagine that most of our readers are comfortable with using mixins, I'll\r\nrefer
    to some core Ruby mixins to illustrate their power before moving on to more \r\nsubtle
    points. For example, consider the following bit of code which implements lazily
    evaluated computations:\r\n\r\n```ruby\r\nclass Computation\r\n\r\n  def initialize(&block)\r\n
    \   @action = block\r\n  end\r\n\r\n  def result\r\n    @result ||= @action.call\r\n
    \ end\r\n\r\n  def <(other)\r\n    result < other.result\r\n  end\r\n\r\n  def
    >(other)\r\n    result > other.result\r\n  end\r\n\r\n  def >=(other)\r\n    result
    >= other.result\r\n  end\r\n\r\n  def <=(other)\r\n    result <= other.result\r\n
    \ end\r\n\r\n  def ==(other)\r\n    result == other.result\r\n  end\r\n\r\nend\r\n\r\na
    = Computation.new { 1 + 1 }\r\nb = Computation.new { 4*5 }\r\nc = Computation.new
    { -3 }\r\n\r\np a < b  #=> true\r\np a <= b #=> true\r\np b > c  #=> true\r\np
    b >= c #=> true\r\np a == b #=> false\r\n```\r\n\r\nWhile Ruby makes defining
    custom operators easy, there is a lot more code here than there needs to be. We
    can easily clean it up by mixing in Ruby's built in `Comparable` module.\r\n\r\n```ruby\r\nclass
    Computation\r\n  include Comparable\r\n\r\n  def initialize(&block)\r\n    @action
    = block\r\n  end\r\n\r\n  def result\r\n    @result ||= @action.call\r\n  end\r\n\r\n
    \ def <=>(other)\r\n    return  0 if result == other.result\r\n    return  1 if
    result > other.result\r\n    return -1 if result < other.result\r\n  end\r\nend\r\n\r\na
    = Computation.new { 1 + 1 }\r\nb = Computation.new { 4*5 }\r\nc = Computation.new
    { -3 }\r\n\r\np a < b  #=> true\r\np a <= b #=> true\r\np b > c  #=> true\r\np
    b >= c #=> true\r\np a == b #=> false\r\n```\r\n\r\nWe see that our individual
    operator definitions have disappeared, and in its place are two new bits of code.
    The first new thing is just an include statement that tells Ruby to mix the `Comparable`
    functionality into the `Computation` class definition. But in order to make use
    of the mixin, we need to tell `Comparable` how to evaluate the sort order of our
    `Computation` objects, and that's where `<=>` comes in.\r\n\r\nThe `<=>` method,
    sometimes called the spaceship operator, essentially fills in a template method
    that allows `Comparable` to work. It codifies the notion of comparison in an abstract
    manner by expecting the method to return `-1` when the current object is considered
    less than the object it is being compared to, `0` when the two are considered
    equal, and `1` when the current object is considered greater than the object it
    is being compared to.\r\n\r\nIf you're still scratching your head a bit, pretend
    that rather than being a core Ruby object, that we've implemented `Comparable`
    ourselves by writing the following code.\r\n\r\n```ruby\r\nmodule Comparable\r\n
    \ def ==(other)\r\n    (self <=> other) == 0\r\n  end\r\n\r\n  def <(other)\r\n
    \   (self <=> other) == -1\r\n  end\r\n\r\n  def <=(other)\r\n    self < other
    || self == other\r\n  end\r\n\r\n  def >(other)\r\n    (self <=> other) == 1\r\n
    \ end\r\n\r\n  def >=(other)\r\n    self > other || self == other\r\n  end\r\nend\r\n```\r\n\r\nNow,
    if you imagine these method definitions literally getting pasted into your `Computation`
    class when `Comparable` is included, you'll see that it would provide a behavior
    that is functionally equivalent to our initial example.\r\n\r\nOf course, it wouldn't
    make sense for Ruby to implement such a feature for us\r\nwithout using it in
    its own structures. Because Ruby's numeric classes\r\nall implement `<=>`, we
    are able to simply delegate our `<=>` call to the \r\nresult of the computations.\r\n\r\n```ruby\r\nclass
    Computation\r\n  include Comparable\r\n\r\n  def initialize(&block)\r\n    @action
    = block\r\n  end\r\n\r\n  def result\r\n    @result ||= @action.call\r\n  end\r\n\r\n
    \ def <=>(other)\r\n    result <=> other.result\r\n  end\r\nend\r\n```\r\n\r\nThe
    only requirement for this code to work as expected is that each `Computation`'s
    result must implement the `<=>` method. Since all objects that mix in `Comparable`
    have to implement `<=>`, any comparable object returned as a result should work
    fine here.\r\n\r\nWhile not a technically complicated example, there is surprising
    power in having a primitive built into your programming language which trivializes
    the implementation of the Template Method design pattern. If you look at Ruby's
    `Enumerable` module and the powerful features it offers, you might think it would
    be a much more complicated example to study. But it too hinges on Template Method
    and requires only an `each()` method to give you all sorts of complex functionality
    including things like `select()`, `map()`, and `inject()`. If you haven't tried
    it before, you should certainly try to roll your own `Enumerable` module to get
    a sense of just how useful mixins can be.\r\n\r\nWe can also invert this relationship
    by having our class define a template, and then relying on the module that we
    mix in to provide the necessary details. If we look back at a previous example
    `TicTacToe`, we can see a practical example of this technique by looking at the
    play method in our `TicTacToe::Game` class.\r\n\r\n```ruby\r\nmodule TicTacToe\r\n
    \ class Game\r\n    def play\r\n      catch(:finished) do\r\n        loop do\r\n
    \         start_new_turn\r\n          show_board\r\n\r\n          check_move {
    |error_message| puts error_message }\r\n          check_win { puts \"#{current_player}
    wins\" }\r\n          check_draw { puts \"It's a tie\" }\r\n        end\r\n      end\r\n
    \   end\r\n\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nIn this code, we wanted
    to keep our event loop abstract, and rely on a mixed in module to provide the
    logic for executing and validating a move as well as checking end game conditions.
    As a result, we ended up with the `TicTacToe::Rules` module shown below.\r\n\r\n```ruby\r\nmodule
    TicTacToe\r\n  module Rules\r\n    def check_move\r\n      row, col = move_input\r\n
    \     board[row, col] = current_player\r\n    rescue TicTacToe::Board::InvalidRequest
    => error\r\n      yield error.message if block_given?\r\n      retry\r\n    end\r\n\r\n
    \   def check_win\r\n      return false unless board.last_move\r\n\r\n      win
    = board.intersecting_lines(*board.last_move).any? do |line|\r\n        line.all?
    { |cell| cell == current_player }\r\n      end\r\n\r\n      if win\r\n        yield\r\n
    \       game_over\r\n      end\r\n    end\r\n\r\n    def check_draw\r\n      if
    @board.covered?\r\n        yield\r\n        game_over\r\n      end\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nWhen we look at this code, we see some basic business
    logic implementing the rules of Tic Tac Toe, with some placeholder hooks being
    provided by `yield()` that allows the calling code to inject some logic at certain
    key points in the process. This is how we manage to split the UI code from the
    game logic, without creating frivolous adapter classes.\r\n\r\nWhile this is a
    more complicated example than our walkthrough of `Comparable`, the two share a
    common thread. In both cases, some coupling exists between the module and the
    object it is being mixed into. This is a common pattern when using mixins, in
    which the module and the code it is mixed into have to do a bit of a secret handshake
    to be able to talk to one another, but as long as they agree on that, neither
    needs to know about the other's inner workings. The end result is two components
    which must agree on an interface but do not need to necessarily understand each
    other's implementations. Code with this sort of coupling is easy to test and easy
    to refactor.\r\n\r\n### Using Mix-ins to Augment Objects Directly\r\n\r\nAs you
    may already know, Ruby's mixin capability is not limited to simply including new
    behavior into a class definition. You can also extend the behavior of a class
    itself, through the use of the `extend()` method. We can look to the Ruby standard
    library <i>forwardable</i> for a nice example of how this is used. Consider the
    following trivial `Stack` implementation.\r\n\r\n```ruby\r\nrequire \"forwardable\"\r\n\r\nclass
    Stack\r\n  extend Forwardable\r\n\r\n  def_delegators :@data, :push, :pop, :size,
    :first, :empty?\r\n\r\n  def initialize\r\n    @data = []\r\n  end\r\nend\r\n```\r\n\r\nIn
    this example, we can see that after we extend our `Stack` class with the `Forwardable`
    module, we are provided with a class level method called `def_delegators` which
    allows us to easily define methods which delegate to an object stored in the specified
    instance variable. Playing around with the `Stack` object a bit should illustrate
    what this code has done for us.\r\n\r\n```ruby\r\n>> stack = Stack.new\r\n=> #<Stack:0x4f09c
    @data=[]>\r\n>> stack.push 1\r\n=> [1]\r\n>> stack.push 2\r\n=> [1, 2]\r\n>> stack.push
    3\r\n=> [1, 2, 3]\r\n>> stack.size\r\n=> 3\r\n>> until stack.empty?\r\n>>   p
    stack.pop\r\n>> end\r\n3\r\n2\r\n1\r\n```\r\n\r\nAs before, it may be helpful
    to think about how we might implement `Forwardable` ourselves. The following bit
    of code shows one way to approach the problem.\r\n\r\n```ruby\r\nmodule MyForwardable\r\n
    \ def def_delegators(ivar, *delegated_methods)\r\n    delegated_methods.each do
    |m|\r\n      define_method(m) do |*a, &b|\r\n        obj = instance_variable_get(ivar)\r\n
    \       obj.send(m,*a, &b)\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhile
    the metaprogramming aspects of this may be a bit noisy to read if you're not familiar
    with them, this is fairly vanilla dynamic Ruby code. If you've got Ruby 1.9.2
    installed, you can actually try it out on your own and verify that it does indeed
    work as expected. But the practical use case of this code isn't what's important
    here.\r\n\r\nThe key thing to notice about this code is that while it essentially
    implements a class method, nothing in the module's syntax directly indicates this
    to be the case. The only hint we get that this is meant to be used at the class
    level is the use of `define_method()`, but we need to dig into the implementation
    code to notice that.\r\n\r\nBefore we wrap up, we should investigate why this
    is the case.\r\n\r\n### A Brief Stroking of the Beard\r\n\r\nThe key thing to
    recognize is that `include()` mixes methods into the instances of the base object
    while `extend()` mixes methods into the base object itself. Notice that this is
    more general than a class method / instance method dichotomy.\r\n\r\nLet's explore
    a few different possibilities using a somewhat contrived example so that we can
    focus on the mixin mechanics. First, we start with an ordinary module, which is
    somewhat useless on its own.\r\n\r\n```ruby\r\nmodule Greeter\r\n  def hello\r\n
    \   \"hi\"\r\n  end\r\nend\r\n```\r\n\r\nBy including `Greeter` into `SomeClass`,
    we make it so that we can now call `hello()` on instances of `SomeClass`.\r\n\r\n```ruby\r\nclass
    SomeClass\r\n  include Greeter\r\nend\r\n\r\nSomeClass.new.hello #=> \"hi\"\r\n```\r\n\r\nBut
    as we saw in the `Forwardable` example, extending `AnotherClass` with `Greeter`
    would allow us to call the hello method directly at the class level, as in the
    example below.\r\n\r\n```ruby\r\nclass AnotherClass\r\n  extend Greeter\r\nend\r\n\r\nAnotherClass.hello
    #=> \"hi\"\r\n```\r\n\r\nBe sure to note at this point that `extend()` and `include()`
    are two totally\r\ndifferent operations. Because you did not extend `SomeClass`
    with `Greeter`, you\r\ncould not call `SomeClass.hello()`. Similarly, you cannot
    call\r\n`AnotherClass.new.hello()` without explicitly including `Greeter`.\r\n\r\nFrom
    the examples so far, it might seem as if `include()` is for defining instance
    methods, and `extend()` is for class methods. But that is not quite accurate,
    and the next bit of code illustrates just how much deeper the rabbit hole goes.\r\n\r\n```ruby\r\nobj
    = Object.new\r\nobj.extend(Greeter)\r\nobj.hello #=> \"hi\"\r\n```\r\n\r\nBefore
    you let this example make you go cross-eyed, let's review the key point I made
    at the beginning of this section: <i>The key thing to recognize is that `include()`
    mixes methods into the instances of the base object while `extend()` mixes methods
    into the base object itself.</i>\r\n\r\nSince not every base object can have instances,
    not every object can have modules included into them (in fact, only classes can).
    But *every* object can be extended by modules. This includes, among other things,
    classes and modules themselves.\r\n\r\nLet's try to bring the two `extend()` examples
    closer together with the following little snippet:\r\n\r\n```ruby\r\nMyClass =
    Class.new\r\nMyClass.extend(Greeter)\r\nMyClass.hello #=> \"hi\"\r\n```\r\n\r\nIf
    you feel like you understand the lines above, you're ready for the rest\r\nof
    this mini-series. If not, please ponder the following questions and leave a\r\ncomment
    sharing your thoughts.\r\n\r\n### Questions To Consider\r\n\r\n  * Why do we have
    both `include()` and `extend()` available to us? Why not just have one way of
    doing mixins?\r\n\r\n  * When you write `extend()` within a class definition,
    does it do any sort of special casing? Or is it the same as calling `extend()`
    on any other object?\r\n\r\n  * Except for mixing in class methods, what is `extend()`
    useful for?\r\n\r\nPlease feel free to ask for hints on any of these if you're
    stumped, or share your answers if you'd like to help others and maybe get a bit
    of feedback to check your assumptions against.\r\n\r\n  \r\n> **NOTE:** This article
    has also been published on the Ruby Best Practices blog. There [may be additional
    commentary](http://blog.rubybestpractices.com/posts/gregory/038-issue-9-uses-for-modules.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: uses-for-modules-3
  :title: Uses for Modules, Part 3
  :summary: See how modules can be used as namespaced function bags, and as singleton
    objects.
  :published: 2010-12-14 00:00:00.000000000 Z
  :issue_number: '1.10'
  :volume: 1
  :body: "> Note: This article series on modules is also available as a [PDF download].
    The\r\n> PDF version has been revised and is more up-to-date than what you see
    here.\r\n\r\n[PDF download]:https://github.com/elm-city-craftworks/pr-monthly/blob/gh-pages/b5e5a89847701c4aa7c170cf/sept-2012-modules.pdf?raw=true\r\n\r\nIn
    the last two issues, we covered mixins and namespacing, two of the most common
    uses for modules. In the second half of this series, we'll look at some other
    ways to use modules that are not quite so obvious.\r\n\r\nWe can now focus on
    the question that caused me to write this series in the\r\nfirst place. Many readers
    were confused by my use of `extend self` within\r\nearlier Practicing Ruby articles,
    and this lead to a number of interesting\r\nquestions on the mailing list at the
    time these articles were originally\r\npublished. While I tried my best to answer
    them directly, I think we're in better\r\nshape to study this topic now that the
    last two articles have laid a \r\nfoundation for us.\r\n\r\n### Review of how
    `extend()` works\r\n\r\nTo understand this trick of mixing modules into themselves,
    one first must understand how `extend()` works. We covered this concept at the
    end of the last article, but we can touch on it again for good measure. Start
    by considering the trivial module shown below.\r\n\r\n```ruby\r\nmodule Greeter\r\n
    \ def hello\r\n    \"hi\"\r\n  end\r\nend \r\n```\r\n\r\nWe had shown that unlike
    `include()` which is especially designed for augmenting class definitions so that
    a mixin can add instance methods to some target class, `extend()` has a much more
    simple behavior and works with any object.\r\n\r\n```ruby\r\nobj = Object.new\r\nobj.extend(Greeter)\r\nobj.hello
    #=> \"hi\"\r\n```\r\n\r\nFrom this, we can see that mixing in a module by using
    extend simply mixes the methods defined by the module directly at that object's
    level. In this way, the methods defined by the module are mixed into the receiver,
    no matter what that object is.\r\n\r\nIn Ruby, classes and modules are ordinary
    objects. We can confirm this by doing a tiny bit of introspection on `Greeter`.\r\n\r\n```ruby\r\n>>
    Greeter.object_id\r\n=> 212500\r\n>> Greeter.class\r\n=> Module\r\n>> Greeter.respond_to?(:extend)\r\n=>
    true\r\n```\r\n\r\nWhile this may be a mental leap for some, you might be able
    to find peace with it by considering the ordinary module definition syntax to
    be a bit of sugar that is functionally equivalent to the following bit of code.\r\n\r\n```ruby
    \ \r\nGreeter = Module.new do\r\n  def hello\r\n    \"hi\"\r\n  end\r\nend\r\n```\r\n\r\nWhen
    written in this way, it becomes far more obvious that `Greeter` is actually just
    an instance of the class Module, making it an ordinary Ruby object at its core.
    Once you feel that you understand this point, consider what happens when the following
    line of code is run.\r\n\r\n```ruby\r\nGreeter.extend(Greeter)\r\n```\r\n\r\nIf
    we compare this to previous examples of `extend()`, it should be clear now that
    despite the seemingly circular reference, this line does exactly what it would
    if called on any other object: It mixes the methods defined by `Greeter` directly
    into the `Greeter` object itself. A simple test confirms this to be true.\r\n\r\n```ruby\r\nGreeter.hello
    #=> \"hi\"\r\n```\r\n\r\nIf we unravel things a bit, we find that we could have
    written our `extend()` call slightly differently, by doing it from within the
    module definition itself:\r\n\r\n```ruby\r\nmodule Greeter\r\n  extend Greeter\r\n\r\n
    \ def hello\r\n    \"hi\"\r\n  end\r\nend\r\n```\r\n\r\nThe reason `extend()`
    works here is because `self == Greeter` in this context.\r\nNoticing this detail
    allows us to use slightly more dynamic approach, resulting\r\nin the following
    code.\r\n\r\n```ruby\r\nmodule Greeter\r\n  extend self\r\n\r\n  def hello\r\n
    \   \"hi\"\r\n  end\r\nend\r\n```\r\n\r\nYou'll find this new code to be functionally
    identical to the previous example, but slightly more flexible. Now, if we change
    the name of our module, we won't need to update our `extend()` call. This is why
    folks tend to write `extend self` rather than `extend TheCurrentModule`.\r\n\r\nHopefully
    by now, it is clear that this trick does not involve any sort of special casing
    for modules, and is an ordinary application of the `extend()` method provided
    by every Ruby object. The only thing that might be confusing is the seemingly
    recursive nature of the technique, but this issue disappears when you recognize
    that modules are not mixed into anything by default, and that modules themselves
    are not directly related to the methods they define. If you understand the difference
    between class and instance methods in Ruby, this isn't a far stretch from that
    concept.\r\n\r\nWhile the inner workings of modules are an interesting academic
    topic, my emphasis is always firmly set on practical applications of programming
    techniques rather than detached conceptual theory. So now that we've answered
    'how does this work?', let's focus on the much more interesting 'how can I use
    it?' topic.\r\n\r\n### Self-Mixins as Function Bags\r\n\r\nA fascinating thing
    about Ruby is the wide range of different software design paradigms it supports.
    While object-oriented design is heavily favored, Ruby can do a surprisingly good
    job of emulating everything from procedure programming to prototype-based programming.
    But the one area that Ruby overlaps most with is functional programming.\r\n\r\nNow,
    before you retire your parenthesis for good and herald Ruby as a replacement for
    LISP, be warned: There is a lot about Ruby's design that makes it a horrible language
    for functional programming. But when used sparingly, techniques from the functional
    world fit surprisingly well in Ruby programs. The technique I find most useful
    is the ability to organize related functions together under a single namespace.\r\n\r\nWhen
    we create class definitions, we tend to think of the objects we're building as
    little structures which manage state and provide behaviors which manipulate that
    state. But sometimes, a more stateless model makes sense. The closer you get to
    pure mathematics, the more a pure functional model makes sense. We need to look
    no farther than Ruby's own `Math` module for an example:\r\n\r\n```ruby\r\n>>
    Math.sin(Math::PI/2.0)\r\n=> 1.0\r\n>> Math.log(Math::E)\r\n=> 1.0\r\n```\r\n\r\nIt
    seems unlikely that we'd want to create an instance of a `Math` object, since\r\nit
    doesn't really deal with any state that persists beyond a single function\r\ncall.
    But it might be desirable to mix this functionality into another object so\r\nthat
    you can call math functions without repeating the `Math` constant\r\nexcessively.
    For this reason, Ruby implements `Math` as a module.\r\n\r\n```ruby\r\n>> Math.class\r\n=>
    Module\r\n```\r\n\r\nFor another great example of modular code design in Ruby
    itself, be sure to check out the `FileUtils` standard library, which allows you
    to execute basic *nix file operations as if they were just ordinary function calls.\r\n\r\nAfter
    seeing how Ruby is using this technique, I didn't find it hard to stumble upon
    scenarios in my own code that could benefit from a similar design. For example,
    when I was working on building out the backend for a trivia website, I was given
    some logic for normalizing user input so that it could be compared against a predetermined
    pattern.\r\n\r\nWhile I could have stuck this logic in a number of different places,
    I decided I wanted to put it within a module of its own, because its logic did
    not rely on any persistent state and could be defined independently of the way
    our questions and quizzes were modeled. The following code is what I came up with:\r\n\r\n```ruby\r\nmodule
    MinimalAnswer\r\n  extend self\r\n\r\n  def match?(pattern, input)\r\n    pattern.split(/,/).any?
    do |e| \r\n      normalize(input) =~ /\\b#{normalize(e)}/i \r\n    end\r\n  end\r\n\r\n
    \ private\r\n\r\n  def normalize(input)\r\n    input.downcase.strip.gsub(/\\s+/,\"
    \").gsub(/[?.!\\-,:'\"]/, '')\r\n  end\r\nend\r\n```\r\n\r\nThe nice thing about
    the code above is that using a modular design doesn't force you to give up things
    like private methods. This allows you to keep your user facing API narrow while
    still being able to break things out into helper methods.\r\n\r\nHere is a simple
    example of how my `MinimalAnswer` module is used within the application:\r\n\r\n```ruby\r\n>>
    MinimalAnswer.match?(\"Cop,Police Officer\", \"COP\")\r\n=> true\r\n>> MinimalAnswer.match?(\"Cop,Police
    Officer\", \"police officer\")\r\n=> true\r\n>> MinimalAnswer.match?(\"Cop,Police
    Officer\", \"police office\")\r\n=> false\r\n>> MinimalAnswer.match?(\"Cop,Police
    Officer\", \"police officer.\")\r\n=> true\r\n```\r\n\r\nNow as I said before,
    this is a minor bit of functionality and could probably be shelved onto something
    like a `Question` object or somewhere else within the system. But the downside
    of that approach would be that as this `MinimalAnswer` logic began to get more
    complex, it would begin to stretch the scope of whatever object you attached this
    logic to. By breaking it out into a module right away, we give this code its own
    namespace to grow in, and also make it possible to test the logic in isolation,
    rather than trying to bootstrap a potentially much more complex object in order
    to test it.\r\n\r\nSo whenever you have a bit of logic that seems to not have
    many state dependencies between its functions, you might consider this approach.
    But since stateless code is rare in Ruby, you may wonder if learning about self-mixins
    really bought us that much.\r\n\r\nAs it turns out, the technique can also be
    used in more stateful scenarios when you recognize that Ruby modules are objects
    themselves, and like any object, can contain instance data.\r\n\r\n### Self-Mixins
    for Implementing Singleton Pattern\r\n\r\nRuby overloads the term 'singleton object',
    so we need to be careful about terminology here. What I'm about to show you is
    how to use these self-mixed modules to implement something similar to the [Singleton
    design pattern](http://en.wikipedia.org/wiki/Singleton_pattern).\r\n\r\nI've found
    in object design that objects typically need zero, one, or many instances. When
    an object doesn't really need to be instantiated at all because it has no data
    in common between its behaviors, the modular approach we just reviewed often works
    best. The vast majority of the remaining cases fall into ordinary class definitions
    which facilitate many instances. Virtually everything we model fits into this
    category, so it's not worth discussing in detail. However, there are some cases
    in which a single object is really all we need. In particular, configuration systems
    come to mind.\r\n\r\nThe following example shows a simple DSL I wrote for the
    trivia application I had mentioned earlier. It may look familiar, and that is
    because it appeared in our discussion on writing configuration systems some weeks
    ago. This time around, our focus will be on how this system actually works rather
    than what purpose it serves.\r\n\r\n```ruby\r\nAccessControl.configure do\r\n
    \ role \"basic\",\r\n    :permissions => [:read_answers, :answer_questions]\r\n\r\n
    \ role \"premium\",\r\n    :parent      => \"basic\",\r\n    :permissions => [:hide_advertisements]\r\n\r\n
    \ role \"manager\",\r\n    :parent      => \"premium\",\r\n    :permissions =>
    [:create_quizzes, :edit_quizzes]\r\n\r\n  role \"owner\",\r\n    :parent      =>
    \"manager\",\r\n    :permissions => [:edit_users, :deactivate_users]\r\nend \r\n```\r\n\r\nTo
    implement code that allows the definitions above to be modeled internally, we
    need to consider how this system will be used. While it is easy to imagine roles
    shifting over time, getting added and removed as needed, it's hard to imagine
    what the utility of having more than one `AccessControl` object would be.\r\n\r\nFor
    this reason, it's safe to say that `AccessControl` configuration data is global
    information, and so does not need the data segregation that creating instances
    of a class provides.\r\n\r\nBy modeling `AccessControl` as a module rather than
    class, we end up with an object that we can store data on that can't be instantiated.\r\n\r\n```ruby\r\nmodule
    AccessControl\r\n  extend self\r\n\r\n  def configure(&block)\r\n    instance_eval(&block)\r\n
    \ end\r\n\r\n  def definitions\r\n    @definitions ||= {}\r\n  end\r\n\r\n  #
    Role definition omitted, replace with a stub if you want to test\r\n  # or refer
    to Practicing Ruby Issue #4\r\n  def role(level, options={})\r\n    definitions[level]
    = Role.new(level, options)\r\n  end\r\n\r\n  def roles_with_permission(permission)\r\n
    \   definitions.select { |k,v| v.allows?(permission) }.map { |k,_| k }\r\n  end\r\n\r\n
    \ def [](level)\r\n    definitions[level]\r\n  end \r\nend\r\n```\r\n\r\nThere
    are two minor points of potential confusion in this code worth discussing, the
    first is the use of `instance_eval` in `configure()`, and the second is that the
    `definitions()` method refers to instance variables. This is where we need to
    remind ourselves that the scope of methods defined by a module cannot be determined
    until it is mixed into something.\r\n\r\nOnce we recognize these key points, a
    bit of introspection shows us what is really going on.\r\n\r\n```ruby\r\n>> AccessControl.configure
    { \"I am #{self.inspect}\" }\r\n=> \"I am AccessControl\"\r\n>> AccessControl.instance_eval
    { \"I am #{self.inspect}\" }\r\n=> \"I am AccessControl\"\r\n>> AccessControl.instance_variables\r\n=>
    [\"@definitions\"]\r\n```\r\n\r\nSince `AccessControl` is an ordinary Ruby object,
    it has ordinary instance variables and can make use of `instance_eval` just like
    any other object. The key difference here is that `AccessControl` is a module,
    not a class, and so cannot be used as a factory for creating more instances. In
    fact, calling `AccessControl.new` raises a `NoMethodError`.\r\n\r\nIn a traditional
    implementation of Singleton Pattern, you have a class which disables instantiation
    through the ordinary means, and creates a single instance that is accessible through
    the class method `instance()`. However, this seems a bit superfluous in a language
    in which classes are full blown objects, and so isn't necessary in Ruby.\r\n\r\nFor
    cases like the configuration system we've shown here, choosing to use this approach
    is reasonable. That having been said, the reason why I don't have another example
    that I can easily show you is that with the exception of this narrow application
    for configuration objects, I find it relatively rare to have a legitimate need
    for the Singleton Pattern. I'm sure if I thought long and hard on it, I could
    dig some other examples up, but upon looking at recent projects I find that variants
    of the above are all I use this technique for.\r\n\r\nHowever, if you work with
    other people's code, it is likely that you'll run into someone implementing Singleton
    Pattern this way. Now, rather than scratching your head, you will have a solid
    understanding of how this technique works, and why someone might want to use it.\r\n\r\n###
    Reflections\r\n\r\nIn Issue 11, we'll wrap up with some even more specialized
    uses for modules, showing how they can be used to build plugin systems as well
    as how they can be used as a replacement for monkey patching. But before we close
    the books on today's lesson, I'd like to share some thoughts that were rattling
    around in the back of my mind while I was preparing this article.\r\n\r\nThe techniques
    I've shown today can be useful in certain edge case scenarios\r\nwhere an ordinary
    class definition might not be the best tool to use. In my own\r\ncode, I tend
    to use the first technique of creating function bags often but sparingly, \r\nand
    the second technique of building singleton objects rarely and typically only \r\nfor
    configuration systems.\r\n\r\nUpon reflection, I wonder to myself whether the
    upsides of these techniques outweigh the cost of explaining them. I don't really
    have a definitive answer to that question, but it's really something I think about
    often.\r\n\r\nOn the one hand, I feel that users of Ruby should have an ingrained
    understanding of its object system. After all, these are actually fairly straightforward
    techniques once you understand how things work under the hood. It's also true
    that you can't really claim to understand Ruby's object system without fully understanding
    these examples. Having a weak understanding of how Ruby's objects work is sure
    to rob you of the joy of working in Ruby, so for this reason, I feel like 'dumbing
    down' our code would be a bad thing.\r\n\r\nOn the other hand, I think that for
    the small gains yielded by using these techniques, we require those who are reading
    our code to understand a whole score of details that are unique to Ruby. When
    you consider that by changing a couple lines of code, you can have a design which
    is not much worse but is understandable by pretty much anyone who has programmed
    in an OO language before, it's certainly tempting to cater to the lowest common
    denominator.\r\n\r\nBut this sort of split-mindedness is inevitable in Ruby, and
    comes up in many scenarios. The truth of the matter is that it's going to take
    many more years before Ruby is truly understood by the programming community at
    large. But as more people dive deeper into Ruby, Ruby is starting to come into
    its own, and the mindset that things should be done as they are in other languages
    is not nearly as common as it was several years ago. For this reason, it's important
    to stop thinking of Ruby in terms of whatever language you've come from, and start
    thinking of it as its own thing. As soon as you do that, a whole range of possibilities
    open up.\r\n\r\nAt least, that's what I think. What about you?\r\n\r\n  \r\n>
    **NOTE:** This article has also been published on the Ruby Best Practices blog.
    There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/040-issue-10-uses-for-modules.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: uses-for-modules-3a
  :title: Addendum to Uses For Modules, Part 3
  :summary: Learn the subtle differences between "extend self", "def self.method",
    and "module_function".
  :published: 2010-12-15 00:00:00.000000000 Z
  :issue_number: 1.10.a
  :volume: 1
  :body: "> Note: This article series on modules is also available as a [PDF download].
    The\r\n> PDF version has been revised and is more up-to-date than what you see
    here.\r\n\r\n[PDF download]:https://github.com/elm-city-craftworks/pr-monthly/blob/gh-pages/b5e5a89847701c4aa7c170cf/sept-2012-modules.pdf?raw=true\r\n\r\nIn
    the [last issue](http://practicingruby.com/articles/38), we discussed the use
    of `extend self` in great detail, but neglected to cover a pair of alternatives
    that seem on the surface to be functionally equivalent. While I don't want to
    spend too much time rehashing an old topic, I want to at least provide an example
    of each approach and comment on their quirks.\r\n\r\n### Defining methods at the
    module level\r\n\r\nOccasionally folks ask whether mixing a module into itself
    via `extend()` is equivalent to the code shown below.\r\n\r\n```ruby\r\nmodule
    Greeter\r\n  def self.hello\r\n    \"hi\"\r\n  end\r\nend\r\n```\r\n\r\nThe short
    answer to that question is \"no\", but it is easy to see where the confusion comes
    from, because calling `Greeter.hello` does indeed work as expected. But the important
    distinction is that methods defined in this way are simply directly defined on
    the module itself and so cannot be mixed into anything at all. There is really
    very little difference between the above code and the example below.\r\n\r\n```ruby
    \ \r\nobj = Object.new\r\n\r\ndef obj.hello\r\n  \"hi\"\r\nend\r\n```\r\n\r\nConsider
    our earlier example of Ruby's `Math` or `FileUtils` modules. With both of these
    modules, you can envision scenarios in which you would call the functions on the
    modules themselves. But there are also cases where using these modules as mixins
    would make a lot of sense. For example, Ruby itself ships with a math mode (-m)
    for irb which mixes in the `Math` module at the top level so you can call its
    functions directly.\r\n\r\n```ruby\r\n$ irb -m\r\n>> sin(Math::PI/2)\r\n=> 1.0\r\n```\r\n\r\nIn
    the above example, if `sin()` were implemented by defining the method\r\ndirectly
    on the `Math` module, there would be no way to mix it into anything.\r\nWhile
    sometimes it might make sense to force a module to never be used as a\r\nmixin,
    that use case is rare, and so little is gained by defining methods on\r\nmodules
    rather than using the `extend self` technique.\r\n\r\n### Using `module_function`\r\n\r\nBefore
    people got in the habit of mixing modules into themselves, they often relied on
    a more specialized feature called `module_function` to accomplish the same goals.\r\n\r\n```ruby\r\nmodule
    Greeter\r\n  module_function\r\n\r\n  def hello\r\n    \"hi\"\r\n  end\r\nend\r\n```\r\n\r\nThis
    code allows the direct calling of `Greeter.hello`, and does not prevent\r\n`Greeter`
    from being mixed into other objects. The `module_function` approach\r\nalso allows
    you to choose certain methods to be module functions while \r\nleaving others
    accessible via mixin only:\r\n\r\n```ruby\r\nmodule Greeter\r\n  def hello\r\n
    \   \"hi\"\r\n  end\r\n\r\n  def goodbye\r\n    \"bye\"\r\n  end\r\n\r\n  module_function
    :hello\r\nend\r\n```\r\n\r\nWith this modified definition, it is still possible
    to call `Greeter.hello`, but attempting to call `Greeter.goodbye` would raise
    a `NoMethodError`. This sort of sounds like it offers the benefits of extending
    a module with itself, but with some added granularity. Unfortunately, there is
    something about `module_function` that makes it quite weird to work with.\r\n\r\nAs
    it turns out, `module_function` works very different under the hood than self-mixins
    do. This is because `module_function` actually doesn't manipulate the method lookup
    path, but instead, it makes a direct copy of the specified methods and attaches
    them to the module itself. If that sounds too weird to be true, check out the
    code below.\r\n\r\n```ruby \r\nmodule Greeter\r\n  def hello\r\n    \"hi\"\r\n
    \ end\r\n\r\n  module_function :hello\r\n\r\n  def hello\r\n    \"howdy\"\r\n
    \ end\r\nend\r\n\r\nGreeter.hello #=> \"hi\"\r\n\r\nclass Foo\r\n  include Greeter\r\nend\r\n\r\nFoo.new.hello
    #=> \"howdy\"\r\n```\r\n\r\nPretty weird behavior, right? You may find it interesting
    to know that I was not actually aware that `module_function` made copies of methods
    until I wrote Issue #10 and was tipped off about this by one of our readers. However,
    I did know about one of the consequences of `module_function` being implemented
    in this way: private methods cannot be used in conjunction with `module_function`.
    That means that the following example cannot be literally translated to use `module_function`.\r\n\r\n```ruby\r\nmodule
    MinimalAnswer\r\n  extend self\r\n\r\n  def match?(pattern, input)\r\n    pattern.split(/,/).any?
    do |e|\r\n      normalize(input) =~ /\\b#{normalize(e)}/i\r\n    end\r\n  end\r\n\r\n
    \ private\r\n\r\n  def normalize(input)\r\n    input.downcase.strip.gsub(/\\s+/,\"
    \").gsub(/[?.!\\-,:'\"]/, '')\r\n  end\r\nend \r\n```\r\n\r\nFrom these examples,
    we see that `module_function` is more flexible than defining methods directly
    on your modules, but not nearly as versatile as extending a module with itself.
    While the ability to selectively define which methods can be called directly on
    the module is nice in theory, I've yet to see a use case for it where it would
    lead to a much better design.\r\n\r\n### Reflections\r\n\r\nWith the alternatives
    to `extend self` having unpleasant quirks, it's no surprise that they're quickly
    falling out of fashion in the Ruby world. But since no technical decision should
    be made based on dogma or a blind-faith acceptance of community conventions, these
    notes hopefully provide the necessary evidence to help you make good design decisions
    on your own.\r\n\r\n  \r\n> **NOTE:** This article has also been published on
    the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/041-issue-10.5-uses-for-modules.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: uses-for-modules-4
  :title: Uses for Modules, Part 4
  :summary: Explore the use of mixins for customizing individual objects.
  :published: 2010-12-16 00:00:00.000000000 Z
  :issue_number: '1.11'
  :volume: 1
  :body: "> Note: This article series on modules is also available as a [PDF download].
    The\r\n> PDF version has been revised and is more up-to-date than what you see
    here.\r\n\r\n[PDF download]:https://github.com/elm-city-craftworks/pr-monthly/blob/gh-pages/b5e5a89847701c4aa7c170cf/sept-2012-modules.pdf?raw=true\r\n\r\nToday
    we're going to wrap up this series on modules by looking at how mixins can be
    useful for implementing custom behavior on individual objects. In particular,
    we'll be looking at how modules can be used both as a replacement for monkey patching,
    as well as for constructing systems that can be extended without the need for
    monkey patching. While neither of these techniques are going to be something you'll
    use every day, they really come in handy when you run into a situation that calls
    for them.\r\n\r\n### Modules instead of Monkey Patches\r\n\r\nBack in the bad
    old days before Prawn, I was working on a reporting framework called Ruby Reports
    (Ruport), which generated PDF reports via `PDF::Writer`. At the time, `PDF::Writer`
    was quite buggy, and essentially abandoned, but was the only game in town when
    it came to PDF generation.\r\n\r\nOne of the bugs was something fairly critical:
    Memory consumption for outputting simple PDF tables would balloon like crazy,
    causing a document with more than a few pages to take anywhere from several minutes
    to several *hours* to run.\r\n\r\nThe original author of the library had a patch
    laying around that inserted a hook which did some caching that greatly reduced
    the memory consumption, but he had not tested it extensively and did not want
    to want to cut a release. I had talked to him about possibly monkey patching `PDF::Document`
    in Ruport's code to add this patch, but together, we came up with a better solution:
    wrap the patch in a module.\r\n\r\n```ruby\r\nmodule PDFWriterMemoryPatch\r\n
    \ unless self.class.instance_methods.include?(\"_post_transaction_rewind\")\r\n
    \   def _post_transaction_rewind\r\n      @objects.each { |e| e.instance_variable_set(:@parent,self)
    }\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIn Ruport's PDF formatter code, we
    did something like the following to apply our patch:\r\n\r\n```ruby\r\n@document
    = PDF::Document.new\r\n@document.extend(Ruport::PDFWriterMemoryPatch)\r\n```\r\n\r\nThroughout
    our application, whenever someone interacted with a `PDF::Document` instance we
    created, they had a patched instance that fixed the memory leak. This meant from
    the Ruport user's perspective, the bug was fixed. So what makes this different
    from monkey patching?\r\n\r\nBecause we were only manipulating the individual
    objects that we created in our library, we were not making a global change that
    might surprise people. For example if someone was building an application that
    only implicitly loaded Ruport as a dependency, and they created a `PDF::Document`
    instance, our patch would not be loaded. This prevented us from causing unexpected
    behavior in any code that lived outside of Ruport itself.\r\n\r\nWhile this approach
    didn't shield us from the risks that a future change to `PDF::Writer` could potentially
    break our patch in Ruport, it did prevent any risk of global consequences. Anyone
    who's ever spent a day scratching their head because of some sloppy monkey patch
    in a third party dependency will immediately be able to see the value of this
    sort of isolation.\r\n\r\nThe neat thing is that a similar approach can be used
    for core extensions as\r\nwell. Rather than re-opening Ruby core classes, you
    can imbue individual\r\ninstances with custom behavior, getting many of the benefits
    of monkey patching\r\nwithout the disadvantages. For example, suppose you want
    to add the `sum)()` and\r\n`average()` methods to Array. If we were monkey patching,
    we'd write something\r\nlike the following code:\r\n\r\n```ruby\r\nclass Array\r\n
    \ def sum\r\n    inject(0) { |s,e| s + e }\r\n  end\r\n\r\n  def average\r\n    sum.to_f
    / length\r\n  end\r\nend\r\n\r\nobj = [1,3,5,7]\r\nobj.sum     #=> 16\r\nobj.average
    #=> 4\r\n```\r\n\r\nThe danger here of course is that you'd be globally stomping
    anyone else's definition of `sum()` and `average()`, which can lead to ugly conflicts.
    All these problems can be avoided with a minor modification.\r\n\r\n```ruby\r\nmodule
    ArrayMathHelpers\r\n  def sum\r\n    inject(0) { |s,e| s + e }\r\n  end\r\n\r\n
    \ def average\r\n    sum.to_f / length\r\n  end\r\nend\r\n\r\nobj = [1,3,5,7]\r\nobj.extend(ArrayMathHelpers)\r\nobj.sum
    \    #=> 16\r\nobj.average #=> 4\r\n```\r\n\r\nBy explicitly mixing in the `ArrayMathHelpers`
    module, we isolate our changes just to the objects we've created ourselves. With
    slight modification, this technique can also be used with objects passed into
    functions, typically by making a copy of the object before working on it.\r\n\r\nBecause
    modules mixed into an instance of an object are looked up before \r\nthe methods
    defined by its class, \r\nyou can actually use this technique for modifying existing
    behavior of an object as well. \r\nThe example below demonstrates modifying `<<`
    on strings so that it allows appending \r\narbitrary objects to a string through
    coercion.\r\n\r\n```ruby\r\nmodule LooseStringAppend\r\n  def <<(value)\r\n    super\r\n
    \ rescue TypeError\r\n    super(value.to_s)\r\n  end\r\nend\r\n\r\na = \"foo\"\r\na.extend(LooseStringAppend)\r\na
    << :bar << :baz #=> \"foobarbaz\"\r\n```\r\n\r\nOf course this (like most core
    modifications), is a horrible idea. But speaking as a pure technique, this is
    far better than the alternative global monkey patch shown below:\r\n\r\n```ruby\r\nclass
    String\r\n  alias_method :old_append, :<<\r\n  \r\n  def <<(value)\r\n    old_append(value)\r\n
    \ rescue TypeError\r\n    old_append(value.to_s)\r\n  end\r\nend\r\n```\r\n\r\nWhen
    using per-object mixins as an alternative to monkey patching, what you gain is
    essentially two things: A first class seat in the lookup path allowing you to
    make use of `super()`, and isolation on a per-object behavior so that consumers
    of your code don't curse you for patching things in unexpected ways. While this
    approach isn't always available, it is definitely preferable whenever you can
    choose it over monkey patching.\r\n\r\nIn Ruby 2.0, we may end up with even better
    option for this sort of thing called refinements, which are also module based.
    But for now, if you must hack other people's objects, this approach is a civil
    way to do it.\r\n\r\nWe'll now take a look at how to produce libraries and applications
    that actively encourage extensions to be done this way.\r\n\r\n### Modules as
    Extension Points\r\n\r\nThis last section is not so much about practical advice
    as it is about taking what we've learned so far and really stretching it as far
    as possible into new territories. In essence, what follows are my own experiments
    with ideas that I'm not fully sure are good, but find interesting enough to share
    with you.\r\n\r\nIn previous Practicing Ruby issues, I've shown some code from
    a command line client we've used for time tracking in my consulting work. The
    tool itself never quite matured far enough to be release ready, but I used it
    as a testing ground for new design ideas, so it is a good conversation starter
    at least.\r\n\r\nToday, I want to show how we implemented commands for it. Essentially,
    I want to walk through what happens when someone types the following command into
    their console:\r\n\r\n```ruby\r\n$ turbine start\r\nTimer started at Wed Dec 15
    17:55:37 -0500 2010\r\n```\r\n\r\nBecause we knew this tool would evolve over
    time, we wanted to make it as hackable as possible. To do this, we set up a system
    in which commands get installed into a hidden folder in each project, making it
    trivial to modify existing commands or add new ones. Here's a quick directory
    listing to show what that structure looks like:\r\n\r\n```ruby\r\n$ ls .turbine/commands/standard/\r\nadd.rb\t\tproject.rb\trewind.rb\tstatus.rb
    commit.rb push.rb\t\t\r\nstaged.rb\tstop.rb drop.rb\treset.rb start.rb\r\n```\r\n\r\nAs
    you might expect, start.rb defines the start command. Here's what its source\r\nlooks
    like:\r\n\r\n```ruby\r\nTurbine::Application.extension(:start_command) do\r\n
    \ def start\r\n    timer = Turbine::Timer.new\r\n    if timer.running?\r\n      prompt.say
    \"Timer already started, please stop or rewind first\"\r\n    else\r\n      timer.write_timestamp\r\n
    \     prompt.say \"Timer started at #{Time.now}\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou'll
    notice that all our commands are direct mappings to method\r\ncalls, which are
    responsible for doing all the work. While I've simplified the\r\nfollowing definition
    to remove some domain specific callbacks and options \r\nparsing, the following
    example shows the basic harness which registers \r\nTurbine's commands:\r\n\r\n```ruby\r\nmodule
    Turbine\r\n  class Application\r\n    def self.extensions\r\n      @extensions
    ||= {}\r\n    end\r\n\r\n    def self.extension(key, &block)\r\n      extensions[key]
    = Module.new(&block)\r\n    end\r\n\r\n    def initialize\r\n      self.class.extensions.each
    do |_, extension|\r\n        extend(extension)\r\n      end\r\n    end\r\n  \r\n
    \   def run(command)\r\n      send(command)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nFrom
    this, we see that `Turbine::Application` stores a Hash of anonymous modules\r\nwhich
    are created on the fly whenever the `extension()` is called. The\r\ninteresting
    thing about this design is that the commands aren't applied globally\r\nto `Turbine::Application`,
    but instead, are mixed in at the instance level. This\r\napproach allows us to
    selectively disable features, or completely replace them \r\nwith alternative
    implementations.\r\n\r\nFor example, consider a custom command that gets loaded
    after the standard commands, which is implemented like this:\r\n\r\n```ruby\r\nTurbine::Application.extension(:start_command)
    do\r\n  def go\r\n    puts \"Let's go!\"\r\n  end\r\nend\r\n```\r\n\r\nBecause
    the module defining the `go()` method would replace the original module in the
    extensions hash, the original module ends up getting completely wiped out. In
    retrospect, for my particular use case, this approach seems to be like using a
    thermonuclear weapon where a slingshot would do, but you can't argue that this
    fails to take extensibility to whole new limits.\r\n\r\nEventually, when someone
    falls off the deep end in their study of modules, they ask 'is it possible to
    uninclude them?', and the short answer to that question is \"No\", promptly followed
    up with \"Why would you want to do that?\". But what we've shown here is a good
    approximation for unincluding a module, even if we haven't quite figured out the
    answer to the 'why' part yet.\r\n\r\nBut sometimes, we have to explore just for
    the fun of it, right? :)\r\n\r\n### Reflections\r\n\r\nI have had a blast writing
    to you all about modules and answering your questions as they come up. Unfortunately,
    the topic is even bigger than I thought, and there are at least two full articles
    I could write on the topic,which might actually be more practical and immediately
    relevant than the materials I've shared today. In particular, we didn't cover
    things like the `included()` and `extended()` hooks, which can be quite useful
    and are worth investigating on your own.\r\n\r\nMoving forward, my goals for Practicing
    Ruby are to be able to hit a wide range of topics, so we'll probably move away
    from the fundamentals of Ruby's object system and go back to some more problem-solving
    oriented topics in the coming weeks. But if you like this kind of format, please
    let me know.\r\n\r\n  \r\n> **NOTE:** This article has also been published on
    the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/043-issue-11-uses-for-modules.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: rapid-prototyping
  :title: Rapid Prototyping
  :summary: Build a tiny prototype of a tetris game on the command line.
  :published: 2010-12-21 00:00:00.000000000 Z
  :issue_number: '1.12'
  :volume: 1
  :body: "Ruby makes it easy to quickly put together a proof-of-concept for almost
    any kind of project, as long as you have some experience in rapid application
    development. In this article, I will go over how I build prototypes, sharing the
    tricks that have worked well for me.\r\n\r\nToday we'll be walking through a bit
    of code that implements a small chunk of a falling blocks game that is similar
    to Tetris. If you're not familiar with Tetris, head over to [freetetris.org](http://freetetris.org)
    and play it a bit before reading this article.\r\n\r\nAssuming you're now familiar
    with the general idea behind the game, I'll walk you through the thought process
    that I went through from the initial idea of working on a falling blocks game
    to the small bit of code I have written for this issue.\r\n\r\n### The Planning
    Phase\r\n\r\nAfter running through a few ideas, I settled on a falling blocks
    game as a good example of a problem that's too big to be tackled in a single sitting,
    but easy enough to make some quick progress on.\r\n\r\nThe next step for me was
    to come up with a target set of requirements for my\r\nprototype. To prevent the
    possibilities from seeming endless, I had to set a\r\ntime limit up front to make
    this decision making process easier. Because \r\nvery small  chunks of focused
    effort can get you far in Ruby, I settled on\r\ncoming up with something I felt
    I could build within an hour or two.\r\n\r\nI knew right away this meant that
    I wasn't going to make an interactive demo. Synchronizing user input and screen
    output is something that may be easy for folks who do it regularly, but my concurrency
    knowledge is very limited, and I'd risk spending several hours on that side of
    things and coming up empty if I went down that path. Fortunately, even without
    an event loop, there are still a lot of options for building a convincing demo.\r\n\r\nIn
    my initial optimism, I thought what I'd like to be able to do is place a piece
    on the screen, and then let gravity take over, eliminating any completed lines
    as it fell into place. But this would require me to implement collision detection,
    something I didn't want to tackle right away.\r\n\r\nEventually, I came up with
    the idea of just implementing the action that happens when a piece collides with
    the junk on the grid. This process involved turning the active piece into inactive
    junk, and then removing any completed rows from the grid. This is something that
    I felt fit within the range of what I could do within an hour or two, so I decided
    to sleep on it and see if any unknowns bubbled up to the surface.\r\n\r\nI could
    have just started hacking right away, but ironically that's a practice I typically
    avoid when putting together rapid prototypes. If this were a commercial project
    and I quoted the customer 2-4 hours, I'd want to use their money in the best possible
    way, and picking the wrong scope for my project would be a surefire way to either
    blow the budget or fail to produce something interesting. I find a few hours of
    passive noodling helps me see unexpected issues before they bite me.\r\n\r\nFortunately,
    this idea managed to pass the test of time, and I set out to begin coding by turning
    the idea into a set of requirements.\r\n\r\n### The Requirements Phase\r\n\r\nA
    good prototype does not come from a top-down or bottom-up design, but instead
    comes from starting in the middle and building outwards. By taking a small vertical
    slice of the problem at hand, you are forced to think about many aspects of the
    system, but not in a way that requires you consider the whole problem all at once.
    This allows most of your knowledge and often a good chunk of your code to be re-used
    when you approach the full project.\r\n\r\nThe key is to start with a behavior
    the user can actually observe. This means that you should be thinking in terms
    of features rather than functions and objects. Some folks use story frameworks
    such as Cucumber to help them formalize this sort of inside-out thinking, but
    personally, I prefer just to come up with a good, clear example and not worry
    about shoehorning it into a formal setting.\r\n\r\nTo do this, I created a simple
    text file filled with ascii art that codified two cases: One in which a line was
    cleared, and where no lines were cleared. Both cases are shown below.\r\n\r\n\r\n###
    CASE 1: REMOVING COMPLETED LINES\r\n\r\n```\r\n==========\r\n           \r\n           \r\n
    \          \r\n           \r\n           \r\n           \r\n   #       \r\n   #|
    \   | \r\n  |#||  ||\r\n|||#||||||\r\n==========\r\n```\r\n\r\nBECOMES:\r\n\r\n```\r\n==========\r\n
    \          \r\n           \r\n           \r\n           \r\n           \r\n\r\n\r\n
    \  |       \r\n   ||    | \r\n  ||||  ||\r\n==========\r\n```\r\n\r\n### CASE
    2: COLLISION WITHOUT ANY COMPLETED LINES\r\n\r\n```\r\n==========\r\n           \r\n
    \          \r\n           \r\n           \r\n           \r\n          \r\n  #
    \      \r\n  ##|    |\r\n  |#||  ||\r\n||| ||||||\r\n==========\r\n```\r\n\r\nBECOMES:\r\n\r\n```\r\n==========\r\n
    \          \r\n           \r\n           \r\n           \r\n           \r\n          \r\n
    \ |       \r\n  |||    | \r\n  ||||  ||\r\n||| ||||||\r\n==========\r\n```\r\n\r\n---------------------------------------------------------------------\r\n\r\nWith
    the goals for the prototype clearly outlined, I set out to write a simple program
    that would perform the necessary transformations.\r\n\r\n### The Coding Phase\r\n\r\nOne
    thing I'll openly admit is that when prototyping something that will take me less
    than a half day from end to end, I tend to relax my standards on both testing
    and writing clean code. The reason for this is that when I'm trying to take a
    nose-dive into a new problem domain, I find my best practices actually get in
    the way until I have at least a basic understanding of the project.\r\n\r\nWhat
    I'll typically do instead is write a single file that implements both the objects
    I need and an example that gets me closer to my goal. For this project, I started
    with a canvas object for rendering output similar to what I outlined in my requirements.\r\n\r\nImagining
    this canvas object already existed, I wrote some code for generating the very
    first bit out output we see in the requirements.\r\n\r\n```ruby\r\ncanvas = FallingBlocks::Canvas.new\r\n\r\n(0..2).map
    do |x|\r\n  canvas.paint([x,0], \"|\")\r\nend\r\n\r\ncanvas.paint([2,1], \"|\")\r\n\r\n(0..3).map
    do |y|\r\n  canvas.paint([3,y], \"#\")\r\nend\r\n\r\n(4..9).map do |x|\r\n  canvas.paint([x,0],
    \"|\")\r\nend\r\n\r\n[4,5,8,9].map do |x|\r\n  canvas.paint([x,1], \"|\")\r\nend\r\n\r\ncanvas.paint([4,2],
    \"|\")\r\ncanvas.paint([9,2], \"|\")\r\n\r\nputs canvas \r\n```\r\n\r\nWhile I
    use a few loops for convenience, it's easy to see that this code does little more
    than put symbols on a text grid at the specified (x,y) coordinates. Once `FallingBlocks::Canvas`
    is implemented, we'd expect the following output from this example:\r\n\r\n```\r\n==========\r\n
    \          \r\n           \r\n           \r\n           \r\n           \r\n           \r\n
    \  #       \r\n   #|    | \r\n  |#||  ||\r\n|||#||||||\r\n==========\r\n```\r\n\r\nWhat
    we have done is narrowed the problem down to a much simpler task, making it easier
    to get started. The following implementation is sufficient to get the example
    working, and is simple enough that we probably don't need to discuss it further.\r\n\r\n```ruby\r\nmodule
    FallingBlocks\r\n  class Canvas\r\n    SIZE = 10\r\n\r\n    def initialize\r\n
    \     @data = SIZE.times.map { Array.new(SIZE) }\r\n    end\r\n\r\n    def paint(point,
    marker)\r\n      x,y = point\r\n      @data[SIZE-y-1][x] = marker\r\n    end\r\n\r\n
    \   def to_s\r\n      [separator, body, separator].join(\"\\n\")\r\n    end\r\n\r\n
    \   def separator\r\n      \"=\"*SIZE\r\n    end\r\n\r\n    def body\r\n      @data.map
    do |row|\r\n        row.map { |e| e || \" \" }.join\r\n      end.join(\"\\n\")\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nHowever, things get a little more hairy
    once we've plucked this low hanging fruit. So far, we've built a tool for painting
    the picture of what's going on, but that doesn't tell us anything about the underlying
    structure. This is a good time to start thinking about what Tetris pieces are.\r\n\r\nWhile
    a full implementation of the game would require implementing rotations and movement,
    our prototype looks at pieces frozen in time. This means that a piece is really
    just represented by a collection of points. If we define each piece based on an
    origin of [0,0], we end up with something like this for a vertical line:\r\n\r\n```ruby\r\nline
    = FallingBlocks::Piece.new([[0,0],[0,1],[0,2],[0,3]])\r\n```\r\n\r\nSimilarly,
    a bent S-shaped piece would be defined like this:\r\n\r\n```ruby\r\nbent = FallingBlocks::Piece.new([[0,1],[0,2],[1,0],[1,1]])\r\n```\r\n\r\nIn
    order to position these pieces on a grid, what we'd need as an anchor point that
    could be used to translate the positions occupied by the pieces into another coordinate
    space.\r\n\r\nWe could use the origin at [0,0], but for aesthetic reason, I didn't
    like the mental model of grasping a piece by a position that could potentially
    be unoccupied. Instead, I decided to define the anchor as the top-left position
    occupied by the piece, which could later be translated to a different position
    on the canvas. This gives us an anchor of [0,3] for the line, and an anchor of
    [0,2] for the bent shape. I wrote the following example to outline how the API
    should work.\r\n\r\n```ruby \r\nline = FallingBlocks::Piece.new([[0,0],[0,1],[0,2],[0,3]])\r\np
    line.anchor #=> [0,3]\r\n\r\nbent = FallingBlocks::Piece.new([[0,1],[0,2],[1,0],[1,1]])\r\np
    bent.anchor #=> [0,2]\r\n```\r\n\r\nOnce again, a simple example gives me enough
    constraints to make it easy to write an object that implements the desired behavior.\r\n\r\n```ruby\r\nclass
    Piece\r\n  def initialize(points)\r\n    @points = points\r\n    establish_anchor\r\n
    \ end\r\n\r\n  attr_reader :points, :anchor\r\n\r\n  # Gets the top-left most
    point\r\n  def establish_anchor\r\n    @anchor = @points.max_by { |x,y| [y,-x]
    }\r\n  end\r\nend\r\n```\r\n\r\nAs I was writing this code, I stopped for a moment
    and considered that this logic, as well as the logic written earlier that manipulates
    (x,y) coordinates to fit inside a row-major data structure are the sort of things
    I really like to write unit tests for. There is nothing particularly tricky about
    this code, but the lack of tests makes it harder to see what's going on at a glance.
    Still, this sort of tension is normal when prototyping, and at this point I wasn't
    even 30 minutes into working on the problem, so I let the feeling pass.\r\n\r\nThe
    next step was to paint these pieces onto the canvas, and I decided to start\r\nwith
    their absolute coordinates to verify my shape definitions. The following example
    \r\noutlines the behavior I had expected.\r\n\r\n```ruby\r\ncanvas = FallingBlocks::Canvas.new\r\n\r\nbent_shape
    = FallingBlocks::Piece.new([[0,1],[0,2],[1,0],[1,1]])\r\nbent_shape.paint(canvas)\r\n\r\nputs
    canvas\r\n```\r\n\r\nOUTPUTS:\r\n\r\n```\r\n==========\r\n          \r\n          \r\n
    \         \r\n          \r\n          \r\n          \r\n          \r\n#         \r\n##
    \       \r\n #        \r\n==========\r\n```\r\n\r\nGetting this far was easy,
    the following definition of `Piece` does the trick:\r\n\r\n```ruby\r\nclass Piece\r\n
    \  SYMBOL = \"#\"\r\n\r\n  def initialize(points)\r\n    @points = points\r\n
    \   establish_anchor\r\n  end\r\n\r\n  attr_reader :points, :anchor\r\n\r\n  #
    Gets the top-left most point\r\n  def establish_anchor\r\n    @anchor = @points.min_by
    { |x,y| [y,-x] }\r\n  end\r\n\r\n  def paint(canvas)\r\n    points.each do |point|\r\n
    \     canvas.paint(point, SYMBOL)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis
    demonstrates to me that the concept of considering pieces as a collection of points
    can work, and that my basic coordinates for a bent piece are right. But since
    I need a way to translate these coordinates to arbitrary positions of the grid
    for this code to be useful, this iteration was only a stepping stone. A new example
    pushes us forward.\r\n\r\n```ruby\r\ncanvas = FallingBlocks::Canvas.new\r\n\r\nbent_shape
    = FallingBlocks::Piece.new([[0,1],[0,2],[1,0],[1,1]])\r\n\r\ncanvas.paint_shape(bent_shape,
    [2,3])\r\n\r\nputs canvas\r\n```\r\n\r\nOUTPUTS\r\n\r\n```\r\n==========\r\n          \r\n
    \         \r\n          \r\n          \r\n          \r\n          \r\n  #       \r\n
    \ ##      \r\n   #      \r\n          \r\n==========\r\n```\r\n\r\nAs you can
    see in the code above, I decided that my `Piece#paint` method was probably better
    off as `Canvas#paint_shape`, just to collect the presentation logic in one place.
    Here's what the updated code ended up looking like.\r\n\r\n```ruby\r\nclass Canvas\r\n
    # ...\r\n\r\n def paint_shape(shape, position)\r\n   shape.translated_points(position).each
    do |point|\r\n     paint(point, Piece::SYMBOL)\r\n   end\r\n end\r\nend\r\n```\r\n\r\nThis
    new code does not rely directly on the `Piece#points` method anymore, but instead,
    passes a position to the newly created `Piece#translated_points` to get a set
    of coordinates anchored by the specified position.\r\n\r\n```ruby\r\nclass Piece\r\n
    \ #...\r\n  \r\n  def translated_points(new_anchor)\r\n    new_x, new_y = new_anchor\r\n
    \   old_x, old_y = anchor\r\n\r\n    dx = new_x - old_x\r\n    dy = new_y - old_y\r\n
    \   \r\n    points.map { |x,y| [x+dx, y+dy] }\r\n  end\r\nend\r\n```\r\n\r\nWhile
    this mapping isn't very complex, it's yet another point where I was\r\nthinking
    'gee, I should be writing tests', and a couple subtle bugs that\r\ncropped up
    while implementing it confirmed my gut feeling. But with the light\r\nvisible
    at the end of the tunnel, I wrote an example to unify piece objects \r\nwith the
    junk left on the grid from previous moves.\r\n\r\n```ruby\r\ngame = FallingBlocks::Game.new\r\nbent_shape
    = FallingBlocks::Piece.new([[0,1],[0,2],[1,0],[1,1]])\r\ngame.piece = bent_shape\r\ngame.piece_position
    = [2,3]\r\ngame.junk += [[0,0], [1,0], [2,0], [2,1], [4,0],\r\n              [4,1],
    [4,2], [5,0], [5,1], [6,0],\r\n              [7,0], [8,0], [8,1], [9,0], [9,1],\r\n
    \             [9,2]]\r\n\r\nputs game\r\n```\r\n\r\nOUTPUTS:\r\n\r\n```\r\n==========\r\n\r\n\r\n\r\n\r\n\r\n\r\n
    \ #\r\n  ##|    |\r\n  |#||  ||\r\n||| ||||||\r\n==========\r\n```\r\n\r\nThe
    key component that tied this all together is the `Game` object, which essentially
    is just a container that knows how to use a `Canvas` object to render itself.\r\n\r\n```ruby\r\nclass
    Game\r\n  def initialize\r\n    @junk = []\r\n    @piece = nil\r\n    @piece_position
    = []\r\n  end\r\n\r\n  attr_accessor :junk, :piece, :piece_position\r\n\r\n  def
    to_s\r\n    canvas = Canvas.new\r\n\r\n    junk.each do |pos|\r\n      canvas.paint(pos,
    \"|\")\r\n    end\r\n\r\n    canvas.paint_shape(piece, piece_position, \"#\")\r\n\r\n
    \   canvas.to_s\r\n  end\r\nend\r\n```\r\n\r\nI made a small change to `Canvas#paint_shape`
    so that the symbol used to display pieces on the grid was parameterized rather
    than stored in `Piece::SYMBOL`. This isn't a major change and was just another
    attempt at moving display code away from the data models.\r\n\r\nAfter all this
    work, we've made it back to the output we were getting out of our first example,
    but without the smoke and mirrors. Still, the model is not as solid as I'd hoped
    for, and some last minute changes were needed to bridge the gap before this code
    was ready to implement the two use cases I was targeting.\r\n\r\nSince the last
    iteration would be a bit cumbersome to describe in newsletter form, please just
    \"check out my final commit\":http://is.gd/jbvdB for this project on github. With
    this new code, it's possible to get output identical to our target story through
    the following two examples.\r\n\r\n### CASE 1: line_shape_demo.rb\r\n\r\n```ruby\r\nrequire_relative
    \"falling_blocks\"\r\n\r\ngame = FallingBlocks::Game.new\r\nline_shape = FallingBlocks::Piece.new([[0,0],[0,1],[0,2],[0,3]])\r\ngame.piece
    = line_shape\r\ngame.piece_position = [3,3]\r\ngame.add_junk([[0,0], [1,0], [2,0],
    [2,1], [4,0],\r\n              [4,1], [4,2], [5,0], [5,1], [6,0],\r\n              [7,0],
    [8,0], [8,1], [9,0], [9,1],\r\n              [9,2]])\r\n\r\nputs game\r\n\r\nputs
    \"\\nBECOMES:\\n\\n\"\r\n\r\ngame.update_junk\r\nputs game\r\n```\r\n\r\n### CASE
    2: bended_shape_demo.rb\r\n\r\n```ruby\r\nrequire_relative \"falling_blocks\"\r\n\r\ngame
    = FallingBlocks::Game.new\r\nbent_shape = FallingBlocks::Piece.new([[0,1],[0,2],[1,0],[1,1]])\r\ngame.piece
    = bent_shape\r\ngame.piece_position = [2,3]\r\ngame.add_junk([[0,0], [1,0], [2,0],
    [2,1], [4,0],\r\n              [4,1], [4,2], [5,0], [5,1], [6,0],\r\n              [7,0],
    [8,0], [8,1], [9,0], [9,1],\r\n              [9,2]])\r\n\r\nputs game\r\n\r\nputs
    \"\\nBECOMES:\\n\\n\"\r\n\r\ngame.update_junk\r\nputs game\r\n```\r\n\r\n### Reflections\r\n\r\nOnce
    I outlined the story by drawing some ascii art, it took me just over 1.5 hours
    to produce working code that performs the transformations described. Overall,
    I'd call that a success.\r\n\r\nThat having been said, working on this problem
    was not without hurdles. While it turns out that removing completed lines and
    turning pieces into junk upon collision is surprisingly simple, I am still uneasy
    about my final design. It seems that there is considerable duplication between
    the grid maintained by `Game` and the `Canvas` object. But a refactoring here
    would be non-trivial, and I wouldn't want to attempt it without laying down some
    tests to minimize the amount of time hunting down subtle bugs.\r\n\r\nFor me,
    this is about as far as I can write code organically in a single sitting without
    either writing tests, or doing some proper design in front of whiteboard, or a
    combination of the two. I think it's important to recognize this limit, and also
    note that it varies from person to person and project to project. The key to writing
    a good prototype is getting as close to that line as you can without flying off
    the edge of a cliff.\r\n\r\nIn the end though, what I like about this prototype
    is that it isn't just an illusion. With a little work, it'd be easy enough to
    scale up to my initial ambition of demonstrating a free falling piece. By adding
    some tests and doing some refactoring, it'd be possible to evolve this code into
    something that could be used in production rather than just treating it as throwaway
    demo-ware.\r\n\r\nHopefully, seeing how I decomposed the problem, and having a
    bit of insight into what my though process was like as I worked on this project
    has helped you understand what goes into making proof-of-concept code in Ruby.
    I've not actually taught extensively about this process before, so describing
    it is a bit of an experiment for me. Let me know what you think!\r\n\r\n  \r\n>
    **NOTE:** This article has also been published on the Ruby Best Practices blog.
    There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/044-issue-12-rapid-prototyping.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: obfuscations-of-christmas-past
  :title: Obfuscations of Christmas Past
  :summary: Tear apart an obfuscated Ruby program from Christian Neukirchen to learn
    some neat tricks.
  :published: 2010-12-23 00:00:00.000000000 Z
  :issue_number: '1.13'
  :volume: 1
  :body: "Rather than always focusing on SERIOUS BUSINESS, I'd like share something
    a little more light hearted today. Whether you celebrate Christmas or not, I think
    you'll find this little holiday themed hack a great deal of fun to play with.\r\n\r\n###
    Christian Neukirchen's Christmas Hack\r\n\r\nWhen I first started programming
    in Ruby, the ruby-talk mailing list was the best place to interact with the community
    and keep up with other active Ruby hackers. But because there were a lot more
    hobbyists in 2004 than there were people doing Ruby as a full time job, the posts
    focused on sharing fun hacks just as often as they did on discussing practical
    issues.\r\n\r\nOne of my favorites was [Christian Neukirchen](http://twitter.com/#!/chneukirchen)'s
    obfuscated Christmas message to the Ruby community in 2004. I've copied the source
    code below, and I encourage you to run it and see that it is indeed a valid Ruby
    program!\r\n\r\n```ruby\r\ns=\"IyBUaGFua3MgZm9yIGxvb2tpbmcgYXQgbXkgY29kZ\r\nS4KIwojIENvcHlyaWdodCAoQykgMjAwMiAgQ2hyaXN0a\r\nWFuI
    \     E       5       l       d     Wtpc                                \r\nmNoZ
    \ W       4      gP       G       N obmV\r\n1a2l      y       Y 2hlb  k       B
    \    nbWF\r\npbC5  j       b    20+CiM     K       I yBUa\r\nGlzI      H       Byb2dyYW
    \       0     gaXM\r\ngZnJ  l       Z  SBzb2Z0d2F   y       Z Tsge\r\nW91I      G
    \    NhbiByZWRpc3      R     yaWJ\r\n1dGU  g        aXQgYW5kL29yCi M       g bW9k\r\naWZ5
    \     I   Gl0IHVuZGVyIHRoZ    S     B0ZX\r\nJtcy  B      vZiB0aGUgR05VIEdlb       m
    VyYW\r\nwgUH      V      ibGljIExpY       2     Vuc2\r\nUuCg  p       T VERPVVQuc3lu
    \ Y       y A9IH\r\nRydW      U    KZDEsIGQyID0gM     C     4xNS\r\nwgMC  4       wNgpzID0gIk1lcnJ
    \       5 IGNo\r\ncmlz      d  G1hcywgLi4uIGFuZCB   h     IGhh\r\ncHB5  I     G5ldyB5ZWFyIgptID0gJ
    \     X d7LC\r\nAuID       ogISArICogMCBPIEB9CnUg P     SAiI\r\nCIgK  i   BzLnNpemUKCnByaW50ICJcci
    \   A gI3t\r\n1fVx      y   IjsKCigwLi4ocy5z    a     XplL\r\nTEpK  S      50b19hLnNvcnRfYnkg
    \      e yByY\r\nW5kI      H 0uZWFjaCB7IHxyfAogIH  N     sZWV\r\nwIGQ  x    CiAgbmV4dCBpZiBzW3JdID
    \    0 9ICI\r\ngIls      wXQogIG0uZWFjaCB7IHxrfAo      gICA\r\ngdVt  y  XSA9IGsKICAgIHByaW50ICIgIC
    \  N 7dX1\r\ncciI    KICAgIHNsZWVwIGQyCiAgfQogIHV    bcl0\r\ngPSB   zW3JdCiAgcHJpbnQgIiAgI3t1fVxyI
    g p9Cg\r\npzbG  VlcCBkMgpwcmludCAiICAje3V9IVxyI   jsKc\r\n2xlZ  X       A    gMwpwc
    \    m       l udCA\r\niICA      j        e3V9IS A       g     LS1j\r\naHJp  c
    \      z    JcbiI7     C       g ojIG\r\nZpbG      x        lciBzc G       F     jZSA\r\njIyM
    \ j       I    yMjIyM     j       I yMjI\r\nyMjI      y       M       j       I
    \    yMjI\r\nyMK\";eval s.delete!(\" \\n\").unpack(\"m*\")[0]##\r\n### Copyright
    (C) 2004  Christian Neukirchen\r\n```\r\n\r\nWhen run, this code prints out <i>\"Merry
    christmas, ... and a happy new year! --chris2\"</i> by randomly filling in each
    character in a little animation. After some folks commented on how cool this hack
    was, someone inevitably asked how it was done, which lead another Ruby hacker
    Michael Neumann to post his guess to the list. Here is what he said:\r\n\r\n>Pretty
    easy (except drawing the tree :). Write the source-code first, then `base64` encode
    it, and insert newlines/whitespace to make the picture.\r\n\r\nAt the time, I
    was too much of a beginner with Ruby to fully appreciate the solution discussion,
    and mostly just chalked it up to magic. But now, the above statement is immediately
    obvious to me, and since it wasn't further explained in the mailing list thread,
    I can give an example for those who are in the same shoes now that I was in a
    few years ago.\r\n\r\nWhat I didn't know at the time is that `Base64` is an encoding
    that allows you to translate any binary data into purely printable characters
    by converting the contents into a string of characters that uses basic alphanumeric
    values. I would have known that if I read the documentation for Ruby's `Base64`
    standard library, but again, I was a newbie at the time. :)\r\n\r\nIt turns out
    that the idea for `Base64` encoding was extracted from how MIME attachments in
    email are implemented. This is all stuff you can find on wikipedia, so rather
    than digging into the gory details, let's see how it relates to the problem at
    hand.\r\n\r\nThe following small snippet should clear things up a bit.\r\n\r\n```ruby\r\n>>
    source = \"puts 'hello world'\"\r\n=> \"puts 'hello world'\"\r\n>> encoded_source
    = Base64.encode64(source)\r\n=> \"cHV0cyAnaGVsbG8gd29ybGQn\\n\"\r\n>> Base64.decode64(encoded_source)\r\n=>
    \"puts 'hello world'\"\r\n>> eval Base64.decode64(encoded_source)\r\nhello world\r\n=>
    nil\r\n```\r\n\r\nAnother way of decoding `Base64` encoded strings is via the
    `String#unpack` method, using the template `\"m*\"`. You can see this in Christian's
    code, which is what tipped Michael off in the first place. With that in mind,
    we can build a tiny obfuscated \"Hello World\" program.\r\n\r\n```ruby\r\ns =
    \r\n\"c  H   V0cyA \r\n n  a     G\r\n VsbG     8\r\n g  d     2\r\n 9  y    bGQn\"\r\n\r\neval
    s.delete(\" \\n\").unpack(\"m*\")[0]\r\n```\r\n\r\nIn the end, Michael was right
    when he said this was pretty easy to do. As long\r\nas you understand some basic
    string manipulation and how to decode a `base64` \r\nencoded string, you could
    use this technique to render your code as pretty much any arbitrary ASCII art.\r\n\r\nOf
    course, one would expect that the guy who eventually would go on to create something
    as clever and useful as the [Rack web server interface](https://github.com/rack/rack)
    would have an extra trick or two up his sleeve. Not to disappoint, Christian confirmed
    Michael's explanation was valid, but in the process revealed that he felt it'd
    be too fragile and tedious to manually format the code himself into the desired
    ascii art.\r\n\r\nFor those curious about how he got around this problem, you
    can check out his [full solution](http://groups.google.com/group/comp.lang.ruby/msg/aa5b4f8eaa85e6b8?dmode=source)\r\n
    which implements a code generator that fills in a template with the `base64` encoded
    source.\r\n\r\nWhile the code should be pretty easy to follow with a little effort,
    feel free to post questions here if you need help figuring things out. It's a
    really neat bit of code and is worth exploring, so I don't mind giving some hints
    where needed.\r\n\r\n### Reflections\r\n\r\nWriting this article reminded me of
    two lessons that I sometimes forget, even to this day.\r\n\r\nThe first lesson
    is that you can't judge the complexity of something by simply scratching its surface.
    When I saw this code posted to ruby-talk back in 2004, even though I was a newbie
    at the time, I could have figured it out if I only took a bit of time to study
    the topics that were being discussed. But since I saw a bunch of obscure binary
    data in the shape of a Christmas tree being passed to `eval()`, I judged the snippet
    as being too complicated for me, appreciated it for its magic, and moved on. That
    sort of lack of self-confidence can really prevent you from stumbling upon interesting
    new ideas, tools, and techniques.\r\n\r\nThe second lesson is that hacking doesn't
    always have to be SERIOUS BUSINESS.\r\nBecause I'm working on things I feel are
    super important most of the time, it's\r\neasy for me to forget to be playful
    and generally curious. Sometimes I feel like\r\nI'm too busy to do something just
    for the joy of the hack, and that worries me a bit. \r\nWriting this article reminded
    that I should resist this temptation, and make more \r\ntime and space in my life
    for playful discovery, because it is a great way to learn \r\nand have fun at
    the same time.\r\n\r\n  \r\n> **NOTE:** This article has also been published on
    the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/045-issue-14-obfuscations.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: duck-typing-in-practice-1
  :title: Duck Typing in Practice, Part 1
  :summary: Investigate the three main ways of doing type checking in Ruby, then work
    on some related exercises.
  :published: 2010-12-28 00:00:00.000000000 Z
  :issue_number: '1.14'
  :volume: 1
  :body: "Type systems are a fundamental part of every programming language. In fact,
    the way a language designer approaches typing goes a long way towards outlining
    the way that thoughts are expressed in that language.\r\n\r\nStatically typed
    languages like C++ and Java make us tend to think of objects as abstract data
    structures that fit within a neatly defined hierarchy. In these languages, there
    isn't a major distinction between an object's class and its type, as the two concepts
    are tied together directly at the implementation level. But the marriage of class
    and type found in these languages is not a universal law shared by all object
    oriented programming languages.\r\n\r\nBy contrast, Ruby's dynamic nature facilitates
    a style of type system known as duck typing. In particular, duck typing breaks
    the strong association between an object's class and its type by defining types
    based on what an object can do rather than what class it was born from. This subtle
    shift in semantics changes virtually everything about how you need to think about
    designing object oriented systems, making it a great topic for Practicing Ruby
    to cover.\r\n\r\nWhile duck typing is possible in many other languages, Ruby is
    designed from the ground up to support this style of objected oriented design.
    In this issue, we will cover some of the options that are available to us for
    doing Ruby-style type checking. \r\n\r\n### Type Checking Techniques\r\n\r\nThere
    are three common ways to do type checking in Ruby, two of which involve\r\nduck
    typing, and one that does not. Here's an example of the approach \r\nthat does
    *not* involve duck typing.\r\n\r\n```ruby\r\ndef read_data(source)\r\n  case source\r\n
    \ when String\r\n    File.read(source)\r\n  when IO\r\n    source.read\r\n  end\r\nend\r\n```\r\n\r\nIf
    you've been working with Ruby for a while, you've probably written code that\r\ndid
    type checking in this fashion. Ruby's case statement is powerful, and\r\nmakes
    this sort of logic easy to write. Our `read_data()` function works as\r\nexpected
    in the following common scenarios:\r\n\r\n```ruby\r\nfilename = \"foo.txt\"\r\nread_data(filename)
    #=> reads the contents of foo.txt by calling \r\n                    #   File.read()\r\n\r\n\r\ninput
    = File.open(\"foo.txt\")\r\nread_data(input) #=> reads the contents of foo.txt
    via \r\n                 #   the passed in file handle\r\n```\r\n  \r\nBut things
    begin to fall apart a bit when we decide we'd like `read_data()` to\r\nwork with
    a `Tempfile`, or with a `StringIO` object, or perhaps with a mock\r\nobject we've
    defined in our tests. We have baked into our logic the assumption that the input
    is always either a descendent of `String` or a descendent of `IO`. The purpose
    of duck typing is to remove these restrictions by focusing only on the messages
    that are being passed back and forth between objects rather than what class they
    belong to. The code below demonstrates one way you can do that.\r\n\r\n```ruby\r\ndef
    read_data(source)\r\n  return source.read if source.respond_to?(:read)\r\n  return
    File.read(source.to_str) if source.respond_to?(:to_str)\r\n  raise ArgumentError\r\nend\r\n```\r\n\r\nWith
    this modification, our method expects far less of its input. The passed in\r\nobject
    simply needs to implement either a meaningful `read()` or `to_str()`\r\nmethod.
    In addition to being backwards compatible with our non-duck-typed code,\r\nthis
    new approach gives us access to many useful standin objects, including: `StringIO`,
    `Tempfile`, mock objects for testing, and any user defined objects that are either
    IO-like or String-like but not a descendent of either.\r\n\r\nHowever, the following
    contrived example illustrates a final corner case that calls for a bit of extreme
    duck typing to resolve. Try to spot the problem before reading about how to solve
    it.\r\n\r\n```ruby\r\nclass FileProxy\r\n  def initialize(tempfile)\r\n    @tempfile
    = tempfile\r\n  end\r\n\r\n  def method_missing(id, *args, &block)\r\n    @tempfile.send(id,
    *args, &block)\r\n  end\r\nend\r\n```\r\n\r\nThis code implements a proxy which
    forwards all of its messages to the wrapped `tempfile` object. However, like many
    hastily coded proxy objects in Ruby, it does not properly forward `respond_to?()`
    calls to the object it wraps. The irb session below illustrates the resulting
    false negative in our test.\r\n\r\n```ruby\r\n# Populate our tempfile through
    the proxy\r\n\r\n>> proxy = FileProxy.new(Tempfile.new(\"foo.txt\"))\r\n=> #<FileProxy:0x39461c
    @tempfile=#<File:/var/f..foo.txt.7910.3>>\r\n>> proxy << \"foo bar baz\"\r\n=>
    #<File:/var/folders/sJ/sJo0IkPYFWCY3t5uH+gi0++++TQ/-Tmp-/foo.txt.7910.3>\r\n>>
    proxy.rewind\r\n=> 0\r\n\r\n# Unsuccessfully test for presence of read() method\r\n\r\n>>
    proxy.respond_to?(:read)\r\n=> false\r\n\r\n# But read() works as expected!\r\n\r\n>>
    proxy.read\r\n=> \"foo bar baz\"\r\n```\r\n\r\nThis issue will cause `read_data()`
    to raise an `ArgumentError` when passed a `FileProxy`. In this case, the best
    solution is to fix `respond_to?()` so that it works as expected, but since you
    may often encounter libraries with bad behaviors like this, it's worth knowing
    what the duck typing fundamentalist would do in this situation.\r\n\r\n```ruby\r\ndef
    read_data(source)\r\n  begin \r\n    return source.read \r\n  rescue NoMethodError\r\n
    \   # do nothing, just catch the specific error you'd expect if\r\n    # read()
    was not present.\r\n  end\r\n\r\n  begin\r\n    File.read(source.to_str)\r\n  rescue
    NoMethodError\r\n    raise ArgumentError # now we've run out of valid cases, so
    let's\r\n                        # raise a meaningful error\r\n   end\r\nend\r\n```\r\n\r\nWith
    this final version, we preserve all the benefits of the previous duck\r\ntyping
    example, but we can work with objects that have dishonest `respond_to?()`\r\nmethods.
    Unfortunately, the cost for such flexibility includes code that is less\r\npleasant
    to read and is almost certainly going to run slower than either of our\r\nprevious
    implementations. Using the exception system for control flow isn't cheap, \r\neven
    if this is the most 'pure' form of type checking we can do.\r\n\r\nWhile we've
    talked about the benefits and drawbacks of each of these approaches, I haven't
    given any direct advice on whether one way of doing type checking is better than
    the others, simply because there is no simple answer to that question.\r\n\r\nI
    will paint a clearer picture in the next article by showing several\r\nrealistic
    examples of why duck typing can come in handy. Until then, I will\r\nleave you
    with a few things to think about.\r\n\r\n### Questions / Study Topics\r\n\r\n*
    Is explicit class checking ever absolutely necessary? Are their situations in
    which even if other options are available, checking the class of an object is
    still the best thing to do?\r\n\r\n* Name something weird that can happen when
    you write your contracts on the messages your objects respond to rather than what
    class of object they are.\r\n\r\n* Try to identify some feature of Ruby that relies
    on duck typing either for its basic functionality or as an extension point meant
    to be customized by application programmers.\r\n\r\n* Share a bit of code which
    does explicit class comparison that you think would be very difficult to convert
    to a duck-typing style.\r\n\r\n* Share a bit of code (either your own or from
    a OSS project you like) that you feel uses duck typing effectively.\r\n\r\nFeel
    free to leave a comment below if any of the above topics interest you.\r\n\r\n
    \ \r\n> **NOTE:** This article has also been published on the Ruby Best Practices
    blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/046-issue-14-duck-typing.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: duck-typing-in-practice-2
  :title: Duck Typing in Practice, Part 2
  :summary: Examine real uses of Ruby's duck-typing capabilities in various open source
    projects and Ruby itself.
  :published: 2010-12-31 00:00:00.000000000 Z
  :issue_number: '1.15'
  :volume: 1
  :body: "Today, I've got a handful of neat examples to share, each which demonstrates
    an interesting use of duck typing. We'll start by looking a feature built into
    Ruby's core, and then look at a few examples from other open source Ruby projects.\r\n\r\n###
    Type Coercion, Ruby-style\r\n\r\nMany dynamically typed languages that offer both
    integer and floating point\r\narithmetic are smart about doing the right thing
    based on whether or not any\r\nfloats are used in a given expression. While I
    assume that you are already \r\nfamiliar with Ruby's behavior, the following example
    demonstrates what \r\nI've just described.\r\n\r\n```ruby\r\n>> 3/2\r\n=> 1\r\n>>
    3/2.0\r\n=> 1.5\r\n```\r\n\r\nThis is an obvious candidate for implementation
    level special casing, but since all the primitive numeric types in Ruby are actually
    objects, Ruby prefers something a bit more flexible and consistent. What actually
    happens when an arithmetic operation is performed on a Ruby number is that a method
    called `coerce()` is called to do any necessary type modifications so that the
    computations work as expected. The irb session shown below demonstrates calling
    `coerce()` directly on both a `Fixnum` and a `Float`.\r\n\r\n```ruby\r\n>> 3.coerce(2)\r\n=>
    [2, 3]\r\n>> 3.coerce(2.0)\r\n=> [2.0, 3.0]\r\n>> 3.0.coerce(3)\r\n=> [3.0, 3.0]\r\n>>
    3.0.coerce(2.0)\r\n=> [2.0, 3.0]\r\n```\r\n\r\nNote that `Fixnum#coerce` only
    returns an array of Float values when its argument is a Float, but that `Float#coerce`
    always does this conversion. While what is shown above only demonstrates how floating
    point coercion works, we can actually create our own objects that duck type to
    Ruby numbers by simply defining a `coerce()` method on them.\r\n\r\nTo demonstrate
    this, I have created a partial implementation of a `BinaryInteger` object. A `BinaryInteger`
    is meant to act similar to Ruby's `Fixnum` objects but display itself to the user
    in binary notation. Here's an example of how such an object might be used:\r\n\r\n```ruby\r\n>>
    int = BinaryInteger.new(40)\r\n=> 0b101000\r\n>> 2 + int\r\n=> 0b101010\r\n>>
    2.5 + int\r\nTypeError: BinaryInteger can't be coerced into Float\r\n\tfrom ./binary_integer.rb:49:in
    `+'\r\n\tfrom (irb):4\r\n\tfrom :0\r\n```\r\n\r\nThe following class definition
    does not quite produce a complete `Numeric` work-alike but it is sufficient for
    making the previous example work as shown. It also serves to demonstrate that
    `coerce()` is indeed the magic that ties all of Ruby's arithmetic operations together.\r\n\r\n```ruby\r\nclass
    BinaryInteger\r\n  def initialize(value)\r\n    @value = value\r\n  end\r\n\r\n
    \ attr_accessor :value\r\n\r\n  def integer?\r\n    true\r\n  end\r\n\r\n  def
    +(other)\r\n    a,b = coerce(other) # use our own coerce here\r\n    self.class.new(a.value
    + b.value)\r\n  end\r\n\r\n  def coerce(other)\r\n    raise TypeError unless other.integer?
    \r\n\r\n    if other.respond_to?(:value)\r\n      [self, other] # no coercion
    needed\r\n    else\r\n      [self, self.class.new(other)]\r\n    end\r\n  end\r\n\r\n
    \ def inspect\r\n    \"0b#{@value.to_s(2)}\"\r\n  end\r\nend\r\n```\r\n\r\nWhile
    it can be tricky to puzzle through how `coerce()` should work, since you can't
    know in advance what the calling object will be, it is a lot more dynamic than
    enforcing class based typing. Getting in the practice of thinking in terms of
    the interactions between the objects in your project rather than their static
    definitions can lead to some very good design insights.\r\n\r\nIn addition to
    the `coerce()` method for arithmetic, Ruby uses a whole score of other coercion
    hooks, including `to_int`, `to_str`, and `to_ary`. These methods are called on
    the arguments passed to a number of `Fixnum`, `String`, and `Array` methods. The
    neat thing is that there is no strict requirement that these methods actually
    return `Fixnum`, `String`, or `Array` objects, as long as they act close enough
    to the real thing where it counts (i.e. for whatever messages that get sent to
    them).\r\n\r\nWe could probably spend all day going through other examples of
    where Ruby uses duck typing for coercion, for extension points, and tons of other
    uses. This is especially true when you consider that almost every mixin relies
    on a form of duck typing. For example, all functionality in `Enumerable` can work
    with anything that implements a sensible `each()` method. Similarly a suitable
    `<=>` operator unlocks all that `Comparable` has to offer. In both the core and
    standard library, you will find plenty of examples of this sort of design.\r\n\r\nThe
    key point to take away from these observations is that duck-typed APIs aren't
    some obscure edge case for the extensibility-obsessed, but instead, something
    baked into Ruby's philosophy from the ground up. This means that you can and should
    imitate this style in your own libraries when it makes sense to do so.\r\n\r\nWe'll
    now take a look at a pair of examples from the wild, one from my own project (Prawn),
    and another from Aaron Patterson's Rails 3.1 performance tuning adventures. Both
    involve the use of duck typing not for the purpose of infinite flexibility, but
    for addressing practical problems that come up in most moderately complex projects.\r\n\r\n###
    Duck typing to avoid scope creep\r\n\r\nThe first example of duck typing in actual
    Ruby projects that I want to share is actually quite similar to the contrived
    `read_data()` example I shared on Tuesday. Today, rather than showing you the
    usage code first, I want you to take a look at the implementation and try to spot
    the usage of duck typing and guess at what it gains us before reading on.\r\n\r\n```ruby\r\ndef
    image(file, options={})\r\n  Prawn.verify_options [:at, :position, :vposition,
    :height,\r\n                        :width, :scale, :fit], options\r\n\r\n  if
    file.respond_to?(:read)\r\n    image_content = file.read\r\n  else\r\n    raise
    ArgumentError, \"#{file} not found\" unless File.file?(file)\r\n    image_content
    = File.binread(file)\r\n  end\r\n\r\n  # additional implementation details omitted.\r\nend\r\n\r\n#
    FULL IMPLEMENTATION OF image() at:\r\n# https://github.com/sandal/prawn/blob/master/lib/prawn/images.rb#L65\r\n```\r\n\r\nIf
    you guessed this code is used to make it so that the `image()` method can be called
    with either a file name or a file handle, you had the right idea. It does all
    of the things we discussed yesterday, allowing the use of this code with `StringIO`,
    `Tempfile`, any mock object that implements a `read()` method, etc. But the really
    interesting use case is the one that we actually wrote this feature for, shown
    below.\r\n\r\n```ruby\r\nrequire \"open-uri\"\r\n\r\nPrawn::Document.generate(\"remote_images.pdf\")
    do\r\n  image open(\"http://prawn.majesticseacreature.com/images/prawn.png\")\r\nend\r\n```\r\n\r\nThrough
    the use of `open-uri`, our duck-typed image method provides a nice way\r\nof rendering
    remote content! While this might not have been an easy feature to\r\nguess without
    knowing a bit about Prawn, it represents the elegant compromise that such an implementation
    affords us. Adding support for remote images was something that our users often
    asked for, but we wanted to avoid giving people the impression that Prawn was
    web-aware, and didn't want to support a special case for this sort of logic, as
    it'd require either an API change or an ugly hack to determine whether the provided
    string was either a URI or a file name.\r\n\r\nThe approach of accepting anything
    with a `read()` method combined with Ruby's standard library `open-uri` made for
    something that is easy to document and easy for our users to remember. While a
    simple hack, I was very satisfied with how this design turned out because it seemed
    to mostly eliminate the problem for our users while simultaneously avoiding some
    overly complex implementation code that might be brittle and hard to test.\r\n\r\nThese
    sort of tough design decisions are certainly not unique to Prawn, so we can now
    turn our eyes to Aaron Patterson's performance optimization work on Rails 3.1.\r\n\r\n###
    Duck typing for performance tuning\r\n\r\nOne area Aaron Patterson found was a
    hotspot for many Rails apps are `ActiveRecord` scopes, which allow the users to
    create custom filters. For example, consider the following example which filters
    by email address.\r\n\r\n```ruby\r\nclass Comment < ActiveRecord::Base\r\n  scope
    :with_email, lambda { |email|\r\n    where(:email => email)\r\n  }\r\nend\r\n\r\n#
    Above code provides functionality shown below\r\nUser.with_email(\"gregory.t.brown@gmail.com\").count
    #=> 1\r\n```\r\n\r\nThe block syntax is nice and clean for simple things, but
    can get a bit unwieldy for complex logic. For example, if we wanted to throw in
    validations for the entered email addresses, our block would end up getting a
    bit ugly unless we implemented some private class methods to help out. If you're
    thinking that private class methods sound weird and might be a bit of a code smell,
    they are, and that's one indication that this API needs to be more flexible than
    what it is.\r\n\r\nThat said, Aaron was on a performance tuning mission, not an
    API overhaul. The\r\nproblem he found with the API was initially not an aesthetic
    one but an\r\nimplementation detail: Executing code stored in a `Proc` object
    is considerably\r\nmore computationally expensive than an ordinary method call.
    While this isn't\r\nlikely to be a bottleneck in ordinary situations, it is common
    for high traffic\r\nRails applications to really hammer on their scopes, since
    they're used for\r\nfiltering the data that is presented to users. The key insight
    Aaron had was\r\nthat making some other object quack like a `Proc` is as easy
    as implementing \r\na `call()` method.\r\n\r\nShown below is the one line patch
    that changes the behavior of `scope()` to\r\nallow the use of any object that
    implements a meaningful `call()` method:\r\n\r\n```ruby\r\n# BEFORE\r\noptions
    = filter.is_a?(Proc) ? filter.call(*args) : filter\r\n\r\n# AFTER\r\noptions =
    filter.respond_to?(:call) ? filter.call(*args) : filter\r\n```\r\n\r\nWith this
    nearly microscopic change, we can write a faster `with_email()` scope that also
    leaves room for complex logic such as validations in its own neatly defined namespace.
    The following definition is functionally equivalent to our original code that
    passes a `Proc` to `scope()`, but has a lot more potential for future growth.\r\n\r\n```ruby\r\nclass
    EmailFilter \r\n  def initialize(model_class)\r\n    @model_class = model_class\r\n
    \ end\r\n\r\n  def call(email)\r\n    validate_address(email)\r\n    @model_class.where(:email
    => email)\r\n  end\r\n\r\n  private\r\n\r\n  def validate_address(email)\r\n    #
    do some validation magic here\r\n  end\r\nend\r\n\r\nclass User < ActiveRecord::Base\r\n
    \ scope :with_email, EmailFilter.new(self)\r\nend\r\n```\r\n\r\nThe nice thing
    about this patch is that nothing is lost by doing things this way. Often times,
    when moving from explicit class checking to behavior based checks, the only overhead
    is that debugging can be a bit more complicated since there is no easy way to
    verify that an object implementing `call()` actually does so in a sensible way.
    However, with adequate unit tests and decent documentation, this kind of fuzziness
    is rarely a big enough problem in practical applications to outweigh the benefits
    that come along with utilizing this technique.\r\n\r\nAside from the superficial
    improvements that come from converting `Proc` calls\r\nto method calls, the general
    approach of writing duck typed interfaces tends to increase the potential for
    further performance improvements. When code is written to explicitly avoid assuming
    too much about how objects are implemented, it is easy to swap out objects that
    are more performant in edge cases, or implement aggressive caching where appropriate.
    While it may seem counterintuitive, the same dynamic nature that makes Ruby slow
    at the implementation level makes a wide range of algorithmic improvements possible.
    We unfortunately won't be exploring this topic today, but it would be a good topic
    for a future issue.\r\n\r\n  \r\n> **NOTE:** This article has also been published
    on the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/047-issue-15-duck-typing-2.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: ruby-hackers
  :title: Interesting Ruby Hackers
  :summary: Find out which Ruby hackers consistently write great code worth reading.
  :published: 2011-01-03 00:00:00.000000000 Z
  :issue_number: '1.16'
  :volume: 1
  :body: "In this article, I've listed five people worth knowing about if you're involved
    in Ruby. If you're reading this in July 2011, please note that I wrote this article
    over 7 months ago, and so the descriptions you see below are slightly outdated.
    That having been said, I still think these five people are on the top of my list
    when it comes to interesting folks in our community.\r\n\r\n### Wayne Seguin ([@wayneeseguin](http://twitter.com/wayneeseguin))\r\n\r\nWayne
    gave us [RVM](http://rvm.beginrescueend.com), the Ruby enVironment Manager. This
    tool quickly evolved from a bunch of crude shell script hacks to something that
    makes working with multiple Ruby versions and implementations a breeze. A tool
    which simply allowed manually switching between versions and implementations of
    Ruby would be useful on its own, but the thing that makes RVM special are all
    the shiny extras that come with it.\r\n\r\nIn addition to basic version switching,
    RVM provides gemsets which are sandboxes for your gem installation environment.
    This makes it possible for each of your projects to have its own gemset, eliminating
    concerns about different projects having dependencies that clash with one another.
    While this is a problem that can often be solved by version locking, having an
    extra layer of protection and organization is great.\r\n\r\nAnother neat feature
    of RVM is the ability to include a `.rvmrc` in any of your project roots, which
    causes `rvm` to automatically switch to the desired ruby version, implementation,
    and gemset that you specify in that file. This reduces the amount of manual switching
    needed, and makes commands like `ruby`, `irb`, `rake`, and `gem` 'just work' without
    having to think about what context you are in.\r\n\r\nAnother thing that is amazing
    about RVM is the amount of support Wayne offers for it. He is nearly infamous
    for his availability on IRC, and he seems to genuinely want to help anyone who
    is trying to use RVM. I've seen him cornered at least a few times at Ruby conferences
    by folks asking questions about how to do this or that with RVM, and he always
    seems to handle those situations gracefully. This is exactly the kind of spirit
    that makes me appreciate someone's work and makes me want to keep watching them
    to see what great things they'll come up with.\r\n\r\n<i>UPDATE 2011.07.19: You
    should also check out Wayne's [BDSM framework](http://bdsm.beginrescueend.com).</i>\r\n\r\n###
    Eleanor McHugh ([@feyeleanor](http://twitter.com/feyeleanor))\r\n\r\nEleanor McHugh
    is an incredibly clever and entertaining hacker who has a deep interest in concurrency
    and low level UNIX plumbing. She spent a lot of time in 2010 working on [GoLightly](http://github.com/feyeleanor/GoLightly),
    a lightweight virtual machine running on top of the Go programming language. Her
    original goal was to re-build miniruby on top of Go, but building the vm became
    a priority in of itself rather than just a stepping stone once she had a chance
    to dig into the problem.\r\n\r\nWhat interests me about Eleanor is that she is
    the kind of person that decides to work on a project first and then figure out
    how to make it all come together later. I know she has been making some significant
    personal sacrifices so that she can work on GoLightly, and that sort of attitude
    is something I really like to see.\r\n\r\nEleanor was one of the guest speakers
    at Mendicant University in 2010, doing a Q&A session with me and the students.
    We touched on how pretty much every modern language handles concurrency, and then
    somehow deviated to discussing Eleanor's background in avionics, in which we collectively
    decided that TDD in that field worked something like \"Whoops, the plane crashed,
    guess that's red.\" This of course lead us to a more serious discussion about
    testing and testability, but was a pretty hilarious diversion along the way.\r\n\r\nWhere
    one can really learn a ton from Eleanor is in a small group or one on one conversation.
    She is the ideal person to catch up with on the hallway track of a conference,
    or to grab a drink with after an event. Each time I've met up with her I've been
    consistently entertained and inspired by her stories, and find myself fortunate
    to be able to call her a friend.\r\n\r\n<i>UPDATE 2011.07.19: Eleanor, like me,
    spends most of her time hacking on community projects. [She can use some help
    with her travel expenses](http://pledgie.com/campaigns/15689), so if you like
    what she's doing, please do contribute what you can.</i>\r\n\r\n### Brian Ford
    ([@brixen](http://twitter.com/brixen))\r\n\r\nBrian is one of the key [Rubinius](http://rubini.us)
    team members and also was instrumental in the creation and adoption of the [RubySpec](http://github.com/rubyspec/rubyspec),
    an executable specification of the Ruby language written in RSpec-like syntax.\r\n\r\nWhile
    I do not closely follow Rubinius, I studied it a bit when researching for a talk
    on Ruby versions and implementations. In the process, I came to learn about RubySpec
    and the specialized testing framework they've built for it called [mspec](https://github.com/rubyspec/mspec).
    This stuff is seriously cool.\r\n\r\nAs you can imagine, building a testing framework
    to test Ruby itself is a harder problem than simply testing code you write using
    Ruby. To account for this, mspec does all sorts of neat things, allowing tests
    to be restricted to particular versions, implementations, and even specific patch
    levels of different Ruby packages. Another interesting aspect of mspec's implementation
    is that because it's designed to help Ruby implementers test their work, the code
    for implementing the testing framework intentionally uses a minimal subset of
    Ruby functionality. As someone interested in tricky design problems, I found myself
    consistently impressed by how mspec is implemented. While I'm not sure exactly
    how much of this is Brian's handiwork, he is one of the key folks who set the
    project in motion.\r\n\r\nRubySpec itself is really impressive. If you haven't
    looked through it before, I strongly encourage that you do so. It provides comprehensive
    unit tests for a huge amount of Ruby's behavior, covering each feature in minute
    detail. I guarantee you that if you spend a little time reading through the specs,
    you'll find an edge case about some Ruby feature that you didn't know about, no
    matter how solid your understanding of Ruby is.\r\n\r\n<strike>While we haven't
    officially announced the details, Brian and I will be working together to run
    Ruby Mendicant University's first Free Software Clinic. This will be a chance
    for some of our students to work with me as we contribute something interesting
    that should make RubySpec even more useful than it already is. More information
    will come about this topic soon.</strike>\r\n\r\nIn addition to his work on Rubinius
    and RubySpec, Brian happens to be an incredible teacher. While most of my interactions
    with him have been over IRC, he is capable of explaining complex and deep computer
    science topics in a way that makes them feel natural and manageable. I finally
    had a chance to see him give a talk in person at RubyConf 2010, and by watching
    [this video](http://confreaks.net/videos/454-rubyconf2010-poisoning-rubinius-the-_why-and-how),
    I think you'll get a sense of what I mean.\r\n\r\n<i>UPDATE 2011.07.19: Brian
    and I haven't had a chance to work on open source projects together with the Mendicant
    University students yet, but I hope we'll have a chance to do so some time in
    the not-too-distant future. I struck the mention of our plans out in the description
    above to make it clear this original plan didn't pan out.</i>\r\n\r\n### Tony
    Arcieri ([@bascule](http://twitter.com/bascule))\r\n\r\nTony is another Ruby hacker
    interested in concurrency, particularly the Actor model of concurrency. He has
    built a number of concurrency tools in Ruby, including [revactor](http://github.com/tarcieri/revactor),
    but eventually decided that what he really wanted was the syntax of Ruby with
    the baked in concurrency model of Erlang. This lead him to begin work on his own
    language, [Reia](http://github.com/tarcieri/reia).\r\n\r\nFor those who haven't
    seen it before, Reia is a fascinating language, even in its infancy. The syntax
    does look and feel like Ruby, but everything is Erlang under the hood. The functionality
    is mapped more towards Erlang than it is towards Ruby, which means that Reia is
    not aiming to be a feature complete Ruby implementation. Working in Reia is an
    interesting exercise in wondering what a smaller, more basic subset of Ruby's
    functionality might look like.\r\n\r\nThe neat thing about Reia is that a lot
    of its code is self hosting, similar to Rubinius. This, combined with the fact
    that you can easily reach down to the Erlang runtime and call functions provided
    in Erlang's core modules, makes it very easy to contribute to Reia's high level
    feature set. During RubyConf 2010 I decided to dip my toe in and help wrap a number
    of the methods in Erlang's List API to make them look and feel like the features
    provided by Ruby's Enumerable module, and I found contributing to the project
    very easy.\r\n\r\nTony is another hacker who is gifted at being a bit irreverent
    towards what are typically considered 'hard problems', and like Brian Ford, he
    is good at helping you understand that building a programming language isn't quite
    as hard as you might think. You can check this out for yourself by watching his
    [RubyConf 2010 talk](http://confreaks.net/videos/457-rubyconf2010-rev-revactor-reia).\r\n\r\n<i>UPDATE
    2011.07.19: Tony's projects move fast. I wouldn't be surprised if everything above
    is now out of date, but hunt down whatever he's working on now and you won't be
    disappointed.</i>\r\n\r\n### Eric Hodel ([@drbrain](http://twitter.com/drbrain))\r\n\r\nEric
    has been in the Ruby community for as long as I can remember, and as a member
    of the Seattle Ruby Group, he automatically can be recognized as an insanely capable
    hacker.\r\n\r\nWhat I feel Eric lacks is enough appreciation from the community
    for the very thankless work he was doing. Anyone who was around in Ruby before
    Rails knows that RubyGems greatly outgrew its initial design a long time ago.
    The code, originally hacked together at a conference, was never really meant to
    live in a world in which gem downloads are measured in the millions rather than
    the hundreds.\r\n\r\nSimilar arguments could be made about projects such as RDoc.
    Being able to autogenerate documentation is an important part of any language's
    infrastructure, but when Dave Thomas first put together RDoc, I doubt he could
    have anticipated how big Ruby would be and how long that code would still remain
    in active use.\r\n\r\nMost people didn't want to touch RubyGems or RDoc, both
    because of how outdated the code was, and because any small change to either of
    them could easily piss off the entire Ruby world. But the more that Ruby's ecosystem
    evolved, the more it became clear that fighting against old, janky architecture
    was a huge waste of time.\r\n\r\nLittle by little, Eric worked towards fixing
    up both of these projects. Now, both RDoc and RubyGems are much, much better than
    what they were before. Each have extension systems that make it so that the core
    code can continue to get smaller and simpler over time, rather than the other
    way around. In the case of RubyGems, that extension system brought us Gemcutter
    (now rubygems.org), which is now the official means of distributing gems to the
    Ruby community. While we have Nick Quaranto to thank for this innovation, we have
    Eric to thank for making RubyGems better so that Gemcutter could actually come
    into existence in the first place.\r\n\r\nIf there is one person in the Ruby community
    that deserves thanks for taking our old and busted tooling and making it serviceable
    again, it's Eric.\r\n\r\n<i>UPDATE 2011.07.19: Even despite the RubyGems turbulence
    over the last several months, I stand by this opinion of Eric's contributions
    100%</i>\r\n\r\n### Who's interesting to you?\r\n\r\nThese are the folks who caught
    my interest over the last year or so. Who is someone you think is worth knowing
    about?\r\n\r\n  \r\n> **NOTE:** This article has also been published on the Ruby
    Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/048-issue-16-interesting-ruby-hackers.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: ruby-hacker-writers
  :title: Interesting Ruby Hacker-Writers
  :summary: Find out which Ruby hackers consistently write great content worth reading.
  :published: 2011-01-07 00:00:00.000000000 Z
  :issue_number: '1.17'
  :volume: 1
  :body: "In the [last issue](http://practicingruby.com/articles/45) we covered five
    folks who are working on really interesting projects. In this issue, I'd like
    to pay some attention to five other Ruby hackers who have caught my attention
    through their excellent technical writing. As a technical author myself, I am
    particularly moved by folks who educate and inform our community through more
    than just code, but through written words as well.\r\n\r\nSimilar to Issue #16's
    list, this lineup is in no particular order, is far too short to do the community
    justice, and is purely subjective in nature. None of these folks knew I was going
    to write about them and my recommendations are completely unsolicited.\r\n\r\n###
    Magnus Holm ([@judofyr](http://twitter.com/judofyr))\r\n\r\nIf you've been on
    Twitter or Hacker News lately, you probably have run into an article or two from
    [Timeless](http://timelessrepo.com), a blog that Magnus is running with help from
    Steve Klabnik. The topics here range from the philosophical (see: [There is No
    Talent](http://timelessrepo.com/there-is-no-talent)), to the obscure low-level
    Ruby hack (see: [Tailin' Ruby](http://timelessrepo.com/tailin-ruby)), but the
    quality is consistently well above that of your run of the mill blog.\r\n\r\nAs
    it turns out, the reason why Timeless feels different than your average blog is
    because it is designed to be that way. Magnus describes the project as <i>\"an
    attempt at creating a new kind of blog with a focus on frequently updated, quality
    content which last longer than the beta of your favorite framework\"</i>. With
    so much web content being incredibly ephemeral in nature, the notion of timeless
    content is attractive, even if it means a considerable challenge for the author.\r\n\r\nAs
    a small historical note, Magnus is also one of the five folks who has written
    articles for the Ruby Best Practices blog. While he only wrote a total of [two
    articles](http://blog.rubybestpractices.com/posts/judofyr/index.html) for us,
    both were very well received by our readers. So even if I can't take credit for
    his recent work, I can at least claim that I knew his potential years ago :)\r\n\r\n###
    Jeff Kreeftmeijer ([@jkreeftmeijer](http://twitter.com/jkreeftmeijer))\r\n\r\nJeff
    is another blogger who has rapidly produced [a ton of great material](http://jeffkreeftmeijer.com/archive/)
    over the last year or so. The topics on his blog bounce around fairly frequently,
    though he seems to take a particular interest in developer practices, particularly
    surrounding git, gem packaging, and testing tools.\r\n\r\nWhat interests me about
    Jeff's writing is that while he's talking about fairly common topics, he typically
    focuses on just a single discussion point, which makes each of his posts a conversation
    waiting to happen. The process of watching Jeff make a point about some opinion
    he has formed about a given tool or technique and then seeing the community respond
    to that point has been a really enjoyable experience so far. For a nice example
    of what I've just described, check out Jeff's [Be awesome, write your gemspec
    yourself](http://jeffkreeftmeijer.com/2010/be-awesome-write-your-gemspec-yourself/)\r\n\r\nJeff's
    conversational approach to writing really leads to some productive conversations
    across a broad cross-section of the Ruby community. It's easy to see this phenomenon
    by either looking at the comments on the article above, or any other article of
    Jeff's that has gained some widespread attention (read: most of them).\r\n\r\nSimilar
    to Magnus, I admire Jeff for breaking out of the standard 'blogging template'
    and developing his own writing style that seems to work quite well.\r\n\r\n###
    MenTaLguY ([@MenTaLguY](http://twitter.com/#!/MenTaLguY))\r\n\r\nI may be showing
    my long, flowing Ruby beard by recommending MenTaLguY on a list of bloggers who
    impressed me in 2010, since the bulk of the materials of his that interested me
    were published in 2005-2006. But two articles posted in 2010 really caught my
    eye, and are worth recognition on their own: [Atomic Operations in Ruby](http://moonbase.rydia.net/mental/blog/programming/atomic-operations-in-ruby.html)
    and [The Biggest Mistake Everyone Makes With Closures](http://moonbase.rydia.net/mental/blog/programming/the-biggest-mistake-everyone-makes-with-closures.html).\r\n\r\nThese
    two articles are guaranteed to expose edge cases that will surprise all but the
    most diligent Rubyists, and are representative of the two things MenTaLguY has
    historically been known for: concurrency and functional programming.\r\n\r\nHis
    blog is written in the old fashioned 'everything in one pot' style, and due to
    a mixture of non-technical and technical content, can be very challenging to dig
    through. For this reason, I've gone way back to his 2006 and 2007 writing and
    pulled a few articles worth checking out, which may intice you to dig even deeper.\r\n\r\n*
    [Simple Lazy Streams](http://moonbase.rydia.net/mental/blog/programming/simple-lazy-streams.html)
    \r\n* [Currying in Ruby](http://moonbase.rydia.net/mental/blog/programming/currying-in-ruby.html)
    \r\n* [Monads in Ruby](http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/)\r\n*
    [Concise Memoization](http://moonbase.rydia.net/mental/blog/programming/concise-memoization.html)\r\n*
    [Eavesdropping on Expressions](http://moonbase.rydia.net/mental/blog/programming/eavesdropping-on-expressions.html)
    \r\n* [Ruby Symbols Explained](http://moonbase.rydia.net/mental/blog/programming/ruby-symbols-explained.html)\r\n*
    [Concurrency Five Ways](http://moonbase.rydia.net/mental/blog/programming/concurrency-five-ways.html)\r\n\r\nThe
    reason I've included MenTaLguY in this lineup is because I feel like he is a representation
    of an unapologetically deeply technical person that we are seeing less and less
    of in a more commercialized ecosystem that tends to value shiny tools and productivity
    tips over deep knowledge and theory. While the new world isn't a bad one because
    we all can find jobs in it, I remember a different community that leaned more
    towards MenTaLguY's direction as recent as five years ago.\r\n\r\nSo this is my
    hat-tip to old school Rubyists, and to MenTaLguY for frequently being ahead of
    his time by focusing on concurrency and functional programming before it was cool.\r\n\r\n###
    Aaron Patterson ([@tenderlove](http://twitter.com/tenderlove))\r\n\r\nAaron is
    another Ruby hacker who has been in the Ruby community for a long time and has
    worked on a number of cool projects, including Nokogiri and Mechanize. I've been
    a friend of Aaron's for a while, and have always admired his abilities as both
    a hacker and story teller. But the thing that really impressed me about Aaron's
    work in 2010 is his writing for the AT&T Interactive Engineering.\r\n\r\nRecently,
    Aaron has been performance tuning Rails 3 by rewriting the low level ARel relational
    algebra library. Doing major refactorings of Rails internals is no easy task,
    but you might think otherwise if you read Aaron's great posts about his work on
    ARel, due to their incredible clarity. It may just be the giant fonts or the pretty
    graphs, but the articles Aaron has written about his work on ARel have been the
    most easy to understand resources on performance tuning in Ruby that I have ever
    seen.\r\n\r\nAaron brushes up against a couple other Rails and Ruby 1.9.2 topics
    on the AT&T blog as well, approaching them in a similar clear and light-hearted
    style. But those looking for a lot more can dig through the archives of tenderlovemaking.com,
    which similarly has no shortage of great Ruby content.\r\n\r\n<i>UPDATE 2011.07.20:
    Looks like the AT&T interactive blog is down right now, so I couldn't provide
    any meaningful links above. But you can still find Aaron writing on his personal
    blog, [Tender Lovemaking](http://tenderlovemaking.com).</i>\r\n\r\n### Peter Cooper
    ([@peterc](http://twitter.com/peterc))\r\n\r\nIt may be a bit \"meta\" to acknowledge
    Peter, since he's typically writing about people who are writing code, or writing
    about people who are writing about writing code, but nonetheless, he is someone
    that deserves both attention and appreciation for the valuable service he's been
    offering our community for years.\r\n\r\nWhile I find a lot of new Ruby resources
    over Hacker News or Twitter, or just by working with my friends and colleagues,
    [Ruby Inside](http://rubyinside.com) remains the place I go when I want to put
    my finger on the pulse of the Ruby community. While small things may go unnoticed
    by Peter, most major new releases of important projects are covered by Ruby Inside.
    RI also is the place to go to see announcements about big upcoming events, or
    just to get a general feel for what Ruby hackers are up to.\r\n\r\nA number of
    my own projects, including Practicing Ruby itself, have gained a lot more attention
    by being featured on Ruby Inside than they would have on their own. Over the years,
    I've seen this site evolve from a time in which the existence of a Ruby news site
    seemed a bit ridiculous since everyone in the community already pretty much knew
    each other to the present day in which we absolutely need to have someone sifting
    through the endless stream of new content so that we know what things we just
    can't afford to miss.\r\n\r\nFor better or for worse, Peter has done a ton to
    help Ruby gain exposure in the broader technical community, and has helped those
    within our community find their way to some really great resources. The high degree
    of professionalism and consistency that Ruby Inside showcases does a lot to create
    a good first impression for our community as a whole.\r\n\r\n<i>UPDATE 2011.07.20:
    Ruby Inside is great, but less frequently updated these days. Be sure to check
    out other things Peter stewards, such as [Ruby Weekly](http://rubyweekly.com/)
    and [Ruby Flow](http://rubyflow.com)</i>\r\n\r\n### Reflections\r\n\r\nI must
    admit, I actually don't spend a lot of time reading technical books or blogs.
    I find that I'm so busy writing and actively practicing that hooking myself up
    to the firehose of new information seems like it would cause me to burst. In general,
    I think we have a community that is too obsessed with the consumption of information,
    and for that reason, it makes it hard for me to come up with a list of folks who
    I'd say can't be missed.\r\n\r\nThat having been said, a little bit of well placed
    information goes a long way, and the five people I have acknowledged in this post
    have really given me some major new insights at one point or another in my career.
    There are others I could say the same about, but I'll leave it to you to find
    them on your own.\r\n\r\nWho is a great hacker-writer that you think is worth
    knowing about?\r\n\r\n  \r\n> **NOTE:** This article has also been published on
    the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/049-issues-17-interesting-ruby-writers.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: dirty-testing-secrets
  :title: Dirty Little Secrets about Testing
  :summary: Take a look at some dark corners of the traditional testing dogma.
  :published: 2011-01-14 00:00:00.000000000 Z
  :issue_number: '1.18'
  :volume: 1
  :body: "Today I have a small rant about the test obsessed culture of Ruby. This
    area in particular is one in which the incredible enthusiasm surrounding the methodology
    seems to have outpaced the individual practitioner's ability to evaluate its utility.
    I'm not just talking about beginners here, but seasoned professionals as well.
    The sheer volume of rapidly changing testing tools and techniques is an indicator
    that we're nowhere near convergence, but that doesn't stop many from describing
    automated testing, particularly in the _Behavior Driven Development_ style, as
    if it were some sort of magic bullet. It isn't.\r\n\r\nSpeaking only from personal
    experience, I can tell you that most projects that I've spent more than a few
    hours hacking on end up better with some automated testing than they would with
    no testing at all. But I can also tell you that uses all the latest and greatest
    tools and techniques, and attempting to \"test all the fucking time\" on large
    scale, long running projects, has actually hurt rather than helped me at times.\r\n\r\nSome
    tests are a waste of time, and other tests can be actively harmful. If you have
    ever experienced the pain of refactoring a test suite in which someone overzealously
    mocked everything except for the object under test, simply to 'decouple the tests
    from the implementation code', you probably have an idea of what I mean. If you
    happen to be one of those folks who are still writing tests that way, you should
    study a bit more about what mocks are actually meant to be used for.\r\n\r\nPersonally,
    I've found testing to get in the way when I'm first exploring a new project. I
    almost always spend a couple hours writing crappy code without any tests at all.
    Test-first development does help drive interfaces and forces you to think about
    API design continuously, but it can only really be used to attain a local maximum.
    When you're trying to get a feel for a whole new concept, what you really need
    is a lantern, not a laser. Not even story frameworks like Cucumber or Steak give
    me the level of flexibility I need, so I go without testing frameworks entirely
    in my initial spikes. The closest thing I get to 'automated testing' in the first
    few hours of a project is a few lines of example code combined with some printlining
    to let me see what my code is doing. Pretty much everything else gets done through
    poking and prodding in irb.\r\n\r\nTypically, the tradeoff of velocity for code
    quality that I make in a spike fairly quickly catches up with me, and that causes
    me to start to think about adding tests and basically just starting from scratch,
    only using code if I feel it's good enough to refactor into something more permanent.
    With enough ideas generated, and a decent high level sense of what my goals are,
    the laser-like quality of unit testing becomes more useful. But there is still
    a lot of things I don't test, even once a project is under way.\r\n\r\nI don't
    test complex interactions with users within a system, unless I begin to frequently
    write code that has system-wide effects. I've definitely been in situations in
    which integration tests have been vital, but they've been far and few in between.
    Part of this is because the projects I work on tend to be deeper than they are
    wide, but it's also because I just trust my design capabilities enough to not
    introduce too many changes that could break more than one part of my application
    at a time. I feel like the majority of integration testing goes into way too much
    detail about the expected paths through a system, and as a result, forces a bunch
    of false-negatives as minor changes that shouldn't affect users end up breaking
    tests.\r\n\r\nSimilarly, I don't place too much emphasis on testing things that
    I will invariably need to manually inspect. So for example, if I'm generating
    a PDF report, I don't typically bother testing my output in an automated fashion.
    What I will do instead is make it dead easy for me to generate that PDF so that
    I can look at it whenever I need to, and I'll keep a copy of the expected output
    around so that I can track down issues when they come up by doing some manual
    comparisons. Things would change somewhat if generating PDF reports was the core
    purpose of my application, but as a single feature, I feel automated testing would
    be mostly a waste of time.\r\n\r\nThere are other areas about testing that concern
    me, but I'll leave them for another day. For now, I'll try to end things on a
    positive note by sharing some of the areas where I do think testing is really,
    really helpful.\r\n\r\n  * Dealing with regressions: In most scenarios, once you've
    created a minimal example to reproduce a bug, it's a small step to convert it
    into a unit test. As long as you introduce the test as far down the stack as possible,
    this minor investment is well worth the effort, as it will catch the bug and draw
    your attention to it if it ever gets reintroduced into your project.\r\n\r\n  *
    Documenting project requirements: When written properly, tests say a lot more
    about intentions than implementation code does. Some folks feel that something
    like Cucumber and/or RSpec does a better job at expressing requirements than more
    low level testing frameworks, but this is primarily an aesthetic argument. No
    matter what framework you use, the purpose of a test is to describe how some code
    should be expected to work, which makes test suites a great way to learn about
    a project.\r\n\r\n  * Safeguarding against harmful changes: For long running projects
    or projects with many developers, automated testing helps detect changes that
    have undesireable or unexpected side effects on the overall system. This is something
    that can also be dealt with by being well organized and fairly disciplined, but
    tests sure don't hurt. Of course, this effect is only accomplished if there is
    sufficient test coverage to catch those unexpected changes, an investment that
    may or may not be worth the effort.\r\n\r\nNote that in the above, I didn't imply
    that testing results in writing better code. I also specifically avoided claiming
    that tests will help you avoid defects in the first place. While I think that
    occasionally testing contributes to accomplishing these two things, it really
    depends on the project as well as the individual developer's skill level and coding
    style. I also didn't claim that writing tests saves time or money. I don't think
    it actually does, and I wouldn't trust that claim until I saw some concrete evidence.\r\n\r\nEven
    with these caveats, the gains listed in the bullet points above make the\r\njuice
    worth the squeeze, in most cases. I can also say that automated testing\r\ndoes
    make you think about software development in a very different way, and that\r\nchange
    in perspective might make you a better programmer. But testing is just\r\none
    of many things that can improve your craft.\r\n\r\nSo my humble advice to all
    Rubyists, newbies and seasoned professionals alike, is to cool your jets when
    it comes to testing. If we remember our main goal is to produce useful software,
    we can find room to make use of helpful techniques without letting them take center
    stage. This I think would be a huge step in the right direction.\r\n\r\n  \r\n>
    **NOTE:** This article has also been published on the Ruby Best Practices blog.
    There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/050-issues-18-testing-dogma.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: thoughts-on-mocking-1
  :title: Thoughts on Mocking, Part 1
  :summary: Consider how the ideas from Martin Fowler's "Mocks aren't Stubs" can be
    applied to Ruby.
  :published: 2011-01-19 00:00:00.000000000 Z
  :issue_number: '1.19'
  :volume: 1
  :body: "When I originally published my [small rant on testing](http://practicingruby.com/articles/47),
    it generated a spirited discussion about a number of different topics. It even
    lead [Bryan Liles](http://twitter.com/bryanl) to post a great set of [testing
    guidelines](https://gist.github.com/785610) to balance out my unfocused rant.
    But the topic that overshadowed almost everything else was that of best practices
    regarding mock objects. In this two part article, we'll try to shine some light
    on that topic, because it is clearly still a point of confusion and occasionally
    even controversy within our community.\r\n\r\nIn Issue #20, I will go over some
    examples of when I use mock objects and when I don't, and try to come up with
    some guidelines for building test suites that do their job without becoming too
    brittle. But before we can really discuss practices, we need to establish a baseline
    level of theory and background knowledge, which is what this post is all about.\r\n\r\nRather
    than doing the heavy lifting myself, I will point you to *the* article to read
    to better understand mock objects. It was written in 2004 (which is about the
    time that I first read it), and then revised in 2007. It is of course, Martin
    Fowler's essay [Mocks Aren't Stubs](http://martinfowler.com/articles/mocksArentStubs.html).\r\n\r\nThe
    article is long, somewhat dry, and includes large amounts of Java code. Don't
    let that discourage you from reading the whole thing from end to end, and if necessary,
    reading it again. Despite the title, Fowler goes into much deeper topics than
    mocks vs. stubs, and hits on many of the key ideas that separate 'mockists' from
    'classicist'. Personally, I feel this is a false dichotomy, but you'll still be
    hard pressed to find a better article that gives the historical background of
    the design ideas that motivated the creation of testing and mocking frameworks
    in the first place.\r\n\r\nI find Fowler's assessment to be reasonable fair, incredibly
    comprehensive, and a very useful place to start from if you are to form any argument
    about one approach vs. another when it comes to mocking. That having been said,
    I am critical of certain aspects of this essay, partly because I am looking at
    it with a 2011 perspective, and partly because I didn't come to Ruby from Java.
    For this reason, I've included my commentary on Fowler's article below. I encourage
    you to read his article in full before reading my comments, as they'll make much
    more sense that way.\r\n\r\n### Commentary on Fowler's \"Mocks Aren't Stubs\"\r\n\r\nFowler
    explores two different concepts in this article: behavior vs. state based verification,
    and classical vs. mockist TDD. While he doesn't directly draw the lines between
    them, he sort of implies that mockists are always focusing on behavior verification
    and that classical TDD leans heavily towards state based verification. There are
    some issues with this line of thinking.\r\n\r\nClaiming that mockists inherently
    focus on behavior is valid. The idea of mocking everything except the object under
    test means that purists would not be able to work with 'real objects' to perform
    state verification on. But this sort of practice does not actually require mocking
    everything except the object under test, what it requires is more carefully written
    tests.\r\n\r\nFowler claims that classicists tend towards writing single tests
    that explicitly test large clusters of code simultaneously, which requires them
    to produce a large amount of fixture data just to get their tests to run. But
    in a post-BDD world, most people know how to isolate their test cases so that
    they focus on one behavior at a time, whether or not they're utilizing mock objects.
    We also know to write comprehensive tests at both the higher and lower levels
    of our project, and so it isn't necessary to worry about exercising all the possible
    paths through our low level objects when calling them through a high level interface.\r\n\r\nPersonally,
    when I'm testing a feature that is towards the top layer of my stack, I try to
    make it so it requires as little configuration as possible to initialize. It shouldn't
    be necessary to load up fixture data for low level features I won't use, so really,
    I only need to trace a single path of execution and provide the right data to
    make it a valid path. I weigh the cost of this against using a mock object, and
    whenever the two are comparable, I prefer the former. Clearly this doesn't make
    me a mockist, but does it fit with Fowler's definition of a classicist? I don't
    know.\r\n\r\nI was never deeply involved in Java programming, but from my limited
    experience with it, I feel that a lot of the arguments Fowler formed in this essay
    were and probably still are more relevant in the Java world. In Java, because
    you don't have things like mixins, indirection is much more common than in Ruby.
    You might need to create 6 objects just to do one small simple thing. In such
    an environment, mock objects must seem like a godsend, as when you multiply that
    phenomena across your entire project, the cost of maintaining mocks would be far
    less than the cost of building complex setups for all those objects. But if you're
    experiencing the same sorts of problems in Ruby, you have a horrible design for
    your project.\r\n\r\nIn Ruby, it is possible and often recommendable to build
    systems that don't have very deep object nesting. For this reason, the ability
    to focus only on mocking direct neighbors of an object under test isn't as much
    of a selling point. If we take away the complex object systems component, we are
    mostly left with the idea that mockists prefer to write mocks so that they can
    focus on driving the object under test, and then go back to use their mocks as
    a contract for the next object they need to create. Again, something that makes
    a lot of sense in languages that punish you for creating new objects. Ruby is
    not like that.\r\n\r\nIn almost every scenario I can imagine, it's better to just
    go ahead and create a skeleton version of an object you need than it is to form
    a mock that is sort of floating in space. It will likely take less time, and working
    with the real object will give better insight into its design than trying to dream
    it up through a cumbersome mock interface. Fowler does touch on this approach
    being a valid one but claims that the mockist approach provides more design guidance.
    I don't see any evidence to support this claim, as the two are essentially functionally
    equivalent with respect to the object under test.\r\n\r\nFowler does an excellent
    job of covering the arguments about test isolation, and I don't have too much
    to add there except to say that I am firmly in favor of watching my whole test
    suite go up in smoke when I make a far reaching change. The false-positives that
    mocks give are downright dangerous in these scenarios, and arguments about it
    being difficult to find what caused the breakage are most likely an indication
    of some deeper problem: I've never had that issue even on my most complex projects.\r\n\r\nFowler's
    entire discussion about Design Style for classicists vs. mockists misses the mark.
    It probably had a lot of truth to it at the time he wrote the article, and may
    still have some truth outside of Ruby. But really, what he is describing here
    is the distinction between old fashioned regression-suite style TDD and what we
    now call Behavior Driven Development. In my opinion, BDD is just a new style of
    TDD that is more principled and focused on design as a first class component of
    writing testable code. So when Fowler says that mockists favor role based systems,
    I think this actually applies more generally to anyone practicing modern TDD.\r\n\r\n###
    Reflections\r\n\r\nAs I said at the very beginning of this article, I think the
    distinction between mockists and classicists is a false dichotomy. I do agree
    that there is a wide chasm to cross between the original purpose of test frameworks
    and the new way of looking at things. But really, once you've decided that tests
    are more than just a safety net for dealing with regressions, you have already
    fallen outside of Fowler's classicist point of view. In my opinion, there is room
    for people who focus on behavior rather than state, but don't necessarily feel
    like mock objects are a good tool to be using by default. These folks are just
    as concerned about design and driving code through tests, but do not subscribe
    to absolutist viewpoints that require a single technique to be used at all times.\r\n\r\nSince
    I consider myself to be in the third category that I've wedged between Fowler's
    two groups, I will need to share some examples of what that means in practical
    terms. The next article should help with that, because it provides an outline
    of how I decide when to mock and when to use real objects instead. Until then,
    I'd be happy to hear your thoughts on this topic, especially what you think of
    Fowler's article.\r\n\r\n  \r\n> **NOTE:** This article has also been published
    on the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/051-issue-19-thoughts-on-mocking.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: thoughts-on-mocking-2
  :title: Thoughts on Mocking, Part 2
  :summary: Explore a few good uses of mock objects from a non-mockist's perspective.
  :published: 2011-01-22 00:00:00.000000000 Z
  :issue_number: '1.20'
  :volume: 1
  :body: "In the [last issue](http://practicingruby.com/articles/48), I encouraged
    everyone to read Martin Fowler's classic article [Mocks Aren't Stubs](http://martinfowler.com/articles/mocksArentStubs.html).
    Since this article is a bit dated and leans heavily towards Java style development
    practices, I also offered my own commentary to hopefully bridge the gap between
    Fowler's insights and the modern Ruby world. Now that we have the theories behind
    us, today we can focus on putting these ideas into practice.\r\n\r\nThere is a
    style of behavior driven development that encourages mocking everything except
    the object under test. Fowler calls folks who follow this methodology _mockists_,
    and more-or-less presents this approach as a completely valid alternative to classic
    TDD, in which test doubles of any variety are only used when absolutely necessary.
    While I think that such an assessment is valid in the context Fowler originally
    wrote his article (2004/Java), I personally feel that the _mockist_ style that
    Fowler describes has no place in modern Ruby development.\r\n\r\nThat having been
    said, when used in moderation, mocking frameworks can make testing a whole lot
    easier. Today, I'll be sharing my thoughts on when to use mocks and when not to.
    While these are not meant to be taken as strict rules to follow, they may shed
    some light on a middle ground between Fowler's classicist and mockist categories.\r\n\r\n>
    **NOTE:** I'm using [citrusbye/contest](http://github.com/citrusbyte/contest)
    and [mocha](https://github.com/floehopper/mocha) in the tests shown in this article,
    but the ideas should apply to any testing framework + mocking system.\r\n\r\n###
    Good uses for mocks\r\n\r\nWhen I think back on my testing habits, I find that
    virtually all of my use of mock objects falls into one or more of the following
    three categories:\r\n\r\n * Testing code which depends on an external resource
    of some sort (a web service, the filesystem, mail server, etc.)\r\n * Testing
    code which would involve a large amount of non-reusable setup and fixture data
    if you didn't mock at a high level.\r\n * Testing code which relies on features
    which are particularly computationally expensive.\r\n\r\nEach of these scenarios
    has their caveats, but odds are, most moderate to large\r\nsize projects I work
    on hit at least one of them, and it isn't rare\r\nto deal with all three of these
    issues simultaneously. That alone tells me that\r\nhaving a good understanding
    of how to use mocks is a key part of TDD. I'll now\r\nshare some examples that
    hopefully help drive that point home.\r\n\r\n<b>Isolation from external resources</b>\r\n\r\nIt
    would be great if our projects were completely self-contained, not having to deal
    with any shared resources, but this isn't realistic. Most projects need to deal
    with at least some external resources and may even have to tackle some systems
    integration problems. This often makes automating testing considerably more challenging
    than we would like it to be.\r\n\r\nThankfully, mock objects provide some shortcuts
    for us. While they won't help us with testing the code that needs to interact
    with the outside world, they can easily be used as stand-ins for our integration
    points when we are testing code that depends on outside resources. This makes
    it possible to test our high level logic without having to access whatever external
    resources our code needs to integrate with.\r\n\r\nTo demonstrate how useful this
    can be, we'll look at some simple tests from a tool I built which uses _win32ole_
    to integrate with some Windows based truck routing software. Below, you can see
    a bit of test code that ensures a particular error gets raised when an invalid
    stop is added to the trip object.\r\n\r\n```ruby\r\ntest \"trip must be able to
    detect an invalid stop\" do \r\n  trip = MilesDavis::Trip.create\r\n  expect_an_invalid_stop\r\n\r\n
    \ error = assert_raises(MilesDavis::InvalidStopError) do \r\n    trip.stops <<
    \"Fakeville, FK\" \r\n  end\r\n\r\n  assert_equal \"Cannot Find: Fakeville, FK\",
    error.message\r\nend \r\n```\r\n\r\nIf you guessed that the `expect_an_invalid_stop`
    method introduces a mock into\r\nthese tests, you were right! While it might look
    a bit like magic on a first\r\nglance, I usually try to separate all but the most
    trivial mock logic into its\r\nown helper methods to make the tests easier to
    maintain. Here's what\r\n`expect_an_invalid_stop` actually does:\r\n\r\n```ruby\r\ndef
    expect_an_invalid_stop\r\n  server = mock()\r\n  server.expects(:CheckPlaceName).returns(0)\r\n
    \ MilesDavis.expects(:server).returns(server)\r\nend\r\n```\r\n\r\nWe can now
    take a look at the implementation code that these tests run against. It is a simple
    module that gets mixed into the stops array when a new `Trip` is created.\r\n\r\n```ruby\r\nmodule
    StopValidation\r\n  def <<(place)\r\n    unless MilesDavis.server.CheckPlaceName(place)
    > 0\r\n      raise InvalidStopError, \"Cannot Find: #{place}\"\r\n    end\r\n\r\n
    \   super\r\n  end\r\nend\r\n```\r\n\r\nIf you go back and re-read the test and
    mock code, it should be pretty clear what is going on here. When this system is
    actually running in production, `MilesDavis.server` refers to a _win32ole_ object,
    which explains the crappy camel case method names. But when running this particular
    test, we swap out the server call to return a mock object of our own creation.\r\n\r\nBy
    crafting our tests to mock out any interaction with the server, our test suite
    still works fine outside of the production environment. Even though the core purpose
    of this library is to integrate with a proprietary bit of Windows code running
    on a particular machine, we were able to develop all but the lowest layer entirely
    within our Linux and Mac-based development environments without needing any direct
    access to the software we were integrating with.\r\n\r\nIt's worth mentioning
    that although this use case was extracted directly from a real world project,
    it was hand picked to demonstrate the value of mocks in this sort of context.
    Other interactions with external resources are not so black and white. For example,
    if you're doing something like manipulating files on a system, it might make more
    sense to use temporary files than it would be to introduce mock objects. There
    are many other scenarios like this, so it's usually best to weigh out the costs
    and benefits before going full steam ahead with mocks.\r\n\r\nThat having been
    said, mocking external resources is almost always a valid use case, if not the
    most optimal one in certain situations.\r\n\r\n<b>Avoiding complex setup + fixtures</b>\r\n\r\nThe
    main reason why integration with external resources is a pain is because it often
    requires lots of configuration and setup just to get things running. A similar
    phenomenon occurs internally when projects get large enough to have some complex
    object relations and/or advanced datastructures.\r\n\r\nWhat follows is a bit
    of test code for a decorator that we built to wrap some low level geospatial data
    that we were storing via PostGIS.\r\n\r\n```ruby\r\ntest \"retreive a valid US
    postal area\" do\r\n  expect_postal_area_search(\"06511\")\r\n  geom = GeoRegion.by_postal(\"06511\")\r\n
    \ assert_equal :postal, geom.interpreted_type\r\nend\r\n```\r\n\r\nThe mocking
    actually happens in `expect_postal_area_search`, which is shown\r\nbelow:\r\n\r\n```ruby\r\ndef
    expect_postal_area_search(zip)\r\n  PostalArea.expects(:find_by_zcta).with(zip).returns(record_stub)\r\nend\r\n```\r\n\r\nThis
    mock emulates a simple `ActiveRecord` search, returning a stubbed out record which
    implements the bare minimum functionality required by our `GeoRegion` class. While
    somewhat uninteresting, below is the definition of `record_stub()`, for those
    curious.\r\n\r\n```ruby\r\ndef record_stub\r\n  stub(:the_geom => Object.new)\r\nend\r\n```\r\n\r\nThe
    guts of `GeoRegion` are actually a little bit complex, but our test was only meant
    to show that `GeoRegion.by_postal` returns an object that responds to `interpreted_type()`
    and returns the value `:postal`. This means we can focus on just that part of
    things without losing anything important.\r\n\r\nThe part of the code that does
    the geometry lookup is a simple delegator to `PostalArea.find_by_zcta`, which
    is what `expect_postal_area_search` mocks out for us. The stubbed out record it
    returns ends up being used in a helper method that defines the `interpreted_type`
    on the record via a mixin and then sets its value.\r\n\r\n```ruby\r\ndef geom_for(record,
    type = nil)\r\n  geom = (record && record.the_geom) or \r\n    raise UnknownFormatError,
    \"Not a valid #{type}\"\r\n\r\n  geom.extend(Meta)\r\n  geom.interpreted_type
    = type \r\n  geom.record = record \r\n  \r\n  return geom \r\nend         \r\n```\r\n\r\nI
    won't bother tracing the longish execution path that lies on either side of this
    helper method, but the key takeaway here is that we're able to avoid to skip two
    layers of complexity by mocking out our call to `PostalArea` and stubbing out
    the actual geometry object that is associated with that `PostalArea`.\r\n\r\nWe
    could have loaded fixture data into our testing environment which had the relevant
    geospacial data to perform the sort of search we needed for this feature, but
    doing so would certainly be more complicated than the two simple lines we used
    to create our mock and stub.\r\n\r\nPart of the reason mocks work out well here
    is that they allow you to focus on the behavior of `GeoRegion` rather than its
    implementation details. Even though under the hood a bunch of complex object manipulation
    is going on, we only really care about a very narrow set of functionality that
    `GeoRegion`'s adds as metadata to the geometry objects looked up through its search
    methods. If we had to actually populate the database with geometry data and concern
    ourselves with the messy relationships between these objects, our tests would
    be far less clear.\r\n\r\nOf course, this technique only really makes sense when
    understanding and maintaining the mock object's interface is easier than creating
    the necessary setup code and fixtures to run the tests with real objects. Often
    times, the scales are tipped in the other direction, which I'll talk about a little
    later in this article. But before we get into the bad ideas, we have one more
    good one to cover.\r\n\r\n<b>Mocking for performance reasons</b>\r\n\r\nThe first
    two techniques both had something in common: They made life easier by preventing
    certain code from actually being run. If we take that idea and apply it to performance,
    we find that running less code is usually faster than running more code.\r\n\r\nLet's
    consider the following simple code that sends an email message to a group each
    time a new member is added.\r\n\r\n```ruby\r\nclass Group\r\n\r\n  def initialize(name,
    admin)\r\n    @name    = name\r\n    @admin   = admin\r\n    @members = []\r\n
    \ end\r\n\r\n  attr_reader :members, :name, :admin\r\n\r\n  def <<(new_user)\r\n
    \   raise if members.include?(new_user)\r\n\r\n    members << new_user\r\n    broadcast(\"New
    user added\", \"#{new_user} joined the #{name} \"+\r\n              \"group on
    #{Date.today}.\")\r\n  end\r\n\r\n  def broadcast(title, content)\r\n    mail
    = Mail.new\r\n\r\n    mail.from(admin)\r\n    mail.to(members)\r\n    mail.subject(title)\r\n
    \   mail.body(content)\r\n\r\n    mail.deliver\r\n  end\r\n\r\nend\r\n```\r\n\r\nBecause
    `Group#broadcast` is almost entirely calls to the external Mail library, it arguably
    doesn't need unit tests, and instead could be covered by integration tests that
    set up a test mail server or something like that. However, `Group#<<` is a different
    story.\r\n\r\nIf we focus on the behavior of appending a user to the group, we
    don't actually need to focus on how `broadcast()` is implemented, we only need
    to verify that it is called. The following test demonstrates how to apply that
    line of thinking.\r\n\r\n```ruby\r\ntest \"adding users\" do\r\n  group = Group.new(\"Practicing
    Ruby\", \"greg@practicingruby.com\")\r\n\r\n  expect_broadcast(group, 2)\r\n\r\n
    \ group << \"joe@example.com\"\r\n  group << \"matz@example.com\"\r\n\r\n  assert_equal
    [\"joe@example.com\", \"matz@example.com\"], group.members\r\nend\r\n```\r\n\r\nThe
    most simple mock that reasonably covers the necessary functionality for `expect_broadcast()`
    is shown below.\r\n\r\n```ruby\r\ndef expect_broadcast(group, count)\r\n  group.expects(:broadcast).times(count)\r\nend\r\n```\r\n\r\nWe
    could actually go much farther here and verify the particular subject and content
    being passed to `broadcast()`, but as I said in [issue #18's mini-rant on testing](http://practicingruby.com/articles/47),
    I don't particularly like testing presentation logic that needs to be hand verified
    due to frequent superficial change. But personal preferences aside, even with
    a more complex set of expectations, using a mock object here is sure to be faster
    than actually sending an email.\r\n\r\nThis is a bit contrived example, but imagine
    a group object with many more methods that send broadcast emails. Add to that
    all the email enabled features across an application, and you'll quickly see the
    clock ticking longer and longer even if you do have a mail server that pipes everything
    to _/dev/null_.\r\n\r\nThis sort of scenario will come up in a number of different
    domains, and whenever it does, mock objects might be the right way to go. The
    main downside of using this sort of approach is that it eliminates the possibility
    of using your tests as a performance benchmark for your project. It is also worth
    noting that without proper integration tests, your mocks will happily go green
    in places that your real code may never be able to run. But since these issues
    tend to get spotted very quickly in manual testing and ordinary application use,
    it's usually okay to wait until this becomes a problem before worrying about it.\r\n\r\nThe
    three types of scenarios I've covered so far pretty much completely describe the
    valid use cases for mocks that have come up in my work. It isn't likely to be
    an exhaustive list, but I've working in a fairly large amount of projects across
    diverse domains and have yet to see another need for mocks that I didn't cover
    here. I did run up against a couple anti-patterns though, so let's take a look
    at those now before we wrap up.\r\n\r\n### Bad uses for mocks\r\n\r\nTwo very
    popular use cases for mocks should actually be considered harmful:\r\n\r\n* Using
    mocks for complete isolation of internal dependencies\r\n* Using mocks as contracts
    for unwritten objects\r\n\r\nTo be sure, there are fairly strong arguments for
    each of these ideas, Fowler alone goes to great lengths making the case for them,
    and he is a moderate on these issues. But I'd argue the line of thinking is really
    geared towards languages that punish users from creating lots of objects with
    simple APIs connecting them together, such as Java. Let's take a look at some
    Ruby examples so that we can consider that point.\r\n\r\n<b>Using mocks for complete
    isolation of internal dependencies</b>\r\n\r\nConsider this simple variation on
    the theme of a user group, in which `Group#<<` constructs Person objects for each
    new member of a group.\r\n\r\n```ruby\r\nclass Group\r\n  def initialize\r\n    @members
    = []\r\n  end\r\n\r\n  attr_reader :members\r\n\r\n  def <<(person_name)\r\n    members
    << Person.new(person_name)\r\n  end\r\n\r\n  def member_names\r\n    members.map
    { |e| e.name }\r\n  end\r\nend\r\n```\r\n\r\nA mockist would not think about whether
    `Person` has external dependencies, complex setup requirements, or performance
    issues. They would just have started with a mock right away, perhaps something
    like this.\r\n\r\n```ruby\r\nclass GroupTest < Test::Unit::TestCase\r\n  test
    \"adding members to a group\" do\r\n    group = Group.new\r\n\r\n    expect_new_member(\"Gregory
    Brown\")\r\n    group << \"Gregory Brown\"\r\n\r\n    expect_new_member(\"Jia
    Wu\")\r\n    group << \"Jia Wu\"\r\n\r\n    assert_equal [\"Gregory Brown\", \"Jia
    Wu\"], group.member_names\r\n  end\r\n\r\n  def expect_new_member(member_name)\r\n
    \   Person.expects(:new).returns(stub(:name => member_name))\r\n  end\r\nend\r\n```\r\n\r\nThe
    neat thing about the code above is that it really does create some major isolation,
    in that it will still allow you to test `Group#<<` and `Group#member_names` with
    nothing more than a bare class definition for `Person`. If we wanted to be hardcore,
    you could even create a `Group#new_person` method and mock that instead, and then
    you wouldn't even need a defined `Person` constant!\r\n\r\nBut before we get too
    excited, let's assume `Person` is just a trivial container method, such as the
    one shown below.\r\n\r\n```ruby\r\nclass Person\r\n  def initialize(name)\r\n
    \   @name = name\r\n  end\r\n\r\n  attr_reader :name\r\nend\r\n```\r\n\r\nThis
    code doesn't require any complex setup, it isn't using any external resources,
    and it doesn't have any performance intensive characteristics to it. That means
    that in order to test it directly, all we need to do is remove a bunch of lines
    from our previous test case.\r\n\r\n```ruby\r\ntest \"adding members to a group\"
    do\r\n  group = Group.new\r\n\r\n  group << \"Gregory Brown\"\r\n  group << \"Jia
    Wu\"\r\n\r\n  assert_equal [\"Gregory Brown\", \"Jia Wu\"], group.member_names\r\nend\r\n```\r\n\r\nBy
    comparison, the above code is much more simple. But some smart folks still write
    it the other way. This is not without reason, and in fact has something to do
    with what happens when a change is made that causes tests to fail. To illustrate
    this, suppose that Person has a simple test that looks something like this.\r\n\r\n```ruby\r\ntest
    \"a user has a name attribute\" do\r\n  user = User.new(\"Gregory Brown\")\r\n
    \ assert_equal \"Gregory Brown\", user.name\r\nend\r\n```\r\n\r\nWith the code
    we've seen so far, this test easily passes. But consider what happens when the
    implementation of User is changed to something like the code below.\r\n\r\n```ruby\r\nclass
    Person\r\n  def initialize(name)\r\n    @name = name.upcase\r\n  end\r\n\r\n  attr_reader
    :name\r\nend\r\n```\r\n\r\nThe version of our test suite which uses mock objects
    will have one failure in the test case that is specifically checking what `Person#name`
    returns. It will not cause our `Group` tests to fail, because a stubbed person
    object is used there instead. I've included the output of a test run using that
    approach so you can see what that looks like.\r\n\r\n```\r\n  1) Failure:\r\ntest_adding_members_to_a_group(GroupTest)\r\n<[\"Gregory
    Brown\", \"Jia Wu\"]> expected but was\r\n<[\"GREGORY BROWN\", \"JIA WU\"]>.\r\n\r\n
    \ 2) Failure:\r\ntest_a_user_has_a_name_attribute(PersonTest)\r\n<\"Gregory Brown\">
    expected but was\r\n<\"GREGORY BROWN\">.\r\n```\r\n\r\nThis is exactly what mockists
    don't like to see. The argument is that as your programs get more complex, the
    dependencies between objects get larger and larger and you end up with tens or
    hundreds of failing tests all because of a change in one place. This phenomena
    can and does occur, and it happens in smaller projects than you might think.\r\n\r\nBut
    still, doesn't something smell fishy?  The mock objects that are now being constructed
    in the tests for `Group#member_names` are now completely out of synchronization
    with the real specifications of the application. It isn't possible to get the
    output they test against in real uses of the application, and so while they adequately
    test the behavior of `Group#member_names`, the isolation has caused the mocks
    to diverge from reality, making them untrustworthy as 'living documentation' for
    the real system.\r\n\r\nPersonally, when I make a change that has potential system-wide
    affects, I prefer my tests to be verbose. Testing objects directly prevents this
    sort of out of sync representation of object behavior from being even possible,
    and so increases the reliability of the tests as both an integration testing safety
    net and as a documentation source.\r\n\r\nAs for sifting through the sea of information
    that gets spit out when you *don't* use mocks, there are ways of effectively sifting
    through it so as to not have problems even in very complex applications. But that
    is a topic more related to general debugging and may be better off described in
    another article.\r\n\r\nWe still have one more point to cover before we wrap up
    here, and this is now edging on being a massive article, so let's get to it.\r\n\r\n<b>Using
    mocks as contracts for unwritten objects</b>\r\n\r\nWhen writing code test first,
    it is possible to use mock objects as stand ins for objects that have not been
    defined yet. As I had mentioned before, with minor alterations we wouldn't even
    need to have a `Person` class defined in order to effectively test `Group#<<`
    and `Group#member_names`.\r\n\r\nThis is sort of neat, because it forces a radical
    form of behavior driven development. Since you're not working with the real collaborator
    objects at all in your tests, you are absolutely forced to work with their expected
    behaviors and not their implementations.\r\n\r\nWe've already hinted at some of
    the downsides of this approach though, in particular, that it is possible for
    our mocks can get out of sync with reality. We've seen an example of tests that
    don't fail, even though they describe invalid output from `User#name`. Now let's
    see an example of a change that does cause our original mock-based tests to fail,
    even though there is nothing wrong with the code itself.\r\n\r\n```ruby\r\n# replace
    the Person object with this definition, which simply renames\r\n# Person#name
    to Person#full_name\r\n#\r\nclass Person\r\n  def initialize(full_name)\r\n    @full_name
    = full_name\r\n  end\r\n\r\n  attr_reader :full_name\r\nend\r\n\r\nclass Group\r\n
    \ # update to call the renamed Person#full_name method\r\n  def member_names\r\n
    \   members.map { |e| e.full_name }\r\n  end\r\nend\r\n```\r\n\r\nWhen we run
    the non-mocked version of our tests, nothing fails, because it never explicitly
    mentions the name attribute on `Person`. But the same cannot be said for our mocked
    code, which explicitly creates stubs with a name attribute, as shown below.\r\n\r\n```ruby\r\n
    \ def expect_new_member(member_name)\r\n    Person.expects(:new).returns(stub(:name
    => member_name))\r\n  end\r\n```\r\n\r\nYou can see the test output below as evidence
    that our mock is now indeed broken.\r\n\r\n```\r\n  1) Failure:\r\ntest_adding_members_to_a_group(GroupTest)\r\n
    \   [/home/sandal/devel/practicing-ruby/group.rb:14:in `member_names'\r\n     /home/sandal/devel/practicing-ruby/group.rb:14:in
    `map'\r\n    ...\r\nunexpected invocation: #<Mock:0x7ff71166e6c0>.full_name()\r\nsatisfied
    expectations:\r\n- expected exactly once, already invoked once: Person.new(any_parameters)\r\n-
    expected exactly once, already invoked once: Person.new(any_parameters)\r\n- allowed
    any number of times, not yet invoked:\r\n  #<Mock:0x7ff71166e6c0>.name(any_parameters)\r\n-
    allowed any number of times, not yet invoked:\r\n  #<Mock:0x7ff71166aac0>.name(any_parameters)\r\n```\r\n\r\nSo
    here we see the knife cuts both ways. While it's true that our mocked code doesn't
    need to worry about the implementations of anything except the object under test,
    it does tightly bind to the interface, even when changes to those interfaces don't
    affect the object under test.\r\n\r\nThis allows us to make the same argument
    that mockists make about cascading errors, from the other side of the fence. As
    projects grow bigger, the amount of red tests due to brittle mock objects grows
    larger and larger, making it harder to see what is actually broken and what needs
    to be changed. But unlike the problem of noisy directly tested objects, these
    sort of failures only indicate a problem with the tests, not the code.\r\n\r\nIn
    languages where creating new objects is hard and time consuming, such a trade
    is probably worth considering. If we had to hand tune a Makefile, set up headers,
    declare variables, and consider memory management just to add a Person object
    like we might in C++, there might be a strong argument for how using mocks for
    driving tests helps you be more agile.\r\n\r\nBut in Ruby, in which our first
    tests can be made to pass with just a single line like the one below, you have
    to wonder whether the juice is worth the squeeze.\r\n\r\n```ruby\r\n  Person =
    Struct.new(:name)\r\n```\r\n\r\nOne important thing to note is that despite my
    criticisms, there are folks out there who use very elegant design techniques and
    testing practices that can minimize the problems I have pointed out. But personally,
    I feel like these folks succeed in spite of the path they've chosen rather than
    because of it. The idea that using mocks to force you to think about design may
    work well as a gateway drug, but then once you've learned how to think about object
    design on its own, you can chuck out the training wheels and just focus on writing
    good code.\r\n\r\nThe examples I've shown here might be a bit biased towards demonstrating
    my arguments, but at least should give a starting point for considering these
    issues on your own.\r\n\r\n### Reflections\r\n\r\nWe've simultaneously shown in
    this article that mock objects are both really damn useful and ridiculously annoying
    at the same time. Personally, I tend to shy away from tooling that requires you
    to swallow a large amount of dogma and a boatload of theory before you can even
    make use of it, and that is the main reason why I'm concerned about the whole
    mockist approach to things. From what I've seen, while a stereotypical _classicist_
    is hard to come by, these _mockist_ folks that Fowler describes do exist and in
    my opinion, do more harm than good in getting folks to write clear, easy to understand
    Ruby code.\r\n\r\nMocking frameworks are big guns, and should be treated as such.
    They can be life\r\nsavers when used in moderation, but can make you pull your
    hair out if you use them inappropriately.\r\n\r\nIn summary, it's a bad idea to
    swallow bad tasting medicine with the abstract promise that it will be better
    for you in the end. If you can see clear benefits from the use of mocks and have
    weighed them out on a case by case basis against your other options, you should
    be fine. But if you are mostly using them because the RSpec team tells you to,
    you're basically screwed :)\r\n\r\nMy final disclaimer about what I've said here
    is that it is entirely based on my own experiences. You've worked on different
    problems in different environments than I have, and I'd love to know how those
    experiences have influenced your own thoughts on mocking.\r\n  \r\n> **NOTE:**
    This article has also been published on the Ruby Best Practices blog. There [may
    be additional commentary](http://blog.rubybestpractices.com/posts/gregory/052-issue-20-thoughts-on-mocking.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: how-to-practice-1
  :title: How to practice, Part 1
  :summary: Discover a new way to practice your coding skills by asking yourself the
    right questions.
  :published: 2011-01-26 00:00:00.000000000 Z
  :issue_number: '1.21'
  :volume: 1
  :body: "When I was 17 years old, I was asked by an Air Force military training\r\ninstructor
    how to get to Carnegie Hall. Before I could even think of why he'd\r\nask me this
    question, he shouted \"Practice! Practice! Practice!\" This was\r\nfollowed by
    an hour long monologue about the finer points of properly making a\r\nbed and
    stowing underwear in a locker, which might explain why my aspirations\r\nfor a
    military career started and ended in JROTC. But that clich of a first\r\nline
    stuck with me, even to this day.\r\n\r\nYou are reading a newsletter called Practicing
    Ruby. Therefore, you must not be\r\naverse to practice or are at least not a stranger
    to it. However, skillful\r\npractice is an art form, and not all types of practice
    should be considered\r\nequal. I assume that our readers have goals that are closer
    to taking the stage\r\nat Carnegie Hall than they are to perfectly folding a pair
    of underwear. With\r\nthat in mind, I'll be sharing my secrets about how I practice,
    in the hopes that\r\nthe techniques I've developed over the years will work for
    you, too.\r\n\r\nPlease decide at this point whether you have about 2-3 hours
    to spare within the\r\nnext few days to try out some exercises that go along with
    this article. If you\r\ndon't feel like you can do that, stop reading now, skip
    and come back to this\r\ntwo-part article when you have time for it. The ideas
    I am covering will only\r\nreally sink in if you put them into action.\r\n\r\nIf
    you've decided to be brave and read on, great! Now is the time to open up\r\nyour
    text editor or grab a sheet of paper and a pen.\r\n\r\n### The $64,000 Question\r\n\r\nThe
    question you need to answer before it ever makes sense to practice, work\r\nhard,
    or even think about anything seriously, is simply this: *What interesting \r\nproblems
    do you need to solve?*\r\n\r\nWhen properly considered, this question can serve
    as a compass that\r\npoints you in the right direction. The key is to pay attention
    to every last\r\ndetail that it demands, so that you can pick the right kind of
    goal. Here are\r\nsome guidelines for picking the right area to focus in:\r\n\r\n*
    First, it must be interesting; something that stands out from\r\nthe ordinary.
    As long as YOU find the topic engaging, it needn't\r\ninterest the whole world.
    But at the very least, it must be something that\r\nwon't get lost in the background
    noise of our day to day lives.\r\n\r\n* Second, it must be a problem. Without
    some form of conflict, without a\r\nstruggle between what is and what can be,
    it is difficult for creativity\r\nor productivity to occur naturally. Problems
    tend to capture the\r\nimagination in ways that 'exercises' or 'routines' never
    can.\r\n\r\n* Third, it must be a need of yours. Notice I use the word need and
    not want.\r\nWhile at the physiological level, needs are very basic (food, water,
    clothing,\r\nshelter, sex, etc), psychologically our needs are much more complex.
    A\r\nneed is the kind of thing that eats at you until you find a way to satisfy\r\nit.
    A need is something that when ignored, makes things worse than what they\r\nshould
    be.\r\n\r\n* Fourth, it must be related to you. There are many, many problems
    out there\r\nthat are interesting and need to be solved. Which challenges are
    you uniquely\r\nqualified to solve? Which challenges are you uniquely pained by
    if they're\r\nleft unsolved?\r\n\r\n* Finally, it must be solvable, or at least
    show promise of being solvable.\r\nThere are problems out there that would be
    great if we could solve\r\nthem, but nothing seems to change about them. Fortunately,
    many problems \r\ncan be solved with sufficient motivation. Don't waste your time
    on the \r\nimpossible, feel free to settle for something challenging but \r\nsurmountable.\r\n\r\nNow
    that I've explained it in detail, I'll repeat the question, and then I\r\nwant
    you to take some time to think about a serious answer to it...\r\n\r\n*What interesting
    problems do you need to solve?*\r\n\r\n### Making a commitment\r\n\r\nDerek Sivers
    claimed you should keep your intentions to yourself when planning\r\nyour goals.
    But Freakonomics thinks he's wrong, and so do I.\r\n\r\nEvery single project that
    I've been successful on, I've described in public\r\nbefore I even broke ground.
    The [original Ruby Mendicant\r\nproject](http://www.oreillynet.com/ruby/blog/2008/03/id_love_to_quit_my_job_sort_of.html)\r\nthat
    brought us [Prawn](http://github.com/sandal/prawn), and my current work at\r\n[Mendicant
    University](http://university.rubymendicant.com) are just two\r\nexamples that
    I can offer some anecdotal evidence for.\r\n\r\nNow have I succeeded at every
    project I have discussed publicly? Hell no! But to\r\nbe honest, I've been kept
    busy enough by my successes that I don't need to worry\r\ntoo much about my failures
    in life. I've also found that by sharing my ideas as\r\nearly as possible, I can
    get a sense if people are as excited about it as I am.\r\nWhile a lukewarm response
    isn't necessarily an indicator of a bad project,\r\nthings that create buzz often
    indicate that you've struck a real nerve. When you\r\nstumble across problems
    like that, you really ought to invest in solving them.\r\n\r\nSo now that you've
    written down your goal, the next step is to share it with\r\nsomeone. I'd recommend
    posting it in the comments section at the end of this\r\narticle, but I'd pretty
    much accept any action you can do to share your idea\r\nwith someone else in the
    world. Tell your kid, tell your wife or husband. It\r\ndoesn't really matter who
    you tell, as long as you put it out there.\r\n\r\nNow is the time where people
    most often second guess themselves, thinking their\r\nidea is not ready yet, or
    that it won't be appreciated by others. If that's\r\nreally how you feel, fine,
    go back to step one and generate a problem that you\r\n*can* share that still
    meets all those guidelines.\r\n\r\nThe next step is to shift from having an idea
    to having something you can\r\nactually act on.\r\n\r\n### Making progress\r\n\r\nAt
    the beginning of the article, I asked you to set aside two to three hours for\r\nworking
    through these exercises. Maybe you've spent a little bit of time\r\nbrainstorming
    already, but you probably have plenty of time left on the clock,\r\nright? If
    so, now is the time to roll up your sleeves and get your hands dirty.\r\n\r\nYou've
    got a goal, and you've told someone about it. Now your next task is to\r\nanswer
    this question: What is a concrete, measurable action you can take that\r\nwill
    take you an hour or less, but still manage to get you closer to your goal?\r\n\r\nWrite
    down your answer to that question and then pass it along to whoever you\r\nshared
    your goal with. Then, sit down and try to do what you said you\r\nwould do. Keep
    working on it until either you've solved the small subproblem\r\nyou've just described,
    or until the full hour runs out.\r\n\r\nOnce you've put the work in, make sure
    to let your selected observers know.\r\nThat'll make you want to build something
    that you actually believe meets your\r\ngoals, rather than lowering your standards
    to match what you've\r\nactually produced. If you fell short of your objectives,
    don't be disappointed,\r\njust explain what obstacles got in your way. Folks are
    more\r\nunderstanding than we give them credit for, and your observer is not likely
    to\r\nbe an exception.\r\n\r\n### Reflecting on your progress\r\n\r\nYou now have
    made a few steps in the direction of solving an important problem\r\nthat you
    find personally interesting. Great work!\r\n\r\nNow, there is only one question
    left to ask: What scares you about this project?\r\n\r\nIf the answer to that
    is 'nothing', pause a moment and double check whether\r\nyou're really being honest
    with yourself. I personally find fear or extreme\r\nuncertainty to be a common
    phenomena when working on hard problems, and if I\r\nfeel 100% confident with
    no real doubts or worries, I begin to think that maybe\r\nthe problem I'm working
    on isn't worth my time. That said, a lack of fear also\r\nsometimes comes from
    being in the state of flow, which is a really pleasant\r\nexperience. Try to distinguish
    between the two, and only settle for 'nothing' if\r\nyou really believe it to
    be true.\r\n\r\nAssuming you do dig up some fears or doubts, write them down,
    in as much detail\r\nas you'd like. Once you've done that, try to separate thing
    things that you can\r\nfigure out answers to from the things that you can't. Take
    a quick glance at the\r\nlist of fears that you won't be able to reason your way
    out of, and decide if\r\nthey're worth giving up your project over. If they are
    worth surrendering over,\r\nquit and start all the way at the beginning, forming
    a new goal for solving a\r\nnew problem that you really care about.\r\n\r\nBut
    if you have the courage to press on, throw out the list of\r\nunresolvable fears
    and focus on the ones that you can do something about. Study\r\nthe topics they
    cover, talk to friends for ideas on how to get through them, and\r\nthen once
    you feel better, throw that list out too.\r\n\r\n### Rinse and Repeat\r\n\r\nToday
    I asked you for a couple hours of your time, to get you to practice your\r\ncraft
    by actually working towards solving something that is important to you.\r\nOdds
    are, a couple hours wasn't enough time to fully solve one of your big\r\nproblems.
    But it was a start.\r\n\r\nThe good news is that the process recurses from here.
    You don't need to work in\r\none hour intervals, but ask yourself what you can
    accomplish in an afternoon, in\r\na work day, or in a week. Then, come up with
    a plan, tell people about it,\r\nexecute, reflect, and repeat.\r\n\r\nThis is
    what I do, and if it works for me, it may well work for you. Please try\r\nit
    out and share your thoughts once you've worked through the suggested \r\nexercises
    in this article.\r\n\r\n### Reflections\r\n\r\nI started out by saying that practice
    is important, and you may have then\r\nexpected to hear me talk about how important
    it is to read books and blogs, or\r\nto work on code katas, or something else
    that involves a disconnected form of\r\nlearning that is separate from real world
    applications. But frankly, I find that\r\nsort of approach to be inefficient,
    when real goals do so much of a better job\r\nof guiding you towards what is really
    important to focus on.\r\n\r\nHopefully by working through the exercises I've
    proposed here, you'll gain a\r\nbetter understanding of why this approach to learning
    can be so power. In the\r\nnext issue, I will share some examples from my own
    projects in which I've used\r\nthis process to make good progress in a short period
    of time. Through that,\r\nyou'll hopefully be able to see how almost all of my
    time spent studying is done\r\nthrough goal based learning rather than some sort
    of separate, isolated practice\r\nsessions.\r\n\r\nMore than any other article
    I've published so far, I hope you will participate\r\nin this one. Even if it
    seems a bit cheesy, I think that actually working\r\nthrough these exercises will
    prove to be a worthwhile experience for you.\r\n  \r\n> **NOTE:** This article
    has also been published on the Ruby Best Practices blog.\r\nThere [may be additional
    commentary](http://blog.rubybestpractices.com/posts/gregory/053-issue-21-how-to-practice.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: how-to-practice-2
  :title: How to practice, Part 2
  :summary: 'See an example of how the practice methods outlined in Issue 1.21 can
    be applied to a real project. '
  :published: 2011-01-28 00:00:00.000000000 Z
  :issue_number: '1.22'
  :volume: 1
  :body: "> **NOTE:** I generally remove temporal references in Practicing Ruby \r\narticles
    to keep them disconnected from a particular point in time, but\r\nin this case
    I intentionally left them in because the post is written\r\nin a sort of \"diary\"
    style. It was originally posted in January 2011.\r\n\r\nIn the [previous issue](http://practicingruby.com/articles/50),
    I provided a\r\nseries of questions and instructions that outlined the way I practice.
    While\r\nsome may have been expecting code katas or other indirect exercises,
    my style is\r\nmore geared towards learning on the job. You start by figuring
    out what's\r\nimportant to you, figure out a baby-step that you can make, and
    then execute.\r\nOnce you've brought yourself one step closer to your goal, you
    reflect a bit on\r\nhow things are going, in particular, what parts of the project
    still scare you.\r\n\r\nI use this technique often, in particular, when I want
    to get started on a new\r\nproject or explore a new area that I'm not that familiar
    with. As luck would\r\nhave it, I actually have a new project I need to start,
    and so today I'll give\r\nyou the chance to metaphorically look over my shoulder
    as I work through this\r\nexercise myself. If you haven't read [Issue\r\n#21](http://practicingruby.com/articles/50),
    now is a good time to do that, so\r\nthat the rest of this article makes sense.\r\n\r\n###
    Step 1: Find out what's important \r\n\r\nWhat interesting problems do you need
    to solve?\r\n\r\nLately, this question has been one that has caused me great anxiety.The
    success\r\nof Mendicant University and even Practicing Ruby to a certain extent
    has caused\r\nan explosion of ideas that all feel worthwhile and important to
    me. But they're\r\nfairly easy to separate into wants and needs, and thankfully,
    much of what I've\r\ncome up with falls in the former category.\r\n\r\nWhen I
    think about it, there is something that I feel I need to do sooner rather\r\nthan
    later. While our courses are booked up until May, we will need to start\r\nadmissions
    for our second trimester soon. Towards the end of last year, we\r\ndecided we
    wanted to do something more fun and lighthearted than an\r\nentrance exam, but
    we didn't take much action since then. With the clock\r\nticking down, making
    headway on this project would surely help give me some\r\npeace of mind.\r\n\r\nWhat
    I'd like to build is a programming quiz site that is inspired by the\r\n[Internet
    Problem Solving Contest](http://ipsc.ksp.sk) and [Project\r\nEuler](http://projecteuler.net),
    but with an MU-themed twist. I'll have\r\nMendicant's co-founder [Jordan Byron](http://twitter.com/Jordan_Byron)
    to help\r\nme with the frontend, but since he's busy with 100 other tasks for\r\nMU,
    I'm the one who needs to build out the backend for this new app. I'll use my\r\nneed
    to write this article as motivation to help me break ground on this new\r\nproject
    today.\r\n\r\n### Step 2: Make a commitment\r\n\r\nI made the broad commitment
    to our students that we'd have a nice replacement\r\nfor MU's currently dull admissions
    process before the next trimester began. But\r\nbroad commitments don't particularly
    inspire action, so I needed to make a\r\nspecific commitment as well.\r\n\r\nWith
    that in mind, I told Jordan I'd have something for him to look\r\nat today, even
    if it was just a small start. Since he'll be arriving at my\r\nhome within an
    hour of me finishing this article, I am already feeling the\r\npressure of having
    something to show for myself, which is a good thing.\r\n\r\n### Step 3: Identify
    a baby step\r\n\r\nThe next step in this process is to come up with a small step
    to get you just a\r\nlittle bit closer to your goal. I knew by the time I finished
    Issue\r\n#21 that I'd be working on this project, so I've been subconsciously
    chewing on\r\nmy baby-step for a couple days now. This to me is totally fine,
    it gives my\r\nbrain a chance to think things through and makes actually sitting
    down and\r\ncoding something easier. Of course, the key thing is that my delivery
    time was\r\nstill boxed in. If you leave things open ended, you may end up\r\ntalking
    yourself out of building anything at all.\r\n\r\nWhen coming up with a tiny step,
    I try to focus on something that is core to the\r\nunderlying project, to maximize
    the amount I learn from the mini spike. In the\r\ncase of our quiz application
    (which we're calling PuzzleNode), validating user\r\nsubmissions is one of the
    most important pieces of functionality.\r\n\r\nWhat I'll do today is do a rough
    proof of concept of the submission validation\r\nsystem, which compares the expected
    output to the actual file\r\nuploaded by a user. I like to subdivide my tasks
    even when working\r\nonly for an hour, so I'm going to attack this in three phases:\r\n\r\n1.
    A simple function that compares two files using a SHA1 hash and returns true\r\nor
    false depending on whether they match.\r\n\r\n1. A tiny sinatra application that
    does the same, but introduces file uploads\r\ninto the picture.\r\n\r\n1. A minimal
    Rails app that actually records whether a submission was valid or\r\ninvalid,
    and properly links puzzles with their expected output.\r\n\r\nI'm setting my time
    limit for an hour, so I'm not sure how far I'll actually\r\nget. No matter what
    happens, I'll try to jot down some notes to give you a feel\r\nfor my though process
    as I work through this exercise.\r\n\r\n### Step 4: Get one step closer\r\n\r\n[06:40]
    I've got my clock set now, and I'm ready to get started. Please excuse\r\nme while
    I go heads down for a bit. I'll pop up with some brief notes here each\r\ntime
    I reach a transition point, and then go into more detail in the reflections\r\nphase.\r\n\r\n[06:45]
    Basic [github project](https://github.com/sandal/pr-issue-22) set up for\r\nthis
    experiment.\r\n\r\n[06:48] Add three text files, a reference which is meant to
    act as the expected\r\nsolution, a good file which is just a copy of the reference,
    and a bad file with\r\nsome modifications to make it not match the reference.\r\n\r\n[06:51]
    Phase 1 complete!\r\n\r\n```ruby\r\n$ ruby check_solution.rb samples/reference.txt
    samples/good.txt \r\nGOOD\r\n\r\n$ ruby check_solution.rb samples/reference.txt
    samples/bad.txt\r\nBAD\r\n```\r\n\r\nSource code is dead simple, just a few lines.\r\n\r\n```ruby\r\nrequire
    \"digest/sha1\"\r\n\r\nexpected = Digest::SHA1.hexdigest(File.read(ARGV[0]))\r\nactual
    \  = Digest::SHA1.hexdigest(File.read(ARGV[1]))\r\n\r\nputs(expected == actual
    ? \"GOOD\" : \"BAD\")\r\n```\r\n\r\n[06:54] Next step is to remind myself how
    file uploads work in Sinatra, an\r\nindicator of how rusty my frontend webdev
    knowledge is...\r\n\r\n[06:57] Google for \"File uploads sinatra\" and find Peter
    Cooper talking about\r\n[this blog\r\npost](http://technotales.wordpress.com/2008/03/05/sinatra-the-simplest-thing-that-could-possibly-work/)\r\nvia
    Ruby Inside.\r\n\r\nOutdated, but worth a shot since it's just a one liner.\r\n\r\n[07:00]
    File uploads working via curl. Time to integrate the phase 1 code\r\ninto my sinata
    app.\r\n\r\n[07:06] Have something I think should work but found some unexpected\r\nbugs.
    Drat!\r\n\r\n[07:08] Oh, apparently I just don't know how to use curl, working
    now! (albiet\r\nwith a little echo hack to add a newline)\r\n\r\n```ruby\r\n$
    curl -F \"data=@samples/bad.txt\" 127.0.0.1:4567/reference.txt; echo\r\nBAD\r\n$
    curl -F \"data=@samples/good.txt\" 127.0.0.1:4567/reference.txt; echo\r\nGOOD\r\n```\r\n\r\nSource
    is still quite simple, so I can inline it here.\r\n\r\n```ruby\r\nrequire \"rubygems\"\r\nrequire
    \"sinatra\"\r\nrequire \"digest/sha1\"\r\n\r\nACCEPTED_FILES = [\"reference.txt\"]\r\n\r\npost
    \"/:expected\" do\r\n  raise unless ACCEPTED_FILES.include?(params[:expected])\r\n\r\n
    \ expected = \r\n    Digest::SHA1.hexdigest(File.read(\"samples/#{params[:expected]}\"))\r\n\r\n
    \ actual   = Digest::SHA1.hexdigest(params[:data][:tempfile].read)\r\n\r\n  expected
    == actual ? \"GOOD\" : \"BAD\"\r\nend\r\n```\r\n\r\nOff we go to phase 3!\r\n\r\n[07:11]
    I need to think up a few AR models. Off to the whiteboard, back in a\r\nmoment.\r\n\r\n[07:15]
    I've decided to cheat a bit. I realized that for a very basic demo, I\r\ndon't
    actually need to store the uploaded files anywhere, but instead, I just\r\nneed
    each puzzle to store its SHA1 fingerprint. Then, when a new submission is\r\nmade,
    you just hash the file uploaded by the user and compare it to the\r\nassociated
    puzzle.\r\n\r\nThis data model omits a lot, and would need a lot of love to actually
    be used in\r\nour application, but it is sufficient for demonstrating just the
    validation\r\nstep.\r\n\r\n```\r\nPuzzle(name: text, fingerprint: text) \r\nSubmission(puzzle_id:
    integer, correct: boolean)\r\n```\r\n\r\nTime to go spit out a Rails skeleton,
    I suppose. The key thing this has saved me\r\nis a trip through paperclip's documentation,
    and a host of questions about\r\nwhether that's still the right tool for the job
    and whether it works with Rails\r\n3 smoothly. I roughly assume that the answer
    to each of those questions is yes,\r\nbut better to not have to answer them right
    now.\r\n\r\n[07:22] Only 18 minutes to go and rails is still installing, sloooooow.\r\n\r\n[07:24]
    Still installing! Should have used --no-rdoc --no-ri!\r\n\r\n[07:25] Finally finished
    installing, while waiting I stumbled upon [this post on\r\ndisabling documentation
    by\r\ndefault](http://stackoverflow.com/questions/1381725/how-to-make-no-ri-no-rdoc-default-for-gem-install).\r\nWill
    need to try that out later.\r\n\r\n[07:26] Doh, never going to undo my stupid
    muscle memory\r\n\r\n$ rails puzzlenode\r\nUsage:\r\n  rails new APP_PATH [options]\r\n\r\n[07:29]
    Hmm, rails comes with a .gitignore file now? That's handy. Though I'm\r\npretty
    sure I just accidentally checked in my config/database.yml. Not\r\na big deal,
    this is just a spike, right?\r\n\r\n[07:30] Wow, now is not the time to be punished
    by the fact that I aliased mvim\r\nto sl on my Gentoo box in an effort to stop
    typing mvim where it doesn't work.\r\nThat seemed like a good idea at the time,
    of course.\r\n\r\n[07:32] Toot toot! Time to switch consoles, this is taking forever.
    Dear reader,\r\nyou *have* googled sl by now, right? :)\r\n\r\n[07:39] Ran out
    of time, so just messed with the data models a bit in the\r\nconsole to imagine
    their interactions. Will need to save a proper implementation\r\nfor later.\r\n\r\n```ruby\r\n>>
    Puzzle.create(:name => \"Reference\", :fingerprint =>\r\n>> Digest::SHA1.hexdigest(File.read(\"#{RAILS_ROOT}/samples/reference.txt\")))\r\n\r\n=>
    #<Puzzle id: 1, name: \"Reference\", fingerprint:\r\n\"a59eb2c51e07e2b7369baef8a0c3cb3b5d7ed3d9\",
    created_at: \"2011-01-28\r\n12:37:41\", updated_at: \"2011-01-28 12:37:41\">\r\n\r\n>>
    Submission.create(:puzzle_id => 1, :correct => false)\r\n\r\n=> #<Submission id:
    1, puzzle_id: 1, correct: false, \r\n     created_at: \"2011-01-28 12:38:41\",
    updated_at: \"2011-01-28 12:38:41\">\r\n>> Submission.create(:puzzle_id => 1,
    :correct => false)\r\n\r\n=> #<Submission id: 2, puzzle_id: 1, correct: false,
    \r\n   created_at: \"2011-01-28 12:38:42\", updated_at: \"2011-01-28 12:38:42\">\r\n\r\n>>
    Submission.create(:puzzle_id => 1, :correct => true)\r\n\r\n=> #<Submission id:
    3, puzzle_id: 1, correct: true, \r\n   created_at: \"2011-01-28 12:38:45\", updated_at:
    \"2011-01-28 12:38:45\">\r\n\r\n>> Puzzle.find(1).submissions.where(:correct =>
    true).count\r\n=> 1\r\n>> Puzzle.find(1).submissions.where(:correct => false).count\r\n=>
    2\r\n```\r\n\r\nHah, at least my associations seem to be working correctly. I
    can has rails!\r\n\r\n### Step 5: Reflect on your progress\r\n\r\nThis exercise
    went more or less as I expected it to, with a couple surprises\r\nhere and there.
    One thing that didn't dawn on me until I reached stage 3 is that\r\nI don't necessarily
    need to worry about file attachments in this application.\r\nWhile certain features
    such as having the ability to review user submissions or\r\ndisplay the reference
    output would require it, a simple alpha product could be\r\nshipped without those
    features and still be quite usable.\r\n\r\nThe exercise hopefully also reflects
    a bit of realism, as I didn't rehearse it\r\nahead of time and ran into some stupid
    things that slowed me down, which is what\r\nmight happen to anyone. That's really
    okay, because in the process, I learned\r\nsome things worth looking into later
    on.\r\n\r\nNow that I'm an hour into this project, my instructions call for me
    to reflect\r\non what scares me about it. I actually have a lot of general fears,
    but in order\r\nto explain them I'd need to give a lot of context about the project
    and those\r\nideas are still fuzzy even in my own mind. That having been said,
    there is a \r\nconcern that I can share which this small spike keeps reminding
    me of.\r\n\r\n### What about this project scares me?\r\n\r\nI'm not sure that
    I like fingerprinting as a method for\r\ndetermining the validity of a solution.
    It scares me to think that if a problem\r\ncalled for you to generate some XML,
    alterations to whitespace could\r\nresult in an otherwise perfectly valid submission
    getting rejected.\r\n\r\nThe way that IPSC and Project Euler solve this problem
    is by restricting\r\nthe submission format. In the case of IPSC this consists
    of bits of numbers or\r\ntext separated by newlines, and for Project Euler the
    solutions are always to\r\ncompute a simple number. I could adopt this strategy,
    but it makes me\r\nworried that it'll limit the kinds of problems I can run at
    PuzzleNode.\r\n\r\nI want to avoid making the problems at PuzzleNode too academic
    in\r\nnature, with a focus more on practical problem solving and creative thinking.\r\nBoth
    Project Euler and IPSC do a good job of this within a subset of their\r\nproblems,
    but most of them are algorithmic. I wonder if that's due to the \r\ninput constraints,
    and if it is, that would be bad for MU.\r\n\r\nOne possibility is that rather
    than doing a bitwise matching via a fingerprint,\r\nI could force users to provide
    JSON data which I could then process and compare\r\nbased on the object structure.
    This would allow for much greater flexibility in\r\nthe way I validate submissions,
    and eliminate the failure-by-formatting issue I\r\npointed out before, but it'd
    both increase the overhead of submitting a solution\r\nand make the backend functionality
    a good deal more complex.\r\n\r\nI think that what I need to do is draft up a
    few puzzles and see how much the\r\ncurrent fingerprinting validation restrictions
    get in the way. I may be worrying\r\nabout nothing, but the only way to tell is
    to produce some content and see where\r\nthat brings me.\r\n\r\n### Step 6: Rinse
    and Repeat\r\n\r\nMy next step is to actually flesh out the Rails backend, since
    I didn't get that\r\nfar with it. I'm glad to have found that I can defer file
    uploads until a bit\r\nlater, this is something I don't think I would have realized
    if I started\r\ndirectly by jumping into the Rails boilerplate.\r\n\r\nOnce I
    have a minimal system functioning, my next step will be to come up with\r\na few
    more problems to test it against. I already have one idea in mind;\r\ngenerating
    more should be easy.\r\n\r\nWith my next step planned, I feel confident that this
    project will keep \r\nmoving forward.\r\n\r\n### Closing Thoughts\r\n\r\nThis
    is a real outline of how I practice. At first, when I wrote up the set of\r\ninstructions,
    I thought formalizing it would make it feel artificial to me. But\r\nhonestly,
    once I got rolling on the spike, things happened pretty much the way\r\nthey always
    would, and the comments I left were just the thoughts that came up\r\nin my mind
    as I went along. In that sense, it didn't feel like practice.\r\n\r\nYou'll notice
    that I start with what I know and work outwards from there. I\r\nrarely try to
    think too hard about what I need to know ahead of time, because I\r\nfind it causes
    me to study the wrong things at the wrong time. A more formal\r\napproach might
    have lead me to study paperclip up front, because this process\r\ninvolves file
    uploads. But the 20-30 minutes that might have costed me we found\r\nthrough experimentation
    is something that I can put off for several weeks\r\nwithout it affecting my progress.\r\n\r\nI
    tend not to plug into the firehose of information coming from books, blogs,\r\nand
    reddit/HN for the same reason. Soaking up that material is begging to find a\r\nsolution
    in search of a problem, rather than the other way around. It's always\r\neasy
    to ask for a recommendation at the time you actually need something, and\r\nGoogle
    is pretty good at digging up well read blog posts or articles about\r\nwhatever
    tool you might need, and so I put off studying until it is necessary.\r\n\r\nI
    don't do a whole lot of code katas, or little practice exercises that I can't\r\nactually
    use for something. I will certainly do those things for entertainment,\r\nbut
    I don't schedule 'practice time' in my day to day life and honestly, I never\r\nhave.
    There is no shortage of necessary learning that takes place when chasing\r\npractical
    goals, and the reward is much greater than just having an abstract\r\nfeeling
    of learning a bit more, you end up with something you can use.\r\n\r\nThe more
    I can make my life my practice, the less I need to be disciplined about\r\nmaking
    time for formal academic exercises. I admit that there are\r\na lot of things
    about my lifestyle and circumstances that make me especially\r\nblessed, but I
    wasn't always in a fortunate position and would give \r\nsimilar advice even when
    I was struggling to make ends meet.\r\n\r\nSo in closing, it may be true that
    the way to Carnegie Hall is via the\r\n\"Practice! Practice! Practice!\" path,
    but in my mind, that means less time\r\nplaying with yourself in the comfort of
    your own home, and more time on small\r\nstages until they lead you to a slightly
    bigger stage which you can then occupy\r\nuntil it too, becomes too small.\r\n\r\nThis
    is how I practice. I hope hearing about it has been useful to you.\r\n\r\n<b>UPDATE
    2011.09.09</b>: <i> The [PuzzleNode website](http://puzzlenode.com)\r\nwas successfully
    launched on time, and has been used to conduct three entrance\r\nexams for Mendicant
    University already. The puzzles there are language agnostic,\r\nand may be fun
    to try out even if you aren't planning to apply to MU. But I'd be\r\njust as happy
    to hear that you're too busy working on real projects that you\r\ncare a lot about
    instead.</i>\r\n \r\n> **NOTE:** This article has also been published on the Ruby
    Best Practices blog. \r\nThere [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/054-issue-22-how-to-practice.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: solid-design-principles
  :title: SOLID Design Principles
  :summary: Work through code samples inspired by Sandi Metz's "SOLID Object-oriented
    Design" presentation.
  :published: 2011-02-05 00:00:00.000000000 Z
  :issue_number: '1.23'
  :volume: 1
  :body: "SOLID is a collection of five object oriented design principles that go
    nicely\r\ntogether. Here's a super brief summary pulled from [the wikipedia\r\npage](http://en.wikipedia.org/wiki/SOLID)
    on the topic:\r\n\r\n* Single responsibility principle: an object should have
    only a single\r\nresponsibility.\r\n\r\n* Open/closed principle: an object should
    be open for extension, but closed for\r\nmodification.\r\n\r\n* Liskov substitution
    principle: objects in a program should be replaceable with\r\ninstances of their
    subtypes without altering the correctness of that program.\r\n\r\n* Interface
    segregation principle: many client specific interfaces are better\r\nthan one
    general purpose interface.\r\n\r\n* Dependency inversion principle: depend upon
    abstractions, do not depend upon\r\nconcretions\r\n\r\nThe term SOLID was coined
    by Uncle Bob Martin to group together these important\r\nconcepts. I had heard
    of each of the design principles SOLID covers over the\r\nyears, but didn't really
    think much of them until I attended a great talk by\r\nSandi Metz at GoRuCo 2009.
    Fortunately, Confreaks recorded [Sandi's\r\ntalk](http://confreaks.net/videos/240-goruco2009-solid-object-oriented-design)\r\nso
    I won't need to try to summarize it here.\r\n\r\nI'd strongly recommend watching
    that video before moving on, because it will go\r\nthrough SOLID in a lot more
    detail than what I plan to do in this article. You\r\nmight also watch [another
    video on the same topic by Jim\r\nWeirich](http://confreaks.net/videos/185-rubyconf2009-solid-ruby),
    which like\r\npretty much any other talk Jim has done, is likely to blow your
    mind.\r\n\r\nRather than giving a tutorial on these principles, I'm going to trust
    you to\r\neither read up on them or watch the videos I've linked to. This way,
    we can\r\nfocus on what I think is a much more interesting problem: How to apply
    these\r\nideas to real code.\r\n\r\n### Single responsibility principle\r\n\r\nThe
    idea that an object should have only a single responsibility shouldn't come\r\nas
    a surprise. This concept is one of the selling points for object oriented\r\nlanguages
    that sets them apart from the more procedural systems that preceded\r\nthem. The
    hard part about putting this idea into practice is figuring out just\r\nhow wide
    to cast the 'single responsibility' net.\r\n\r\nIn my experience, most objects
    are born with just one goal in mind, and so\r\nadhere to this principle at least
    superficially in the early stages of\r\ngreenfield projects. It's later when systems
    get more complex that our objects\r\nlose their identity. To demonstrate this
    phenomena, we can look at the life\r\ncycle of the Document object from my PDF
    generation library Prawn.\r\n\r\nBack in early 2008, when the project was just
    beginning, my idea was that the\r\njob of the Document class would be to wrap
    the low level concept of a Document\r\nat the PDF layer, with a few extra convenience
    functions at the high level. For\r\na sketch of what that looked like at the time,
    we can take a look at the\r\nobject's public methods.\r\n\r\n```\r\nDirectly implemented
    on Prawn::Document\r\n  start_new_page, page_count, page_size, page_layout, render,
    render_file\r\n\r\nMixed in via Prawn::Document::Graphics\r\n  line_width=, line,
    line_to, curve_to, curve, circle_at, ellipse_at,\r\n  polygon, rectangle, stroke,
    fill, fill_color, stroke_color\r\n\r\nMixed in via Prawn::Document::PageGeometry\r\n
    \ page_dimensions\r\n```\r\n\r\nThis is so early in Prawn's history that it didn't
    even have text support yet.\r\nWhile the API wasn't perfectly well factored at
    this point in time, the fact\r\nthat almost all the above methods directly produced
    PDF instructions or\r\nmanipulated low level structures made me feel that it was
    a reasonably cohesive\r\nset of features.\r\n\r\nFast forward by a year, and we
    end up with feature explosion on `Document`.\r\nHere's what shipped in Prawn 0.4.1:\r\n\r\n```\r\nDirectly
    implemented on Prawn::Document\r\n  start_new_page, page_count, cursor, render,
    render_file, bounds,\r\n  bounds=, move_up, move_down, pad_top, pad_bottom, pad,
    mask,\r\n  compression_enabled?, y, margin_box, margins, page_size,\r\n  page_layout,
    font_size\r\n\r\nIncluded via Prawn::Document::Text\r\n  text, text_options, height_of
    (via Prawn::Document::Text::Wrapping),\r\n  naive_wrap (via Prawn::Document::Text::Wrapping)\r\n\r\nIncluded
    via Prawn::Document::PageGeometry\r\n  page_dimensions\r\n\r\nIncluded via Prawn::Document::Internals\r\n
    \ ref, add_content, proc_set, page_resources, page_fonts, \r\n  page_xobjects,
    names\r\n\r\nIncluded via Prawn::Document::Annotations\r\n  annotate, text_annotation,
    link_annotation\r\n\r\nIncluded via Prawn::Document::Destinations\r\n  dests,
    add_dest, dest_xyz, dest_fit,  dest_fit_horizontally, \r\n  dest_fit_vertically,
    dest_fit_rect, dest_fit_bounds,\r\n  dest_fit_bounds_horizontally, dest_fit_bounds_vertically\r\n\r\nIncluded
    via Prawn::Graphics\r\n  move_to, line_to, curve_to, rectangle, line_width=, line_width,\r\n
    \ line, horizontal_line, horizontal_rule, vertical_line, curve,\r\n  circle_at,
    ellipse_at, polygon, stroke, stroke_bounds, fill,\r\n  fill_and_stroke, fill_color
    (via Prawn::Document::Color), \r\n  stroke_color (via Prawn::Document::Color)\r\n\r\nIncluded
    via Prawn::Images\r\n  image\r\n```\r\n\r\nThe above list of methods is almost
    embarrassingly scattershot, but it was due\r\nto an oversight. The mistake I made
    was thinking that splitting different\r\naspects of functionality into modules
    was a valid way of respecting the single\r\nresponsibility principle. But this
    is deeply flawed thinking, because the end\r\nresult of pulling in roughly 50
    methods into a single object by mixing in 8\r\nmodules results in a single object,
    `Prawn::Document` having 60+ public methods\r\nall sharing the same state and
    namespace. Any illusion of a physical separation\r\nof concerns is all smoke and
    mirrors here.\r\n\r\nOnce an object gets this fat, thinking about the cohesiveness
    of the interface\r\nis the most minor detail to be worried about. I've focused
    on the 60 public\r\nmethods here, but if we count private methods, they would
    easily exceed 100.\r\nSometimes folks think that private methods in mixins don't
    actually get mixed\r\ninto the base object, but that's an incorrect assumption,
    making this problem\r\nmuch, much worse.\r\n\r\nHaving close to two hundred methods
    living in one space causes you to run into\r\nreally basic, fundamental problems
    such as namespace clashes on method names and\r\nvariables. It also makes data
    corruption downright easy, because it's hard to\r\nkeep track of how a couple
    hundred methods manipulate a common dataset. Once you\r\nreach this point, you're
    back in procedural coding land where all manners of bad\r\nthings can happen.\r\n\r\nNow
    that I've sufficiently kicked my own ass, I can tell you the solution to\r\nthis
    problem is simple, if not easy to refactor towards once you've already made\r\nthe
    mess: you just introduce more objects. To do so, we need to identify the\r\ndifferent
    concerns and group them together, putting abstraction barriers between\r\ntheir
    implementations and the behaviors they provide.\r\n\r\nAn easy realization to
    make is that over time, Prawn's `Document` became two\r\ndifferent things at the
    conceptual level. When we see methods like\r\n`page_xobjects`, `ref`, and `proc_set`,
    we know that there are some low level\r\ntools in use here. But what about methods
    like move_up, move_down, text, image,\r\nand others like them? These are clearly
    meant for something that resembles a\r\ndomain specific language, and Prawn does
    look gorgeous at the high level, just\r\nsee the simple example below to see what
    I mean.\r\n\r\n```ruby\r\nPrawn::Document.generate('hello.pdf') do \r\n  text
    \"Hello Prawn!\"\r\nend \r\n```\r\n\r\nWith 20/20 hindset, the solution to this
    problem is obvious: Produce a whole\r\nlayer of low level tooling that closely
    follows the PDF spec, creating objects\r\nfor managing things like a PDF-level
    page, the rendering of raw PDF strings,\r\netc. Make as many objects as necessary
    to do that, and then maybe provide a\r\nfacade that makes interacting with them
    a bit easier.\r\n\r\nThen, for the higher level features, do the same thing. Have
    an object who's job\r\nis to provide nice looking methods that rely on Prawn's
    lower level\r\nobjects to do the dirty work. Dedicate whole objects or even clusters
    of objects\r\nto text, images, graphics, and any other cluster of functionality
    that\r\npreviously was mixed into Document directly. The objects might require
    a bit\r\nmore wiring, but the facade can hide that by doing things like the pseudo-code\r\nbelow.\r\n\r\n```ruby\r\ndef
    text(contents, options={})\r\n  text_element = Prawn::TextElement.new(contents,
    options)\r\n  text_element.render_on(current_page)\r\nend\r\n```\r\n\r\nNaming
    the benefits of this over the previous design would take a long time, but\r\nwe've
    at least cut out those pesky namespace and data corruption concerns\r\nwhile providing
    a cohesive API.\r\n\r\nWhile I don't think that the scale of our design problem
    in Prawn is comparable\r\nto what most Ruby hackers are likely to experience in
    their day to day work, it\r\ndoes show just how bad things can get when you start
    dealing with very complex\r\nsystems. Prawn has improved a lot since its 0.4.1
    release, but undoing the\r\ndamage that was done by neglecting this for so long
    has been a slow and painful\r\nprocess for us.\r\n\r\nThe real lesson here is
    that you can't respect SRP without real abstraction\r\nbarriers. SRP is about
    more than just creating a cohesive API, you actually need\r\nto create a physical
    separation of concerns at the implementation level of your\r\nsystem.\r\n\r\nSince
    it's very likely that you're experiencing this sort of issue on a smaller\r\nscale
    in the projects you're working on, keeping the story about what happened\r\nto
    me in Prawn in mind may help you learn from my mistakes instead of your own.\r\n\r\n###
    Open/closed principle\r\n\r\nThe open/closed principle tells us that an object
    should be open for extension,\r\nbut closed for modification. This can mean a
    lot of different things, but the\r\nbasic idea is that when you introduce a new
    behavior to an existing system,\r\nrather than modifying old objects you should
    create new objects which inherit\r\nfrom or delegate to the target object you
    wish to extend. The theoretical payoff\r\nis that taking this approach improves
    the stability of your application by\r\npreventing existing objects from changing
    frequently, which also makes\r\ndependency chains a bit less fragile because there
    are less moving parts to\r\nworry about.\r\n\r\nPersonally, I feel that treating
    this principle as an absolute law would lead to\r\nthe creation of a lot of unnecessary
    wrapper objects that could make your\r\napplication harder to understand and maintain,
    so much that it might outweigh\r\nthe stability benefits you'd gain. But that
    doesn't mean these ideas don't have\r\ntheir value, in fact, they provide an excellent
    alternative to extensive\r\nmonkeypatching of third party code.\r\n\r\nTo illustrate
    this, I'd like to talk about \r\n[i18n_alchemy](https://github.com/carlosantoniodasilva/i18n_alchemy),
    a project\r\nby Carlos Antonio da Silva that was built as a student project for
    his Mendicant\r\nUniversity core course. The goal of this project was to make
    it easy to add\r\nlocalizations for numeric, time, and date values in ActiveRecord.\r\n\r\nEarly
    on in the course, Carlos came to me with an implementation that\r\nmore-or-less
    followed the standard operating procedure for developing Rails\r\nplugins. While
    Carlos shouldn't be faulted for following community trends here,\r\nthe weapon
    of choice was a shotgun blast into an `ActiveRecord::Base` object's\r\nnamespace,
    via a mixin which could be used on a per-model level. By including\r\nthis module,
    you would end up with behavior that looked a bit like this:\r\n\r\n```ruby\r\nsome_model
    = SomeModel.where(something)\r\nsome_model.a_number     #=> <a localized value>\r\nsome_model.a_number_raw
    #=> <the original numeric value>\r\n```\r\n\r\nNow, there are pros and cons to
    this approach, but I felt pretty sure that we\r\ncould do better, and through
    conversations with Carlos, we settled on a much\r\nbetter design that didn't make
    such far reaching changes to the model objects.\r\nBefore I explain how it works,
    I'd like to show an example of how i18n_alchemy\r\nworks now:\r\n\r\n```ruby  \r\nsome_model
    = SomeModel.where(something)\r\nsome_model.a_number     #=> <the original numeric
    value>\r\n\r\nlocalized_model = some_model.localized\r\nlocalized_model.a_number
    #=> <a localized value>\r\n```\r\n\r\nIn this new implementation, you do have
    to explicitly ask for a localized\r\nobject, but that small change gains us a
    lot. The module that gives us\r\n`SomeModel#localized` only introduces that one
    method, rather than a hook that\r\ngets run for every `ActiveRecord::Base` method.
    That means that\r\nordinary calls to models extended by i18n_alchemy still work
    as they always did.\r\n\r\nOur localized model act differently, but it's actually
    not an instance of\r\nSomeModel at all. Instead, it is a simple proxy object that
    defines special\r\naccessors for the methods that i18n_localized, delegating everything
    else to the\r\ntarget model instance.\r\n\r\nThis makes it possible for the consumer
    to choose when it'd be best to work with\r\nthe localized object, and when it'd
    be best to work with the model directly.\r\nUnlike the first implementation which
    breaks the ordinary expected\r\nbehavior of an ActiveRecord model, this approach
    creates a new entity which can\r\nhave new behaviors while reusing old functionality.\r\n\r\nWe
    were both pretty proud of the results here, because it gives some of the\r\nconvenient
    feel of mixing in some new functionality into an existing Ruby object\r\nwithout
    the many downsides. This of course is only a single example of how you\r\ncan
    use OCP in your own code, but I think it's a particularly good one.\r\n\r\n###
    Liskov substitution principle\r\n\r\nThe idea behind Liskov substitution is that
    functions that are designed operate\r\non a given type of object should work without
    modification when they operate on\r\nobjects that belong to a subtype of the original
    type. In many object oriented\r\nlanguages, the type of an object is closely tied
    to its class, and so in those\r\nlanguages, this principle mostly describes a
    rule about a relationship between a\r\nsubclass and a superclass. In Ruby, this
    concept is a bit more fluid, and\r\nprobably requires a bit more explanation up
    front.\r\n\r\nWhen we talk about the type of an object in Ruby, we're concerned
    with\r\nwhat messages that object responds to rather than what class that object
    is an\r\ninstance of. This seems like a subtle difference, but it has a profound\r\nimpact
    on how we think about thing. In Ruby, type checking can range from very\r\nstrict
    to none at all, as shown by the examples below.\r\n\r\n```ruby\r\n  ## Different
    ways of type checking, from most to least coarse ##\r\n\r\n  # verify the class
    of an object matches a specific class\r\n  object.class == Array\r\n\r\n  # verify
    object's class descends from a specific class\r\n  object.kind_of?(Array)   \r\n\r\n
    \ # verify a specific module is mixed into this object\r\n  object.kind_of?(Enumerable)\r\n
    \ \r\n  # verify object claims to understand the specified message\r\n  object.respond_to?(:sort)
    \  \r\n\r\n  # don't verify, trust object to either behave or raise an error\r\n
    \ object.sort                 \r\n```\r\n\r\nRegardless of the level of granularity
    of the definition, objects that are meant\r\nto be treated as subtypes of a base
    type should not break the contracts of the\r\nbase type. This is a very hard standard
    to live up to when dealing with ordinary\r\nclass inheritance or module mixins,
    since you basically need to know the\r\nbehavior specifications for everything
    in the ancestry chain, and so the rule of\r\nthumb is basically not to inherit
    from anything or mix in a module unless you're\r\nfairly certain that the behavior
    you're implementing will not interfere with the\r\ninternal operations of your
    ancestors.\r\n\r\nTo demonstrate a bit of a weird LSP issue, let's think about
    what happens when\r\nyou subclass an `ActiveRecord::Base` object. Technically
    speaking, if we give\r\nourselves a pass for breaking signature of methods provided
    by Object, we'd\r\nstill need to keep track of all the behaviors `ActiveRecord::Base`
    provides, and\r\ntake care not to violate them. Here's a brief list of method
    names, but keep in\r\nmind we'd also need to match signatures and return values.\r\n\r\n```ruby\r\n>>
    ActiveRecord::Base.instance_methods(false).sort\r\n=> [\"==\", \"[]\", \"[]=\",
    \"attribute_for_inspect\", \"attribute_names\",\r\n\"attribute_present?\", \"attribute_types_cached_by_default\",
    \"attributes\",\r\n\"attributes=\", \"attributes_before_type_cast\", \"becomes\",
    \"cache_key\",\r\n\"clone\", \"colorize_logging\", \"column_for_attribute\", \"configurations\",\r\n\"connection\",
    \"connection_handler\", \"decrement\", \"decrement!\",\r\n\"default_scoping\",
    \"default_timezone\", \"delete\", \"destroy\",\r\n\"destroy_without_callbacks\",
    \"destroy_without_transactions\",\r\n\"destroyed?\", \"eql?\", \"freeze\", \"frozen?\",
    \"has_attribute?\", \"hash\",\r\n\"id\", \"id=\", \"id_before_type_cast\", \"include_root_in_json\",
    \"increment\",\r\n\"increment!\", \"inspect\", \"lock_optimistically\", \"logger\",\r\n\"nested_attributes_options\",
    \"new_record?\", \"partial_updates\",\r\n\"partial_updates?\", \"pluralize_table_names\",
    \"primary_key_prefix_type\",\r\n\"quoted_id\", \"readonly!\", \"readonly?\", \"record_timestamps\",
    \"reload\",\r\n\"reload_without_autosave_associations\", \"reload_without_dirty\",
    \"save\",\r\n\"save!\", \"save_without_dirty\", \"save_without_dirty!\",\r\n\"save_without_transactions\",
    \"save_without_transactions!\",\r\n\"save_without_validation\", \"save_without_validation!\",
    \"schema_format\",\r\n\"skip_time_zone_conversion_for_attributes\", \"store_full_sti_class\",\r\n\"store_full_sti_class?\",
    \"table_name_prefix\", \"table_name_suffix\",\r\n\"time_zone_aware_attributes\",
    \"timestamped_migrations\", \"to_param\",\r\n\"toggle\", \"toggle!\", \"update_attribute\",
    \"update_attributes\",\r\n\"update_attributes!\", \"valid?\", \"valid_without_callbacks?\",\r\n\"write_attribute\",
    \"write_attribute_without_dirty\"]\r\n```\r\n\r\nHopefully your impression after
    reading this list is that LSP is basically\r\nimpossible to be a purist about,
    but let's try to come up with a plausible\r\nviolation that isn't some obscure
    edge case. For example, what happens if we're\r\nbuilding a database model for
    describing a linux system configuration, which has\r\na field called logger in
    it? You can certainly at least get away with the\r\nmigration for it without Rails
    complaining, using something like the code shown\r\nbelow.\r\n\r\n```ruby\r\nclass
    CreateLinuxConfigs < ActiveRecord::Migration\r\n  def self.up\r\n    create_table
    :linux_configs do |t|\r\n      t.text :logger\r\n      t.timestamps\r\n    end\r\n
    \ end\r\n\r\n  def self.down\r\n    drop_table :linux_configs\r\n  end\r\nend\r\n```\r\n\r\nThe
    standard behavior of `ActiveRecord`'s models is to provide dynamic accessors\r\nto
    a record's database fields, which means we should expect the following\r\nbehavior:\r\n\r\n```ruby\r\nconfig
    \       = LinuxConfig.new\r\nconfig.logger = \"syslog-ng\"\r\nconfig.logger #=>
    \"syslog-ng\"\r\n```\r\n\r\nBut because `ActiveRecord::Base` also implements a
    method called `logger`, and the\r\ndynamic attribute lookup is just a method_missing
    hack, we end up with a\r\ndifferent behavior:\r\n\r\n```ruby\r\nconfig        =
    LinuxConfig.new\r\nconfig.logger = \"syslog-ng\" \r\nconfig.logger #=> #<ActiveSupport::BufferedLogger:0x00000000b6de38
    \r\n              #     @level=0, @buffer={}, @auto_flushing=1, \r\n              #
    \    @guard=#<Mutex:0x00000000b6dde8>,\r\n              #     @log=#<File:/home/x/demo/log/development.log>>\r\n```\r\n\r\nIf
    you've been following closely, you probably saw this coming from a mile away,\r\neven
    if you couldn't predict the exact behavior. It's worth mentioning that even\r\nRails
    knows that this sort of setup will lead to bad things, but their checks\r\nwhich
    raise an error when they spot this LSP violation apparently aren't\r\ncomprehensive.
    But to be fair, if we try to set this at the time our record was\r\ninitialized,
    or if we try to use write_attribute, we get a pretty decent error\r\nmessage.\r\n\r\n```ruby\r\n>>
    config = LinuxConfig.new(:logger => \"syslog-ng\")\r\nActiveRecord::DangerousAttributeError:
    logger is defined by ActiveRecord\r\n```\r\n\r\n```ruby\r\n>> config = LinuxConfig.new\r\n=>
    #<LinuxConfig id: nil, logger: nil, created_at: nil, updated_at: nil>\r\n>> config.write_attribute(:logger,
    \"syslog-ng\")\r\nActiveRecord::DangerousAttributeError: logger is defined by
    ActiveRecord\r\n```\r\n\r\nThis sort of proactive error checking is actually more
    than we should expect\r\nfrom most parent classes, `ActiveRecord::Base` just takes
    special consideration\r\nbecause it is so widely used. You can't expect every
    object you might subclass\r\nto even try to catch these sorts of violations, and
    it's not a great idea to\r\nintroduce this sort of logic into your own base classes
    without carefully\r\nconsidering the context. Of course, that doesn't mean that
    there aren't measures\r\nyou can take to avoid LSP violations in code that you
    design yourself.\r\n\r\nI don't want to go into too much detail here, but there
    are two techniques I\r\nlike to use for mitigating LSP issues. The first one is
    object composition, and\r\nthe second is defining per-object behavior. Just as
    an experiment, I've thrown\r\ntogether a rethinking of how `ActiveRecord` could
    handle dynamic accessors in a\r\nslightly more robust way.\r\n\r\n```ruby\r\nrequire
    \"delegate\"\r\n\r\nmodule DynamicFinderProxy\r\n\r\n  extend self\r\n\r\n  def
    build_proxy(record)\r\n    proxy = SimpleDelegator.new(record)\r\n    record.attribute_names.each
    do |a|\r\n      proxy.singleton_class.instance_eval do\r\n        define_method(a)
    { read_attribute(a) }\r\n        define_method(\"#{a}=\") { |v| write_attribute(a,v)
    }\r\n      end\r\n    end\r\n\r\n    proxy\r\n  end\r\n\r\nend\r\n\r\nclass FakeActiveRecord\r\n\r\n
    \ class << self\r\n    def new\r\n      obj = allocate\r\n      obj.send(:initialize)\r\n
    \     DynamicFinderProxy.build_proxy(obj)\r\n    end\r\n\r\n    def column_names(*names)\r\n
    \     @column_names = names unless names.empty?\r\n      @column_names\r\n    end\r\n
    \ end\r\n\r\n  def attribute_names\r\n    self.class.column_names\r\n  end\r\n\r\n
    \ def read_attribute(a)\r\n    logger.puts(\"Reading #{a}\")\r\n    instance_variable_get(\"@#{a}\")\r\n
    \ end\r\n\r\n  def write_attribute(a,v)\r\n    logger.puts(\"Writing #{a}\")\r\n
    \   instance_variable_set(\"@#{a}\",v)\r\n  end\r\n\r\n  def logger\r\n    STDOUT\r\n
    \ end\r\nend\r\n\r\nclass LinuxConfig < FakeActiveRecord\r\n  column_names \"logger\",
    \"crontab\"\r\nend\r\n\r\nrecord = LinuxConfig.new\r\nrecord.logger = \"syslog-ng\"\r\np
    record.logger\r\n```\r\n\r\nNow, I'll admit that there is some deep voodoo in
    this code, but it at least\r\nindicates to me that we should be thinking differently
    about our options in\r\nRuby. We have more than just vanilla inheritance to play
    with, and even ordinary\r\nmixins have their limitations, so maybe we need a whole
    new set of design\r\nprinciples that take Ruby's deeply dynamic nature into account?
    Or perhaps I've\r\njust passed the midway point in a very long article and have
    decided to go off\r\non a little tangent to keep myself entertained. I'll let
    you be the judge.\r\n\r\n### Interface segregation principle\r\n\r\nI've seen
    a couple different interpretations of the interface segregation\r\nprinciple,
    with the most narrow ones almost directly outlining the use case for\r\nJava-style
    interfaces, which is to prevent code from specifying that an object\r\nmust be
    a specific type when all that is required is a certain set of methods to\r\nhave
    a meaningful implementation.\r\n\r\nRuby offers a lot of flexibility and its dynamic
    typing makes a lot of interface\r\nsegregation principle violations just go away
    on their own. That having been\r\nsaid, we still see a lot of `is_a?()` and `respond_to?()`
    checks which are both\r\na form of LSP violation.\r\n\r\nTo protect against those
    violations, the best bet is to embrace duck typing as\r\nmuch as possible. Since
    this article is already super long and we've already\r\ncovered duck typing extensively
    in issues\r\n[#14](http://practicingruby.com/articles/43) and\r\n[#15](http://practicingruby.com/articles/44)
    of Practicing Ruby, It would be\r\nsufficient to simply re-read those articles
    if you need a refresher and then\r\npromptly move on to the next principle. But
    in case you want to dig deeper, here\r\nare a couple more articles related to
    this topic that you should definitely read\r\nif you haven't seen them before.
    All three are about how to get around\r\nexplicitly naming classes in case statements,
    which is a form of LSP violation.\r\n\r\n* [Ruby case statements and kind_of?(Sandi
    Metz)](http://sandimetz.com/2009/06/ruby-case-statements-and-kindof.html)\r\n\r\n*
    [The Double Dispatch Dance (Aaron Patterson)](http://blog.rubybestpractices.com/posts/aaronp/001_double_dispatch_dance.html)\r\n\r\n*
    [The Decorator Delegator Disco (Gregory Brown)](http://blog.rubybestpractices.com/posts/gregory/008-decorator-delegator-disco.html)\r\n\r\nThat
    should add an extra hour or so of homework for you. This is getting a bit\r\ncrazy
    though, so let's hit that last principle and call it a day.\r\n\r\n### Dependency
    inversion principle\r\n\r\nYou probably already know about the values of dependency
    inversion (aka\r\ndependency injection) if you've been working in Ruby for a while
    now. You also\r\nprobably know that unlike some other languages, there really
    isn't a need for DI\r\nframeworks because it implements all the necessary tools
    for good DI at the\r\nlanguage level. But in case you didn't get the memo, I'll
    go through a quick\r\nexample of how dependency inversion can come in handy.\r\n\r\nSuppose
    we have a simple object, like a `Roster`, which keeps track of a list of\r\npeople,
    and we have a `RosterPrinter` which creates formatted output from that\r\nlist.
    Then we might end up with some code similar to what is shown below.\r\n\r\n```ruby\r\nclass
    Roster\r\n  def initialize        \r\n    @participants = []\r\n  end\r\n\r\n
    \ def <<(new_participant)\r\n    @participants << new_participant\r\n  end\r\n\r\n
    \ def participant_names\r\n    @participants.map { |e| e.full_name }\r\n  end\r\n\r\n
    \ def to_s\r\n    RosterPrinter.new(participant_names).to_s\r\n  end\r\nend\r\n\r\nclass
    RosterPrinter\r\n  def initialize(participant_names)\r\n    @participant_names
    = participant_names\r\n  end\r\n\r\n  def to_s\r\n    \"Participants:\\n\" +\r\n
    \   @participant_names.map { |e| \"* #{e}\" }.join(\"\\n\")\r\n  end\r\nend\r\n```\r\n\r\nThe
    nice thing about this code is that it separates the presentation of a roster\r\nfrom
    its data representation, bringing it in line with the single\r\nresponsibility
    principle. But the problem with it is that `Roster` and\r\n`RosterPrinter` are
    needlessly coupled, which limits the value of\r\nseparating the objects in the
    first place. Modifying `Roster#to_s()` can\r\nsolve this problem.\r\n\r\n```ruby\r\nclass
    Roster\r\n  # other methods same as before\r\n\r\n  def to_s(printer=RosterPrinter)\r\n
    \   printer.new(participant_names).to_s\r\n  end\r\nend\r\n\r\n# usage\r\nroster.to_s
    \r\n```\r\n\r\nThis new code is functionally equivalent to our previous example
    when called\r\nwith no arguments, but opens a whole host of new opportunities.
    For example, we\r\ncan trivially swap in any printer object we'd like now.\r\n\r\n```ruby
    \ \r\nclass HTMLRosterPrinter\r\n  def initialize(participant_names)\r\n    @participant_names
    = participant_names\r\n  end\r\n\r\n  def to_s\r\n    \"<h3>Participants</h3><ul>\"+\r\n
    \   @participant_names.map { |e| \"<li>#{e}</li>\" } +\r\n    \"</ul>\r\n  end\r\nend\r\n\r\n#
    usage\r\nroster.to_s(HTMLRosterPrinter)\r\n```\r\n\r\nBy injecting the printer
    object into `Roster`, we avoid resorting to\r\nsomething as uncouth as creating
    a `Roster` subclass for the sole purpose of\r\nwiring up the `HTMLRosterPrinter`.\r\n\r\nOf
    course, the most common place that talk about dependency inversion comes up\r\nis
    when folks are thinking about automated testing. While Ruby makes it possible\r\nto
    mock out calls to pretty much any object, it's a whole lot cleaner to pass in\r\nraw
    mock objects than it is to set expectations on real objects.\r\n\r\nDependency
    inversion can really come in handy, but it's important to provide\r\nsensible
    defaults so that you don't end up forcing consumers of your API to do a\r\nlot
    of tedious wiring. The trick is to make it so you can swap out\r\nimplementations
    easily, it's not as important for your code to have no opinion\r\nabout which
    implementation it should use. Folks sometimes forget this and as a\r\nresult their
    code gets quite annoying to work with. However, Ruby makes it easy\r\nto provide
    defaults, so there is no real reason why this issue can't be averted.\r\n\r\n###
    Reflections\r\n\r\nThis article is much longer than I expected it would be, but
    I feel like I've\r\njust scratched the surface. An interesting thing about the
    SOLID principles is\r\nthat they all sort of play into each other, so you tend
    to get the most out of\r\nthem by looking at all five concepts at once rather
    than each one in isolation.\r\n\r\nOne thing I want to emphasize is that when
    I make use of SOLID or any other set\r\nof design principles, I use them as a
    metric rather than a set of\r\nconstructive rules. I don't typically set out designing
    a system with all of\r\nthese different guidelines in mind, as that would give
    me a claustrophobic\r\nfeeling. However, when the time comes to sanity check a
    new design or make\r\nincremental improvements to an old one during a refactoring
    session, SOLID\r\nprovides a good checklist for pinpointing areas of my code that
    might deserve\r\nsome rethinking.\r\n\r\nSometimes you break these rules by accident,
    and that's okay. Sometimes you\r\nbreak them because you are making a conscious
    trade to avoid some other bad\r\nthing from happening, and that's okay too. As
    long as you're regularly checking\r\nyour assumptions about things and actually
    caring about the overall design of\r\nyour system, you shouldn't feel guilty for
    not following these guidelines\r\nperfectly. In fact, it is more dangerous to
    blindly follow design principles to\r\nthe letter than it is to completely ignore
    them.\r\n\r\nWe have much, much more design discussion to come, so hopefully you
    enjoyed this\r\narticle. :)\r\n\r\n> **NOTE:** This article has also been published
    on the Ruby Best Practices blog. There \r\n[may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n\r\n"
- :slug: connascence
  :title: Connascence as a Software Design Metric
  :summary: Work through code samples inspired by Jim Weirich's "Building Blocks of
    Modularity" presentation.
  :published: 2011-02-11 00:00:00.000000000 Z
  :issue_number: '1.24'
  :volume: 1
  :body: "My article on the [SOLID design\r\nprinciples](http://practicingruby.com/articles/52)
    was inspired by a great talk\r\nI saw by Sandi Metz at GoRuCo 2009. Coincidentally,
    this  article is inspired by\r\nanother great talk I saw in 2009, called [The
    Building Blocks of\r\nModularity](http://confreaks.net/videos/77-mwrc2009-the-building-blocks-of-modularity).\r\nThis
    talk was given by Jim Weirich at MWRC, and if you haven't seen it yet, I\r\nurge
    you to stop what you're doing and watch it right now.\r\n\r\nIn the talk, Jim
    jokingly claims he's presenting on the \"Grand Unified Theory of\r\nSoftware Development\".
    Personally, I think that isn't too far off the mark,\r\nbecause connascence is
    a fundamentally simple concept when compared to things\r\nlike the SOLID principles
    or any of other design concepts we'll be studying in\r\nthis series.\r\n\r\n###
    Brief introduction to connascence for the uninitiated\r\n\r\nSince I didn't know
    the concept of connascence even existed before seeing Jim's\r\ntalk, and because
    it's not a super common discussion topic even among design\r\ngeeks, we should
    at least steal some [content from\r\nWikipedia](http://en.wikipedia.org/wiki/Connascent_software_components)
    to frame\r\nour discussion around:\r\n\r\n><i>\"Two software components are connascent
    if a change in one would require the other to be modified in order to maintain
    the overall correctness of the system. Connascence is a way to characterize and
    reason about certain types of complexity in software systems.\"</i>\r\n\r\nIf
    you haven't watched Jim's talk yet, I'll remind you to go ahead and do that\r\nnow.
    But if some reason you can't or won't, you should know that the kinds of\r\ncomplexity
    that connascence can be used to reason about all have\r\nto do with coupling.
    The relationship between the concept of connascence to the\r\nconcept of coupling
    becomes a little more clear when you look at the various\r\nkinds of connascence
    that can be found in software systems. Below I've listed\r\nout the various kinds
    of connascence in order from weakest to strongest:\r\n\r\n* <b>Name:</b> when
    multiple components must agree on the name of an entity.\r\n* <b>Type:</b> when
    multiple components must agree on the type of an entity.\r\n* <b>Meaning:</b>
    when multiple components must agree on the meaning of specific values.\r\n* <b>Position:</b>
    when multiple components must agree on the order of values.\r\n* <b>Algorithm:</b>
    when multiple components must agree on a particular algorithm.\r\n* <b>Execution
    (order):</b> when the order of execution of multiple components is important.\r\n*
    <b>Timing:</b> when the timing of the execution of multiple components is important.\r\n*
    <b>Identity:</b> when multiple components must reference the entity. \r\n\r\nKnowing
    the various kinds of connascence gives us a metric for determining the characteristics
    and severity of the coupling in our systems. The idea is simple: The more remote
    the connection between two clusters of code, the weaker the connascence between
    them should be.\r\n\r\nGood design principles encourages us to move from tight
    coupling to looser\r\ncoupling where possible. But connascence allows us to be
    much more specific\r\nabout what kinds of problems we're dealing with, which makes
    it easier to reason\r\nabout the types of refactorings that can be used to weaken
    the connascence\r\nbetween components.\r\n\r\nIn this article, I will show how
    you can convert instance of Type, Meaning, \r\nPosition, and Algorithm-based\r\nconnascence
    down to Connascence of Name. While all forms of connascence are\r\nworth studying,
    these ones are the most likely to appear in your daily work.\r\n\r\n### Connascence
    of Name\r\n\r\nName based coupling exists when a name change in one place requires
    a code\r\nchange in other places. Being the weakest form of connascence, it's
    also by far\r\nthe most common. Every module, class, method and variable we create
    introduces\r\nconnascence of name, assuming it is actually used for something.
    As an example,\r\nconsider the following code:\r\n\r\n```ruby\r\nmailer = Mailer.new\r\nmailer.deliver(:to
    \     => \"gregory.t.brown@gmail.com\", \r\n               :from    => \"fake@fake.com\",\r\n
    \              :subject => \"You have won a lifetime supply of...\",\r\n               :body
    \   => \"Dear Sir, I am pleased to inform...\")\r\n```\r\n\r\nIn just this script,
    we see an incredible amount of name based coupling. Any of\r\nthe following trivial
    changes to Mailer would cause all code that depends on it\r\nto break immediately.\r\n\r\n*
    Wrapping the Mailer class definition in a namespace, e.g. `FancyUnicorn::Mailer`\r\n\r\n*
    Renaming the `deliver()` method to `send_message()`\r\n\r\n* Renaming any of the
    keys in the hash passed to `deliver()`, i.e. changing\r\nthe `:to` key so that
    it reads `:recipient`\r\n\r\nBut the fact is, there isn't really any way around
    this sort of coupling in most\r\nscenarios, and it's not necessarily a sign of
    a problem. That having been said,\r\nthe reason why naming things is so important
    in computer science is because even\r\nloosely coupled, highly cohesive systems
    have copious amounts of name based\r\ncoupling, which have widespread effects
    that only increase as systems get more\r\ncomplex.\r\n\r\nSometimes, it is possible
    to eliminate Connascence of Name and the the coupling\r\nthat comes along with
    it. For example, consider this way of defining class\r\nmethods in Ruby:\r\n\r\n```ruby\r\nclass
    Mailer\r\n  def Mailer.configure(*args)\r\n    #...\r\n  end\r\nend\r\n```\r\n\r\nThere
    is a clear dependence in this code between the second line of code and the\r\nfirst,
    in which if the first line changes, so too must the second line. We can\r\nrewrite
    this to avoid that coupling, if we just take advantage of Ruby's `self`\r\nkeyword
    here:\r\n\r\n```ruby\r\nclass Mailer\r\n  def self.configure(*args)\r\n    #...\r\n
    \ end\r\nend\r\n```\r\n\r\nBut while eliminating Connascense of Name is desireable
    when it is both possible\r\nand convenient to do so, it's not always realistic.
    We need to accept that\r\nbecause names don't change all that often, a little
    bit of CoN is often\r\nharmless. In fact, when given the choice between CoN and
    other forms of\r\nconnascence, name based coupling is preferable. We will now
    take\r\na look at the other forms of connascence to see why that is the case.\r\n\r\n###
    Connascence of Type\r\n\r\nFolks like to think that Ruby is immune to typing issues,
    but that \r\nassumption is often far too optimistic. The following code is a \r\ndirect
    example of Connascence of Type:\r\n\r\n```ruby\r\ndef average(values)\r\n   raise
    ArgumentError unless values.kind_of?(Array)\r\n\r\n   values.inject(:+) / values.size.to_f\r\nend\r\n```\r\n\r\nOne
    might attempt to resolve the problem by moving away from strict class\r\nchecking
    and instead use a `respond_to?()` check:\r\n\r\n```ruby\r\ndef average(values)\r\n
    \  unless values.respond_to?(:inject) && values.respond_to?(:size)\r\n     raise
    ArgumentError \r\n   end\r\n\r\n   values.inject(:+) / values.size.to_f\r\nend\r\n```\r\n\r\nThis
    certainly loosens the type coupling, but does not eliminate it. If we\r\naccept
    the notion that the type of a Ruby object is defined by what that object\r\ncan
    do, `respond_to?()` is still a form of type check, done at the method level\r\ninstead
    of at the level of the class hierarchy. It can sometimes even result in\r\nfalse
    negatives, because not all code which implements dynamic behavior through\r\n`method_missing()`
    updates `respond_to?()` to add those methods. This can lead\r\nto code similar
    to previous example to fail with certain kinds of proxy objects,\r\neven though
    they implement all necessary behaviors.\r\n\r\nTo truly free ourselves from Connascence
    of Type, one option is to just remove\r\nthe guard clause and let Ruby bubble
    up with an exception for objects that don't\r\nwork as our code expects them to.
    But sometimes, we want to make sure our\r\ndebugging isn't harder than it needs
    to be. Here's an alternative that preserves\r\nthe error handling in a way that
    is free of type dependencies:\r\n\r\n```ruby\r\ndef average(values)\r\n   values.inject(:+)
    / values.size.to_f\r\nrescue NoMethodError\r\n   raise ArgumentError, \"The average()
    function can only \" +\r\n                        \"operate on collections which
    implement \" +\r\n                        \"the inject() and size() methods\"\r\nend\r\n```\r\n\r\nIf
    this feels a bit overkill, it's because it probably is. But the general idea\r\nof
    removing the `kind_of?()` and `respond_to?()` checks is a good one, because\r\nit
    puts us squarely back in the realm of Connascence of Name. Our dependency is\r\nnow
    simply that the values object has a pair of methods with the names\r\n`inject()`
    and `size()`.\r\n\r\n### Connascence of Meaning\r\n\r\nIn its most basic form,
    Connascence of Meaning is all about magic values. For\r\nexample, consider a legacy
    access control system in\r\nwhich an admin is given the value 0, a manager 1,
    and an ordinary user 2. You\r\ncould end up writing code like this:\r\n\r\n```ruby\r\nif
    user.access_level == 0\r\n  shoot_nukes_at_moon\r\nelse\r\n  raise AccessDeniedError\r\nend\r\n```\r\n\r\nThe
    trouble is, once you've littered your system with hard-coded numeric values,\r\nyou
    will have a hard time remembering what they do, and will have a hard time\r\nhunting
    them down when they need to be changed. To fix this issue, we can modify\r\nour
    hypothetical `User` object:\r\n\r\n```ruby\r\nclass User\r\n  ACCESS_LEVELS =
    { 0 => :admin, 1 => :manager, 2 => :user }\r\n\r\n  def admin?\r\n    ACCESS_LEVELS[access_level]
    == :admin\r\n  end\r\nend\r\n```\r\n\r\nWe try to avoid repeating Connascence
    of Meaning even in the more local context\r\nof the `User` class by storing the
    actual role mappings in a constant. We then\r\nprovide a convenience method `User#admin?`
    to be used externally, resulting in\r\nnewly minted caller code that looks like
    this:\r\n\r\n```ruby\r\nif user.admin?\r\n  shoot_nukes_at_moon\r\nelse\r\n  raise
    AccessDeniedError\r\nend\r\n```\r\n\r\nNow I don't know about you, but I think
    I'd be much less likely to accidentally\r\nnuke the moon if the code were written
    this way. We haven't totally \r\neliminated the `Connascence of Meaning`, but
    we've moved it to a hyper-local \r\ncontext within a single constant on the User
    model. Because all of the \r\ncalling code is now just exhibiting Connascence
    of Name, this is a great \r\nrefactoring.\r\n\r\n### Connascence of Position\r\n\r\nConnascence
    of Position is something that we see every day in Ruby because\r\nmethod parameters
    are ordered. If we go to our mailer example, we could have\r\njust as easily written
    the `Mailer#deliver()` method to use explicitly ordered\r\nparameters, similar
    to what is shown in the example below.\r\n\r\n```ruby\r\nclass Mailer\r\n  def
    deliver(to, from, subject, message)\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nAPIs
    like this annoy the heck out of me, because the calling code typically\r\ndoesn't
    give any hints at why the arguments are specified in a particular order.\r\nTake
    a look at how opaque things get when we just try to reproduce our previous\r\nexample
    using this slightly different API:\r\n\r\n```ruby\r\nmailer.deliver(\"gregory.t.brown@gmail.com\",
    \r\n               \"fake@fake.com\",\r\n               \"You have won a lifetime
    supply of...\",\r\n               \"Dear Sir, I am pleased to inform...\")\r\n```\r\n\r\nLooking
    at this code, it's very difficult to determine who is the sender and who\r\nis
    the recipient, and even more difficult to think about how you might introduce\r\ndefault
    values into the mix. Every change to the ordering or length of the list\r\nof
    arguments can lead to broken code in remote places in your codebase. For all\r\nof
    these reasons, Rubyists tend to prefer hash-based pseudo-keyword arguments\r\nfor
    all but the most straightforward method signatures.\r\n\r\nHowever, introducing
    keyword arguments isn't the only way to reduce CoP in\r\nmethod signatures to
    CoN. Another alternative that is perhaps underused is to\r\nsimply create objects
    that provide all the necessary attributes that you would\r\ntypically use a hash
    for. In this case, we can envision a simple `Message`\r\nobject being introduced:\r\n\r\n```ruby\r\nmessage
    = Message.new\r\nmessage.to      = \"gregory.t.brown@gmail.com\"\r\nmessage.from
    \   = \"fake@fake.com\"\r\nmessage.subject = \"You have won a lifetime supply
    of...\"\r\nmessage.body    = \"Dear Sir, I am pleazed to inform...\"\r\n\r\nmailer.deliver(message)\r\n```\r\n\r\nAssuming
    that the `Mailer#deliver` method just depends on the attribute readers\r\nfor
    those attributes, this is functionally equivalent to the hash based code but\r\noffers
    a number of advantages. `Message` is now a reusable, independently\r\ntestable
    entity that can do things like validations internally. This moves some\r\nof the
    error checking and simple transformation code that might be needed to use\r\na
    parameters hash into a more local setting. With a little creativity, it's\r\nrelatively
    easy to make the API look a little nicer by letting `Mailer#deliver`\r\ncreate
    the message object for you.\r\n\r\n```ruby\r\nmailer.deliver do |message|\r\n
    \ message.to      = \"gregory.t.brown@gmail.com\"\r\n  message.from    = \"fake@fake.com\"\r\n
    \ message.subject = \"You have won a lifetime supply of...\"\r\n  message.body
    \   = \"Dear Sir, I am pleazed to inform...\"\r\nend\r\n```\r\n\r\nThis sort of
    API is fairly common in Ruby as well, but probably not as common as\r\nit should
    be. So next time you're faced with the CoP problem when dealing with\r\nmethod
    arguments, consider fixing it by putting a nice shiny new object in\r\nplace.\r\n\r\nIt's
    worth noting that Connascence of Position is certainly not limited to\r\nmethod
    arguments in Ruby. Anywhere in which a change in position of some data\r\nrequires
    you to change code elsewhere, you've got a CoP issue, and should think\r\nabout
    how to reduce it if possible.\r\n\r\n### Connascence of Algorithm\r\n\r\nConnascence
    of Algorithm often looks and smells a bit like the DRY principle.\r\nBut there
    are many cases in which code that violates DRY doesn't have a CoA\r\nproblem,
    and some rare cases where the opposite is true. The key thing about CoA\r\nis
    the dependency between two or more clusters of code.\r\n\r\nThe following example
    is a CoA example from the wild, from a programming quiz\r\nsite that we're working
    on as part of Mendicant University's admission process.\r\nFirst, you can see
    a fairly DRY model which is meant to compare uploaded\r\nsolutions to the actual
    answer for a given puzzle.\r\n\r\n```ruby\r\nclass Puzzle < ActiveRecord::Base\r\n
    \ def file=(tempfile)\r\n    write_attribute :fingerprint, sha1(tempfile)\r\n
    \ end\r\n\r\n  def valid_solution?(tempfile)\r\n    fingerprint == sha1(tempfile)\r\n
    \ end\r\n\r\n  private\r\n\r\n  def sha1(tempfile)\r\n    Digest::SHA1.hexdigest(tempfile.read)\r\n
    \ end\r\nend\r\n```\r\n\r\nInternally, this code is fairly free of CoA, particularly
    because the algorithm\r\nfor fingerprinting solutions has been extracted into
    the `Puzzle#sha1()` helper.\r\nBut because this is a private method, I ended up
    with tests that explicitly do\r\nthe hashing themselves to verify that the `Puzzle#file=()`
    method is working as\r\nexpected.\r\n\r\n```ruby\r\ntest \"must be able to create
    a fingerprint for a file\" do\r\n  tempfile = Tempfile.new(\"puzzle_sample\")\r\n
    \ tempfile << \"Sample Text\"\r\n  tempfile.rewind\r\n\r\n  expected_fingerprint
    = Digest::SHA1.hexdigest(tempfile.read)\r\n  tempfile.rewind\r\n\r\n  puzzle =
    Puzzle.new(:file => tempfile)\r\n\r\n  assert_equal expected_fingerprint, puzzle.fingerprint\r\nend\r\n```\r\n\r\nThis
    has an upside in that it sanity checks the exact behavior, ensuring that\r\nthe
    tempfile is actually hashed via SHA1. But since the focus of the test is\r\nmore
    on ensuring that a hash was generated rather than the way it was generated,\r\nwe
    might be able to improve this by extracting the fingerprinting code into its\r\nown
    module.\r\n\r\n```ruby\r\nmodule Fingerprint\r\n  extend self\r\n\r\n  def [](stream)\r\n
    \   Digest::SHA1.hexdigest(stream.read)\r\n  end\r\nend\r\n```\r\n\r\nThen, I
    could rewrite the code and tests to look like they do below:\r\n\r\n```ruby\r\nclass
    Puzzle < ActiveRecord::Base\r\n  def file=(tempfile)\r\n    write_attribute :fingerprint,
    Fingerprint[tempfile]\r\n  end\r\n\r\n  def valid_solution?(tempfile)\r\n    fingerprint
    == Fingerprint[tempfile]\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\ntest \"must
    be able to create a fingerprint for a file\" do\r\n  tempfile = Tempfile.new(\"puzzle_sample\")\r\n
    \ tempfile << \"Sample Text\"\r\n  tempfile.rewind\r\n\r\n  expected_fingerprint
    = Fingerprint[tempfile]\r\n  tempfile.rewind\r\n\r\n  puzzle = Puzzle.new(:file
    => tempfile)\r\n\r\n  assert_equal expected_fingerprint, puzzle.fingerprint\r\nend\r\n```\r\n\r\nThe
    end result would be that the algorithm for how I was generating digital\r\nfingerprints
    for the solutions could change, and I would not need to update my\r\ntests, as
    long as the names of everything stayed the same.\r\n\r\nIn this case, arguably
    just fully applying the DRY principle would lead us to\r\nthe same place, but
    the concept of connascence lets us think about the\r\nconsequences of DRY in a
    less abstract way. Like all the other types of\r\nconnascence, there is a lot
    more we could talk about here, but in the interest\r\nof time, we'll skip the
    details for now.\r\n\r\n### Reflections\r\n\r\nWhile we dug deep into some heavy
    theory in [last week's SOLID\r\narticle](http://practicingruby.com/articles/52),
    I tried to keep the connascence\r\nexamples simple, practical, and common. But
    that is not to say that connascence\r\nisn't every bit as deep a concept as SOLID,
    and your investigations should not\r\nstop at the examples I've shown here.\r\n\r\nIn
    the two articles to follow this one, we'll be looking at particular patterns\r\nand
    techniques that can help you design better code. Now that you're armed with\r\nboth
    the SOLID principles and the metrics of connascence, you have a solid basis\r\nfor
    thinking about these problems in more specific contexts. I encourage you to\r\nre-read
    these first two articles as you continue on with this series, and get\r\nback
    to me with any questions you might have.\r\n  \r\n> **NOTE:** This article has
    also been published on the Ruby Best Practices blog. \r\nThere [may be additional
    commentary](http://blog.rubybestpractices.com/posts/gregory/056-issue-24-connascence.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: creational-design-patterns
  :title: Creational Design Patterns
  :summary: Examine a use case for each of the classic creational design patterns
    laid out by the Gang of Four.
  :published: 2011-02-22 00:00:00.000000000 Z
  :issue_number: '1.25'
  :volume: 1
  :body: "In this issue and the next one, I look at several design patterns laid out
    by\r\nthe Gang of Four and explore their relevance to modern day Ruby programming.
    My\r\ngoal is not so much to teach the design patterns themselves, but instead
    give\r\npractical examples using real code so that you can consider what their
    strengths\r\nand weaknesses are.\r\n\r\nIn this article, I focus on the creational
    design patterns, all of which have to\r\ndo with instantiating new objects. They
    are listed below in no particular order:\r\n\r\n  * Singleton\r\n  * Multiton\r\n
    \ * Factory Method\r\n  * Abstract Factory\r\n  * Builder\r\n  * Prototype  \r\n\r\nAn
    important thing to keep in mind is that while the original GoF book was\r\nwritten
    with C++ and Smalltalk examples, none of the patterns were written with\r\nRuby's
    semantics in mind. This makes it necessary to use a little poetic license\r\nto
    explore how these patterns apply in Ruby. That having been said, the examples\r\nwe'll
    look at attempt to preserve the spirit of the patterns they implement even\r\nif
    they're not semantically identical.\r\n\r\n### Singleton\r\n\r\n<i>UPDATE 2011-12-20:
    Be sure to check out what [Practicing Ruby\r\n2.8](http://practicingruby.com/articles/shared/jleygxejeopq)
    has to say about\r\nimplementing Singleton pattern in Ruby. My feelings on this
    have changed over\r\ntime</i>\r\n\r\nThe [Singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern)
    is used\r\nin situations where a single instance of a class is all you need. Singleton\r\nobjects
    are meant provide an effective way of organizing global state and\r\nbehavior,
    such as configuration data, logging support, or other similar needs.\r\nThis pattern
    is common enough that Ruby provides a module in its standard\r\nlibrary that makes
    it easier to implement.\r\n\r\nIn the code below, I've implemented a simple logger
    using Ruby's singleton\r\nlibrary, which on the surface should look quite like
    an ordinary Ruby class\r\ndefinition.\r\n\r\n```ruby\r\nrequire \"singleton\"\r\n\r\nclass
    SimpleLogger\r\n  include Singleton\r\n\r\n  def initialize\r\n    @output = []\r\n
    \ end\r\n\r\n  attr_reader :output\r\n\r\n  def error(message)\r\n    output <<
    formatted_message(message, \"ERROR\")\r\n  end\r\n\r\n  def info(message)\r\n
    \   output << formatted_message(message, \"INFO\")\r\n  end\r\n\r\n  def write(filename)\r\n
    \   File.open(filename, \"w\") { |f| f << output.join(\"\\n\") }\r\n  end\r\n\r\n
    \ private\r\n\r\n  def formatted_message(message, message_type)\r\n    \"#{Time.now}
    | #{message_type}: #{message}\"\r\n  end\r\n\r\nend\r\n```\r\n\r\nNothing here
    looks out of the ordinary, but you can begin to see the impact of the Singleton
    mixin as soon as you try to create a SimpleLogger instance.\r\n\r\n```ruby\r\n>>
    logger = SimpleLogger.new\r\nNoMethodError: private method `new' called for SimpleLogger:Class\r\n
    \ from (irb):2\r\n```\r\n\r\nSince the purpose of the singleton pattern is to
    allow for the creation of only a single instance, it makes sense that you might
    not be able to expect construction to work as normal. The example below demonstrates
    what you need to do instead.\r\n\r\n```ruby\r\nlogger = SimpleLogger.instance\r\n\r\nlogger.error(\"Some
    serious problem\")\r\nlogger.info(\"Something you might want to know\")\r\nlogger.write(\"log.txt\")\r\n```\r\n\r\nThe
    class method `instance()` gets added by the Singleton mixin, and takes responsibility
    for initializing the SimpleLogger object. The first time this method is called,
    an instance of SimpleLogger is created, and initialize gets called as usual. Each
    subsequent call refers to that exact instance, preventing additional instances
    of this class from being created.\r\n\r\nAt this point, you might be wondering
    what the advantage of this approach is\r\nover using ordinary class definitions
    and global variables, such as in the code\r\nbelow:\r\n\r\n```ruby\r\n$LOGGER
    = SimpleLogger.new\r\n$LOGGER.error(\"Some serious problem\")\r\n$LOGGER.info(\"Something
    you might want to know\")\r\n```\r\n\r\nThis is a reasonable question to ask,
    because this approach is just as straightforward and has similar strengths and
    weaknesses. If Ruby did not have an open class system, you could argue that it's
    less likely that you'd run into side effects with different definitions of SimpleLogger
    than you would with someone reassigning $LOGGER, but that clearly does not apply
    here. It does seem like it'd be marginally more likely to see a variable reassigned
    than a class stomped on, particularly if proper namespacing was used, but it's
    important to notice that in Ruby, this particular benefit of Singleton objects
    is marginal at best.\r\n\r\nThe real benefit that using the Singleton pattern
    provides in Ruby over its alternatives is that instantiation is lazy evaluated,
    and enforces the single instance limitation. The former provides a potential performance
    and memory bonus when the object never ends up getting used, and the latter helps
    prevent accidental object creation. Both of these things are nice to have, and
    it only takes a bit of extra effort make them happen.\r\n\r\nThe standard library
    implementation of the Singleton pattern is reasonable, and fairly clever. However,
    I feel it probably leans a bit too closely to a direct translation, and instead
    typically use a different technique in my own code. Below you can see how I might
    write SimpleLogger if left to my own devices.\r\n\r\n```ruby\r\nmodule SimpleLogger\r\n
    \ extend self\r\n\r\n  def error(message)\r\n    output << formatted_message(message,
    \"ERROR\")\r\n  end\r\n\r\n  def info(message)\r\n    output << formatted_message(message,
    \"INFO\")\r\n  end\r\n\r\n  def write(filename)\r\n    File.open(filename, \"w\")
    { |f| f << output.join(\"\\n\") }\r\n  end\r\n\r\n  private\r\n\r\n  def formatted_message(message,
    message_type)\r\n    \"#{Time.now} | #{message_type}: #{message}\"\r\n  end\r\n\r\n
    \ def output\r\n    @output ||= []\r\n  end\r\nend\r\n```\r\n\r\nThis code preserves
    the lazy evaluation component while removing the concept of an instance entirely.
    The module itself becomes a singleton object, allowing you to call methods directly
    on it which affect the state stored on the module.\r\n\r\n```ruby\r\nSimpleLogger.error(\"Some
    serious problem\")\r\nSimpleLogger.info(\"Something you might want to know\")\r\nSimpleLogger.write(\"log.txt\")\r\n```\r\n\r\nI
    like to use this approach because what I end up with is truly a single object,
    rather than a class who's job is to provide a single instance. I also like to
    be able to call my singleton methods directly on that object without having to
    retrieve the singular instance.\r\n\r\nThe downside of this code, and the reason
    why I showed both approaches instead of just my preferred one, is that it requires
    a much greater amount of Ruby knowledge to actually understand how it works. Additionally,
    through the loss of the `initialize()` hook, you need to either do something like
    create a setup method that you explicitly call before any other methods, or do
    lazy initialization of all data as I've done in the `output()` method. These idioms
    are fairly common, but again, take you a bit farther away from the look and feel
    of an 'ordinary class definition', which may be offputting to some.\r\n\r\nNo
    matter which approach you choose, it's worth keeping in mind that the Singleton
    pattern should be used in moderation. Due to Ruby's open class system, singleton
    objects are essentially nothing more than overengineered global variables. As
    with any form of global state, this makes them more difficult to test, easier
    to corrupt, and harder to isolate when it comes time to debug issues with them.
    However, when used sparingly and for the right reasons, they can be a good tool
    for managing global state and interactions.\r\n\r\n### Multiton\r\n\r\nThe [Multiton
    pattern](http://en.wikipedia.org/wiki/Multiton) is an extension to the Singleton
    pattern which maps unique keys to specific instances of a class. The idea is that
    there should only be one instance of an object for each unique key in use, limiting
    the number of objects that need to be created. For a practical example, we can
    look at some code in the PDF generation library Prawn which implements this sort
    of behavior.\r\n\r\nAs a PDF generation library that operates at the very low
    level, we need to process and utilize font metrics information extensively. Because
    font files can become quite large, the processing cost of initializing one of
    our Font objects can be very computationally expensive. However, since this information
    is unique for each font that we use, there is no need to re-instantiate fonts
    once they have been initialized.\r\n\r\nWhile the actual source code is more complex
    than what I'll show here, the basic idea of applying a multiton here is quite
    simple. We can start off by assuming that our `Font` class has an ordinary constructor
    which takes a font file and then processes it into a meaningful dataset. Initializing
    a font directly then looks something like this.\r\n\r\n```ruby  \r\nfont = Font.new(\"/path/to/times.ttf\")\r\n```\r\n\r\nOn
    top of this basic interface, we layer a mapping mechanism that when used, looks
    something like the code below.\r\n\r\n```ruby\r\nFont.map(\"Times New Roman\"
    => \"/path/to/times.ttf\")\r\nFont[\"Times New Roman\"] #=> A font instance\r\n```\r\n\r\nTo
    bring all of the above together, we can take a look at a skeletal `Font` class
    which implements the Multiton pattern.\r\n\r\n```ruby\r\nclass Font\r\n  class
    << self\r\n    def file_names\r\n      @file_names ||= {}\r\n    end\r\n\r\n    def
    instances\r\n      @instances ||= {}\r\n    end\r\n\r\n    def map(params)\r\n
    \     file_names.update(params)\r\n    end\r\n\r\n    def [](name)\r\n      instances[name]
    ||= new(file_names[name])\r\n    end\r\n  end\r\n\r\n  def initialize(filename)\r\n
    \   puts \"processing #{filename}\"\r\n  end\r\n\r\n  # details omitted\r\nend\r\n```\r\n\r\nWhile
    the mapping is a bit complex here because it's a two stage process, the core idea
    of the Multiton still shines through. What we have are lazy evaluated Font instances
    which do not get created until the first time `Font[some_font_name]` is called.
    Each subsequent call will result in the original instance being returned rather
    than a new instance of Font being created.\r\n\r\nThis basic pattern can be used
    any time you have a scenario in which each unique key can be mapped to exactly
    one object. This sort of structure can be a super effective caching technique,
    but should also be used with caution as it too introduces global state and added
    complexity that should not be taken lightly.\r\n\r\n### Factory Method\r\n\r\nThe
    [Factory Method pattern](http://en.wikipedia.org/wiki/Factory_method) is used
    for putting a layer of abstraction on top of object creation so that directly
    working with its constructor is no longer necessary. This process can lead to
    more expressive ways of building new objects, and can also allow for the creation
    of new objects without explicitly referencing their class.\r\n\r\nIn a Mendicant
    University course, one of our students (Carol Nichols) ran into a design issue
    that we were able to improve by introducing factory methods. She was building
    an `AdjacencyMatrix` datastructure for storing graph data, and her original API
    looked like this:\r\n\r\n```ruby\r\nclass AdjacencyMatrix\r\n  def initialize(data,
    directed=false)\r\n    #...\r\n  end\r\nend\r\n\r\nundirected_matrix = AdjacencyMatrix.new(data)
    \r\ndirected_matrix   = AdjacencyMatrix.new(data, true)\r\n```\r\n\r\nUsing boolean
    switches as arguments aren't especially expressive, and so the suggestion was
    quickly made to move towards a hash-based argument allowing for the following
    usage.\r\n\r\n```ruby\r\nundirected_matrix = AdjacencyMatrix.new(data) \r\ndirected_matrix
    \  = AdjacencyMatrix.new(data, :directed => true)\r\n```\r\n\r\nGenerally speaking,
    this isn't a bad strategy, but the more we thought about it, the more we realized
    that there isn't really a need for a dynamic option here. Consumers would always
    know whether a graph they were trying to represent was directed or undirected
    at the time they constructed their object, and the default call without the `:directed`
    argument still wasn't very expressive about this detail. After some discussion,
    we settled on the following design, which introduces the Factory method pattern.\r\n\r\n```ruby\r\nclass
    AdjacencyMatrix\r\n  class << self\r\n    def undirected(data)\r\n      new(data)\r\n
    \   end\r\n\r\n    def directed(data)\r\n      new(data,true)\r\n    end\r\n\r\n
    \   private :new\r\n  end\r\n\r\n  def initialize(data, directed=false)\r\n    #...\r\n
    \ end\r\nend\r\n\r\nundirected_matrix = AdjacencyMatrix.undirected(data) \r\ndirected_matrix
    \  = AdjacencyMatrix.directed(data)\r\n```\r\n\r\nWhile this code does still have
    its original wart intact internally, the interface that consumers interact with
    has been greatly improved. By making the `new()` method private at the class level,
    we force users to call the factory methods, and it becomes immediately clear what
    type of graph is being processed each time a new `AdjacencyMatrix` is constructed.\r\n\r\nThis
    type of scenario comes up often, and the use of factory methods can be used\r\nto
    simplify or at least hide the complexity of constructor calls by giving an\r\nexpressive
    name to a certain way of constructing a given object. However,\r\nsometimes factories
    go even farther by completely decoupling the object creation\r\nprocess from the
    class of the object being created. While I won't go into much\r\ndetail about
    this rare use case, we see this sort of factory very\r\noften in test code, particularly
    when dealing with object mappers in web \r\napplications.\r\n\r\nThe following
    example from `factory_girl` demonstrates how code which does not\r\nreference
    a particular class can be used to instantiate records \r\nvia ActiveRecord:\r\n\r\n```ruby\r\nfactory
    :user do\r\n  first_name 'John'\r\n  last_name  'Doe'\r\n  admin false\r\nend\r\n\r\nFactoryGirl.build(:user)
    #=> an instance of the User model\r\n```\r\n\r\nI won't elaborate on how this
    works, but it should serve as food for thought,\r\nand perhaps would be a good
    project to [dig into the\r\nsource](https://github.com/thoughtbot/factory_girl)
    so that you can get a sense\r\nof how factory methods can simplify the object
    creation process while also making \r\nit more flexible.\r\n\r\n### Abstract Factory\r\n\r\nDue
    to the flexible nature of Ruby's type system, we don't need an actual language
    construct for abstract classes. With that in mind, when we note that an [Abstract
    Factory](http://en.wikipedia.org/wiki/Abstract_factory) is simply an abstract
    interface for concrete Factory objects to conform to, this pattern pretty much
    falls away. This is perhaps easier to show than to explain, so I will go ahead
    and build out a Ruby version of the example shown in the wikipedia article I've
    linked to above.\r\n\r\n```ruby\r\nmodule OSXGuiToolkit\r\n  extend self\r\n\r\n
    \ def button\r\n    Button.new\r\n  end\r\n  \r\n  class Button\r\n    def paint\r\n
    \     puts \"I'm an OSX Button\"\r\n    end\r\n  end\r\nend\r\n\r\nmodule WinGuiToolkit\r\n
    \ extend self\r\n  \r\n  def button\r\n    Button.new\r\n  end\r\n\r\n  class
    Button\r\n    def paint\r\n      puts \"I'm a WINDOWS button\"\r\n    end\r\n
    \ end\r\nend\r\n\r\nclass Application\r\n  def initialize(gui_toolkit)\r\n    button
    = gui_toolkit.button\r\n    button.paint\r\n  end\r\nend\r\n\r\n# this check is
    a very quick hack, not reliable.\r\nif PLATFORM =~ /darwin/\r\n  Application.new(OSXGuiToolkit)\r\nelse\r\n
    \ Application.new(WinGuiToolkit)\r\nend\r\n```\r\n\r\nIn this example, you'll
    see that we've eliminated the explicit Abstract Factory interface. Instead, what
    we've done is created two concrete object factories, `OSXGuiToolkit` and `WinGuiToolkit`,
    that implement a common API. We then create a simple Application stub class which
    shows that the GUI toolkit factory should be injected into the Application. The
    reason for this is seen in the final bit of code which determines which toolkit
    to use based on the platform the code is running on.\r\n\r\nThe notion of using
    dependency injection in combination with object factories is an interesting one
    to me. I honestly don't find myself writing code like this often at all (and so
    couldn't share a relevant example of my own), but I'm not sure if that's just
    because I don't think of it in times where it might be the right strategy to use.
    In any case, this hopefully demonstrates that the notion of an Abstract Factory
    in Ruby is a conceptual one that has no need for actual abstract classes or interface
    objects.\r\n\r\n### Builder\r\n\r\nThe purpose of the [Builder pattern](http://en.wikipedia.org/wiki/Builder_pattern)
    is to create an abstract blueprint describing the steps of creating an object,
    and then allow many different implementations to actually carry out that process
    as long as they provide the necessary steps. This is once again a pattern that
    in Ruby is purely conceptual due to the lack of a need for explicit interfaces
    or abstract classes. However, unlike the Abstract Factory pattern, I have actually
    used the ideas behind builder in some real code of my own, and have an example
    handy that captures the spirit of the pattern.\r\n\r\nA while back, I was experimenting
    with coming up with some generalized domain language for producing output in a
    number of different formats. While I had more complex goals in mind, the basic
    usage ended up looking something like what you see below.\r\n\r\n```ruby\r\nclass
    ListFormatter < Fatty::Formatter\r\n  format :text do\r\n    def render\r\n      params[:data].map
    { |e| \"* #{e}\" }.join(\"\\n\")\r\n    end\r\n  end\r\n\r\n  format :html do\r\n
    \   def render\r\n      list_elements = params[:data].map { |e| \"<li>#{e}</li>\"
    }.join\r\n      \"<ul>#{list_elements}</ul>\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWith
    some formats defined, the ListFormatter class can be used in the following manner.\r\n\r\n```ruby\r\n
    \ data = %w[foo bar baz]\r\n  [:html, :text].each do |format|\r\n    puts ListFormatter.render(format,
    :data => data)\r\n  end\r\n```\r\n\r\nOUTPUTS:\r\n\r\n```\r\n  * foo\r\n  * bar\r\n
    \ * baz\r\n  <ul><li>foo</li><li>bar</li><li>baz</li></ul>   \r\n```\r\n\r\nWhile
    this all may look a bit magical on the surface, the implementation is just a few
    lines of relatively dull dynamic Ruby code.\r\n\r\n```ruby\r\nmodule Fatty\r\n
    \ class Formatter\r\n    \r\n    class << self    \r\n      def formats\r\n        @formats
    ||= {}\r\n      end\r\n    \r\n      def format(name, options={}, &block)\r\n
    \       formats[name] = Class.new(Fatty::Format, &block)\r\n      end\r\n        \r\n
    \     def render(format, params={})        \r\n        format_obj = formats[format].new\r\n
    \       format_obj.params = params\r\n        format_obj.render\r\n      end   \r\n
    \   end\r\n  end\r\n  \r\n  class Format\r\n    attr_accessor :params \r\n  end\r\nend\r\n```\r\n\r\nThe
    bulk of this code looks like my Multiton example, albeit one that operates on
    anonymous Class objects. But instead of focusing on that detail, you should turn
    your attention to the `render()`, which is where the builder process comes in.\r\n\r\nEach
    time render is called, a new instance of an anonymous Format subclass is created,
    and then customized. The params attribute is set and the render method is called
    to return the finally constructed object, our output data. As long as each format
    object that is implements all the required steps, they can be used interchangeably,
    which is the key feature that the Builder pattern emphasizes.\r\n\r\nThis example
    perhaps would be more convincing if you took a look at it in its real setting,
    in which I do things like call a validations hook, mix in helper methods to the
    format instances, and otherwise perform more interesting operations. But since
    we're running on the long side already with this article, I'll invite you to investigate
    this on your own by checking out [the source code](https://github.com/sandal/fatty)
    I wrote a couple years ago for this experiment.\r\n\r\nIt's worth noting that
    this isn't a perfect example of Builder because I think the pattern doesn't apply
    directly to Ruby, and that the code I've demonstrated is a bit of a hack. But
    it might be a good conversation starter at least for those who are interested
    in investigating this pattern further, since it tries to attack a problem that
    the Builder pattern would be well suited for in a static language.\r\n\r\n###
    Prototype \r\n\r\nI've included a reference to the [Prototype pattern](http://en.wikipedia.org/wiki/Prototype_pattern)
    here for completeness, but unfortunately am unsure whether or not it is remotely
    applicable to Ruby. The purpose of the Prototype pattern is to provide an alternative
    to manually constructing new objects by allowing for customization through the
    cloning of existing objects. Presumably this is a good idea when the setup of
    an object is more costly than it would be to create a copy of the initial post-processed
    data. However, I'm coming up with a hard time seeing when this approach would
    be better than ordinary object composition combined with some side effects free
    operations done on the source data.\r\n\r\nI think what's interesting about the
    Prototype pattern is that it gives you a different way of looking at object oriented
    programming which allows you to envision an object system without needing the
    concept of classes. There are two languages I know of that are specifically designed
    to implement that kind of environment, [Self](http://en.wikipedia.org/wiki/Self_%28programming_language%29)
    and [Io](http://en.wikipedia.org/wiki/Io_%28programming_language%29).\r\n\r\nBecause
    I feel out of my depth when it comes to suggesting a good use of this pattern
    in Ruby, I welcome readers to submit their own ideas. Personally, I feel like
    this pattern isn't a good fit for Ruby, but I could be wrong and would love to
    see evidence of my own ignorance!\r\n\r\n### Reflections\r\n\r\nEvery example
    I've shown in this article reflects a design approach that I feel is elegant compared
    to the obvious alternatives. But each and every one of them requires a lot of
    explanation and assume more than a fair bit of Ruby and object oriented programming
    knowledge. For this reason, it always baffles me when beginners or even some intermediate
    developers bother to learn about patterns at all. Since they don't really make
    sense to think about until you run into fairly complex problems, and when you
    do need to apply them you need to be very careful not to overengineer things,
    they seem like a tool to be used sparingly by strongly skilled developers rather
    than gratuitously by the masses.\r\n\r\nThat said, I think that it's nice to be
    able to recognize a pattern when you see it, regardless what your level of experience
    is. It's also good to have at least a working knowledge of how to implement patterns
    so that when someone is discussing design with you, you can have a common vocabulary
    to work with. For these reasons, the study of patterns might be relevant to all
    active developers.\r\n\r\nWhile there are clearly lots of different ways to abstract
    object creation, there are even more ways to create interesting compositions of
    object clusters. In the next article we'll explore that topic by looking at the
    structural design patterns.\r\n  \r\n> **NOTE:** This article has also been published
    on the Ruby Best Practices blog. There [may be additional commentary](http://blog.rubybestpractices.com/posts/gregory/059-issue-25-creational-design-patterns.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: structural-design-patterns
  :title: Structural Design Patterns
  :summary: Examine a use case for each of the classic structural design patterns
    laid out by the Gang of Four.
  :published: 2011-02-28 00:00:00.000000000 Z
  :issue_number: '1.26'
  :volume: 1
  :body: "In this two part series, I've been looking at the classical design patterns
    laid out by the Gang of Four and exploring their relevance to modern day Ruby
    programming. Rather than teaching the design patterns themselves, my goal is to
    give practical examples using real code so that you can consider what the strengths
    and weaknesses of these techniques are.\r\n\r\nIn this issue, I'll be focusing
    on the structural design patterns, all of which have to do with the relationships
    between clusters of code. The seven patterns listed below are the ones we'll focus
    on in this article.\r\n\r\n  * Adapter\r\n  * Bridge\r\n  * Composite\r\n  * Proxy\r\n
    \ * Decorator\r\n  * Facade\r\n  * Flyweight\r\n\r\nAn important thing to keep
    in mind is that while the original GoF book was written with C++ and Smalltalk
    examples, none of the patterns were written with Ruby's semantics in mind. This
    makes it necessary to use a little poetic license to explore how these patterns
    apply in Ruby. That having been said, the examples we'll look at attempt to preserve
    the spirit of the patterns they implement even if they're not semantically identical.\r\n\r\n###
    Adapter \r\n\r\nAn [Adapter](http://en.wikipedia.org/wiki/Adapter_pattern) is
    used when you want to provide a unified interface to a number of different objects
    that implement similar functionality. This pattern is easy to spot in the wild
    for a Ruby developer, as most of us have to use ActiveRecord in our day to day
    work. Under the hood, ActiveRecord talks to a large amount of different databases,
    but wraps them up in a common interface its implementation code can avoid worrying
    about their individual differences. This is exactly the sort of thing the Adapter
    pattern is useful for.\r\n\r\nIncreasingly, Rubyists are finding this pattern
    to be useful in other settings as well. In particular, things like Intridea's
    [multi_json](https://github.com/intridea/multi_json) gem allow libraries and applications
    to be built against an abstract interface rather than requiring some particular
    JSON library that might conflict with other dependencies. Inspired by the ideas
    behind multi_json, a Mendicant University student (Mitko Kostov) built a similar
    adapter library for Markdown processors called [Marky](https://github.com/mytrile/marky).
    The base implementation is very simple, and gives us a good opportunity to look
    at one way to implement an Adapter in Ruby from the ground up.\r\n\r\nThe basic
    idea is that we want to be able to use a common interface while easily\r\nconfiguring
    which backend is used. The following example shows how Marky might\r\nbe used:\r\n\r\n```ruby
    \ \r\n# using RDiscount as a backend\r\nMarky.adapter = :rdiscount\r\n\r\nMarky.to_html(\"hello
    world\") #=> \"<p>hello world</p>\r\n\r\n# using BlueCloth as a backend\r\nMarky.adapter
    = :bluecloth\r\n\r\nMarky.to_html(\"hello world\") #=> \"<p>hello world</p>\"\r\n```\r\n\r\nTo
    make this work, it is necessary to map the name of an adapter to a class which
    wraps the underlying engine and implements a `to_html()` method. The code that
    actually wires up the adapter is shown below.\r\n\r\n```ruby\r\nmodule Marky\r\n
    \ extend self\r\n\r\n  def adapter\r\n    return @adapter if @adapter\r\n    self.adapter
    = :rdiscount\r\n    @adapter\r\n  end\r\n   \r\n  def adapter=(adapter_name)\r\n
    \   case adapter_name\r\n    when Symbol, String\r\n      require \"adapters/#{adapter_name}\"\r\n
    \     @adapter = Marky::Adapters.const_get(\"#{adapter_name.to_s.capitalize}\")\r\n
    \   else\r\n      raise \"Missing adapter #{adapter_name}\"\r\n    end\r\n  end\r\n\r\n
    \ def to_html(string)\r\n    adapter.to_html(string)\r\n  end\r\nend\r\n```\r\n\r\nWhile
    this uses a tiny bit of dynamic Ruby magic to look up the right module name, when
    we see the actual adapters, it all comes together.\r\n\r\n```ruby\r\n# adapters/bluecloth.rb\r\n\r\nrequire
    \"bluecloth\"\r\n\r\nmodule Marky\r\n  module Adapters\r\n    module Bluecloth\r\n
    \     extend self\r\n      def to_html(string)\r\n        ::BlueCloth.new(string).to_html\r\n
    \     end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\n# adapters/rdiscount.rb\r\n\r\nrequire
    \"rdiscount\"\r\n\r\nmodule Marky\r\n  module Adapters\r\n    module Rdiscount\r\n
    \     extend self\r\n      def to_html(string)\r\n        ::RDiscount.new(string).to_html\r\n
    \     end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nSince all the adapters implement
    a `to_html()` method that share a common\r\ncontract, `Marky.to_html()` will work
    regardless of what adapter gets loaded.\r\nThe win here is that if that libraries,
    applications and frameworks rely on\r\nadapters rather than concrete implementations,
    it will be easier to swap\r\none engine out for another when necessary.\r\n\r\nWhile
    not every problem domain needs added level of indirection that Adapters introduce,
    they can come in handy when there are several competing implementations solving
    a common problem but you don't want to forced to choose one over the other.\r\n\r\n###
    Bridge\r\n\r\nThe idea behind a [Bridge](http://en.wikipedia.org/wiki/Bridge_pattern)
    is to place a physical separation between the interface of a given type of object
    and its implementation. In languages in which the type system gets in the way,
    this kind of pattern is important for reducing the proliferation of various type
    permutations by making hierarchies of interfaces and implementations orthogonal
    to one another. If that sounds like academic jibberish to you, there is a [SourceMaking
    article](http://sourcemaking.com/design_patterns/bridge) that might help sort
    the concepts out for you a bit.\r\n\r\nI had a hard time thinking through where
    this pattern has its place in Ruby, mainly because there is a built in separation
    of interface and implementation in Ruby via duck typing semantics. The best example
    I could come up with was to port the painfully complex C++ example that SourceMaking
    uses in their article to something that is a bit more natural looking in Ruby.
    Read it over, and think about what it might be gaining us as you go.\r\n\r\n```ruby\r\n##Concrete
    Implementations\r\n\r\nclass BasicTimeData\r\n  def initialize(hour, minutes)\r\n
    \   @hour     = hour\r\n    @minutes  = minutes\r\n  end\r\n\r\n  def formatted_output\r\n
    \   \"Time is #{@hour}:#{@minutes}\"\r\n  end\r\nend\r\n\r\nclass TimeWithMeridianData\r\n
    \ def initialize(hour, minutes, meridian)\r\n    @hour     = hour\r\n    @minutes
    \ = minutes\r\n    @meridian = meridian\r\n  end\r\n\r\n  def formatted_output\r\n
    \   \"Time is #{@hour}:#{@minutes} #{@meridian}\"\r\n  end\r\nend\r\n\r\n##Bridge\r\n\r\nmodule
    TimeFormatter\r\n  def to_s\r\n    @time_data.formatted_output\r\n  end\r\nend\r\n\r\n##
    Abstract Objects linked to Concrete Implementations through Bridge\r\n\r\nclass
    BasicTime\r\n  include TimeFormatter\r\n  \r\n  def initialize(*a, &b)\r\n    @time_data
    = BasicTimeData.new(*a, &b)    \r\n  end\r\nend\r\n\r\nclass TimeWithMeridian\r\n
    \ include TimeFormatter\r\n\r\n  def initialize(*a, &b)\r\n    @time_data = TimeWithMeridianData.new(*a,
    &b)\r\n  end\r\nend\r\n\r\n## Example Usage\r\n\r\ntime1  = BasicTime.new(\"10\",\"30\")\r\ntime2
    \ = TimeWithMeridian.new(\"10\",\"30\",\"PM\")\r\n\r\n[time1, time2].each { |t|
    puts t }\r\n```\r\n\r\nWhile it might just due to the nature of the example, I
    feel this code is still quite contrived, and that hides its benefits. The takeway
    here is mostly that it's possible for both `BasicTimeData` and `TimeWithMeridianData`
    to change without breaking `BasicTime` and `TimeWithMeridian`, as long as `TimeFormatter`
    is updated. Similarly, a change in the needs of `BasicTime` and `TimeWithMeridian`
    will not affect the concrete implementations of the data structures, as long as
    the bridge provides the necessary wiring.\r\n\r\nThe thing that I struggle with
    in this pattern is understanding what unique behaviors the `BasicTime` and `TimeWithMeridian`
    objects could implement that justify their existence. Is this pattern an artifact
    of static languages that isn't really needed in Ruby? Or am I just missing some
    important detail that could be cleared up with a good example or two? Feel free
    to leave a comment letting me know what you think.\r\n\r\n### Composite \r\n\r\nThe
    [Composite pattern](http://en.wikipedia.org/wiki/Composite_pattern) is useful
    when you want to treat a group of objects as if it were a single, unified object.
    To explore this pattern, we can look at some experimental code I wrote for Prawn
    which was designed to make it possible to treat all objects drawn in the document
    as compositions of primitive PDF instructions. We can start with an example of
    rendering a curve, working from the outside in.\r\n\r\nWhen `curve()` is called
    on a Prawn drawing, the PDF content is generated as a\r\nside effect and the user
    does not need to do anything with the return value of\r\nthat method. However,
    if someone wanted to play with the internals, they could\r\ncall `curve!()` instead
    and get themselves an object that implements a\r\n`to_pdf()` method, as in the
    following example:\r\n\r\n```ruby\r\nchunk = canvas.curve!(:point1 => [100,100],\r\n
    \                     :point2 => [50,50], \r\n                      :bound1 =>
    [60,90],\r\n                      :bound2 => [60,90])\r\n\r\nputs chunk.to_pdf\r\n\r\n...........................................................OUTPUTS..\r\n\r\n
    \ 100.000 100.000 m\r\n  60.000 90.000 60.000 90.000 50.000 50.000 c\r\n```\r\n\r\nWe
    can catch a glimpse of how this `to_pdf()` method is actually implemented via
    several composed primitive objects by taking a look at the source for the `curve!()`
    method.\r\n\r\n```ruby\r\ndef curve!(params)\r\n  chunk(:curve, params) do |c|\r\n
    \   [ move_to!(:point => c[:point1]),\r\n      curve_to!(:point => c[:point2],\r\n
    \               :bound1 => c[:bound1],\r\n                :bound2 => c[:bound2])
    ]\r\n\r\n  end\r\nend\r\n```\r\n\r\nIn the above, `chunk()` is a helper method
    which builds a `Prawn::Core::Chunk` object, which serves as the composite object
    in this system. We'll look at how chunks are implemented in a bit, but note that
    the block given to the `chunk()` method defines what the individual chunk is composed
    of. In this case, a curve consists of two subchunks, one responsible for generating
    a move instruction, and one for rendering a curve from the current drawing location
    to another point. The definitions for both of those methods are shown below.\r\n\r\n```ruby\r\ndef
    move_to!(params)\r\n  chunk(:move_to, params) do |c|\r\n    raw_chunk(\"%.3f %.3f
    m\" % c[:point])\r\n  end\r\nend\r\n\r\ndef line_to!(params)\r\n  chunk(:line_to,
    params) do |c|\r\n    raw_chunk(\"%.3f %.3f l\" % c[:point])\r\n  end\r\nend\r\n```\r\n\r\nSimilar
    to `chunk!()`, these methods can called directly, producing an object with a `to_pdf()`
    method, as shown below.\r\n\r\n```ruby\r\nchunk = canvas.move_to!(:point => [100,100])\r\nputs
    chunk.to_pdf\r\n\r\nchunk2 = canvas.curve_to!(:point => [50,50],\r\n                          :bound1
    => [60,90],\r\n                          :bound2 => [60,90])\r\n\r\nputs chunk2.to_pdf\r\n\r\n#
    combined output is identical to calling curve!() directly.\r\n```\r\n\r\nThrough
    these two methods, we encounter the leaf nodes in our composition, `Prawn::Core::RawChunk`
    objects. These objects are where the actual text that is in our `to_pdf()` is
    stored. With that in mind, we can now look at the actual objects that this graphics
    system is built on.\r\n\r\n```ruby\r\nmodule Prawn\r\n  module Core\r\n    class
    RawChunk\r\n      def initialize(content)\r\n        @content = content\r\n        @command
    = :raw_pdf_text\r\n        @params = {}\r\n      end\r\n\r\n      attr_accessor
    :content, :command, :params\r\n      alias_method :to_pdf, :content\r\n    end\r\n\r\n
    \   class Chunk\r\n      def initialize(command, params={}, &action)\r\n        @command
    = command\r\n        @params = params\r\n        @action = action\r\n      end\r\n\r\n
    \     attr_reader :command, :params, :action\r\n\r\n      def content\r\n        action.call(self)\r\n
    \     end\r\n\r\n      def to_pdf\r\n        case results = content\r\n        when
    Array\r\n          results.map { |sub_chunk| sub_chunk.to_pdf }.join(\"\\n\")\r\n
    \       when Prawn::Core::Chunk, Prawn::Core::RawChunk\r\n          results.to_pdf\r\n
    \       else\r\n          raise \"Bad Chunk: #{results.class} not supported\"\r\n
    \       end\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nFrom this we
    see that a chunk's content can be an array of children, a chunk, or a raw chunk
    object. The `to_pdf()` method is responsible for traversing downwards through
    the composition until it reaches the raw chunk objects which simply return the
    raw content. But because the APIs match, we can look at the chunks at any level
    of the system and burrow down to their raw data.\r\n\r\nWhile this might be a
    bit of an intense example, it shows how the Composite pattern can be used to make
    a complex set of objects look and feel as if they were a single unified entity.
    It may be a bit much to take in on a first glance, but try to think of how you
    could apply these ideas to your own code and you might gain some useful insights.\r\n\r\n###
    Proxy\r\n\r\nA [Proxy](http://en.wikipedia.org/wiki/Proxy_pattern) is any object
    that acts as a drop-in replacement object that does a bit of work and then delegates
    to some other underlying object. This is another pattern that's easy to recognize
    for Rails developers, because it is used extensively in ActiveRecord associations
    support. The following example shows a typical interaction between a base model
    and one of its associations.\r\n\r\n```ruby\r\nquiz = Quiz.first\r\nquiz.questions.class
    #=> Array\r\n\r\nquiz.questions.count #=> 10\r\n\r\nquiz.questions.create(:question_text
    => \"Who is the creator of Ruby?\",\r\n                      :answer        =>
    \"Matz\")\r\n\r\nquiz.questions.count #=> 11\r\n\r\nquiz.questions[-1].answer
    #=> \"Matz\" \r\n```\r\n\r\nWhile the questions association claims to be an array,
    it also provides some of the common helpers found in `ActiveRecord::Base`. If
    we stick to the core idea and ignore some of the Rails specific details, creating
    such an association proxy is fairly easy to do using Ruby's delegate standard
    library. The code below more or less does the trick.\r\n\r\n```ruby\r\nrequire
    \"delegate\"\r\n\r\nclass Quiz\r\n  def questions\r\n    @questions                  ||=
    HasManyAssociation.new([])\r\n    @questions.associated_class ||= Question\r\n\r\n
    \   @questions\r\n  end\r\nend\r\n\r\nclass Question\r\n  def initialize(params)\r\n
    \   @params = params\r\n  end\r\n\r\n  attr_reader :params\r\n\r\n  def answer\r\n
    \   params[:answer]\r\n  end\r\nend\r\n\r\nclass HasManyAssociation < DelegateClass(Array)\r\n
    \ attr_accessor :associated_class\r\n\r\n  def initialize(array)\r\n    super(array)\r\n
    \ end\r\n\r\n  def create(params)\r\n    self << associated_class.new(params)\r\n
    \ end\r\nend\r\n\r\nquiz = Quiz.new\r\n\r\n# grab the proxy object\r\nquestions
    = quiz.questions\r\n\r\n\r\n# use custom create() method on proxy object\r\n\r\nquestions.create(:question_text
    => \"Who is the creator of Ruby?\",\r\n                 :answer        => \"Matz\")\r\nquestions.create(:question_text
    => \"Who is the creator of Perl?\",\r\n                 :answer        => \"Larry
    Wall\")\r\n\r\n\r\n# use array like behavior on proxy object\r\n\r\np questions[0].answer
    #=> \"Matz\"\r\np questions[1].answer #=> \"Larry Wall\"\r\np questions.map {
    |q| q.answer }.join(\", \") #=> \"Matz, Larry Wall\"\r\n```\r\n\r\nInterestingly
    enough, while Ruby provides a standard library for building Proxy objects, most
    people tend to implement them in a different way, through the use of an explicit
    `method_missing()` hook on a blank slate object such as Ruby 1.9's BasicObject.
    For example, we could have written our HasManyAssociation code in the manner shown
    below and things would still work as expected.\r\n\r\n```ruby\r\nclass HasManyAssociation
    < BasicObject\r\n  attr_accessor :associated_class\r\n\r\n  def initialize(array)\r\n
    \   @array = array\r\n  end\r\n\r\n  def create(params)\r\n    self << associated_class.new(params)\r\n
    \ end\r\n\r\n  def method_missing(*a, &b)\r\n    @array.send(*a, &b)\r\n  end\r\nend\r\n```\r\n\r\nWithout
    looking at the source, I'm almost sure that Rails does something similar to this,
    because doing some_association.class returns Array rather than the name of the
    proxy object. This is the only noticeable difference between this approach and
    the DelegateClass approach.\r\n\r\nPersonally, I've written proxies in both ways,
    and I tend to prefer the `DelegateClass()` approach slightly, simply because it's
    more explicit and doesn't require me to explicitly define a `method_missing()`
    hook. But on the other hand, we can see that rolling your own proxy implementation
    is trivial in Ruby, and some may prefer the self contained nature of doing the
    delegation work yourself. It'd be interesting to hear what readers have to say
    on this topic, so please feel free to post to the mailing list if you prefer one
    approach over the other.\r\n\r\n### Decorator\r\n\r\nWhile there is a clear distinction
    between a [Decorator](http://en.wikipedia.org/wiki/Decorator_pattern) and a Proxy
    in static languages, in Ruby the two concepts almost merge, except that a Decorator
    is used for the purpose of adding / extending behavior of a target object, and
    a Proxy is a more general concept.\r\n\r\nSince I've already written up a cool
    example of using decorators on this blog, I think what I'll do is point you over
    there in the interest of keeping this article from being even more incredibly
    long than it already is. Check out the [Decorator Delegator Disco](http://blog.rubybestpractices.com/posts/gregory/008-decorator-delegator-disco.html)
    if you want to see some interesting code samples that implement this pattern.\r\n\r\n###
    Facade\r\n\r\nThe [Facade pattern](http://en.wikipedia.org/wiki/Facade_pattern)
    simplifies how users interact with a codebase by implementing an interface that
    hides many implementation details for the most common behaviors needed by consumers.
    Looking at it from the outside, a perfect example of this is the open-uri standard
    library. When using open-uri, it is possible to do a simple HTTP get request with
    just a single line of code, as shown below.\r\n\r\n```ruby\r\nrequire \"open-uri\"\r\n\r\nputs
    open(\"http://www.google.com\").read\r\n```\r\n\r\nThe purpose of open-uri is
    to make reading a resource via an HTTP GET request look and feel like opening
    an ordinary file. This is a very common use case, so open-uri makes it easy to
    work with. To see what this facade is hiding, we can write the equivalent code
    using the libraries it wraps, `Net::HTTP` and `URI`.\r\n\r\n```ruby\r\nrequire
    'net/http'\r\nrequire 'uri'\r\n\r\nurl = URI.parse('http://www.google.com')\r\n\r\nres
    = Net::HTTP.start(url.host, url.port) {|http|\r\n  http.get('/index.html')\r\n}\r\n\r\nputs
    res.body\r\n```\r\n\r\nWhile the code above isn't especially difficult to read,
    it certainly feels like more work than the previous example. This is primarily
    because of the flexibility and functionality tradeoff between the two approaches.
    The open-uri library can afford to be much more high level and limited in scope
    because its sole purpose is to help make a single particular task easier. On the
    other hand, `Net::HTTP` and `URI` are both complex tools that can be used for
    a number of different things. The use of the Facade pattern allows for both kinds
    of objects to coexist peacefully within a single system.\r\n\r\nIt's worth keeping
    in mind that pretty much every DSL you encounter is a Facade of some form or another.
    If you're interested in seeing how simple interfaces can mask highly complex networks
    of objects, consider doing a source dive into your favorite tool that utilizes
    a domain specific language, such as Rake, RSpec, or Sinatra. You'll find a number
    of different techniques at work depending on which project you explore, but all
    have the common characteristic of providing a simplified way to interact with
    a deep system.\r\n\r\n### Flyweight\r\n\r\nThe [Flyweight pattern](http://en.wikipedia.org/wiki/Flyweight_pattern)
    is a way to represent what would seem like a large amount of data in a lightweight
    way. This is one of those patterns that mostly goes away in Ruby due to built
    in language constructs, but it's worth taking a look at just for the sake of completeness.\r\n\r\nThe
    wikipedia article linked above discusses font metrics as a common application
    of the flyweight pattern, in which you may want to associate each character in
    a string with a large amount of information describing how that character should
    be rendered. The basic idea is that it'd be far too inefficient memory-wise to
    create a new instance of font metrics data for every character in a document.
    So instead, using the Flyweight pattern, it is possible to map the index of characters
    in a string to a single instance for each unique character, vastly reducing the
    amount of memory consumed. This is a problem I've actually had to solve before
    within Prawn, but it's a bit of a tough one demonstrate briefly if we attempt
    to show real code.\r\n\r\nHowever, if we stub out the actual font metrics generation,
    it's easy to see that this problem can be solved by wrapping a simple Ruby hash
    that has an initializer block.\r\n\r\n```ruby\r\nclass FontMetrics\r\n\r\n  def
    initialize(string)\r\n    @string = string\r\n  end\r\n\r\n  def [](index)\r\n
    \   glyph_data[@string[index]]\r\n  end\r\n\r\n  def glyph_data\r\n    @glyph_data
    ||= Hash.new { |h,k| h[k] = metrics_for(k) }\r\n  end\r\n\r\n  # stubbed out,
    but would typcially refer to something\r\n  # largish and time consuming to generate\r\n
    \ # \r\n  def metrics_for(k)\r\n    { :bbox => [rand(100), rand(100), rand(100),
    rand(100)] }\r\n  end\r\n\r\nend\r\n\r\nstring = \"Hello World\"\r\n\r\nmetrics
    = FontMetrics.new(string)\r\n\r\np metrics[0]  #=> {:bbox=>[86, 44, 88, 31]}\r\np
    metrics[2]  #=> {:bbox=>[52, 7, 38, 98]}\r\np metrics[3]  #=> {:bbox=>[52, 7,
    38, 98]}\r\np metrics[-2] #=> {:bbox=>[52, 7, 38, 98]}\r\n\r\np metrics[2].object_id
    == metrics[3].object_id #=> true\r\n\r\np metrics[0] == metrics[1] #=> false\r\np
    metrics[2] == metrics[3] #=> true\r\n```\r\n\r\nFrom the above code, we see that
    the `FontMetrics` object gives the appearance of having data for each and every
    character in the string, but checking the `object_id` for each proves that only
    one object per unique character has been created. While I suppose we could call
    this a Flyweight, I think that in Ruby we'd just say that we were caching the
    metrics data using a hash with an initializer. But perhaps using this vocabulary
    wouldn't hurt, if we want to keep our minds focused on the high level concepts.\r\n\r\n###
    Reflections\r\n\r\nAfter writing two articles on the the topic, I'm finding myself
    getting sick of design patterns. But when I look back on the code I've shared
    with you, I realize that when I built these things, I never really thought consciously
    about what pattern they were, and it took me until the time of writing this article
    to put a name on them.\r\n\r\nA major concern I have about classical patterns
    is that in order to see the resemblance of the code I've shared to the original
    GoF patterns, you really need to look at things sideways and squint a bit. It'd
    be great for me to be able to just say 'Use a flyweight here' and have it mean
    something, but if you say that to someone without a strong background in Ruby,
    you may end up with hundreds of lines of a Java-esque monstrosity.\r\n\r\nTo be
    sure, I'm not saying that this exploration has not been worthwhile. Forcing myself
    to think of how many of the classic GoF patterns might materialize themselves
    in Ruby has been a very interesting experience, because it's really making me
    think about how we build and design our code. But the problem of whether we can
    actually have a common vocabulary about concepts that really get distorted in
    translation makes me wonder about the merits of stacking up pattern definitions,
    at least without giving them new names.\r\n\r\nI'm quite curious about what folks
    have been thinking as they read through the last two articles, in particular,
    I wonder if seeing me try to attack patterns from a purely pragmatic perspective
    has changed anything about the way readers look at these concepts. I'm also kind
    of curious if 'that guy' is out there, silently thinking to himself \"Well...
    actually\" after seeing my somewhat liberal interpretation of these classic patterns.
    Please leave a comment letting me know what you think!\r\n  \r\n> **NOTE:** This
    article has also been published on the Ruby Best Practices blog. There [may be
    additional commentary](http://blog.rubybestpractices.com/posts/gregory/060-issue-26-structural-design-patterns.html#disqus_thread)
    \r\nover there worth taking a look at.\r\n"
- :slug: ways-to-load-code
  :title: Ways to load code
  :summary: Explore the strengths and weaknesses of the many code loading mechanisms
    in Ruby.
  :published: 2011-08-23 00:00:00.000000000 Z
  :issue_number: '2.1'
  :volume: 2
  :body: "There are many ways to load Ruby code, and that has lead to confusion over
    the years. In this article, I will give you the backstory behind several conventions
    seen in the wild and share some stories about how I use those conventions in my
    own code.\r\n\r\nThe topic of code loading breaks up naturally into two subtopics:
    loading code\r\nwithin your own project and loading code from third-party libraries.
    People tend\r\nto struggle more with loading code properly within their own projects
    than they\r\ndo with loading code from third-party libraries, so that's what I'll
    focus on\r\nexclusively in this issue.\r\n\r\nFor now, I will focus on the basic
    mechanics of `load()`, `auto_load()`,\r\n`require()`, and `require_relative()`.
    I'll discuss how they work so you can\r\nthen think about how they can be used
    within your own projects.\r\n\r\n### Kernel#load\r\n\r\nSuppose we have a file
    called _calendar.rb_ that contains the code shown here:\r\n\r\n```ruby\r\nclass
    Calendar\r\n  def initialize(month, year)\r\n    @month = month\r\n    @year  =
    year\r\n  end\r\n\r\n  # A simple wrapper around the *nix cal command.\r\n  def
    to_s\r\n    IO.popen([\"cal\", @month.to_s, @year.to_s]) { |io| io.read }\r\n
    \ end\r\nend\r\n\r\nputs Calendar.new(8, 2011)\r\n```\r\n\r\nGiven an absolute
    path to this file, the contents will be loaded and then\r\nexecuted immediately:\r\n\r\n```console\r\n>>
    load \"/Users/seacreature/devel/practicing-ruby-2/calendar.rb\"\r\n    August
    2011\r\nSu Mo Tu We Th Fr Sa\r\n    1  2  3  4  5  6\r\n 7  8  9 10 11 12 13\r\n14
    15 16 17 18 19 20\r\n21 22 23 24 25 26 27\r\n28 29 30 31\r\n```\r\n\r\nI can also
    just specify a path relative to my current working directory and get the same
    results. That means that if _calendar.rb_ is in the same directory from which
    I invoked my irb session, I'm able to call `load()` in the manner shown here:\r\n\r\n```console\r\n>>
    load \"./calendar.rb\"\r\n    August 2011\r\nSu Mo Tu We Th Fr Sa\r\n    1  2
    \ 3  4  5  6\r\n 7  8  9 10 11 12 13\r\n14 15 16 17 18 19 20\r\n21 22 23 24 25
    26 27\r\n28 29 30 31\r\n```\r\n\r\nAn interesting thing about `load()` is that
    it does not do any checks to see\r\nwhether it has already loaded a file and will
    happily reload and reexecute a\r\nfile each time you tell it to. So, in practice,
    the implementation of `load()`\r\nis functionally similar to the code shown here:\r\n\r\n```ruby\r\ndef
    fake_load(file)\r\n  eval File.read(file)\r\n  true\r\nend\r\n```\r\n\r\nThe main
    benefit of indiscriminately reloading and reexecuting code is that you\r\ncan
    make changes to your files and then `load()` them again within a single\r\nsession
    without having to restart the program that's loading the code. So, for\r\nexample,
    if we changed _calendar.rb_ to output August 2012 instead of August\r\n2011, we
    could just load it again without restarting irb. But we'd also be\r\ngreeted with
    some warnings in the process:\r\n\r\n\r\n```console\r\n>> load \"./calendar.rb\"\r\n/Users/seacreature/devel/practicing-ruby-2/calendar.rb:2:
    \r\nwarning: method redefined; discarding old initialize\r\n/Users/seacreature/devel/practicing-ruby-2/calendar.rb:2:
    \r\nwarning: previous definition of initialize was here\r\n/Users/seacreature/devel/practicing-ruby-2/calendar.rb:8:
    \r\nwarning: method redefined; discarding old to_s\r\n/Users/seacreature/devel/practicing-ruby-2/calendar.rb:8:\r\nwarning:
    previous definition of to_s was here\r\nAugust 2012\r\nSu Mo Tu We Th Fr Sa\r\n
    \     1  2  3  4\r\n5  6  7  8  9 10 11\r\n12 13 14 15 16 17 18\r\n19 20 21 22
    23 24 25\r\n26 27 28 29 30 31\r\n```\r\n\r\nIf you remember that Ruby classes
    and modules are permanently open to\r\nmodification, these warnings should make
    a lot of sense. The first time we\r\ncalled `load()`, it defined the `initialize()`
    and `to_s()` methods for the\r\n`Calendar` class. The second time we called `load()`,
    that class and its methods\r\nalready existed, so it redefined them. This is not
    necessarily a sign of a bug,\r\nbut Ruby warns you of the possibility that it
    might be.\r\n\r\nUltimately, these warnings are Ruby telling you that there is
    probably a better\r\nway for you to do what you're trying to do. One interesting
    way to get around\r\nthe problem is to use `Kernel#load()`'s wrap functionality.
    \ Rather than telling\r\nyou directly how it works, I'm going to show you by example
    and see if you can\r\nguess what's going on.\r\n\r\nSuppose we kill our irb session
    and fire up a new one; we're now back to a blank\r\nslate. We then run the following
    code and see the familiar calendar output:\r\n\r\n```console\r\n>> load \"./calendar.rb\",
    true\r\n    August 2012\r\nSu Mo Tu We Th Fr Sa\r\n          1  2  3  4\r\n 5
    \ 6  7  8  9 10 11\r\n12 13 14 15 16 17 18\r\n19 20 21 22 23 24 25\r\n26 27 28
    29 30 31\r\n```\r\n\r\nThen we decide that we want to look a little deeper into
    the future so that we\r\nknow what to plan for in AD 2101. We reload the code
    using the same command as\r\nbefore:\r\n\r\n```console\r\n>> load \"./calendar.rb\",
    true\r\n    August 2101\r\nSu Mo Tu We Th Fr Sa\r\n    1  2  3  4  5  6\r\n 7
    \ 8  9 10 11 12 13\r\n14 15 16 17 18 19 20\r\n21 22 23 24 25 26 27\r\n28 29 30
    31\r\n```\r\n\r\nThis time, we don't see any warnings, so obviously something
    has changed. Here's\r\na clue:\r\n\r\n```console\r\n>> Calendar\r\nNameError:
    uninitialized constant Object::Calendar\r\n  from (irb):2\r\n  from /.../.rvm/rubies/ruby-1.9.2-p180/bin/irb:16:in
    `<main>'\r\n```\r\n\r\nSurely the `Calendar` class must have been defined *somewhere*,
    because the\r\nprogram worked as expected. So what is going on here? Take a look
    at the\r\nfollowing code; it should give you a clearer picture of what is happening:\r\n\r\n```ruby\r\ndef
    fake_load(file)\r\n  Module.new.module_eval(File.read(file))\r\n  true\r\nend\r\n```\r\n\r\nIn
    this implementation, our approximation of `load()` is evaluating the loaded\r\ncode
    in the context of an anonymous module, which essentially wraps everything\r\nits
    own namespace. This step prevents any of the constants defined in the loaded\r\ncode
    from being defined within the global namespace, including any class or\r\nmodule
    definitions.\r\n\r\nThe existence of this option is a hint that although `load()`
    is suitable for\r\ncode loading, it is geared more to implementing customized
    runners for Ruby code\r\nthan to simply loading the classes and modules in your
    projects. So if you've\r\nbeen using `load()` on a daily basis, you might be using
    the wrong tool for the\r\njob at least some of the time. It should be clear by
    the end of this article why\r\nthat is the case.\r\n\r\nNow that we have looked
    at the most simple code loading behavior Ruby has to\r\noffer, we will jump straight
    into the deep end and explore one of its most\r\ncomplex options: loading code
    on demand via `Kernel#autoload`.\r\n\r\n### Kernel#autoload\r\n\r\nRegardless
    of whether you've used it explicitly in your own projects, the\r\nconcept of automatically
    loading code on demand should be familiar to anyone\r\nfamiliar with Rails. In
    Rails, none of the classes or modules you define are\r\nloaded until the first
    time they are referenced in your running program. There\r\nare two main benefits
    to this design: faster startup time and delayed loading of\r\noptional dependencies.\r\n\r\nRails
    uses its own customized code to accomplish this result, but the basic idea\r\nis
    similar to what can be done with Ruby's `autoload()` method. To illustrate\r\nhow
    `autoload()` works, let's revisit our `Calendar` class that we began\r\nbuilding
    while discussing `load()`. This time, we have a file called\r\n_calendar.rb_ that
    contains only the definition of the `Calendar` class, not the\r\ncode that actually
    calls methods on it:\r\n\r\n```ruby\r\nclass Calendar\r\n  def initialize(month,
    year)\r\n    @month = month\r\n    @year  = year\r\n  end\r\n\r\n  # A simple
    wrapper around the *nix cal command.\r\n  def to_s\r\n    IO.popen([\"cal\", @month.to_s,
    @year.to_s]) { |io| io.read }\r\n  end\r\nend\r\n```\r\n\r\nThe following irb
    session demonstrates the behavior of `autoload()`. \r\n\r\n```console\r\n>> autoload(:Calendar,
    \"./calendar.rb\") #1\r\n=> nil\r\n>> defined?(Calendar)                   #2\r\n=>
    nil\r\n>> puts Calendar.new(8,2011)            #3\r\n    August 2011\r\nSu Mo
    Tu We Th Fr Sa\r\n    1  2  3  4  5  6\r\n 7  8  9 10 11 12 13\r\n14 15 16 17
    18 19 20\r\n21 22 23 24 25 26 27\r\n28 29 30 31\r\n\r\n=> nil\r\n>> defined?(Calendar)
    \                  #4\r\n=> \"constant\"\r\n```\r\n\r\nIn our first step, we set
    up the `autoload()` hook, instructing Ruby to load the\r\nfile _calendar.rb_ at
    the time that the first constant lookup happens for the\r\nCalendar constant.
    In the second step, we check to ensure that `autoload()` does\r\nnot actually
    load the file for you automatically by verifying that Calendar has\r\nnot yet
    been defined. Then, in our third step, we build and output our Calendar.\r\nLast,
    we see that the constant is now defined.\r\n\r\nThis exposes us to some cool Ruby
    voodoo while also raising a lot of questions.\r\nIt may help to approximate how
    `autoload()` might be implemented in order to\r\nwrap your head around the idea.
    Although the following code is evil and should\r\nnever be used for anything but
    educational purposes, it simulates the load on\r\ndemand behavior nicely.\r\n\r\n```ruby\r\n$load_hooks
    = Hash.new\r\n\r\nmodule Kernel\r\n  def fake_autoload(constant_name, file_name)\r\n
    \   $load_hooks[constant_name] = file_name\r\n  end\r\nend\r\n\r\ndef Object.const_missing(constant)\r\n
    \ load $load_hooks[constant]\r\n  const_get(constant)\r\nend\r\n\r\nfake_autoload
    :Calendar, \"./calendar.rb\"\r\np defined?(Calendar)\r\nputs Calendar.new(8,2011)\r\np
    defined?(Calendar)\r\n```\r\n\r\nAfter reading the previous example code and playing
    with it a bit, remember the\r\ndependency on `const_missing()` and forget pretty
    much everything else about the\r\nimplementation. The real `autoload()` handles
    a lot more cases than this trivial\r\nexample gives it credit for.\r\n\r\nWith
    the `const_missing()` dependency in mind, try to guess what will happen\r\nwhen
    the following code is run:\r\n\r\n```ruby\r\nclass Calendar; end\r\n\r\nautoload
    :Calendar, \"./calendar.rb\"\r\np defined?(Calendar)\r\nputs Calendar.new(8,2011)\r\np
    defined?(Calendar)\r\n```\r\n\r\nIf you guessed that it didn't output a nicely
    formatted calendar, you guessed\r\ncorrectly. Below you can see that when I run
    this script, all the code in\r\n_calendar.rb_ never gets loaded, so the default
    `Object#initialize` and\r\n`Object#to_s` are being called instead:\r\n\r\n```console\r\n\"constant\"\r\n<Calendar:0x0000010086d6b0>\r\n\"constant\"\r\n```\r\n\r\nBecause
    `autoload()` does not check to see whether a constant is already defined\r\nwhen
    it registers its hook, you do not get an indication that the _calendar.rb_\r\nfile
    was never loaded until you actually try to use functionality defined in\r\nthat
    file. Thus `autoload()` is safe to use only when there is a single, uniform\r\nplace
    where a constant is meant to be defined; it cannot be used to\r\nincrementally
    build up class or module definitions from several different source\r\nfiles.\r\n\r\nThis
    sort of rigidity is frustrating, because unlike load(), which does not care\r\nhow
    or where you define your code, `autoload()` is much more opinionated. What\r\nyou've
    seen here is a single example of the constraints it puts on you, but it\r\nis
    easy to imagine other scenarios in which `autoload()` can feel like a brittle\r\nway
    to load code. I'll leave it up to you to try to figure out some of those\r\nissues,
    but feel free to ask me for some hints if you get stumped.\r\n\r\nIn the context
    of Railsparticularly when working in development mode, in which\r\nthe whole
    environment gets reloaded on every requestsome form of automatic\r\nloading makes
    sense. However, outside of that environment, the drawbacks of\r\n`autoload()`
    tend to outweigh the benefits, so most Ruby projects tend to avoid\r\nit entirely
    by making heavy use of `require()`.\r\n\r\n### Kernel#require()\r\n\r\nIf you've
    written any code at all outside of Rails, odds are you've used\r\n`require()`
    before. It is actually quite similar to `load()` but has a few\r\nadditional features
    that come in handy. To illustrate how `require()` works,\r\nlet's revisit our
    original _calendar.rb_ file, the one that had a bit of code to\r\nbe executed
    in the end of it.\r\n\r\n```ruby\r\nclass Calendar\r\n  def initialize(month,
    year)\r\n    @month = month\r\n    @year  = year\r\n  end\r\n\r\n  # A simple
    wrapper around the *nix cal command.\r\n  def to_s\r\n    IO.popen([\"cal\", @month.to_s,
    @year.to_s]) { |io| io.read }\r\n  end\r\nend\r\n\r\nputs Calendar.new(8, 2011)\r\n```\r\n\r\nIf
    we attempt to load this code twice via `require()`, we immediately see an\r\nimportant
    way in which it differs from `load()`.\r\n\r\n```console\r\n>> require \"./calendar.rb\"
    #1\r\n    August 2011\r\nSu Mo Tu We Th Fr Sa\r\n    1  2  3  4  5  6\r\n 7  8
    \ 9 10 11 12 13\r\n14 15 16 17 18 19 20\r\n21 22 23 24 25 26 27\r\n28 29 30 31\r\n\r\n=>
    true\r\n>> require \"./calendar.rb\" #2\r\n=> false\r\n```\r\n\r\nWhen I ran `require()`
    the first time, the familiar calendar output greeted me,\r\nand then the function
    returned a true value. The second time I ran it, nothing\r\nhappened and the function
    returned false. This is a feature, and not a bug. The\r\nfollowing code is a crude
    approximation of what is going on under the hood in\r\n`require()`:\r\n\r\n```ruby\r\n$LOADED_BY_FAKE_REQUIRE
    = Array.new\r\n\r\ndef fake_require(file)\r\n  full_path = File.expand_path(file)\r\n
    \ return false if $LOADED_BY_FAKE_REQUIRE.include?(full_path)\r\n\r\n  load full_path\r\n
    \ $LOADED_BY_FAKE_REQUIRE << full_path\r\n\r\n  return true\r\nend\r\n```\r\n\r\nThis
    behavior ensures that each file loaded by `require()` is loaded exactly\r\nonce,
    even if the `require()` calls appear in many places. Therefore, updates to\r\nthose
    files will take effect after they have been loaded once. Although this\r\nbehavior
    makes `require()` less suitable than `load()` for quick exploratory\r\ncode loading,
    it does prevent programs from needlessly reloading the same code\r\nagain and
    again, similar to how `autoload()` works once a constant has been\r\nloaded.\r\n\r\nAnother
    interesting property of `require()` is that you can omit the file\r\nextension
    when loading your code. Thus `require(\"./calendar\")` will work just as\r\nwell
    as `require(\"./calendar.rb\")`. Though this may seem like a small feature,\r\nthe
    reason it exists is that Ruby can load more than just Ruby files.\r\nWhen you
    omit an extension on a file loaded with `require()`, it will attempt to\r\nload
    the file with the \".rb\" extension first, but will then cycle through the\r\nfile
    extensions used by C extensions as well, such as \".so\", \".o\", and \".dll\".\r\nDespite
    being an obscure property, it's one that we often take for\r\ngranted when we
    load certain standard libraries or third-party gems. This\r\nbehavior is another
    detail that separates `require()` from `load()`, as the\r\nlatter can work only
    with explicit file extensions.\r\n\r\nThe main benefit of using `require()` is
    that it provides the explicit,\r\npredictable loading behavior of `load()` with
    the caching functionality of\r\n`autoload()`. It also feels natural for those
    who use RubyGems, as the standard\r\nway of loading libraries distributed as gems
    is via the patched version of\r\n`Kernel#require()` that RubyGems provides.\r\n\r\nUsing
    `require()` will take you far, but it suffers from a pretty irritating\r\nproblemshared
    by `load()` and `autoload()`with the way it looks up files. The\r\n`require_relative()`
    is meant to solve that problem, so we'll take a look at it\r\nnow.\r\n\r\n###
    Kernel#require_relative()\r\n\r\nEach time I referenced files using a relative
    path in the previous examples, I\r\nwrote the path to explicitly reference the
    current working directory. If you're\r\nused to using Ruby 1.8, this may come
    as a surprise to you. If you've been using\r\nRuby 1.9.2, it may or may not appear
    to be the natural thing to do. However, now\r\nis the time when I confess that
    it's almost always the wrong way to go about\r\nthings.\r\n\r\nRuby 1.9.2 removes
    the current working directory from your path by default for\r\nsecurity reasons.
    So, in our previous example, if we attempted to write\r\n`require(\"calendar\")`
    instead of `require(\"./calendar\")`, it would fail on Ruby\r\n1.9.2 even if we
    invoked irb in the same folder as the _calendar.rb_ file.\r\nExplicitly referencing
    the current working directory works on both Ruby 1.8.7\r\nand Ruby 1.9.2, which
    is why this convention was born. Unfortunately, it is an\r\nantipattern, because
    it forces us to assume that our code will be run from a\r\nparticular place on
    the file system.\r\n\r\nImagine a more typically directory structure, such as
    this:\r\n\r\n\r\n```console\r\nlib/\r\n  calendar.rb\r\n  calendar/\r\n    month.rb\r\n
    \   year.rb\r\nbin/\r\n  calendar.rb\r\n```\r\n\r\nWe could have a _bin/ruby_calendar.rb_
    file that looks like this code:\r\n\r\n```ruby\r\nrequire \"lib/calendar\"\r\n\r\ncase
    ARGV.size\r\nwhen 2\r\n  puts Calendar::Month.new(ARGV[0], ARGV[1])\r\nwhen 1\r\n
    \ puts Calendar::Year.new(ARGV[0])\r\nelse\r\n  raise \"Invalid arguments\"\r\nend\r\n```\r\n\r\nSimilarly,
    our _lib/calendar.rb file_ might include `require()` calls such as\r\nthese:\r\n\r\n```ruby\r\nrequire
    \"lib/calendar/year\"\r\nrequire \"lib/calendar/month\"\r\n```\r\n\r\nNow if we
    run _bin/ruby_calendar.rb_ from the project root, things will work as\r\nexpected.\r\n\r\n```bash\r\n$
    ruby bin/ruby_calendar.rb 2011\r\n# ...\r\n```\r\n\r\nBut if we ran this file
    from any other directory, it'd fail to work as expected\r\nbecause the relative
    paths would be evaluated relative to wherever you executed\r\nthe files from,
    not relative to where the files live on the file system. That\r\nis, if you execute
    _ruby_calendar.rb_ in the _bin/_ folder, it would look for a file\r\ncalled _bin/lib/calendar.rb_.\r\n\r\nOne
    way to solve this problem is to use the same mechanism that the Ruby\r\nstandard
    library and RubyGems uses: modify the loadpath.\r\n\r\nIn _bin/ruby_calendar.rb_,
    we rewrite our code to match this:\r\n\r\n```ruby\r\n$LOAD_PATH.unshift(\"#{File.dirname(__FILE__)}/../lib\")\r\nrequire
    \"calendar\"\r\n\r\ncase ARGV.size\r\nwhen 2\r\n  puts Calendar::Month.new(ARGV[0],
    ARGV[1])\r\nwhen 1\r\n  puts Calendar::Year.new(ARGV[0])\r\nelse\r\n  raise \"Invalid
    arguments\"\r\nend\r\n```\r\n\r\nBecause we've added the _lib/_ folder to the
    lookup path for all `require()`\r\ncalls in our application, we can modify _lib/calendar.rb_
    to match the\r\nfollowing:\r\n\r\n```ruby\r\nrequire \"calendar/year\"\r\nrequire
    \"calendar/month\"\r\n```\r\n\r\nThis approach makes it possible to run the _ruby_calendar.rb_
    program from any\r\nlocation within the file system, as long as we tell ruby where
    to find it. That\r\nmeans you can run it directly from within the _bin/_ folder,
    or even with an\r\nabsolute path.\r\n\r\n\r\n```bash\r\n# NOTE: this is common
    in cron jobs.\r\n$ ruby /Users/seacreature/devel/ruby_calendar/bin/ruby_calendar.rb\r\n```\r\n\r\nThis
    approach works, and was quite common in Ruby for some time. Then, people\r\nbegan
    to get itchy about it, because it is definitely overkill. It effectively\r\nadds
    an entire folder to the `$LOAD_PATH`, giving Ruby one more place it has to\r\nlook
    on every require and possibly leading to unexpected naming conflicts\r\nbetween
    libraries.\r\n\r\nThe solution to that problem is to not mess with the `$LOAD_PATH`
    in your code.\r\nTherefore, you expect either that the `$LOAD_PATH` variable will
    be properly set\r\nby the `-I` flag when you invoke ruby or irb, or that you have
    to write code\r\nthat dynamically determines the proper relative paths to require
    based on your\r\ncurrent working directory. The latter approach requires less
    effort from the end\r\nuser but makes your code ugly. Below you'll see what people
    resorted to on Ruby\r\n1.8 before a better solution came along:\r\n\r\n\r\n```ruby\r\n#
    bin/ruby_calendar.rb\r\nrequire \"#{File.dirname(__FILE__)}/../lib/calendar\"\r\n\r\ncase
    ARGV.size\r\nwhen 2\r\n  puts Calendar::Month.new(ARGV[0], ARGV[1])\r\nwhen 1\r\n
    \ puts Calendar::Year.new(ARGV[0])\r\nelse\r\n  raise \"Invalid arguments\"\r\nend\r\n\r\n#
    lib/calendar.rb\r\nrequire \"#{File.dirname(__FILE__)}/calendar/year\"\r\nrequire
    \"#{File.dirname(__FILE__)}/calendar/month\"\r\n```\r\n\r\nUsing this approach,
    you do not add anything to the `$LOAD_PATH` but instead\r\ndynamically build up
    relative paths by referencing the `__FILE__` variable and\r\ngetting a path to
    the directory it's in. This code will evaluate to different\r\nvalues depending
    on where you run it from, but in the end, the right path will\r\nbe produced and
    things will just work.\r\n\r\nPredictably, people took efforts to hide this sort
    of ugliness behind helper\r\nfunctions, and one such function was eventually adopted
    into Ruby 1.9. That\r\nhelper is predictably called `require_relative()`. Using
    `require_relative()`,\r\nwe can simplify our calls significantly while preserving
    the \"don't touch the\r\n`$LOAD_PATH` variable\" ethos:\r\n\r\n\r\n```ruby\r\n#
    bin/ruby_calendar.rb\r\nrequire_relative \"../lib/calendar\"\r\n\r\ncase ARGV.size\r\nwhen
    2\r\n  puts Calendar::Month.new(ARGV[0], ARGV[1])\r\nwhen 1\r\n  puts Calendar::Year.new(ARGV[0])\r\nelse\r\n
    \ raise \"Invalid arguments\"\r\nend\r\n\r\n# lib/calendar.rb\r\nrequire_relative
    \"calendar/year\"\r\nrequire_relative \"calendar/month\"\r\n```\r\n\r\nThis code
    looks and feels like it would work in the way that we'd like to think\r\n`require()`
    would work. The files we reference are relative to the file in which\r\nthe actual
    calls are made, rather than the folder in which the script was\r\nexecuted in.
    For this reason, it is a much better approach than pretty much\r\nanything I've
    shown so far.\r\n\r\nOf course, it is not a perfect solution. In some cases, it
    does not work as\r\nexpected, such as in Rackup files. Additionally, because it's
    a Ruby 1.9\r\nfeature, it's not built into Ruby 1.8.7. The former issue cannot
    be worked\r\naround, but the latter can be. I'll go into a bit more detail about
    both of\r\nthese issues in the recommendations section, which is coming up right
    now.\r\n\r\n### Conventions and Recommendations\r\n\r\nIf you remember one thing
    from this article, it should be that whenever it's\r\npossible to use `require_relative()`
    and there isn't an obviously better\r\nsolution, it's probably the right tool
    to reach for. It has the fewest \r\ndark corners and pretty much just works.\r\n\r\nThat
    said, take my advice with a grain of salt. I no longer actively\r\nmaintain any
    Ruby 1.8 applications, nor do I have to deal with code that must\r\nrun on both
    Ruby 1.8 and 1.9. If I were in those shoes again, I'd weigh\r\nout four different
    possible ways of approaching things:\r\n\r\n1) Explicitly use `require()` with
    the `File.dirname(__FILE__)` hack\r\n\r\n2) Write my own `require_relative()`
    implementation leaning on the previous\r\n   hack that gets defined only if `require_relative()`
    isn't already\r\n   implemented\r\n\r\n3) Add a dependency for Ruby 1.8 only on
    the `require_relative` gem\r\n\r\n4) Assume that `$LOAD_PATH` is set for me via
    the `-I` flag on execution,\r\n   or some other means, and then write ordinary
    require calls \r\n   relative to the _lib/_ folder in my project.\r\n\r\nI can't
    give an especially good picture of when I'd pick one of those options\r\nover
    the other, because it's been about a year since I've last had to think\r\nabout
    it. But any of those four options seem like at least reasonable ideas. I\r\nwould
    *not* employ the common but painfully ugly\r\n`require(\"./file_in_the_working_dir.rb\")`
    hack in any code that I expected to\r\nuse for anything more than a spike or demonstration.\r\n\r\nWhether
    using `require_relative()` explicitly, or one of the workarounds listed\r\nabove,
    I like to use some form of relative require whenever I can. Occasionally,\r\nI
    do use `load()`, particularly in spikes where I want to  reload files into an\r\nirb
    session without restarting irb.  But I don't think that `load()` ends up in\r\nproduction
    code of mine unless there is a very good reason to use it. A possible\r\ngood
    reason would be if I were building some sort of script runner, such as what\r\nyou
    could find in Rails when it reloads your development environment or in\r\nautotest.
    In the autotest case in particular in which your test files are\r\nreloaded each
    time you make an edit to any of your files in your project, it\r\nseems that using
    `load()` with its obscure second parameter is a good idea. But\r\nthese are not
    tools I'd expect to be building on a daily basis, so `load()`\r\nremains somewhat
    of an obscure tool for me.\r\n\r\nI never use `autoload()`. I've just not run
    into the issues that some folks in\r\nRails experience regarding slow startup
    times of applications in any way that\r\nhas mattered to me. I feel like the various
    gotchas that come along with using\r\n`autoload()` and the strict conventions
    it enforces are not good things to\r\nimpose on general-purpose uses of Ruby.
    I don't know whether I think that it\r\nmakes sense in to context of Rails, but
    that's a very different question than\r\nwhether it should be used in ordinary
    Ruby applications and libraries. It makes\r\nat least some sense in Rails, but
    in most Ruby applications, it does not. The\r\nonly time I might think about looking
    into `autoload()` is if I had some sort of\r\noptional dependency that I wanted
    to be loaded only on demand. I have never\r\nactually run into that issue, and
    I've found that the following hack provides a\r\nway to do optional dependencies
    that seems to work just fine:\r\n\r\n```ruby\r\nbegin\r\n  require \"some_external_dependency\"\r\n
    \ require \"my_lib/some_feature_that_depends_on_dependency\"\r\nrescue LoadError\r\n
    \ warn \"Could not load some_external_dependency.\"+\r\n       \" Some features
    are disabled\"\r\nend\r\n```\r\n\r\nBut really, optional dependencies are things
    I very rarely need to think about.\r\nThere are valid use cases for them, but
    unless something is very difficult to\r\ninstall or your project is specifically
    meant to wrap various mutually exclusive\r\ndependencies, I typically will just
    load up all my dependencies regardless of\r\nwhether the user ends up using them.
    This policy has not caused me problems,\r\nbut your mileage will vary depending
    on the type of work you are doing.\r\n\r\nOn a somewhat tangential note, I try
    to avoid things like dynamic require calls\r\nin which I walk over a file list
    generated from something like `Dir.glob()` or\r\nthe like. I also avoid using
    `Bundler.require()`, even when I use bundler. The\r\nreason I avoid these things
    is because I like to be able control the exact order\r\nin which my files and
    my dependencies are being loaded. It's possible to not\r\nhave to worry about
    this sort of thing, but doing so requires a highly\r\ndisciplined way of organizing
    your code so that files can be loaded\r\nindependently. \r\n\r\n### Questions
    / Feedback \r\n\r\nI hope this background story about the various ways to load
    code along with the\r\nfew bits of advice I've offered in the end here have been
    useful to you. I am\r\nhappy to answer whatever questions you have; just leave
    a comment below.\r\n"
- :slug: attacking-sticky-problems
  :title: How to attack sticky problems
  :summary: Work through a few lessons that will help you find a starting point whenever
    you feel stuck.
  :published: 2011-08-30 00:00:00.000000000 Z
  :issue_number: '2.2'
  :volume: 2
  :body: "One project that I've always wanted to work on is the creation of a generic
    table datastructure for Ruby. I've partially solved this problem in a dozen contexts
    before, but I've never come up with something I've been happy enough with to extract
    into its own gem. \r\n\r\nEvery time I've attempted to work on this project in
    the past, I've set myself up for failure by thinking of the seemingly endless
    amount of things that a generic table structure would need to implement. Recently,
    I approached the problem from a different angle and ended up feeling a lot happier
    with the way things went. In this article, I share the lessons I learned that
    helped me attack this very sticky problem.\r\n\r\n### Lesson 1: Work on specific
    cases before attempting to generalize\r\n\r\nIn the past, I had always been bogged
    down by thinking of all the possible ways my table structure was going to be used.
    This time around, I forced myself to think of a single, specific use case to focus
    on first. Instantly, the idea of of performing some manipulations on sales data
    came to mind, because I hate the reporting features PayPal gives me.\r\n\r\nTypically,
    I'd start by creating some fake data that was themed to fit this scenario, but
    lately I've been experimenting more and more with trying to work with real data
    whenever it isn't too inconvenient. I've had mixed results with that approach,
    but this time around, a few minutes of cleanup work got me from a nastily formatted
    CSV file with way too much information to a nice array of arrays in JSON format
    that's concise enough to let us see the entire contents of the file, as shown
    here: \r\n\r\n```\r\n[[\"Date\",\"Payments Received\",\"Amount Received\",\r\n
    \ \"Payment Fees\",\"Net Amount\"],\r\n [\"6/30/2011\",\"7\",\"52.00\",\"-3.93\",\"48.07\"],\r\n
    [\"6/29/2011\",\"14\",\"152.00\",\"-8.98\",\"143.02\"],\r\n [\"6/28/2011\",\"5\",\"40.00\",\"-2.73\",\"37.27\"],\r\n
    [\"6/27/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n [\"6/26/2011\",\"2\",\"12.00\",\"-0.99\",\"11.01\"],\r\n
    [\"6/25/2011\",\"1\",\"4.00\",\"-0.46\",\"3.54\"],\r\n [\"6/24/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/23/2011\",\"1\",\"16.00\",\"-0.76\",\"15.24\"],\r\n [\"6/22/2011\",\"2\",\"12.00\",\"-0.95\",\"11.05\"],\r\n
    [\"6/21/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n [\"6/20/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/19/2011\",\"1\",\"16.00\",\"-0.76\",\"15.24\"],\r\n [\"6/18/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/17/2011\",\"1\",\"4.00\",\"-0.42\",\"3.58\"],\r\n [\"6/16/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/15/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n [\"6/14/2011\",\"2\",\"36.00\",\"-1.69\",\"34.31\"],\r\n
    [\"6/13/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n [\"6/12/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/11/2011\",\"1\",\"4.00\",\"-0.46\",\"3.54\"],\r\n [\"6/10/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/9/2011\",\"1\",\"4.00\",\"-0.46\",\"3.54\"],\r\n [\"6/8/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/7/2011\",\"1\",\"4.00\",\"-0.46\",\"3.54\"],\r\n [\"6/6/2011\",\"0\",\"0.00\",\"0.00\",\"0.00\"],\r\n
    [\"6/5/2011\",\"2\",\"20.00\",\"-1.22\",\"18.78\"],\r\n [\"6/4/2011\",\"4\",\"52.00\",\"-3.23\",\"48.77\"],\r\n
    [\"6/3/2011\",\"9\",\"100.00\",\"-6.13\",\"93.87\"],\r\n [\"6/2/2011\",\"8\",\"72.00\",\"-4.79\",\"67.21\"],\r\n
    [\"6/1/2011\",\"8\",\"136.00\",\"-6.67\",\"129.33\"]]\r\n ```\r\n\r\nMy next step
    was to come up with a question about this data that would be easy to answer by
    visual inspection, and trivial to represent using nothing more than primitive
    Ruby objects. The question I settled on was, \"How many payments were received
    on 6/14/2011?\"\r\n\r\n```ruby\r\ndata = JSON.parse(File.read(\"sales.json\"))\r\nrow
    = data.find { |x| x[0] == \"6/14/2011\" }\r\np row[1] #=> \"2\"\r\n```\r\n\r\nIf
    instead I'd chosen a question that required too much thought to answer, the judgmental
    side of my brain would have kicked in too early and derailed my efforts to get
    even the smallest start on the problem. However, by picking an extremely simple
    problem to work on, I managed to turn the judge's voice in my head into a collaborator
    rather than an interrogator.\r\n\r\nThe judge looked at these three lines of code
    and instantly started in with his criticisms.\r\n\r\nJUDGE: _\"This is just terrible!
    If the order of the columns in your data changes, this code is going to break!
    Also, your output is clearly supposed to be numeric, but you're getting back a
    string. And that JSON call looks ugly too, and your mother is a . . . \"_\r\n\r\nAddressing
    all his points right away would have been a bad idea because it would have led
    me into a spiral of self-doubt. Instead, I just looked for one thing we could
    agree on so that we had some common ground to start from. The criticism about
    the column order dependency was a pretty good one, so I decided to work with that.\r\n\r\nWhenever
    I think of good APIs that I've seen for table interactions, the approach ActiveRecord
    3 takes always comes to mind. It seemed to fit this particular problem well, so
    I cautiously asked the judge for his opinion on the following code.\r\n\r\n```ruby\r\ntable
    = Table.new(data)\r\nrow   = table.where(\"Date\" => \"6/14/2011\").first\r\n\r\np
    row[\"Payments Received\"] #=> \"2\"\r\n```\r\n\r\nJUDGE: _\"Hmm . . . that `first()`
    call looks weird, but this is a LOT better than your last attempt. I won't be
    convinced until I see an implementation, though. Also, do you really think baking
    in the assumption that there are headers in the first row of your data is a good
    idea?\"_\r\n\r\nHis point about headers was a good one, soknowing that this was
    the closest thing I could get to approval from the judgeI started writing some
    tests that took his suggestion into account.\r\n\r\n```ruby\r\ndescribe \"Table\"
    do\r\n  it \"must be able to search for matching records\" do\r\n    fixture_dir
    = \"#{File.dirname(__FILE__)}/fixtures\"\r\n    json_data   = File.read(\"#{fixture_dir}/sales.json\")\r\n
    \   \r\n    names, *data  = JSON.parse(json_data)\r\n    table         = Table.new(data,
    names)\r\n\r\n    expected_payments = \"2\"\r\n    \r\n    match = table.where(\"Date\"
    => \"6/14/2011\").first\r\n    match[\"Payments Received\"].must_equal(expected_payments)\r\n
    \ end\r\nend\r\n```\r\n\r\nBefore I even get a chance to run these tests, the
    judge snapped at me.\r\n\r\nJUDGE: _\"Whoa, that fixture loading code looks disgusting.
    Do you really think that you can get away with that while I'm watching?\"_\r\n\r\nHe
    was right, of course, so I opened up my test helper file and wrote a little method
    to hide the messy code and isolate it to one place:\r\n\r\n```ruby\r\ndef json_fixture(filename)\r\n
    \ test_dir = File.dirname(__FILE__)\r\n  JSON.parse(File.read(\"#{test_dir}/fixtures/#{filename}.json\"))\r\nend\r\n```\r\n\r\nUsing
    this helper file, I was able to make my tests look a whole lot better.\r\n\r\n```ruby\r\ndescribe
    \"Table\" do\r\n  it \"must be able to search for matching records\" do\r\n    names,
    *data  = json_fixture(\"sales\")\r\n    table         = Table.new(data, names)\r\n\r\n
    \   expected_payments = \"2\"\r\n    \r\n    match = table.where(\"Date\" => \"6/14/2011\").first\r\n
    \   match[\"Payments Received\"].must_equal(expected_payments)\r\n  end\r\nend\r\n```\r\n\r\nI
    looked to the judge for approval and got a half-hearted shrug, which was good
    enough for me. By the time I finished writing these tests, I already had an idea
    in mind for how to implement a solution.\r\n\r\n```ruby\r\nclass Table\r\n  def
    initialize(data, attribute_names)\r\n    @data = data.map { |e| Hash[attribute_names.zip(e)]
    }\r\n  end\r\n\r\n  def where(conditions)\r\n    @data.select do |row|\r\n      conditions.all?
    { |k,v| row[k] == v }\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nEven though this
    code passed the test, the judge could no longer contain himself, and fired off
    another burst of scathing criticism.\r\n\r\nJUDGE: _\"This code is a giant hack.
    You store each row in a hash, but hashes are meant for unordered content and a
    row is necessarily ordered. Yes, I know that in Ruby 1.9 you can iterate over
    hashes in insert order, but that's going to come back and bite you later. What
    if you want to introduce a column rename operation in the future? There is no
    way to do that with your current code without either changing the iteration order
    or generating entirely new hashes for the entire structure. Even worse, hash keys
    must be unique. What if you have a table with two column names that are the same?
    To make matters worse, the code reeks of primitive obsession. Unless you introduce
    a `Row` object soon, every feature you add to `Table` is going to get more and
    more complicated because it will have two concerns: representing an ordered list
    of rows and manipulating the data within those rows. But who says that users are
    going to want to work with just rows? What if they want to organize their data
    by columns instead? Oh, and as I was saying about your mom . . . \"_\r\n\r\nThis
    rant was too much to take in all at once, and I felt overwhelmed. I knew that
    responding directly to his criticisms line by line would only fan the flames.
    The points he made about problems I might run into later could have very well
    been valid, but thinking about them at this particular point in time would have
    sent me down a deadly path of feature creep. I needed to take a step back and
    consider the big picture.\r\n\r\n### Lesson 2: Seek ways to defer tough design
    decisions\r\n\r\nAfter catching my breath, I realized that I could address many
    of the judge's points without actually making any major decisions about implementation
    details. I could do this by introducing a `Record` object. This object would initially
    have a core implementation similar to my previous example but would make it much
    easier to introduce changes down the line. The following test describes what I
    was shooting for:\r\n\r\n```ruby\r\ndescribe \"Record\" do\r\n  it \"must allow
    access to attributes by name\" do\r\n    data       = [\"6/14/2011\", \"2\", \"36.00\",
    \"-1.69\", \"34.31\"]\r\n    names      = [\"Date\", \"Payments Received\", \"Amount
    Received\", \r\n                  \"Payment Fees\", \"Net Amount\"] \r\n\r\n    record
    \    = Record.new(data, names)\r\n\r\n    record[\"Payments Received\"].must_equal(\"2\")\r\n
    \   record[\"Payment Fees\"].must_equal(\"-1.69\")\r\n  end\r\n\r\n  it \"must
    support conditional matching\" do\r\n    data       = [\"6/14/2011\", \"2\", \"36.00\",
    \"-1.69\", \"34.31\"]\r\n    names      = [\"Date\", \"Payments Received\", \"Amount
    Received\", \r\n                  \"Payment Fees\", \"Net Amount\"] \r\n\r\n    record
    \    = Record.new(data, names)\r\n\r\n    record.matches?(\"Date\" => \"6/14/2011\").must_equal(true)\r\n
    \   record.matches?(\"Date\" => \"6/12/2011\").must_equal(false)\r\n  end\r\nend\r\n```\r\n\r\nTo
    pass these tests, I pushed logic down from the `Table` class into a newly created
    `Record` class:\r\n\r\n```ruby\r\nclass Record\r\n  def initialize(values, attribute_names)\r\n
    \   @data = Hash[attribute_names.zip(values)]\r\n  end\r\n\r\n  def [](key)\r\n
    \   @data[key]\r\n  end\r\n\r\n  def matches?(conditions)\r\n    conditions.all?
    { |k,v| self[k] == v }\r\n  end\r\nend\r\n```\r\n\r\nThe judge was eerily silent
    as this test went green. Perhaps he was waiting to see what my next move would
    be, or maybe he had just run out of jokes about my mom. Nonetheless, I took this
    as my cue to go update my `Table` code so that it would use `Record` objects instead
    of hashes:\r\n\r\n```ruby\r\nclass Table\r\n  def initialize(data, attribute_names)\r\n
    \   @data = data.map { |e| Record.new(e, attribute_names) }\r\n  end\r\n\r\n  def
    where(conditions)\r\n    @data.select { |record| record.matches?(conditions) }\r\n
    \ end\r\nend\r\n```\r\n\r\nJust after I reran my `Table` tests and saw that they
    were passing, the judge said something that I had to ask him to repeat, because
    it was so surprising.\r\n\r\nJUDGE: _\"Not bad.\"_\r\n\r\nHe refused to elaborate,
    but I think I finally figured out why he approved of this newer version of my
    code. After thinking about his previous barrage of complaints, I realized that
    this new `Table` implementation did not raise any of the same questions. When
    you look at the problem at hand and then at the object that directly solves that
    problem, the object looks natural, well focused, and unsurprising. A `Table` is
    a collection of `Record` objects. The `Table#where` method selects from that collection
    the records that match the conditions. These explanations are very easy to follow
    and directly line up with the code itself.\r\n\r\nThe thing that made this new
    `Table` code \"not bad\" in the eyes of the judge is that it is a proper abstraction,
    whereas my previous implementation was just an indirect wrapper over some primitive
    operations. My newer code was written with the changing needs for our `Record`
    object in mind, which is what made all the difference.\r\n\r\n### Lesson 3: Let
    real use cases be your guide, not imagined scenarios\r\n\r\nIn his various outbursts,
    the judge pointed out lots of different things that he felt my `Table` code should
    do. Here is a short list of them, for those who haven't been keeping track:\r\n\r\n*
    Should be able to set column data types (i.e., convert a column that contains
    numeric strings into numeric values)\r\n* Should be able to deserialize array-of-arrays
    datastructure from JSON\r\n* Should provide a way to match a single record rather
    than calling `first()` on the array returned by `Table#where`\r\n* Should preserve
    data ordering explicitly\r\n* Should support both by column and by row access\r\n*
    Should be able to rename columns\r\n* Should be able to support multiple columns
    with the same name\r\n\r\nOn their own, all these ideas sound like good ones.
    But taken together, we're talking about a lot of additional work for a nonspecific
    gain. I know from previous experience that going down this path will lead to a
    very complex, very bloated object. Take a look at my `Ruport::Data::Table` implementation
    from several years ago if you want to see just how complicated this sort of thing
    can get:\r\n\r\nhttps://github.com/ruport/ruport/blob/master/lib/ruport/data/table.rb
    \r\n\r\nThis time around, I'm going to take a very different approach, adding
    features to my `Table` object only when I have a real project that depends on
    that feature. Even when there is something the API doesn't support, I will try
    to work around the problem and see how much pain it causes me. Only after something
    causes me a lot of pain in one place or a little pain spread across several places
    will I add new features.\r\n\r\nI am very interested to see what kind of code
    is produced from this sort of aggressive use-case-driven development. But testing
    this idea is something that we're going to need to do collectively as homework,
    because not enough time passed between when I started this experiment and when
    I published the article you are reading now. \r\n\r\nIf you'd like to help, please
    take a look at the following repository on Github and follow the instructions
    in the README.\r\n\r\nhttp://github.com/sandal/waffle\r\n\r\n### Reflections\r\n\r\nHopefully,
    by following in my footsteps, you were able to notice some similarities to your
    own struggles with sticky projects. As this article was just a story about an
    approach that seems to have worked for me, your mileage will probably vary. Still,
    I'd love to hear what you think of the ideas I mentioned here, especially if you
    have a different way of dealing with this kind of problem."
- :slug: closures-are-complicated
  :title: A closure is a double edged sword
  :summary: Discover why the closure property can sometimes lead to hard-to-spot memory
    leaks.
  :published: 2011-09-06 00:00:00.000000000 Z
  :issue_number: '2.3'
  :volume: 2
  :body: "Every `Proc` object is a closure, which means that each code block you write
    captures references to data from its surrounding scope for later use. Although
    that sounds highly academic, it has some very practical benefits that you're probably
    already aware of, as well as some drawbacks that you may or may not know about.\r\n\r\n###
    Closures make block-based APIs feel natural\r\n\r\nThe closure property of `Proc`
    objects is what makes the following snippet of code possible:\r\n\r\n```ruby\r\nclass
    Vector\r\n  def initialize(data)\r\n    @data = data\r\n  end\r\n\r\n  def *(num)\r\n
    \   @data.map { |e| e * num }\r\n  end\r\nend\r\n\r\n>> Vector.new([1,2,3]) *
    7\r\n=> [7, 14, 21]\r\n```\r\n\r\nIn this example, when we call `@data.map` and
    provide it with a code block to execute, we have no trouble accessing the `num`
    variable. However, this local variable is not defined within the block's local
    scope; it's defined within the enclosing scope (the `Vector#*`) method. To see
    that these are truly two different scopes, check out the following examples, which
    clarify the relationship between the `Proc` object's code and its enclosing scope.\r\n\r\n```ruby\r\ndef
    proc_can_see_outer_scope_locals\r\n  y = 10\r\n  lambda { p defined?(y) }.call\r\nend\r\n\r\ndef
    proc_can_modify_outer_scope_locals\r\n  y = 10\r\n  lambda { y = 20 }.call\r\n
    \ p y\r\nend\r\n\r\ndef proc_destroys_block_local_vars_on_exit\r\n  lambda { y
    = 10 }.call\r\n  p defined?(y)\r\nend\r\n\r\nproc_can_see_outer_scope_locals          #=>
    \"local-variable\"\r\nproc_can_modify_outer_scope_locals       #=> 20\r\nproc_destroys_block_local_vars_on_exit
    \  #=> nil\r\n```\r\n\r\nThe first example demonstrates that a `Proc` object's
    code can access the local variables of its enclosing scope, which is exactly what
    is going on in our `Vector` example. The second example is an answer to a question
    that arises naturally from the first example, which is whether the `Proc` object's
    code can modify the contents of the local variables that are defined in its enclosing
    scope. The third example simply verifies that once the `Proc` object's code has
    been called, any variables set up within its own code block are wiped out and
    are not visible from the outer scope.\r\n\r\n### Closures make memory management
    complicated\r\n\r\nThough they take some getting used to, the behaviors provided
    by the closure property in `Proc` objects are relatively easy to understand and
    have many practical benefits. However, they do give rise to a complex behavior
    that sometimes leads to surprising results. Check out the following example for
    a bit of a head trip.\r\n\r\n``` ruby\r\ndef new_counter\r\n  x = 0\r\n  lambda
    { x += 1 }\r\nend\r\n\r\ncounter_a = new_counter\r\ncounter_a.call\r\ncounter_a.call\r\n\r\np
    counter_a.call #=> 3\r\n\r\ncounter_b = new_counter\r\np counter_b.call #=> 1\r\n\r\np
    counter_a.call #=> 4\r\n```\r\n\r\nIn the example code, we see that the two `Proc`
    objects returned by the `new_counter()` method are referencing two different locations
    in memory. This behavior is a bit confusing because we can usually count on methods
    to clean up after themselves them once they wrap up whatever they are doing. But
    because the purpose of a `Proc` object is in part to be able to delay the execution
    of code, it's impossible for the `new_counter()` method to do this cleanup task
    for us. So here's what happens: `counter_a` gets a reference to the local variable
    `x` that was set up the first time we called `new_counter()`, and `counter_b`
    gets a reference to a different local variable `x` that was set up the second
    time we called `new_counter()`.\r\n\r\nIf used correctly, this behavior can be
    a feature. It's not one that you or I would use every day, but because this approach
    can be used to maintain state in a purely functional way, it is at least academically
    interesting. However, in most ordinary use cases, it is much more likely that
    this behavior is going to cause a memory leak than that it will do anything helpful
    for you, as it leads to lots of seemingly throwaway data stored in local variables
    getting dangling references that prevent that data from being garbage collected.\r\n\r\n###
    Not all closure-based memory leaks are so obvious\r\n\r\nCapturing references
    to locals from the enclosing scope for longer than necessary isn't the only way
    that you can cause leaks with `Proc` objects. Every `Proc` object also creates
    a reference to the object that it was defined within, creating a leak that is
    even harder to notice. Let's take a look at an example of how that can come back
    to bite you.\r\n\r\nSuppose we have a configurable logger module and we want to
    record a message to the logs each time a new `User` object is created. If we were
    going for something simple and straightforward, we might end up with code similar
    to what you see here:\r\n\r\n```ruby\r\nmodule Logger\r\n  extend self\r\n\r\n
    \ attr_accessor :output\r\n\r\n  def log(msg)\r\n    output << \"#{msg}\\n\"\r\n
    \ end\r\nend\r\n\r\nclass User\r\n  def initialize(id)\r\n    @id = id\r\n    Logger.log(\"Created
    User with ID #{id}\")\r\n  end\r\nend\r\n```\r\n\r\nBut if we wanted to be a bit
    more fancy, we could build a logger that delayed the writing of the logs until
    we explicitly asked for them to be written. We could use `Proc` objects for lazy
    evaluation, giving us a potential speed boost whenever we didn't actually need
    to view our logs.\r\n\r\n```ruby\r\nmodule LazyLogger\r\n  extend self\r\n\r\n
    \ attr_accessor :output\r\n\r\n  def log(&callback)\r\n    @log_actions ||= []\r\n
    \   @log_actions << callback\r\n  end\r\n\r\n  def flush\r\n    @log_actions.each
    { |e| e.call(output) }\r\n  end\r\nend\r\n\r\nclass User\r\n  def initialize(id)\r\n
    \   @id = id\r\n    LazyLogger.log { |out| out << \"Created User with ID #{id}\"
    }\r\n  end\r\nend\r\n```\r\n\r\nAlthough this code may look simple, it has a subtle
    memory leak. The leak can be verified via the following simple script, which shows
    that 1000 users still exist in the system, even though the objects were created
    as throwaway objects:\r\n\r\n```ruby\r\nLazyLogger.output = \"\"\r\n1000.times
    { |i| User.new(i) }\r\n\r\nGC.start\r\np ObjectSpace.each_object(User).count #=>
    1000\r\n```\r\n\r\nIf instead we use our more vanilla code that does not use `Proc`
    objects, we see that for the most part*, the garbage collector has done its job.\r\n\r\n```ruby\r\nLogger.output
    = \"\"\r\n1000.times { |i| User.new(i) }\r\n\r\nGC.start\r\n\r\n# (*): I expected
    below to be 0, but GC clearly ran. Weird.\r\np ObjectSpace.each_object(User).count
    #=> 1\r\n```\r\n\r\nOur `LazyLogger` leaks because when `LazyLogger.log` is called
    with a block from within `User#initialize`, a new `Proc` object is created that
    holds a reference to that user object. That `Proc` object ends up getting stored
    in the `@log_actions` array in `LazyLogger` module and needs to be kept alive
    at least until `LazyLogger.flush` is called in order for everything to work as
    expected. Thus our `User` objects that we expected to get thrown away still have
    live references to them, so they don't end up getting garbage collected.\r\n\r\nThese
    kinds of problems can be very easy to run into and very hard to work around. In
    fact, I've have been having trouble figuring out how to preserve the `LazyLogger`
    behavior in a way that'd plug the leak or at least mitigate it somewhat. In this
    particular case, it'd be possible to call `clear` on the `@log_actions` array
    whenever `flush` is called, and that would free up the references to the `User`
    instances. But that approach still ends up keeping unnecessary references alive
    longer than you might want, and the pattern doesn't necessarily apply generally
    to other scenarios.\r\n\r\n### Reflections\r\n\r\nBecause we use code blocks so
    freely and tend to ignore the closure property, many Ruby applications and libraries
    have memory leaks in them. Even fairly experienced developers (myself included)
    don't necessarily design with these issues in mind. Those who do have firm memory
    constraints to deal with are forced to use a variety of awkward techniques to
    overcome this problem. \r\n\r\nOne possible way to avoid closure-based memory
    leaks is to use `Method` objects in place of `Proc` objects wherever the closure
    properties are not required. Another option is to create `Proc` objects in a different
    context to avoid accidental references to objects that you want garbage collected.
    In fact, I recently needed to use the latter approach in order to make use of
    `ObjectSpace.define_finalizer`. Although that's a bit of an obscure topic, it's
    a good example of what we've just been talking about, so I recommend checking
    out [this article by Mike Perham](http://www.mikeperham.com/2010/02/24/the-trouble-with-ruby-finalizers/).
    \r\n\r\nI don't want to give much more advice on handling memory management, because
    it's not an area in which I'm particularly strong. I welcome any corrections to
    what I've said here, if you find that I've made a mistake anywhere.\r\n\r\n###
    Questions/Discussion Points\r\n\r\nThis article wasn't especially long, but the
    material is quite dense, and I don't want to push my luck by covering too many
    concepts at once. That said, I've provided a few exercises for those who want
    to dig a bit deeper and would be happy to continue discussing the topic in general
    now that we have a starting point. Leave a comment if something is on your mind!\r\n\r\n*
    Find a good example of an API that allows you to use a `Method` object in place
    of a `Proc` object, or create your own. Investigate the performance and memory
    differences between the two approaches by writing benchmarks.\r\n\r\n* Use two
    different approaches to implement your own `attr_accessor` function: one using
    the closure-based `define_method`, and another using `module_eval` with a string.
    Compare the performance characteristics of calling the dynamically defined methods
    and try to reason about why one is faster than the other, if they are not comparable
    to one another.\r\n\r\n* Share your thoughts on when you need to worry about the
    downsides of closures, and when you don't. Come up with some metrics for determining
    what issues to look out for.\r\n\r\n* CHALLENGE: Explain why my `ObjectSpace`
    example showed 1 `User` instance, not 0!"
- :slug: building-enumerable-and-enumerator
  :title: Building Enumerable & Enumerator in Ruby
  :summary: Learn about Ruby's powerful iteration tools by implementing some of its
    functionality yourself.
  :published: 2011-09-13 00:00:00.000000000 Z
  :issue_number: '2.4'
  :volume: 2
  :body: "When I first came to Ruby, one of the things that impressed me the most
    was the killer features provided by the `Enumerable` module. I eventually also
    came to love `Enumerator`, even though it took me a long time to figure out what
    it was and what one might use it for.\r\n\r\nAs a beginner, I had always assumed
    that these features worked through some dark form of magic that was buried deep
    within the Ruby interpreter. With so much left to learn just in order to be productive,
    I was content to postpone learning the details about what was going on under the
    hood. After some time, I came to regret that decision, thanks to David A. Black.\r\n\r\nDavid
    teaches Ruby to raw beginners not only by showing them what `Enumerable` can do,
    but also by making them implement their own version of it! This is a profoundly
    good exercise, because it exposes how nonmagical the features are: if you understand
    `yield`, you can build all the methods in `Enumerable`. Similarly, the interesting
    features of `Enumerator` can be implemented fairly easily if you use Ruby's `Fiber`
    construct.\r\n\r\nIn this article, we're going to work through the exercise of
    rolling your own subset of the functionality provided by `Enumerable` and `Enumerator`,
    discussing each detail along the way. Regardless of your skill level, an understanding
    of the elegant design of these constructs will undoubtedly give you a great source
    of inspiration that you can draw from when designing new constructs in your own
    programs.\r\n\r\n### Setting the stage with some tests\r\n\r\nI've selected a
    small but representative subset of the features that `Enumerable` and `Enumerator`
    provide and written some tests to nail down their behavior. These tests will guide
    my implementations throughout the rest of this article and serve as a roadmap
    for you if you'd like to try out the exercise on your own.\r\n\r\nIf you have
    some time to do so, try to get at least some of the tests to go green before reading
    my implementation code and explanations, as you'll learn a lot more that way.
    But if you're not planning on doing that, at least read through the tests carefully
    and think about how you might go about implementing the features they describe.\r\n\r\n```ruby\r\nclass
    SortedList\r\n  include FakeEnumerable\r\n\r\n  def initialize\r\n    @data =
    []\r\n  end\r\n\r\n  def <<(new_element)\r\n    @data << new_element\r\n    @data.sort!\r\n
    \  \r\n    self\r\n  end\r\n  \r\n  def each\r\n    if block_given?\r\n      @data.each
    { |e| yield(e) }\r\n    else\r\n      FakeEnumerator.new(self, :each)\r\n    end\r\n
    \ end \r\nend\r\n\r\nrequire \"minitest/autorun\"\r\n\r\ndescribe \"FakeEnumerable\"
    do\r\n  before do\r\n    @list = SortedList.new\r\n\r\n    # will get stored interally
    as 3,4,7,13,42\r\n    @list << 3 << 13 << 42 << 4 << 7\r\n  end\r\n\r\n  it \"supports
    map\" do\r\n    @list.map { |x| x + 1 }.must_equal([4,5,8,14,43])  \r\n  end\r\n\r\n
    \ it \"supports sort_by\" do\r\n    # ascii sort order\r\n    @list.sort_by {
    |x| x.to_s }.must_equal([13, 3, 4, 42, 7])\r\n  end\r\n\r\n  it \"supports select\"
    do\r\n    @list.select { |x| x.even? }.must_equal([4,42])\r\n  end\r\n\r\n  it
    \"supports reduce\" do\r\n    @list.reduce(:+).must_equal(69)\r\n    @list.reduce
    { |s,e| s + e }.must_equal(69)\r\n    @list.reduce(-10) { |s,e| s + e }.must_equal(59)\r\n
    \ end\r\nend\r\n\r\ndescribe \"FakeEnumerator\" do\r\n  before do\r\n    @list
    = SortedList.new\r\n\r\n    @list << 3 << 13 << 42 << 4 << 7\r\n  end\r\n\r\n
    \ it \"supports next\" do\r\n    enum = @list.each\r\n\r\n    enum.next.must_equal(3)\r\n
    \   enum.next.must_equal(4)\r\n    enum.next.must_equal(7)\r\n    enum.next.must_equal(13)\r\n
    \   enum.next.must_equal(42)\r\n\r\n    assert_raises(StopIteration) { enum.next
    }\r\n  end\r\n\r\n  it \"supports rewind\" do\r\n    enum = @list.each\r\n\r\n
    \   4.times { enum.next }\r\n    enum.rewind\r\n\r\n    2.times { enum.next }\r\n
    \   enum.next.must_equal(7)\r\n  end\r\n\r\n  it \"supports with_index\" do\r\n
    \   enum     = @list.map\r\n    expected = [\"0. 3\", \"1. 4\", \"2. 7\", \"3.
    13\", \"4. 42\"]  \r\n\r\n    enum.with_index { |e,i| \"#{i}. #{e}\" }.must_equal(expected)\r\n
    \ end\r\nend\r\n```\r\n\r\nIf you do decide to try implementing these features
    yourself, get as close to the behavior that Ruby provides as you can, but don't
    worry if your implementation is different from what Ruby really uses. Just think
    of this as if it's a new problem that needs solving, and let the tests guide your
    implementation. Once you've done that, read on to see how I did it.\r\n\r\n###
    Implementing the `FakeEnumerable` module\r\n\r\nBefore I began work on implementing
    `FakeEnumerable`, I needed to get its tests to a failure state rather than an
    error state. The following code does exactly that:\r\n\r\n```ruby\r\nmodule FakeEnumerable\r\n
    \ def map \r\n  end\r\n\r\n  def select\r\n  end\r\n\r\n  def sort_by\r\n  end\r\n\r\n
    \ def reduce(*args)\r\n  end\r\nend\r\n```\r\n\r\nI then began working on implementing
    the methods one by one, starting with `map`. The key thing to realize while working
    with `Enumerable` is that every feature will build on top of the `each` method
    in some way, using it in combination with `yield` to produce its results. The
    `map` feature is possibly the most straightforward nontrivial combination of these
    operations, as you can see in this implementation:\r\n\r\n```ruby\r\ndef map \r\n
    \ out = []\r\n\r\n  each { |e| out << yield(e) }\r\n\r\n  out\r\nend\r\n```\r\n\r\nHere
    we see that `map` is simply a function that builds up a new array by taking each
    element and replacing it with the return value of the block you provide to it.
    We can clean this up to make it a one liner using `Object#tap`, but I'm not sure
    if I like that approach because it breaks the simplicity of the implementation
    a bit. That said, I've included it here for your consideration and will use it
    throughout the rest of this article, just for the sake of brevity.\r\n\r\n```ruby\r\ndef
    map\r\n  [].tap { |out| each { |e| out << yield(e) } }\r\nend\r\n```\r\n\r\nImplementing
    `select` is quite easy as well. It builds on the same concepts used to implement
    `map` but adds a conditional check to see whether the block returns a `true` value.
    For each new yielded element, if the value returned by the block is logically
    true, the element gets added to the newly built array; otherwise, it does not.\r\n\r\n```ruby\r\ndef
    select\r\n  [].tap { |out| each { |e| out << e if yield(e) } }\r\nend\r\n```\r\n\r\nImplementing
    `sort_by` is a little more tricky. I cheated and looked at the API documentation,
    which (perhaps surprisingly) describes how the method is implemented and even
    gives a reference implementation in Ruby. Apparently, `sort_by` uses a [Schwartzian
    transform](http://en.wikipedia.org/wiki/Schwartzian_transform) to convert the
    collection we are iterating over into tuples containing the sort key and the original
    element. It then uses `Array#sort` to put these in order, and it finally uses
    `map` on the resulting array to convert the array of tuples back into an array
    of the elements from the original collection. That's definitely more confusing
    to explain than it is to implement in code, so just look at the following code
    for clarification:\r\n\r\n```ruby\r\ndef sort_by\r\n  map { |a| [yield(a), a]
    }.sort.map { |a| a[1] }\r\nend\r\n```\r\n\r\nThe interesting thing about this
    implementation is that `sort_by` is dependent on `map`, both on the current collection
    being iterated over as well as on the `Array` it generates. But after tracing
    it down to the core, this method is still expecting the collection to implement
    only the `each` method. Additionally, because `Array#sort` is thrown into the
    mix, your sort keys need to respond to `<=>`. But for such a powerful method,
    the contract is still very narrow.\r\n\r\nImplementing `reduce` is a bit more
    involved because it has three different ways of interacting with it. It's also
    interesting because it's one of the few `Enumerable` methods that isn't necessarily
    designed to return an `Array` object. I'll let you ponder the following implementation
    a bit before providing more commentary, because reading through it should be a
    good exercise. \r\n\r\n```ruby\r\ndef reduce(operation_or_value=nil)\r\n  case
    operation_or_value\r\n  when Symbol\r\n    # convert things like reduce(:+) into
    reduce { |s,e| s + e }\r\n    return reduce { |s,e| s.send(operation_or_value,
    e) }\r\n  when nil\r\n    acc = nil\r\n  else\r\n    acc = operation_or_value\r\n
    \ end\r\n\r\n  each do |a|\r\n    if acc.nil?\r\n      acc = a\r\n    else\r\n
    \     acc = yield(acc, a)\r\n    end\r\n  end\r\n\r\n  return acc\r\nend\r\n```\r\n\r\nFirst,
    I have to say I'm not particularly happy with my implementation; it seems a bit
    too brute force and I think I might be missing some obvious refactorings. But
    it should have been readable enough for you to get a general feel for what's going
    on. The first paragraph of code is simply handling the three different cases of
    `reduce()`. The real operation happens starting with our `each` call.\r\n\r\nWithout
    a predefined initial value, we set the initial value to the first element in the
    collection, and our first yield occurs starting with the second element. Otherwise,
    the initial value and first element are yielded. The purpose of `reduce()` is
    to perform an operation on each successive value in a list by combining it in
    some way with the last calculated value. In this way, the list gets reduced to
    a single value in the end. This behavior explains why the old alias for this method
    in Ruby was called `inject`: a function is being injected between each element
    in the collection via our `yield` call. I find this operation much easier to understand
    when I'm able to see it in terms of primitive concepts such as `yield` and `each`
    because it makes it possible to trace exactly what is going on.\r\n\r\nIf you
    are having trouble following the implementation of `reduce()`, don't worry about
    it. It's definitely one of the more complex `Enumerable` methods, and if you try
    to implement a few of the others and then return to studying `reduce()`, you may
    have better luck. But the beautiful thing is that if you ignore the `reduce(:+)`
    syntactic sugar, it introduces no new concepts beyond that what is used to implement
    `map()`. If you think you understand `map()` but not `reduce()`, it's a sign that
    you may need to brush up on your fundamentals, such as how `yield` works.\r\n\r\nIf
    you've been following along at home, you should at this point be passing all your
    `FakeEnumerable` tests. That means it's time to get started on our `FakeEnumerator`.\r\n\r\n###
    Implementing the `FakeEnumerator` class\r\n\r\nSimilar to before, I needed to
    write some code to get my tests to a failure state. First, I set up the skeleton
    of the `FakeEnumerator` class.\r\n\r\n```ruby\r\nclass FakeEnumerator\r\n  def
    next\r\n  end\r\n\r\n  def with_index\r\n  end\r\n\r\n  def rewind\r\n  end\r\nend\r\n```\r\n\r\nThen
    I realized that I needed to back and at least modify the `FakeEnumerable#map`
    method, as my tests rely on it returning a `FakeEnumerator` object when a block
    is not provided, in a similar manner to the way `Enumerable#map` would return
    an `Enumerator` in that scenario.\r\n\r\n```ruby\r\nmodule FakeEnumerable\r\n
    \ def map \r\n    if block_given?\r\n      [].tap { |out| each { |e| out << yield(e)
    } }\r\n    else\r\n      FakeEnumerator.new(self, :map)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAlthough,
    technically speaking, I should have also updated all my other `FakeEnumerable`
    methods, it's not important to do so because our tests don't cover it and that
    change introduces no new concepts to discuss. With this change to `map`, my tests
    all failed rather than erroring out, which meant it was time to start working
    on the implementation code.\r\n\r\nBut before we get started, it's worth reflecting
    on the core purpose of an `Enumerator`, which I haven't talked about yet. At its
    core, an `Enumerator` is simply a proxy object that mixes in `Enumerable` and
    then delegates its `each` method to some other iterator provided by the object
    it wraps. This behavior turns an internal iterator into an external one, which
    allows you to pass it around and manipulate it as an object. \r\n\r\nOur tests
    call for us to implement `next`, `rewind`, and `each_index`, but before we can
    do that meaningfully, we need to make `FakeEnumerator` into a `FakeEnumerable`-enabled
    proxy object. There are no tests for this because I didn't want to reveal too
    many hints to those who wanted to try this exercise at home, but this code will
    do the trick:\r\n\r\n```ruby\r\nclass FakeEnumerator\r\n  include FakeEnumerable\r\n\r\n
    \ def initialize(target, iter) \r\n    @target = target\r\n    @iter   = iter\r\n
    \ end\r\n\r\n  def each(&block)\r\n    @target.send(@iter, &block) \r\n  end\r\n\r\n
    \  # other methods go here...\r\nend\r\n```\r\n\r\nHere we see that `each` uses
    `send` to call the original iterator method on the target object. Other than that,
    this is the ordinary pattern we've seen in implementing other collections. The
    next step is to implement our `next` method, which is a bit tricky.\r\n\r\nWhat
    we need to be able to do is iterate once, then pause and return a value. Then,
    when `next` is called again, we need to be able to advance one more iteration
    and repeat the process. We could do something like run the whole iteration and
    cache the results into an array, then do some sort of indexing operation, but
    that's both inefficient and impractical for certain applications. This problem
    made me realize that Ruby's `Fiber` construct might be a good fit because it specifically
    allows you to jump in and out of a chunk of code on demand. So I decided to try
    that out and see how far I could get. After some fumbling around, I got the following
    code to pass the test:\r\n\r\n```ruby\r\n# loading the fiber stdlib gives us some
    extra features, including Fiber#alive?\r\nrequire \"fiber\" \r\n\r\nclass FakeEnumerator\r\n
    \ def next\r\n    @fiber ||= Fiber.new do\r\n      each { |e| Fiber.yield(e) }\r\n\r\n
    \     raise StopIteration\r\n    end\r\n\r\n    if @fiber.alive?\r\n      @fiber.resume
    \r\n    else\r\n      raise StopIteration\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis
    code is hard to read because it isn't really a linear flow, but I'll do my best
    to explain it using my very limited knowledge of how the `Fiber` construct works.
    Basically, when you call `Fiber#new` with a block, the code in that block isn't
    executed immediately. Instead, execution begins when `Fiber#resume` is called.
    Each time a `Fiber#yield` call is encountered, control is returned to the caller
    of `Fiber#resume` with the value that was passed to `Fiber#yield` returned. Each
    subsequent `Fiber#resume` picks up execution back at the point where the last
    `Fiber#yield` call was made, rather than at the beginning of the code block. This
    process continues until no more `Fiber#yield` calls remain, and then the last
    executed line of code is returned as the final value of `Fiber#resume`. Any additional
    attempts to call `Fiber#resume` result in a `FiberError` because there is nothing
    left to execute.\r\n\r\nIf you reread the previous paragraph a couple of times
    and compare it to the definition of my `next` method, it should start to make
    sense. But if it's causing your brain to melt, check out the [Fiber documentation](http://ruby-doc.org/core-1.9/classes/Fiber.html),
    which is reasonably helpful. \r\n\r\nThe very short story about this whole thing
    is that using a `Fiber` in our `next` definition lets us keep track of just how
    far into the `each` iteration we are and jump back into the iterator on demand
    to get the next value. I prevent the `FiberError` from ever occurring by checking
    to see whether the `Fiber` object is still alive before calling `resume`. But
    I also need to make it so that the final executed statement within the `Fiber`
    raises a `StopIteration` error as well, to prevent it from returning the result
    of `each`, which would be the collection itself. This is a kludge, and if you
    have a better idea for how to handle this case, please leave me a comment.\r\n\r\nThe
    use of `Fiber` objects to implement `next` makes it possible to work with infinite
    iterators, such as `Enumerable#cycle`. Though we won't get into implementation
    details, the following code should give some hints as to why this is a useful
    feature:\r\n\r\n```ruby\r\n>> row_colors = [:red, :green].cycle\r\n=> #<Enumerator:
    [:red, :green]:cycle>\r\n>> row_colors.next\r\n=> :red\r\n>> row_colors.next\r\n=>
    :green\r\n>> row_colors.next\r\n=> :red\r\n>> row_colors.next\r\n=> :green\r\n```\r\n\r\nAs
    cool as that is, and as much as it makes me want to dig into implementing it,
    I have to imagine that you're getting tired by now. Heck, I've already slept twice
    since I started writing this article! So let's hurry up and finish implementing
    `rewind` and `each_index` so that we can wrap things up.\r\n\r\nI found a way
    to implement `rewind` that is trivial, but something about it makes me wonder
    if I've orphaned a `Fiber` object somewhere and whether that has weird garbage
    collection mplications. But nonetheless, because our implementation of `next`
    depends on the caching of a `Fiber` object to keep track of where it is in its
    iteration, the easiest way to rewind back to the beginning state is to simply
    wipe out that object. The following code gets my `rewind` tests passing:\r\n\r\n```ruby\r\ndef
    rewind\r\n  @fiber = nil\r\nend\r\n```\r\n\r\nNow only one feature stands between
    us and the completion of our exercise: `with_index`. The real `with_index` method
    in Ruby is much smarter than what you're about to see, but for its most simple
    functionality, the following code will do the trick:\r\n\r\n```ruby\r\ndef with_index\r\n
    \ i = 0\r\n  each do |e| \r\n    out = yield(e, i)\r\n    i += 1\r\n    out\r\n
    \ end\r\nend\r\n```\r\n\r\nHere, I did the brute force thing and maintained my
    own counter. I then made a small modification to control flow so that rather than
    yielding just the element on each iteration, both the element and its index are
    yielded. Keep in mind that the `each` call here is a proxy to some other iterator
    on another collection, which is what gives us the ability to call `@list.map.with_index`
    and get `map` behavior rather than `each` behavior. Although you won't use every
    day, knowing how to implement an around filter using `yield` can be quite useful.\r\n\r\nWith
    this code written, my full test suite finally went green. Even though I'd done
    these exercises a dozen times before, I still learned a thing or two while writing
    this article, and I imagine there is still plenty left for me to learn as well.
    How about you?\r\n\r\n### Reflections\r\n\r\nThis is definitely one of my favorite
    exercises for getting to understand Ruby better. I'm not usually big on contrived
    practice drills, but there is something about peeling back the magic on features
    that look really complex on the surface that gives me a great deal of satisfaction.
    I find that even if my solutions are very much cheap counterfeits of what Ruby
    must really be doing, it still helps tremendously to have implemented these features
    in any way I know how, because it gives me a mental model of my own construction
    from which to view the features.\r\n\r\nIf you enjoyed this exercise, there are
    a number of things that you could do to squeeze even more out of it. The easiest
    way to do so is to implement a few more of the `Enumerable` and `Enumerator` methods.
    As you do that, you'll find areas where the implementations we built out today
    are clearly insufficient or would be better off written another way. That's fine,
    because it will teach you even more about how these features hang together. You
    can also discuss and improve upon the examples I've provided, as there is certainly
    room for refactoring in several of them. Finally, if you want to take a more serious
    approach to things, you could take a look at the tests in [RubySpec](https://github.com/rubyspec/rubyspec)
    and the implementations in [Rubinius](https://github.com/rubinius/rubinius). Implementing
    Ruby in Ruby isn't just something folks do for fun these days, and if you really
    enjoyed working on these low-level features, you might consider contributing to
    Rubinius in some way. The maintainers of that project are amazing, and you can
    learn a tremendous amount that way.\r\n\r\nOf course, not everyone has time to
    contribute to a Ruby implementation, even if it's for the purpose of advancing
    their own understanding of Ruby. So I'd certainly settle for a comment here sharing
    your experiences with this exercise."
- :slug: regession-testing
  :title: Thoughts on regression testing
  :summary: Benefit from two lessons about regression testing that were learned the
    hard way.
  :published: 2011-09-20 00:00:00.000000000 Z
  :issue_number: '2.5'
  :volume: 2
  :body: "The most simple and unambiguous benefit that automated testing provides
    is that it can be used to minimize the impact of regressions. If each bug fix
    is accompanied by a corresponding test, it makes it very likely that known defects
    will be noticed immediately whenever they resurface. Over the lifetime of a project,
    regression tests end up forming a safety net that makes refactoring easier and
    maintenance work less scary.\r\n\r\nIn this article, we will look at a couple
    of real bugs that were fixed in practicingruby.com and the tests that are meant
    to prevent them from recurring. Working on these fixes taught Jordan and me two
    valuable lessons that I think are worth sharing. For some, they will serve as
    evidence of why you should be writing regression tests; for others, they will
    serve more as a reminder of why the time you're investing into your tests is worthwhile.\r\n\r\n_As
    a bit of a warning to those expecting sage advice in this article, I am in no
    way an expert at Rails testing, and even my Ruby testing skills are probably average.
    But this newsletter is about practicing Ruby, not just pontificating about it.
    I'm not afraid to show some of my own weak spots from time to time, as long as
    we can all learn something from it._\r\n\r\n### LESSON 1: More granular tests
    make for better regression suites  \r\n\r\nWe now have support for Github-style
    mentions in our comments here on practicingruby.com, but the initial version of
    this feature was much more fragile than the one that is now in place. When Jordan
    first demonstrated the feature to me, I immediately tried to break it by manually
    testing how it dealt with case sensitivity, punctuation, and mentions of users
    who were not subscribed to Practicing Ruby. I succeeded at demonstrating bad behavior
    for two out of three of these cases, so Jordan quickly coded up a fix and an accompanying
    test for that fix. The test he wrote is shown here:\r\n\r\n```ruby\r\ntest \"returns
    an array of valid users mentioned\" do\r\n  person = Factory(:user, :github_nickname
    => \"PerSon\")\r\n  frank = Factory(:user, :github_nickname => \"frank-pepelio\")\r\n\r\n
    \ comment = Factory(:comment,\r\n    :body => \"I mention @person: and @FRank-pepelio
    but @noexist isn't there\")\r\n\r\n  mentioned_users = comment.mentioned_users\r\n\r\n
    \ assert_equal 2, mentioned_users.count\r\n  assert mentioned_users.include?(person)\r\n
    \ assert mentioned_users.include?(frank)\r\nend\r\n```\r\n\r\nSeeing this test
    go green was sufficient evidence for me that after the fix, the feature was working
    as I'd expect it to. We committed it, and for the moment, the problem was solved.
    But when I took a second look at this test while preparing this article, I decided
    that I should rewrite it. Can you guess why?\r\n\r\nIf you guessed that it was
    because I have some deep-rooted hatred for Frank Pepelio, unfortunately that's
    not correct. But if instead you guessed that it was because I thought this test
    was covering too many different behaviors at once, you were spot on. I came up
    with the following tests as a suitable replacement.\r\n\r\n```ruby\r\ntest \"returns
    an array of valid users mentioned\" do\r\n  person = Factory(:user, :github_nickname
    => \"PerSon\")\r\n  frank = Factory(:user, :github_nickname => \"frank-pepelio\")\r\n\r\n
    \ comment = Factory(:comment,\r\n    :body => \"I mention @PerSon and @frank-pepelio\")\r\n\r\n
    \ mentioned_users = comment.mentioned_users\r\n\r\n  assert_equal 2, mentioned_users.count\r\n
    \ assert mentioned_users.include?(person)\r\n  assert mentioned_users.include?(frank)\r\nend\r\n\r\ntest
    \"omits mentioned users that do not have a matching user record\" do\r\n  frank
    = Factory(:user, :github_nickname => \"frank-pepelio\")\r\n\r\n  comment = Factory(:comment,\r\n
    \   :body => \"I mention @frank-pepelio and @noexist\")\r\n\r\n  mentioned_users
    = comment.mentioned_users\r\n\r\n  assert_equal [frank], mentioned_users\r\nend\r\n\r\ntest
    \"match mentioned users without case sensitivity\" do\r\n  frank = Factory(:user,
    :github_nickname => \"frank-pepelio\")\r\n\r\n  comment = Factory(:comment,\r\n
    \   :body => \"I mention @FRANK-pepelio\")\r\n\r\n  mentioned_users = comment.mentioned_users\r\n\r\n
    \ assert_equal [frank], mentioned_users\r\nend\r\n\r\ntest \"allows user mentions
    to include punctuation\" do\r\n  frank = Factory(:user, :github_nickname => \"frank-pepelio\")\r\n
    \ person = Factory(:user, :github_nickname => \"person\")\r\n\r\n  comment = Factory(:comment,
    :body => \"@person, @frank-pepelio: YAY!\")\r\n  mentioned_users = comment.mentioned_users\r\n\r\n
    \ assert_equal 2, mentioned_users.count\r\n  assert mentioned_users.include?(person)\r\n
    \ assert mentioned_users.include?(frank)\r\nend\r\n```\r\n\r\nThese tests are
    a whole lot more verbose than the ones Jordan wrote, even though they cover the
    same set of behaviors. However, the extra effort of writing tests this way gains
    us quite a bit. Our new tests are much more granular, making the expectations
    for this feature more explicit and easier to understand for those reading the
    tests. More important, though, the increased granularity extends to feedback provided
    by test failures. If we make a change that causes our mentions to no longer be
    case sensitive, we get a failure in the specific test about case sensitivity,
    rather than in a catch-all test designed to fully define the behavior of the feature.
    \r\n\r\nThe value of your test suite as a safety net against regressions is directly
    related to the granularity of your tests. For any given feature, the more complex
    it is, the greater the importance of granular testing. Additionally, the more
    features you have, the more difficult it will be to keep track of the edge cases
    of any single feature unless you break out each of its behaviors explicitly. Because
    of the multiplicative effect between these two things, it means that most of the
    time, it's worth it to make your test more granular, even if doing so takes a
    bit more time, effort, and code.\r\n\r\n### LESSON 2: Testing your critical paths
    is important\r\n\r\nPart of the process of rolling out our new notification features
    (including mentions) was to set up background job processing for sending emails.
    We decided to try out [MailHopper](https://github.com/cerebris/mailhopper), but
    in order to do so, we needed to upgrade to Rails 3.1. The upgrade was relatively
    straightfoward and Jordan did a fair bit of manual testing to make sure that notification
    emails were still being sent and that the application as a whole was still working
    as expected.\r\n\r\nUnfortunately, the one area he forgot to check was the code
    I wrote for linking MailChimp subscriptions to GitHub accounts. This may be some
    of the most simple code in the the application, but I still managed to use a couple
    of deprecated APIs without realizing it. If we had some integration tests in place,
    we probably would have caught these issues, but because we didn't, they didn't
    surface until several hours after we deployed the Rails 3.1 upgrade.\r\n\r\nThe
    issues themselves were downright trivial. In one of our HAML-based views, I had
    written `- form_for` instead of `= form_for`, which upon upgrading to Rails 3.1
    prevented the form from being rendered. In the process of fixing this issue, I
    stumbled across another problem. It used to be possible to call `ActionMailer`
    methods by prefixing them with `deliver_`; in Rails 3.1, though, you use an ordinary
    method call that returns a `Mail` object that you're expected to explicitly call
    `deliver` on. Because my code was using the old syntax, it ended up raising a
    `NoMethodError` rather than sending an email once we did the upgrade. It took
    only a few minutes to fix these issues, but the fact that they cropped up at all
    was a sign of a deeper problem.\r\n\r\nIn the early stages of building out practicingruby.com,
    we avoided writing tests because the code was very simple and because doing a
    manual check of all the features took no more than a few minutes before each deploy.
    I wanted to focus on content generation, and I didn't want to overwhelm Jordan
    with too much work on Practicing Ruby because it would take his focus off of Mendicant
    University. But, as we fast-forward a couple weeks, the application is now complex
    enough that not writing tests is costing us time rather than saving us time. Even
    if we still don't necessarily need 100% test coverage, we need to make sure that
    we've got the critical paths through this application covered so that the site
    can remain a good experience for our readers.\r\n\r\nWith that in mind, I set
    out to write integration tests that cover the process of linking your GitHub account
    to your MailChimp subscription from end to end. I started with the easy case of
    when your GitHub email address matches the one you subscribed to this newsletter
    with. The code below is my first rough draft of a test that walks through that
    process.\r\n\r\n```ruby\r\ntest \"github autolinking\" do\r\n  Factory.create(:user,
    :email => \"gregory.t.brown@gmail.com\")\r\n\r\n  OmniAuth.config.add_mock(:github,
    {\r\n    :uid => '12345',\r\n    :user_info => {\r\n      :nickname => 'sandal',\r\n
    \     :email    => \"gregory.t.brown@gmail.com\"\r\n    }\r\n  })\r\n\r\n  visit
    community_url\r\n\r\n  auth_link = Authorization.find_by_github_uid(\"12345\").\r\n
    \                           authorization_link\r\n\r\n\r\n  assert_equal authorization_link_path(auth_link),
    current_path\r\n\r\n  refute_empty ActionMailer::Base.deliveries\r\n\r\n  mail
    = ActionMailer::Base.deliveries.first\r\n  ActionMailer::Base.deliveries.clear\r\n\r\n
    \ assert_equal [\"gregory.t.brown@gmail.com\"], mail.to\r\n\r\n  visit \"/sessions/link/#{auth_link.secret}\"\r\n
    \ assert_equal articles_path, current_path\r\nend\r\n```\r\n\r\nI was initially
    expecting this test to pass, but upon running, it ended up with a failure. I had
    forgotten that my previous manual testing was only of the more complex workflow,
    which has you explictly enter your email address. The fact that the same confirmation
    email gets sent by our application in two different ways is a sign that there
    is some violation of DRY going on, but the more immediate realization I had was
    that the setup costs of testing these different scenarios manually was causing
    both Jordan and me to cut corners and to not test all the paths we should have
    been testing. Fortunately, rewriting another `ActionMailer` call got this test
    to go green. \r\n\r\nNo longer feeling confident in my ability to weed out these
    errors from memory, I did a quick projectwide search with ack on the word \"deliver\"
    to confirm that this was indeed the last instance of this particular bug. After
    I was sure that was the case, I was able to move onto the workflow that caused
    me to detect this bug in the first place: our manual MailChimp-to-GitHub linking
    process. It is more or less the same set of steps, but involves filling out a
    form field before the confirmation email gets sent. \r\n\r\n```ruby\r\ntest \"github
    manual linking\" do\r\n  Factory.create(:user, :email => \"gregory.t.brown@gmail.com\")\r\n\r\n
    \ OmniAuth.config.add_mock(:github, {\r\n    :uid => '12345',\r\n    :user_info
    => {\r\n      :nickname => 'sandal',\r\n      :email    => \"test@test.com\"\r\n
    \   }\r\n  })\r\n\r\n  visit community_url\r\n\r\n  auth_link = Authorization.find_by_github_uid(\"12345\").\r\n
    \                           authorization_link\r\n\r\n\r\n  assert_equal edit_authorization_link_path(auth_link),
    current_path\r\n  fill_in \"authorization_link_mailchimp_email\", \r\n          :with
    => \"gregory.t.brown@gmail.com\"\r\n  click_button(\"Link this email address to
    my Github account\")\r\n\r\n  refute_empty ActionMailer::Base.deliveries\r\n  mail
    = ActionMailer::Base.deliveries.first\r\n  ActionMailer::Base.deliveries.clear\r\n\r\n
    \ assert_equal [\"gregory.t.brown@gmail.com\"], mail.to\r\n\r\n  auth_link.reload\r\n\r\n
    \ visit \"/sessions/link/#{auth_link.secret}\"\r\n  assert_equal articles_path,
    current_path\r\nend\r\n```\r\n\r\nBecause I had already fixed the issues that
    would have prevented these tests from passing, this test went green without any
    additional modifications to the application. However, when writing regression
    tests, it's important to be able to verify that your tests are able to detect
    the defects they're meant to protect against. To do so, I went ahead and reverted
    each of my fixes one by one, then reapplied them to confirm that without each
    fix, the tests fail, and with them, the tests pass. This check isn't quite a substitute
    for writing tests before writing code but does at least help ensure that your
    tests are valid.\r\n\r\nNow that the immediate concern of having some tests to
    accompany my bug fixes was resolved, I turned my eye to the messy code I had just
    written and found it in dire need of refactoring. Because I typically only ever
    worked far down the Rails stack in my consulting work, proper integration testing
    is a skill I never picked up. But just my sense of Ruby coding in general made
    me realize that I could do some simple extractions to at least hide some of the
    nasty stuff this code was doing. The following tests show what I ended up with.\r\n\r\n```ruby\r\ntest
    \"github autolinking\" do\r\n  email = \"gregory.t.brown@gmail.com\"\r\n  uid
    \  = \"12345\"\r\n\r\n  create_user(:email => email)\r\n  login(:nickname => \"sandal\",
    :email => email, :uid => uid)\r\n\r\n  visit community_url\r\n  get_authorization_link(uid)\r\n\r\n
    \ assert_confirmation_sent(email)\r\n\r\n  assert_activated\r\nend\r\n\r\ntest
    \"github manual linking\" do\r\n  mailchimp_email = \"gregory.t.brown@gmail.com\"\r\n
    \ github_email    = \"test@test.com\"\r\n  uid             = \"12345\"\r\n\r\n
    \ create_user(:email => mailchimp_email)\r\n  login(:nickname => \"sandal\", :email
    => github_email, :uid => uid)\r\n\r\n  visit community_url\r\n  get_authorization_link(uid)\r\n\r\n
    \ assert_email_manually_entered(mailchimp_email)\r\n\r\n  assert_confirmation_sent(mailchimp_email)\r\n\r\n
    \ assert_activated\r\nend\r\n```\r\n\r\nTo get the code to look like this, I didn't
    do anything fancy. I just did ordinary method extractions by pushing paragraphs
    of code down into functions. In the event that you want to see exactly what changes
    I made, you can check out [this gist](https://gist.github.com/3829d5bfc124c3640c5b),
    which contains the entire test file. The end result provides a fairly nice high-level
    description of each step of these two scenarios.\r\n\r\nWriting these tests took
    me longer than I would have liked, in part because I'm not that comfortable with
    integration testing in Rails, but also because there are a lot of moving parts
    to consider. However, because this is a multistep process that involves nontrivial
    setup, repeated manual testing would quickly end up taking up more of my time
    than writing these tests did. For that reason, I definitely suggest writing up
    some integration tests for whatever critical paths you have in your applications.\r\n\r\nTo
    make a long story short, the more annoying your workflows are to test manually,
    the more important it is for you to write automated tests that do the job for
    you. Also, your critical paths through your application really ought to be covered
    with automated tests so that they don't just go up in smoke without you noticing.
    The good news is that your integration tests needn't be bulletproof in order to
    be useful.\r\n\r\n### Reflections\r\n\r\nI am trying to reach two audiences at
    once with this article: those who'd benefit from seeing how bug fixes can be accompanied
    by tests to help prevent regressions, and those who have experience with Rails
    testing who can discuss strategies for how to improve the tests I wrote.\r\n\r\nTo
    be brutally honest, this newsletter is called Practicing Ruby and not Practicing
    Rails for a reason: I'm not really a Rails developer. However, I imagine that
    most of our readers have at least some experience with Rails and that many of
    you may be much stronger at testing Rails applications than I am. My hope is that
    you will take this opportunity to learn by teaching and tell me a thing or two
    about how I could have made my integration tests better.\r\n\r\nIn particular,
    I am made uneasy by the large amount of global state that I'm having to manage
    in my integration tests. Is this a standard practice? If not, what are the alternatives?
    Am I supposed to use more mock objects to avoid these situations? Should I be
    designing my applications differently to make them easier to test? If so, what
    changes could I make to my implementation code to make these tests easier to write?
    These are all questions that ran through my mind as I was working on this article,
    and I'd appreciate any links to good resources that might help me answer them,
    or some advice based on your own experiences.\r\n"
- :slug: learning-new-things-step-by-step
  :title: Learning new things step-by-step
  :summary: Build a simple arcade game in 13 tiny steps.
  :published: 2011-09-27 00:00:00.000000000 Z
  :issue_number: '2.6'
  :volume: 2
  :body: "One of the lessons I always try to teach programmers of various skill levels
    is that it is very important to work in small steps. This approach is especially
    important when you're learning a new tool or technique, due to all the unexpected
    issues that can crop up in uncharted territory. Most folks seem to conceptually
    understand the value of working in small iterations, yet still bite off more than
    they can chew on a consistent basis because the question of \"how small is small
    enough?\" is a hard one to answer.\r\n\r\nIn this article, I have written up the
    steps I took to familiarize myself with the game library [Ray](http://mon-ouie.github.com/projects/ray.html).
    Although I am somewhat familiar with vector graphics, I've never built an arcade
    game before in any programming language, so it's genuinely new territory for me.
    Regardless of whether you have experience with this sort of programming, you should
    thus be able to follow along in my footsteps and have a similar experience to
    mine.\r\n\r\n## Building a simple arcade game in 13 steps\r\n\r\nOriginally, I'd
    planned to build a fairly complete Pac-Man clone, but then I realized that process
    would be a bit too complicated to explain in a single article. So I decided to
    instead go with a more basic rule set that would still keep some of the Pac-Man
    style gameplay intact.\r\n\r\nThe game I came up with is called \"Goodies and
    Baddies,\" and the rules are very simple. You play as a small red rectangle on
    a 640x480 screen, and you move around using your keyboard's arrow keys. There
    are 20 goodies (white rectangles) randomly distributed around the playing area,
    and your job is to collect them all. However, you need to avoid being captured
    by the 5 baddies (blue rectangles), who will chase you around the screen as you
    try to collect the goodies. Touching one of the baddies will cause you to lose,
    but if you can collect all 20 goodies without getting captured, you win!\r\n\r\nAfter
    establishing this set of rules, I set out to implement the game. I took notes
    as I worked and was able to identify 13 distinct steps that I took as I worked
    towards the final goal. They are listed here and serve as a good blueprint for
    trying this out at home if you have the time to do so:\r\n\r\n* Step 1: Render
    Ray's \"Hello World\" example\r\n* Step 2: Render a red 20x20 square to the screen\r\n*
    Step 3: Get the red square to follow the mouse pointer\r\n* Step 4: Move the square
    to the left using the left arrow\r\n* Step 5: Allow all arrow keys to move the
    square\r\n* Step 6: Make the square move a bit faster\r\n* Step 7: Display 20
    randomly placed 10x10 white squares\r\n* Step 8: Keep the red square from leaving
    the screen\r\n* Step 9: Remove white squares when they get covered up \r\n* Step
    10: Display \"You win\" when all white squares are gone.\r\n* Step 11: Add five
    randomly placed 15x15 blue squares\r\n* Step 12: Display \"You lose\" on collision
    with a blue square\r\n* Step 13: Make the blue squares follow the red square\r\n\r\nThose
    who can't follow along by running my code should still be able to walk through
    the process virtually by looking at my implementation code while examining the
    screenshots and videos I've provided. The videos were recorded without any sound
    and are simply visual aids to make it easier to understand what the code in this
    article is actually doing.\r\n\r\nWhat follows is a detailed report of my progress
    on each step. Those wishing to implement the game themselves before reading how
    I built it should stop reading now and head on over to the [Ray documentation](http://mon-ouie.github.com/projects/ray.html).\r\n\r\n##
    Step 1: Render Ray's \"Hello World\" example\r\n\r\nA \"Hello World\" example
    is typically the most simple program that can be written using any system. It
    is not designed to teach you how a given library or framework is meant to be used
    but is instead meant to provide a smoke test to make sure that there are no obvious
    issues with your environment before you take on more serious work.\r\n\r\nGetting
    a \"Hello World\" example to run is not necessarily a sign that you will have
    smooth sailing from there on out, but failing to get one to run raises major red
    flags. That's why I chose running Ray's \"Hello World\" as our first step, even
    though we don't need to mess with rendering text until much later in the process.\r\n\r\n###
    Implementation\r\n\r\nThe following code was taken directly from Ray's website
    and is simple enough that it's pretty obvious what's going on, even if you haven't
    worked with the library before.\r\n\r\n```ruby\r\nrequire 'ray'\r\n\r\nRay.game
    \"Hello world!\" do\r\n  register { add_hook :quit, method(:exit!) }\r\n\r\n  scene
    :hello do\r\n    @text = text \"Hello world!\", :angle => 30, :at => [100, 100],
    :size => 30\r\n    render { |win| win.draw @text }\r\n  end\r\n\r\n   scenes <<
    :hello\r\nend\r\n```\r\n\r\n### Results\r\n\r\nWhen I ran the \"Hello World\"
    example, here is what was rendered in a little 640x480 window on my screen:\r\n\r\n<div
    align=\"center\">\r\n<img width=\"640\" src=\"http://i.imgur.com/pYJSi.png\" alt=\"\"
    title=\"Hosted by imgur.com\" />\r\n</div>\r\n\r\nThough not particularly exciting,
    it serves the purpose of verifying that the library can at least be loaded up
    and successfully complete a trivial task. Because Ray has some external dependencies
    that must be manually installed, this test is especially important.\r\n\r\nIf
    we look a little more carefully at the rendered content and compare it to our
    implementation code, we get a few hints about how Ray works. For example, we can
    infer that the default background color is black and the default text color is
    white. We can also infer that it displays the first _scene_  by default without
    explicitly telling it which scene to render. We also see that it looks like Ray's
    coordinate system places y=0 at the top of the screen. This placement is pretty
    common for graphics systems, but it's always good to get the question of \"Which
    way is up?\" out of the way as early as possible.\r\n\r\nIt wouldn't be hard to
    come up with more questions that might be answerable by tweaking this example
    a bit, but when I first start learning a new library, I try not to be too adventurous.
    So rather than getting bogged down in the details, I revisited the documentation
    to figure out how to render a rectangle to the screen.\r\n\r\n## Step 2: Render
    a red 20x20 square to the screen\r\n\r\nRendering text was a nice start, but because
    most of this game hinges on manipulting polygons, not words, it was important
    to test out some basic drawing operations right away. Because Ray's documentation
    includes a whole section on polygons, this next step was quite easy to work through.\r\n\r\n###
    Implementation\r\n\r\nThe simple program here shares the same boilerplate code
    as the previous \"Hello world\" example but simply swaps out the text rendering
    code with some polygon manipulation code.\r\n\r\n```ruby\r\nrequire 'ray'\r\n\r\nRay.game
    \"Test\" do\r\n  register { add_hook :quit, method(:exit!) }\r\n\r\n  scene :square
    do\r\n    @rect = Ray::Polygon.rectangle([0, 0, 20, 20], Ray::Color.red)\r\n    @rect.pos
    = [200, 200]\r\n\r\n    render do |win|\r\n      win.draw @rect\r\n    end\r\n
    \ end\r\n\r\n  scenes << :square\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe following
    screenshot shows what was rendered to the screen after I made this small change:\r\n\r\n<div
    align=\"center\">\r\n<img src=\"http://i.imgur.com/3iXgj.png\" alt=\"\" title=\"Hosted
    by imgur.com\" />\r\n</div>\r\n\r\nAfter comparing the results to the implementation
    code, it became clear to me that in order to use Ray effectively, I'd need to
    begin thinking in terms of vector graphics and matrix transformations. In particular,
    the example demonstrates that Ray represents its drawable objects using an abstract
    coordinate system for points and edges and then translates those coordinates to
    determine where they end up being rendered on the screen. This is why we define
    the square with a top-left corner of (0,0) and then later explicitly set the position
    to (200,200).\r\n\r\nKnowing the math behind 2D transformations is not essential
    for completing this exercise, but a basic background in those concepts wouldn't
    hurt. I kept forgetting that this was how Ray worked under the hood while working
    on this article, which caused some of my debugging sessions to drag on longer
    than they should have. If you're following along at home and attempting to do
    each step before reading how I did it, it might not hurt for you to brush up on
    [the basic math involved in 2D graphics](http://www.willamette.edu/~gorr/classes/GeneralGraphics/Transforms/transforms2d.htm)
    before continuing with the exercise.\r\n\r\nOnce I got a square rendered on the
    screen, the next step was to make it move.\r\n\r\n## Step 3: Get the red square
    to follow the mouse pointer\r\n\r\nEven though the final plans called for this
    to be a game you play using the arrow keys on your keyboard instead of a mouse,
    the `on :mouse_motion` example in Ray's documentation was staring me in the face
    and provided too much instant gratification to skip over.\r\n\r\n### Implementation\r\n\r\nThis
    code shows the changes that I made to make the square follow the mouse pointer
    around the screen. If you are trying to run these examples as you read along,
    simply replace the scene code from step 2 with this new implementation. All the
    other boilerplate code will remain the same throughout the rest of this article.\r\n\r\n```ruby\r\nscene
    :square do\r\n  @rect = Ray::Polygon.rectangle([0, 0, 20, 20], Ray::Color.red)\r\n
    \ @rect.pos = [200,200]\r\n\r\n  on :mouse_motion do |pos|\r\n    @rect.pos =
    pos\r\n  end\r\n\r\n  render do |win|\r\n    win.draw @rect\r\n  end\r\nend\r\n```\r\n\r\n###
    Results\r\n\r\nThis video shows the red square following the mouse pointer around
    the screen:\r\n\r\n<iframe width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/ywwcj1KH-1o?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nOnce I got this code working,
    I was able to get a rough sense of how Ray handles its main event loop. The `on()`
    method allows you to define observers for various events. Any matching callbacks
    get triggered on each tick, before the `render` code gets executed. The `:mouse_motion`
    event was an easy one to start with because it simply yields the position of the
    mouse pointer on each tick, but the general concept could be applied just as well
    to key press events.\r\n\r\nBut before messing with handling keyboard interaction,
    I decided to take a quick glance at what kind of object the `on :mouse_motion`
    observer was yielding. I thought it was possible that these would be just simple
    two-element arrays, but after doing a few printline statements, realized that
    they were `Ray::Vector2` objects. A [brief source dive](https://github.com/Mon-Ouie/ray/blob/master/lib/ray/vector.rb)
    brought me up to speed on what to expect from this sort of object; then I moved
    on to the next step.\r\n\r\n## Step 4: Move the square to the left using the left
    arrow\r\n\r\nI initially tripped up on this step because I didn't understand that
    the `:key_press` event gets triggered only when the key is initially pressed and
    does not trigger repeatedly while a key is held down. However, once I found the
    matching `:key_release` event and an example that used both of them, I was able
    to make some progress by implementing some simple transactional logic.\r\n\r\n###
    Implementation\r\n\r\nThe following code uses an instance variable `@moving_left`
    to track whether the square needs to continue moving left. Whenever `@moving_left`
    is true, it uses vector addition to translate the current position of the rectangle.\r\n\r\n```ruby\r\nscene
    :square do\r\n  @rect = Ray::Polygon.rectangle([0, 0, 20, 20], Ray::Color.red)\r\n
    \ @rect.pos = [200,200]\r\n\r\n  on :key_press, key(:left) do\r\n    @moving_left
    = true\r\n  end\r\n\r\n  on :key_release, key(:left) do\r\n    @moving_left =
    false\r\n  end\r\n\r\n  render do |win|\r\n    win.draw @rect\r\n    @rect.pos
    += [-1,0] if @moving_left\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe
    following video shows the red square creeping slowly to the left each time I hold
    down the left arrow key:\r\n\r\n<iframe width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/7k64QyBiq_0?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nAfter I got this step working,
    I investigated a couple more things about Ray through experimentation. My tinkering
    caused me to discover that the `key()` method actually converts the symbolic value
    `:left` into a `Ray::Key` object, which is a simple container that looks up the
    key code for you. I also found out that the position of a drawable object appears
    to be immutable, so you can't do things like `@rect.pos.x -= 1` and expect it
    to work. Instead, you need to do vector addition and then assign a new position
    object. This design decision would have made a lot more sense to me if I kept
    the mathematical underpinnings of vector graphics in mind while working in this
    step, but instead, it just lead me to scratch my head for a while.\r\n\r\n## Step
    5: Allow all arrow keys to move the square\r\n\r\nI could have repeated the general
    approach I took in step 4 to get all my arrow keys working, but it would have
    been tedious. If I read the documentation a little more closely before starting
    step 4, I would have seen that Ray's author pretty much says exactly that in one
    of his examples.\r\n\r\n### Implementation\r\n\r\nThe following code uses the
    conditionless callback `always` to run some code on each tick and checks whether
    a key is being held down by calling the aptly named `holding?` method that I overlooked
    in step 4.\r\n\r\n```ruby\r\nscene :square do\r\n  @rect = Ray::Polygon.rectangle([0,
    0, 20, 20], Ray::Color.red)\r\n  @rect.pos = [200,200]\r\n\r\n  always do\r\n
    \   @rect.pos += [-1, 0] if holding?(:left)\r\n    @rect.pos += [1, 0] if holding?(:right)\r\n
    \   @rect.pos += [0, -1] if holding?(:up)\r\n    @rect.pos += [0, 1] if holding?(:down)\r\n
    \ end\r\n\r\n  render do |win|\r\n    win.draw @rect\r\n  end\r\nend\r\n```\r\n\r\n###
    Results\r\n\r\nAfter making this change, the red square was able to move in all
    directions, as shown in the following video. Moving diagonally simply requires
    holding down two keys at once (i.e., holding up and left moves northwest across
    the screen).\r\n\r\n<iframe width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/zW98M-tdzfo?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nThe main thing that I noticed
    was that moving the red square around was tedious because it was moving so slowly.
    I investigated a few options, including changing Ray's default frame rate, but
    my wife quickly talked me into doing something much simpler.\r\n\r\n## Step 6:
    Make the square move a bit faster\r\n\r\nThis step involved tweaking the distance
    traveled by the red square on each tick, thus increasing its speed.\r\n\r\n###
    Implementation\r\n\r\nIn the following code, I changed the distance that the red
    square moves when a key is held down from 1 to 2, effectively doubling its speed.\r\n\r\n```ruby\r\nscene
    :square do\r\n  @rect = Ray::Polygon.rectangle([0, 0, 20, 20], Ray::Color.red)\r\n
    \ @rect.pos = [200,200]\r\n\r\n  always do\r\n    @rect.pos += [-2, 0] if holding?(:left)\r\n
    \   @rect.pos += [2, 0] if holding?(:right)\r\n    @rect.pos += [0, -2] if holding?(:up)\r\n
    \   @rect.pos += [0, 2] if holding?(:down)\r\n  end\r\n\r\n  render do |win|\r\n
    \   win.draw @rect\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThis video
    shows the faster-moving rectangle. Jumping a distance of two pixels at a time
    still looks like smooth motion, so this approach definitely was more simple than
    any of the other ideas I had in mind.\r\n\r\n<iframe width=\"640\" height=\"480\"
    src=\"//www.youtube.com/embed/B4_KZonH3qw?rel=0\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nThis
    was the first time that I started feeling the desire to refactor things: updating
    four values when I could have updated one seemed a bit tedious. However, I try
    to keep a semistrict policy of not refactoring unless I am in deep pain for the
    first few hours of working with a new tool. The reason I do this is to allow my
    mind to work in a purely creative mode, avoiding invoking the inner \"judge\"
    that I talked about in [Practicing Ruby 2.2](http://practicingruby.com/articles/2).
    Take this note as fair warning, though: there will be more repetitive code to
    come before this exercise is completed!\r\n\r\nAt this point, I had a red square
    moving at a speed that looks comparable to how things tend to move in old-school
    arcade games. Because the novelty value of moving a little square around in a
    void wears off pretty quickly, the next step was to introduce some other game
    objects into the mix.\r\n\r\n## Step 7: Display 20 randomly placed 10x10 white
    squares\r\n\r\nIn this step, I introduced the goodies that our red rectangle is
    meant to collect. Researching collision detection at this point would only complicate
    things, so instead I focused on the visual aspect of things as well as some simple
    bounds testing.\r\n\r\n### Implementation\r\n\r\nThe following code generates
    20 random squares and renders them completely within the visible area on the screen.
    It does not introduce any new Ray concepts, so it should be pretty easy to follow.\r\n\r\n```ruby\r\nscene
    :square do\r\n  @rect = Ray::Polygon.rectangle([0, 0, 20, 20], Ray::Color.red)\r\n
    \ @rect.pos = [200,200]\r\n\r\n  max_x = window.size.width - 20\r\n  max_y = window.size.height
    - 20\r\n\r\n  @goodies = 20.times.map do\r\n    x = rand(max_x) + 10\r\n    y
    = rand(max_y) + 10\r\n    \r\n    g = Ray::Polygon.rectangle([0,0,10,10])\r\n
    \   g.pos = [x,y]\r\n\r\n    g\r\n  end\r\n\r\n  always do\r\n    @rect.pos +=
    [-2, 0] if holding?(:left)\r\n    @rect.pos += [2, 0] if holding?(:right)\r\n
    \   @rect.pos += [0, -2] if holding?(:up)\r\n    @rect.pos += [0, 2] if holding?(:down)\r\n
    \ end\r\n\r\n  render do |win|\r\n    @goodies.each { |g| win.draw(g) }\r\n    win.draw
    @rect\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe following screenshot
    demonstrates what this effect ended up looking like. It's almost like a starry
    night! \r\n\r\n<div align=\"center\">\r\n<img src=\"http://i.imgur.com/yLqJW.png\"
    alt=\"\" title=\"Hosted by imgur.com\" />\r\n</div>\r\n\r\nAdding bounds checking
    to make sure the white squares would be rendered within the visible area of the
    screen reminded me that I should have done something similar to prevent the red
    square from moving beyond the edge of the screen as well.\r\n\r\n## Step 8: Keep
    the red square from leaving the screen\r\n\r\nThe next step was to implement a
    rudimentary means of keeping the red square from completely disappearing from
    the screen.\r\n\r\n### Implementation\r\n\r\nThe following code checks to make
    sure that the top-left corner of the red square never exits the screen by updating
    its position only if the new location is within the screen's dimensions. I show
    only the updated `always` callback because it was the only thing that changed.\r\n\r\n```ruby\r\nalways
    do\r\n  if @rect.pos.x - 2 > 0\r\n    @rect.pos += [-2, 0] if holding?(:left)\r\n
    \ end\r\n\r\n  if @rect.pos.x + 2 < window.size.width\r\n    @rect.pos += [2,
    0] if holding?(:right)\r\n  end\r\n\r\n  if @rect.pos.y - 2 > 0\r\n    @rect.pos
    += [0, -2] if holding?(:up)\r\n  end\r\n\r\n  if @rect.pos.y + 2 < window.size.height\r\n
    \   @rect.pos += [0, 2] if holding?(:down)\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe
    following video shows bounds checking behavior that is slightly different than
    the previous implementation code; my original code used (-10,-10) rather than
    (0,0) as the abstract origin for my rectangle. If you run the code yourself, your
    rectangle will get closer to the edge at times than what this video shows.\r\n\r\n<iframe
    width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/FDbvirfhywY?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nIn retrospect, this code was
    a bit buggy, as it really should have been looking at all the corners of the square,
    not just the top-left corner. But because it was good enough to keep the red square
    from completely sailing off into the void, I decided to save the fix as a problem
    for later. Putting it off would be a bad idea if I were writing production code,
    but thankfully the rules for spiking are different.\r\n\r\nThe next step was to
    get over my tensions about this buggy and unrefactored code and get my red square
    to interact with the white squares.\r\n\r\n## Step 9: Remove white squares when
    they get covered up \r\n\r\nIn this step, we finally need to think about collision
    detection: specifically, how to determine when one rectangle is contained within
    another. It turns out that Ray provides some helpers for this, but it took a source
    dive for me to find them, and a lot of experimentation to figure out how exactly
    to use them.\r\n\r\n### Implementation\r\n\r\nThe following code uses the `Array#to_rect`
    core extension that Ray provides for creating `Ray::Rect` objects. This object
    provides basic collision detection routines, including an `inside?` method that
    can be used to determine whether one rectangle is completely contained within
    another. On each tick, any of the white squares that are contained with the bounds
    of the red square get removed.\r\n\r\n```ruby\r\nalways do\r\n  # same code as
    in step 8 goes here\r\n\r\n  @goodies.reject! { |e|\r\n    goodie = [e.pos.x,
    e.pos.y, 10, 10].to_rect\r\n    \r\n    goodie.inside?([@rect.pos.x, @rect.pos.y,
    20, 20])\r\n  }\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe following video demonstrates
    collecting goodies. To make things a bit more challenging, I made it so that you
    must completely cover the white squares rather than simply touching them.\r\n\r\n<iframe
    width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/MmLlCMS0a7s?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nOnce I figured out how to use
    `Ray::Rect`, implementing this functionality was relatively straightforward. However,
    my early confusion about `Ray::Polygon.rectangle` made me think that it returned
    a `Ray::Rect` object, which it does not. After digging through the source for
    both `Polygon` and `Rect` at both the Ruby level and the C level, I could not
    find an easy way to automatically convert a rectangular polygon into a `Rect`
    object, maybe because Ray is still a pretty young library, or maybe because of
    a design decision. \r\n\r\nRather than dwelling on that question, I just manually
    instantiated `Ray::Rect` objects via `Array#to_rect` so that I could keep moving
    on. This is the exact point at which I thought that perhaps I should introduce
    some sort of data model for my game objects that could implement `to_rect` on
    and remove some of this duplication, but I once again brushed those tensions aside
    in favor of moving on to something new.\r\n\r\n## Step 10: Display \"You win\"
    when all white squares are gone\r\n\r\nIn this step, I introduced the winning
    game condition, which is removing all the white squares from the screen.\r\n\r\n###
    Implementation\r\n\r\nOnly a minor modification to the `render` callback was needed
    to complete this step. We simply check whether the array of white squares is empty,
    and if so, render the phrase \"YOU WIN\" to the screen similar to the way we rendered
    \"Hello World\" in step 1.\r\n\r\n```ruby\r\nrender do |win|\r\n  if @goodies.empty?\r\n
    \   win.draw text(\"YOU WIN\", :at => [100,100], :size => 60)\r\n  else\r\n    @goodies.each
    { |g| win.draw(g) }\r\n    win.draw @rect\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe
    following video demonstrates that the game can now be won. You may want to fast-forward
    a bit, as it takes a while to collect all those white squares.\r\n\r\n<iframe
    width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/G2gqOCoK4_o?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nThis was a really simple step,
    so there isn't much more to say about it. The next step was to introduce baddies
    into the game. \r\n\r\n## Step 11: Add five randomly placed 15x15 blue squares\r\n\r\nIn
    this step, I placed some blue squares in random locations around the screen to
    serve as our baddies. As in step 7, I focused on the visual aspect of things and
    didn't immediately jump into collision detection or movement rules.\r\n\r\n###
    Implementation\r\n\r\nThe following code shows the changes that needed to be made
    to get the blue squares onto the screen. They are very similar to those in step
    7, but if you want to see the full context, you can view [a snapshot of the game's
    source code for this step](https://github.com/elm-city-craftworks/goodies_and_baddies/blob/41110cc71d3f94231754313fec47d1ad6a87e902/game.rb\r\n)
    on github.\r\n\r\n```ruby\r\nscene :square do\r\n  # same code as step 10 goes
    here\r\n\r\n  @baddies = 5.times.map do\r\n    x = rand(max_x) + 15\r\n    y =
    rand(max_y) + 15\r\n    g = Ray::Polygon.rectangle([0,0,15,15], Ray::Color.blue)\r\n
    \   g.pos += [x,y]\r\n    g\r\n  end\r\n  \r\n  always do\r\n    # ... same as
    step 10 goes here\r\n  end\r\n\r\n  render do |win|\r\n    if @goodies.empty?\r\n
    \     win.draw text(\"YOU WIN\", :at => [100,100], :size => 60)\r\n    else\r\n
    \     @goodies.each { |g| win.draw(g) }\r\n      @baddies.each { |g| win.draw(g)
    }\r\n      win.draw @rect\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe
    following screenshot shows what the randomized blue squares look like:\r\n\r\n<div
    align=\"center\">\r\n<img src=\"http://i.imgur.com/Q9mwQ.png\" alt=\"\" title=\"Hosted
    by imgur.com\" />\r\n</div>\r\n\r\nThis step was pretty much a direct repeat of
    what I did in step 7, so there isn't a whole lot of interesting things to discuss
    here. The next step was to get these blue squares to be more than just pretty
    drawings by making them deadly.\r\n\r\n## Step 12: Display \"You lose\" on collision
    with a blue square\r\n\r\nIn this step, I introduce a losing condition, which
    marks the point where my program actually becomes a functional game, even if it's
    a very boring one.\r\n\r\n### Implementation\r\n\r\nRevisiting the `Ray::Rect`
    source code, I found that it also provides a simple `collide?` method that tells
    you whether any part of a given rectangle intersects with another. The following
    code uses this feature to make it so that even if a single point of a blue rectangle
    touches the red one, the game ends in a loss. If this excerpt is too hard to follow
    without the surrounding context, check out [the source code of the game at this
    step](https://github.com/elm-city-craftworks/goodies_and_baddies/blob/5595b3fe43decd1f06f1376cc2bd1cfd9c24ec06/game.rb)
    on github.\r\n\r\n```ruby \r\nscene :square do\r\n  # same code as in step 11\r\n\r\n
    \ always do\r\n    # same code as in step 11\r\n\r\n    @game_over ||= @baddies.any?
    { |e|\r\n      baddie = [e.pos.x, e.pos.y, 15, 15].to_rect\r\n      baddie.collide?([@rect.pos.x,
    @rect.pos.y, 20,20])\r\n    }\r\n  end\r\n\r\n  render do |win|\r\n    if @goodies.empty?\r\n
    \     win.draw text(\"YOU WIN\", :at => [100,100], :size => 60)\r\n    elsif @game_over\r\n
    \     win.draw text(\"YOU LOSE\", :at => [100,100], :size => 60)\r\n    else\r\n
    \     @goodies.each { |g| win.draw(g) }\r\n      @baddies.each { |g| win.draw(g)
    }\r\n      win.draw @rect\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThis
    video shows that the game ends in failure as soon as the red square touches a
    blue square:\r\n\r\n<iframe width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/4W37HjwBHiw?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nIn this step, I explicitly
    built even more `Ray::Rect` objects, pushing me even closer to the breaking pointa
    point at which refactoring was not simply desirable but absolutely necessary.
    But with only one step left to implement before completing the exercise, I pressed
    on.\r\n\r\n## Step 13: Make the blue squares follow the red square\r\n\r\nThis
    final step makes the game a whole lot more interesting and even somewhat fun.
    There are lots of ways that you could code the movement rules for the baddies,
    but I went with the simplest one: proceed in a straight line toward the red square
    on each tick.\r\n\r\n### Implementation\r\n\r\nThis code should be fairly self-explanatory,
    as it does not introduce any new Ray concepts. It uses a simple algorithm for
    moving each blue square towards the red square that randomizes the distance traveled
    on each tick by choosing a number between 0 and 2.5. The [final source code for
    the game](https://github.com/elm-city-craftworks/goodies_and_baddies/blob/cdf0fe1b59fe2416886e94da6e45c2affc1dc111/game.rb)
    is available on github.\r\n\r\n```ruby\r\nscene :square do\r\n  # same code as
    in step 12\r\n\r\n  always do\r\n    # same code as in step 12\r\n\r\n    @baddies.each
    do |e|\r\n      if e.pos.x < @rect.pos.x\r\n        e.pos += [rand*2.5,0]\r\n
    \     else\r\n        e.pos -= [rand*2.5,0]\r\n      end\r\n\r\n      if e.pos.y
    < @rect.pos.y\r\n        e.pos += [0, rand*2.5]\r\n      else\r\n        e.pos
    -= [0, rand*2.5]\r\n      end\r\n    end\r\n  end\r\n\r\n  render do |win|\r\n
    \   # same code as in step 12\r\n  end\r\nend\r\n```\r\n\r\n### Results\r\n\r\nThe
    following video shows a complete run of the game, ending in victory. Before you
    try it out yourself and end up frustrated, please note that I recorded about 20
    losses before getting conditions favorable enough for me to win.\r\n\r\n<iframe
    width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/290MSnc72Jg?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nAt this point, I accomplished
    my goal of having a fairly interesting playable game in 13 small steps. If I wanted
    to go further, I would first go back and comprehensively refactor this code, and
    I would also study Ray in a more detailed fashion. However, I was thrilled to
    be able to get this far without doing that.\r\n\r\n## Reflections\r\n\r\nHopefully,
    seeing my process of learning new things has been useful to you. Everyone says
    you should work in baby steps, but it is my experience that many intermediate
    developers have a much different idea of what a 'small step' is than more skilled
    developers tend to have. Even with my level of experience, I consistently find
    that the programmers that I look up to have a much more refined sense of simplicity
    and focus than I do. \r\n\r\nOne of the most beneficial aspects of taking things
    one step at a time is that doing so isolates the risk of running into unknown-unknowns
    and lets you handle them individually. There were many times when holes in my
    own understanding of how Ray works combined with holes in its documentation caused
    me to get confused or frustrated. However, the feeling of struggling with a single
    issue is much more manageable than thinking about dozens of potential blockers
    simultaneously.\r\n\r\nThere is also something to be said for instant gratification.
    The smaller your steps are, the sooner you see some measureable progress. Each
    successful step forward gives you a small feeling of satisfaction that motivates
    you to take on the next challenge. This feeling is a key reason why many people
    like doing test-driven development, and it can be applied to a broad range of
    practices.\r\n\r\nThe one thing that I often reevaluate while working in this
    style is to what extent I should be refactoring as I go. Writing about my process
    today made me even more uncertain about whether it makes sense to let the code
    get so ugly just for the sake of preventing judgmental thoughts from arising.
    However, I feel like the question of whether to refactor as you go is largely
    a matter of personal preference. That said, I'm very curious to hear what your
    experience was like while working through this exercise, as well as what you thought
    of the approach I took. So what do you think?\r\n\r\n"
- :slug: unobtrusive-ruby-in-practice
  :title: '"Unobtrusive Ruby" in Practice'
  :summary: Explore ideas from Mike Burns's "Unobtrusive Ruby" blog post via practical
    code samples.
  :published: 2011-10-04 00:00:00.000000000 Z
  :issue_number: '2.7'
  :volume: 2
  :body: "When Mike Burns outlined his vision of [Unobtrusive Ruby](http://robots.thoughtbot.com/post/10125070413/unobtrusive-ruby),
    I initially thought it was going to be a hit with the community. However, a lack
    of specific examples led to a backlash of criticism and caused the post to generate
    more heat than light. This is unfortunate, because the ideas he outlined are quite
    valuable and shouldn't be overlooked.\r\n\r\nIn this article I share my own interpretation
    of what Unobtrusive Ruby means, based on the the points that Mike outlined. I
    can't guarantee that my take on this is what Mike had in mind, but it should be
    interesting to those who wanted a more well defined roadmap than what he provided.
    To get this most out of this article, I recommend going back and [reading what
    Mike wrote](http://robots.thoughtbot.com/post/10125070413/unobtrusive-ruby) before
    continuing on. Try to think about what these concepts mean to you, and then compare
    them to what I've outlined here.\r\n\r\nThe following guidelines are the ones
    Mike laid out, but I've replaced his explanations with my own in the hopes that
    attacking these ideas from a second angle will be useful.\r\n\r\n## Take Objects,
    Not Classes\r\n\r\nBecause Ruby lets us pass classes around like any other object,
    we have a way to do dependency injection that isn't as common in other languages.
    For example, we can write something like the following code:\r\n\r\n``` ruby\r\nclass
    Roster\r\n def initialize          \r\n    @participants = []  \r\n  end  \r\n
    \ \r\n  def <<(new_participant)  \r\n    @participants << new_participant  \r\n
    \ end  \r\n  \r\n  def participant_names  \r\n    @participants.map { |e| e.full_name
    }  \r\n  end  \r\n  \r\n  def print(printer=RosterPrinter)\r\n    printer.new(participant_names).print\r\n
    \ end    \r\nend\r\n\r\nclass RosterPrinter  \r\n  def initialize(participant_names)
    \ \r\n    @participant_names = participant_names  \r\n  end  \r\n  \r\n  def print\r\n
    \   puts \"Participants:\\n\" +  \r\n    @participant_names.map { |e| \"* #{e}\"
    }.join(\"\\n\")  \r\n  end  \r\nend \r\n```\r\n\r\nThis feels clever, but this
    form of dependency injection is more brittle than it\r\nneeds to be. A [recent
    conversation with Derick\r\nBailey](http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html#comment-317367342)\r\non
    my [SOLID\r\narticle](http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html)\r\nabout
    a very similar example made me realize just how much we tend to pass\r\nclasses
    around unnecessarily when we could be directly passing the objects our\r\nclass
    depends on. With that in mind, Derick helped me refactor the previous example
    to the more flexible design shown below. \r\n\r\n```ruby\r\nclass Roster\r\n def
    initialize          \r\n    @participants = []  \r\n  end  \r\n  \r\n  def <<(new_participant)
    \ \r\n    @participants << new_participant  \r\n  end  \r\n  \r\n  def participant_names
    \ \r\n    @participants.map { |e| e.full_name }  \r\n  end  \r\n  \r\n  def print(printer=RosterPrinter.new)\r\n
    \   printer.print(@participants)\r\n  end    \r\nend\r\n\r\nclass RosterPrinter
    \   \r\n  def print(participant_names)\r\n    puts \"Participants:\\n\" +  \r\n
    \   participant_names.map { |e| \"* #{e}\" }.join(\"\\n\")  \r\n  end  \r\nend
    \r\n```\r\n\r\nWhile this is a subtle change, it has a major impact on the way
    `Roster` and its printer object relate to one another. The `Roster#print` method
    originally had a dependency on both the constructor of its printer object as well
    as its `print()` instance method. Our new code reduces that coupling by depending
    only on the existence of a `print()` method in the general case. The examples
    below demonstrate the added flexibility that this new approach offers us.\r\n\r\n```ruby\r\n#
    does not provide a .new() method\r\nmodule FunctionalPrinter\r\n  def self.print(participant_names)\r\n
    \   puts \"Participants:\\n\" +  \r\n    participant_names.map { |e| \"* #{e}\"
    }.join(\"\\n\")  \r\n  end\r\nend\r\n\r\nrequire \"prawn\"\r\n\r\n# has a different
    constructor than RosterPrinter\r\nclass PDFPrinter\r\n  def initialize(filename)\r\n
    \   @document = Prawn::Document.new\r\n    @filename = filename\r\n  end\r\n\r\n
    \ def print(participant_names)\r\n    @document.text(\"Participants\", :size =>
    16)\r\n\r\n    participant_names.each do |e|\r\n      @document.text(\"- #{e}\")\r\n
    \   end\r\n\r\n    @document.render_file(@filename)\r\n  end\r\nend\r\n\r\nroster
    = Roster.new\r\nroster << \"Gregory Brown\" << \"Jia Wu\" << \"Jordan Byron\"\r\n\r\nputs
    \"USING DEFAULT\"\r\nroster.print\r\n\r\nputs \"USING FUNCTIONAL PRINTER\"\r\nroster.print(FunctionalPrinter)\r\n\r\nputs
    \"USING PDF PRINTER (see roster.pdf)\"\r\nroster.print(PDFPrinter.new(\"roster.pdf\"))\r\n```
    \r\n\r\nBoth the `FunctionalPrinter` and `PDFPrinter` demonstrate corner cases
    that our original code did not account for. By following the guideline of accepting
    objects rather than classes as the arguments to our methods, our new design can
    accomodate these types of objects without modification of the `Roster#print` code.
    As we see from these examples, this makes life easier for us. \r\n\r\n## Never
    Require Inheritance\r\n\r\nSome libaries we use strongly encourages us to create
    subclasses of the objects they provide, while others downright force us to do
    so. `ActiveRecord` is an example of a library that is almost useless without inheritance,
    but is very complicated and would be hard to use as an example. The code below
    is a much simpler example of a tool which expects you to use subclasses of its
    provided `Plugin` class to get the job done.\r\n\r\n```ruby\r\nmodule Inspector\r\n
    \ def self.analyze(data)\r\n    Plugin.registered_plugins.each { |e| e.new.analyze(data)
    }\r\n  end\r\n\r\n  class Plugin\r\n    def self.inherited(base)\r\n      registered_plugins
    << base\r\n    end\r\n\r\n    def self.registered_plugins\r\n      @registered_plugins
    ||= []\r\n    end\r\n\r\n    def analyze(data)\r\n      raise NotImplementedError\r\n
    \   end\r\n  end\r\nend\r\n\r\nclass WordCountPlugin < Inspector::Plugin\r\n  def
    analyze(data)\r\n    word_count = data.split(/ /).length\r\n    puts \"Content
    contained #{word_count} words\"\r\n  end\r\nend\r\n\r\nclass WordLengthPlugin
    < Inspector::Plugin\r\n  def analyze(data)\r\n    longest = data.split(/ /).map
    { |e| e.length }.max\r\n    puts \"Longest word contained #{longest} characters\"\r\n
    \ end\r\nend\r\n\r\nInspector.analyze(\"This is a test of the watcher plugins\")\r\n\r\n##
    OUTPUTS\r\nContent contained 8 words\r\nLongest word contained 7 characters   \r\n```\r\n\r\nUsing
    the `inherited` hook is a clever way to implictly register plugins, but comes
    with a number of downsides. For example, you are forced to make all your plugins
    inherit from `Inspector::Plugin`, which means your class can't be a subclass of
    anything else. Additionally, you need to use a class even if a module would make
    more sense. This is a direct consequence of the \"interface taking classes rather
    than ordinary objects\" issue, and cannot be easily avoided. If you throw in things
    like having to be aware of possible Liskov Substitution Principle violations,
    it becomes clear that an API which forces you to use subclassing is not exactly
    flexible.\r\n\r\nThe code below shows a much more flexible alternative, which
    completely removes the dependency on class inheritance.\r\n\r\n```ruby\r\nmodule
    Inspector\r\n  def self.analyze(data)\r\n    registered_plugins.each { |e| e.analyze(data)
    }\r\n  end\r\n\r\n  def self.registered_plugins\r\n    @registered_plugins ||=
    []\r\n  end\r\nend\r\n\r\nmodule WordCountPlugin\r\n  def self.analyze(data)\r\n
    \   word_count = data.split(/ /).length\r\n    puts \"Content contained #{word_count}
    words\"\r\n  end\r\nend\r\n\r\nmodule WordLengthPlugin\r\n  def self.analyze(data)\r\n
    \   longest = data.split(/ /).map { |e| e.length }.max\r\n    puts \"Longest word
    contained #{longest} characters\"\r\n  end\r\nend\r\n\r\nInspector.registered_plugins
    << WordCountPlugin << WordLengthPlugin\r\nInspector.analyze(\"This is a test of
    the watcher plugins\")\r\n```\r\n\r\nNow any object that has a valid `analyze`
    method will work as a plugin, as long as you explicitly register it with `Inspector`.
    This results in much cleaner looking code for this trivial implementation, but
    the general strategy can also can be used in situations where inheritance is still
    a part of the picture. The code below shows plugins which inherit from a parent
    class coexisting with plugins built from scratch.\r\n\r\n```ruby\r\nmodule Inspector\r\n
    \ def self.analyze(data)\r\n    registered_plugins.each { |e| e.analyze(data)
    }\r\n  end\r\n\r\n  def self.registered_plugins\r\n    @registered_plugins ||=
    []\r\n  end\r\n\r\n  class Plugin\r\n    def self.verify(&block)\r\n      validations
    << block\r\n    end\r\n\r\n    def self.validations\r\n      @validations ||=
    []\r\n    end\r\n\r\n    def self.analyze(&block)\r\n      define_method :analyze
    do |data|\r\n        validate(data) \r\n        block.call(data)\r\n      end\r\n
    \   end\r\n\r\n    def validate(data)\r\n      raise unless self.class.validations.all?
    { |v| v.call(data) }\r\n    end\r\n  end\r\nend\r\n\r\nclass WordCountPlugin <
    Inspector::Plugin\r\n  verify { |data| data.is_a?(String) }\r\n\r\n  analyze do
    |data|\r\n    word_count = data.split(/ /).length\r\n    puts \"Content contained
    #{word_count} words\"\r\n  end\r\nend\r\n\r\nmodule WordLengthPlugin\r\n  # same
    as before, not inheriting from anything\r\nend\r\n\r\nInspector.registered_plugins
    << WordCountPlugin.new << WordLengthPlugin\r\nInspector.analyze(\"This is a test
    of the watcher plugins\")\r\n```\r\n\r\nThis small change makes a big difference
    in flexibility, and leaves some of the decision making up to your users rather
    than forcing them down a particular path. Using the default approach of inheriting
    from `Inspector::Plugin` will feel nearly identical to an inheritance-only approach
    to the user. However, if more customizations are needed, this design provides
    an easy way to build plugins from scratch. Because it is so easy to implement
    this pattern, it is probably worth doing even if your immediate needs don't call
    for such flexibility.\r\n\r\n## Inject Dependencies\r\n\r\nI covered dependency
    injection and the dependency inversion principle at length in [Practicing Ruby
    1.23](http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html).
    Rather than repeating those details here, I'd like you to read that article as
    well as the comments from [Derick Bailey](http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html#comment-317367342).
    My conversation with Derick taught me a thing or two about the subtle distinctions
    between dependency injection (a technique) and dependency inversion (a design
    principle) that are hard to summarize but still well worth working through if
    you want to solidify your understanding of these two very important concepts.\r\n\r\nAs
    an example of some practical code which uses dependency injection, we can look
    at the Highline command line library. In ordinary usage, Highline outputs everything
    to `STDIN` and `STDOUT`. You can install HighLine via RubyGems and run the example
    below to get a feel for how it works.\r\n\r\n```ruby\r\nrequire \"highline\"\r\n\r\nconsole
    = HighLine.new\r\nname    = console.ask(\"What is your name?\") \r\nconsole.say(\"Hello
    #{name}\")\r\n```\r\n\r\nIn ordinary cases, this is exactly what we want: ordinary
    input and output from your console. However, to test HighLine, we made it possible
    to inject input and output objects to use in place of `STDIN` and `STDOUT`. The
    example below shows the use of `StringIO` objects, which is what we use in our
    unit tests. \r\n\r\n```ruby\r\nrequire \"stringio\"\r\nrequire \"highline\"\r\n\r\ninput
    \  = StringIO.new(\"Gregory\\n\")\r\ninput.rewind # set seek pos back to 0\r\n\r\noutput
    \ = StringIO.new\r\n\r\nconsole = HighLine.new(input, output)\r\nname = console.ask(\"What
    is your name?\")\r\nconsole.say(\"Hello #{name}!\")\r\n\r\noutput.rewind\r\nputs
    output.read\r\n```\r\n\r\nInterestingly enough, this 'feature' of HighLine has
    caused it to be used in a number of contexts that we didn't anticipate. For example,
    it is occasionally used in GUI programs for its input validation features, and
    sometimes used in non-interactive scripts for its text formatting features. If
    we had directly worked against `STDIN` and `STDOUT`, these ways of using HighLine
    would not be possible without ugly hacks.\r\n\r\n## Unit Tests Are Fast\r\n\r\nPersonally,
    I am not obsessive about unit test performance. Many Rubyists care a lot about
    this, and advocate the heavy use of mock objects to speed up your tests. Mike
    points out in his article that the combination of \"mock objects, a lack of inheritance,
    and injected dependencies\" will make your tests fast, and that's basically true.
    \r\n\r\nDependency injection does facilitate the use of mock objects, and our
    HighLine example demonstrates why that is the case. A lack of inheritance might
    imply that your method call chains are shorter and that you have fewer dependencies,
    but it's not as strong of a metric as he makes it seem. Eventually, object composition
    can end up being more-or-less the same as inheritance in complexity, and in those
    cases you may still end up with slow tests. But the fact that composed object
    systems are easier to decouple is probably what he's getting at here.\r\n\r\nFor
    some practical examples of how you can use mocks to decouple your tests from your
    code and speed things up a bit, see [Practicing Ruby 1.20](http://blog.rubybestpractices.com/posts/gregory/052-issue-20-thoughts-on-mocking.html).
    If you read through that article, you'll find out why I don't care so much about
    limiting my dependencies to only the object under test. But when all else is considered
    equal, fewer dependencies means less code, which probably means faster tests.\r\n\r\nHaving
    a performant test suite is certainly ideal, it's just a matter of weighing out
    the costs of fine tuning your test suite vs. the benefits that faster test runs
    provide. Personally I felt that Mike came on a bit too strong about this particular
    point, but many well known Rubyists would disagree with me on this one.\r\n\r\n##
    Require No Interface\r\n\r\nMike suggests that your library code should allow
    your user to be able to name their methods however they want, and should be designed
    to consume rather than be consumed. He then recognizes that this may not always
    be possible, and concedes that if you need the user to implement certain features,
    that you should limit it to one or two methods at the most. This is great general
    advice, and if you look at Ruby itself, we can find some good examples.\r\n\r\nThe
    `Enumerable` module is capable of providing the vast majority of its features
    if the user implements only an `each` method. If you want to use things like `sort`,
    you only need the yielded elements to implement a `<=>` method. This means that
    all features in `Enumerable` can be supported by \"one or two methods\" implemented
    by the user, which makes it a very good API considering the great wealth of functionality
    it provides.\r\n\r\nHowever, `Enumerator` takes things a step farther by requiring
    no interface at all. You can name the methods of the target collection anything
    you want, you simply need to tell `Enumerator` which method it should delegate
    its `each` method to when you initialize an `Enumerator`. See the example below
    to see how flexible this approach is.\r\n\r\n```ruby\r\nclass RandomInfiniteList\r\n
    \ def generate\r\n    loop do\r\n      yield rand\r\n    end\r\n  end\r\nend\r\n\r\nenum
    = Enumerator.new(RandomInfiniteList.new, :generate)\r\np enum.next\r\np enum.take(10)\r\n```\r\n\r\nIn
    this way, `Enumerator` can be made to turn any object with an iterator method
    into an `Enumerable` object, regardless what the name of that method is. This
    can be useful when you're working with unidiomatic Ruby objects which provide
    an iterator but do not mix in `Enumerable`.\r\n\r\nWe can also look at a bit less
    abstract of an example. If we look back at our `Inspector` example that we were
    using to discuss how to avoid hard inheritance requirements, we can see that it
    requires only a small interface for plugins to conform to. While it isn't so bad
    that each plugin needed an `analyze` method in our last iteration, we can make
    some modifications to make it so that it depends on no interface at all, which
    may bring us a step closer to what Mike was hinting at.\r\n\r\nThe example below
    shows what an `Inspector` class which implements a \"expects no interface\" API
    style might look like. To keep things interesting, I've left implementing this
    class up to you. If you get stuck, feel free to leave a comment asking for hints
    on how to build this out.\r\n\r\n```ruby\r\n# delegates to the WordLengthPlugin
    module\r\nInspector.report(\"Word Length\") do |data|\r\n  WordLengthPlugin.analyze(data)\r\nend\r\n\r\n#
    implements the report as an inline function\r\nInspector.report(\"Word Count\")
    do |data|\r\n  word_count = data.split(/ /).length\r\n  puts \"Content contained
    #{word_count} words\"\r\nend\r\n\r\nInspector.analyze(\"This is a test of the
    watcher plugins\")\r\n```\r\n\r\n## Data, Not Action\r\n\r\nThis guideline seems
    to boil down to the idea that your API calls should be simple 'data in, data out'
    operations whenever that level of simplicity is easily within reach. After thinking
    about this concept a bit, I realized that a pair of common Ruby operations serve
    as perfect examples.\r\n\r\nSuppose that you want to open a binary file and read
    its contents into a `String`. You could write the following code and it will get
    the job done.\r\n\r\n```ruby\r\nfile = File.open(\"foo.jpg\", \"rb\")\r\nimage_data
    = file.read\r\nfile.close\r\n```\r\n\r\nBut this approach is only the correct
    way to do things if you want to explicitly work with the `File` object and control
    exactly when it gets opened and closed. If all you want to do is read the contents
    of a binary file, this is three actions for what should be one \"data in, data
    out\" operation. Fortunately, Ruby recognizes this as a common use case and provides
    a nicer API that you can use instead.\r\n\r\n```ruby\r\nimage_data = File.binread(\"foo.jpg\")\r\n```\r\n\r\nIn
    this example, we pass the filename and get back the contents of that file data.
    While we have less control over the overall process, we also get to ignore irrelevant
    details like exactly when the file is opened and closed. This is what I think
    that Mike probably meant when he said \"data, not action\", and can be applied
    when designing your own APIs. To drive the point home further, we can look at
    one example.\r\n\r\nThe code below shows the generic form of doing a GET request
    via the `Net::HTTP` standard library. It is not the most terse way to use `Net::HTTP`,
    but one of the most common.\r\n\r\n```ruby\r\nrequire 'net/http'\r\n\r\nurl =
    URI.parse('http://www.google.com')\r\nres = Net::HTTP.start(url.host, url.port)
    do |http|\r\n  http.get('/')\r\nend\r\n\r\nputs res.body\r\n```\r\n\r\nThere is
    a whole lot going on here, including explicit `URI` parsing and explicit calls
    to `get()`. But as we saw with `File.open` vs. `File.binread`, Ruby provides a
    convenient alternative for this very common operation. The open-uri standard library
    makes it possible to write the following code instead.\r\n\r\n```ruby\r\nrequire
    \"open-uri\"\r\n\r\nputs open(\"http://google.com\").read\r\n```\r\n\r\nOnce again,
    we see a series of complex actions being converted into a simple \"data in, data
    out\" operation. In this case, we are converting a string which represents a URI
    into an IO object via the globally available `open()` method. This makes it possible
    for us to not think about explicitly parsing our string into a `URI` object, and
    lets us ignore the details about starting a HTTP connection and explicitly making
    a GET request. When all we want is the source of a web page, it's great to be
    able to ignore these details.\r\n\r\n## Always Be Coding\r\n\r\nAs I reflect back
    on Mike's guidelines for \"Unobtrusive Ruby\", it all seems to come down to making
    life easier for your users by limited the amount of impact your system has on
    them. Give your users small, flexible APIs that do not demand much of their systems,
    and they will have better luck using your code. This seems like a noble set of
    goals to me, and hopefully my examples demonstrate the same spirit that Mike wanted
    to encourage in his post.\r\n\r\nHowever, I always worry about using design guidelines
    like these as some sort of absolute set of commandments. There were a whole lot
    of words like \"always\" and \"never\" in the original \"Unobtrusive Ruby\" post
    which if left unchecked, could cause more harm than good. For me, context is king,
    and these ideas seem much more important for those who are writing code that is
    intended for widespread reuse than they might be for ordinary application development.
    That having been said, the examples I've shown here demonstrate that you can often
    be on the right side of these guidelines with little to no additional effort.
    This means that if we can keep the ideas behind \"Unobtrusive Ruby\" in the back
    of our mind and apply them when it's an easy fit, we may well end up improving
    our code for the better.\r\n\r\nThis article is meant to be a conversation starter,
    and is not meant to be taken as gospel. Please share your own thoughts on what
    \"Unobtrusive Ruby\" means to you, either via a comment here or on your own blog.
    I think it's a conversation worth having, even if we haven't quite nailed down
    all the definitions yet. If we end up getting an interesting discussion going,
    I'll invite Mike to check out what we've discussed and see what he thinks about
    it.\r\n\r\nSo what do you think? Was my code unobtrusive enough for you? If not,
    why not? ;)"
- :slug: ruby-and-the-singleton-pattern-dont-get-along
  :title: Ruby and the singleton pattern don't get along
  :summary: Model the singleton pattern in seven different ways, without discovering
    an elegant solution.
  :published: 2011-10-11 00:00:00.000000000 Z
  :issue_number: '2.8'
  :volume: 2
  :body: "Many design patterns that originated in other object-oriented languages
    have elegant Ruby translations. However, the [Singleton](http://en.wikipedia.org/wiki/Singleton_pattern)
    stands out as a construct that seems to have no good way to implement in Ruby.
    In this article, I will walk through the different options and explain why they
    all have something wrong with them. But first, we need a working definition of
    the singleton pattern to make sure we're on the same page.\r\n\r\nPut briefly,
    the singleton pattern is a clever way of implementing global objects that you
    never need to explicitly instantiate. Not to be confused with Ruby's mostly unrelated
    concept of a \"singleton class,\" the singleton pattern is applied when only a
    single instance of an object is needed across an entire application. Typical examples
    include objects that represent configuration data, global logging systems, and
    other similar structures. But there are also some subtle use cases in Ruby due
    to the fact that classes and modules are objects. For example, we have the `Math`
    module on which we can call methods such as `Math.sin()`, and `Math.cos()`. The
    `Math` module is acting as a singleton object in this context, even if it's not
    immediately obvious to the user. Keep in mind while reading this article that
    I've lumped this sort of use case in with the more traditional ones, as it shifts
    the perspective somewhat.\r\n\r\nThere are a lot of different ways to implement
    this general pattern in Ruby, but as I've already mentioned, they all pretty much
    suck. That said, studying this problem can teach us a thing or two about the subtleties
    (and warts) of the Ruby object system. As you read along, try figuring out the
    downsides of each implementation before moving on to read my explanations. This
    exercise will make the article more interesting and may even uncover some fresh
    ideas that I haven't considered yet.\r\n\r\n### Using the `Singleton` module provided
    by the standard library\r\n\r\nRuby provides a standard library to assist in implementing
    the singleton pattern. The following code (originally from Practicing Ruby 1.25)
    illustrates how you can use this library to build a simple logger object.\r\n\r\n```ruby\r\nrequire
    \"singleton\"\r\n\r\nclass SimpleLogger\r\n  include Singleton\r\n\r\n  def initialize\r\n
    \   @output = []\r\n  end\r\n\r\n  attr_reader :output\r\n\r\n  def error(message)\r\n
    \   output << formatted_message(message, \"ERROR\")\r\n  end\r\n\r\n  def info(message)\r\n
    \   output << formatted_message(message, \"INFO\")\r\n  end\r\n\r\n  def write(filename)\r\n
    \   File.open(filename, \"a\") { |f| f << output.join }\r\n  end\r\n\r\n  private\r\n\r\n
    \ def formatted_message(message, message_type)\r\n    \"#{Time.now} | #{message_type}:
    #{message}\\n\"\r\n  end\r\nend\r\n```\r\n\r\nBy including the `Singleton` module,
    we make it so that it is no longer possible to create an instance of the `SimpleLogger`
    class in an ordinary way.\r\n\r\n```\r\n>> logger = SimpleLogger.new\r\nNoMethodError:
    private method `new' called for SimpleLogger:Class\r\n  from (irb):2\r\n```\r\n\r\nThis
    behavior makes sense, because the point of the singleton pattern is to prevent
    multiple instances of a given object from being created. This example code shows
    how to get at a `SimpleLogger` instance in a way that guarantees that only one
    will be created.\r\n\r\n```ruby\r\nlogger = SimpleLogger.instance\r\n\r\nlogger.error(\"Some
    serious problem\")\r\nlogger.info(\"Something you might want to know\")\r\nlogger.write(\"log.txt\")\r\n```\r\n\r\nThis
    interface is a bit cumbersome to work with, but it gets the job done, and on its
    own isn't too bad. However, disabling `new` and adding an `instance` method isn't
    all that the `Singleton` module does. It also does all of the following things:\r\n\r\n*
    Overrides `inherited()` on the class to ensure that subclasses also retain `Singleton`
    behavior\r\n* Overrides `dup()`/`clone()` on the class to ensure that copied classes
    also retain `Singleton` behavior\r\n* Overrides `_load()` to call `instance()`,
    modifying `Marshal` loading behavior to return the single instance\r\n* Overrides
    `_dump()` to strip state information when serializing via `Marshal`\r\n* Overrides
    `dup()`/`clone()` on the instance to raise a `TypeError`, preventing cloning or
    duping of the instance\r\n\r\nWhen you think about what a singleton object is
    actually meant to be, these changes make sense. However, many Rubyists look at
    this and see a whole lot of complexity without a lot of direct benefits. This
    impression causes many folks to avoid the use of the `Singleton` module in favor
    of implementations that are a bit more low ceremony. These implementations tend
    to ignore some of the edge cases that the `Singleton` module accounts for but
    are much easier to understand.\r\n\r\n### Using a class consisting of only class
    methods\r\n\r\nThe following code uses ordinary class methods as an alternative
    to the previous approach. We explicitly call `undef_method` to make it so that
    instances of this class cannot be created, but otherwise this code is a vanilla
    Ruby class definition.\r\n\r\n```ruby\r\nclass SimpleLogger\r\n  class << self\r\n
    \   undef_method :new\r\n\r\n    def output\r\n      @output ||= []\r\n    end\r\n\r\n
    \   def error(message)\r\n      output << formatted_message(message, \"ERROR\")\r\n
    \   end\r\n\r\n    def info(message)\r\n      output << formatted_message(message,
    \"INFO\")\r\n    end\r\n\r\n    def write(filename)\r\n      File.open(filename,
    \"a\") { |f| f << output.join }\r\n    end\r\n\r\n    private\r\n\r\n    def formatted_message(message,
    message_type)\r\n      \"#{Time.now} | #{message_type}: #{message}\\n\"\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nUsing this class is very simple, as the entire API
    consists of class method calls.\r\n\r\n```ruby\r\nSimpleLogger.error(\"Some serious
    problem\")\r\nSimpleLogger.info(\"Something you might want to know\")\r\nSimpleLogger.write(\"log.txt\")\r\n```\r\n\r\nThis
    approach isn't too bad, but it has its own set of caveats. The use of `undef_method`
    to disable the `new` method makes our `Class` object into something that is some
    ways class-like, but isn't quite a class anymore. From a purity standpoint, something
    just feels wrong about a construct that can exist in an inheritance hierarchy
    but cannot be instantiated. There is also the question of whether it ever really
    makes sense to create a subclass of a singleton object.\r\n\r\nFor a number of
    reasons, these philosophical issues tend to push folks in the direction of Ruby's
    `Module` construct, which at first glance seems to address some of these problems.\r\n\r\n###
    Using a module consisting of only module methods\r\n\r\nEvery module is an object
    that cannot exist in a hierarchy and cannot be instantiated but otherwise holds
    similar properties of `Class` objects. Note how similar this code is to our previous
    example.\r\n\r\n```ruby\r\nmodule SimpleLogger\r\n  class << self\r\n    def output\r\n
    \     @output ||= []\r\n    end\r\n\r\n    def error(message)\r\n      output
    << formatted_message(message, \"ERROR\")\r\n    end\r\n\r\n    def info(message)\r\n
    \     output << formatted_message(message, \"INFO\")\r\n    end\r\n\r\n    def
    write(filename)\r\n      File.open(filename, \"a\") { |f| f << output.join }\r\n
    \   end\r\n\r\n    private\r\n\r\n    def formatted_message(message, message_type)\r\n
    \     \"#{Time.now} | #{message_type}: #{message}\\n\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe
    two approaches are so similar that they look identical from the end user's perspective:\r\n\r\n```ruby\r\nSimpleLogger.error(\"Some
    serious problem\")\r\nSimpleLogger.info(\"Something you might want to know\")\r\nSimpleLogger.write(\"log.txt\")\r\n```\r\n\r\nOf
    course, if we look under the hood, we find that these two implementations are
    quite different. Although it's true that we've effectively made it impossible
    to create a subclass of `SimpleLogger` and that we didn't have to explicitly disable
    the `new` method because `Module` does not provide one, we now are faced with
    the problem that this module can be mixed into other objects.\r\n\r\nJust as a
    class can have methods at the class level and the instance level, a module can
    have methods at the module level and the \"mixin\" level. Our `SimpleLogger` code
    defines all of its methods at the module level, which means that mixing it into
    an object via `include` or `extend` will not add any new functionality to the
    object it gets mixed into. From a purity standpoint, this approach is pretty much
    identical to the \"useless instances\" that would be possible for us to create
    if we allowed calls to the `new` method in our class-based `SimpleLogger`. Modules
    therefore don't actually give us much of an advantage over classes after all.\r\n\r\nTo
    make matters more confusing, Ruby provides us with a couple additional ways to
    use modules to implement the singleton pattern that bring new kinds of complexity
    into the mix.\r\n\r\n### Using a module with `module_function`\r\n\r\nIf I were
    to create a list of Ruby's most confusing features, `module_function` would be
    near the top. It is a keyword (like `private` and `protected`), which allows you
    to specify certain methods within a module to be callable at the module level.
    This feature seems useful at a glance and is even used by Ruby's `Math` module.
    The interesting thing about module methods is that they serve as public methods
    on the module itself but get mixed into other objects as private methods. \r\n\r\nThis
    example code demonstrates directly calling methods on the `Math` module, which
    looks similar to our previous module-based singleton pattern example.\r\n\r\n```ruby\r\nclass
    Point\r\n  def initialize(x,y)\r\n    @x = x\r\n    @y = y\r\n  end\r\n\r\n  attr_reader
    :x, :y\r\n\r\n  def distance_to(other_point)\r\n    Math.hypot(other_point.x -
    x, other_point.y - y)\r\n  end\r\nend\r\n\r\npoint_a = Point.new(0,0)\r\npoint_b
    = Point.new(4,3)\r\n\r\np point_a.distance_to(point_b)\r\n```\r\n\r\nIf we instead
    include the `Math` module into the `Point` class, we see that the behavior is
    different than defining methods directly on the `Math` module because its functionality
    does get mixed into `Point`.\r\n\r\n```ruby\r\nclass Point\r\n  include Math\r\n\r\n
    \ def initialize(x,y)\r\n    @x = x\r\n    @y = y\r\n  end\r\n\r\n  attr_reader
    :x, :y\r\n\r\n  def distance_to(other_point)\r\n    hypot(other_point.x - x, other_point.y
    - y)\r\n  end\r\nend\r\n\r\npoint_a = Point.new(0,0)\r\npoint_b = Point.new(4,3)\r\n\r\np
    point_a.distance_to(point_b)\r\n```\r\n\r\n\r\nThis pattern of having a module
    that doubles as a mixin and a singleton object probably has limited applications,
    but it seems reasonable for the `Math` module because each method provided by
    `Math` is purely functional and is also unlikely to clash with other features
    within a given class. But even if mixing in the `Math` module is convenient and
    relatively safe, we wouldn't want our `Point` object to expose the features that
    the `Math` object provides via its public API. This is where we notice that `module_function`
    anticipates this potential problem and attempts to solve it by making all mixed-in
    methods private.\r\n\r\n```\r\n>> point_a.hypot(4,3)\r\nNoMethodError: private
    method `hypot' called for #<Point:0x0000010083bd68 @x=0, @y=0>\r\n    from (irb):20\r\n
    \   from /Users/seacreature/.rvm/rubies/ruby-1.9.3-rc1/bin/irb:16:in `<main>'\r\n```\r\n\r\nThough
    this is potentially a useful feature, we now must keep in mind that modules that
    utilize `module_function` do not have ordinary mixin behavior. However, this is
    not the main reason why I said that `module_function` is confusing. To generate
    our proper \"WTF?\" moment, we can attempt to use `module_function` to implement
    our `SimpleLogger` object.\r\n\r\n```ruby\r\nmodule SimpleLogger\r\n  module_function\r\n
    \ \r\n  def output\r\n    @output ||= []\r\n  end\r\n\r\n  def error(message)\r\n
    \   output << formatted_message(message, \"ERROR\")\r\n  end\r\n\r\n  def info(message)\r\n
    \   output << formatted_message(message, \"INFO\")\r\n  end\r\n\r\n  def write(filename)\r\n
    \   File.open(filename, \"a\") { |f| f << output.join }\r\n  end\r\n\r\n  private\r\n\r\n
    \ def formatted_message(message, message_type)\r\n    \"#{Time.now} | #{message_type}:
    #{message}\\n\"\r\n  end\r\nend\r\n```\r\n\r\nThat implementation *almost* works,
    but ends up failing with an error that is quite surprising unless you know exactly
    how `module_function` works. \r\n\r\n```\r\n>> SimpleLogger.error(\"This won't
    actually succeed\")\r\nNoMethodError: undefined method `formatted_message' for
    SimpleLogger:Module\r\n    from (irb):29:in `error'\r\n    from (irb):50\r\n    from
    /Users/seacreature/.rvm/rubies/ruby-1.9.3-rc1/bin/irb:16:in `<main>'\r\n```\r\n\r\nThe
    reason this happens is multifaceted. When using `module_function` with no arguments,
    as we do, the public methods that are defined after the `module_function` call
    are treated as module functions and get copied onto the module itself. However,
    once the private keyword is reached, the methods are no longer treated as module
    functions and thus don't end up getting copied onto the module. It is therefore
    effectively impossible to use `module_function` if you want to have your module
    methods call any private methods. If we accept this limitation and remove the
    `private` keyword from our `SimpleLogger` definition, things will work as expected
    using the original runner code from the previous examples.\r\n\r\nIf you made
    it through the previous example without becoming incredibly confused, try guessing
    what this code will do before running it, and then prepare to be surprised.\r\n\r\n```ruby\r\nmodule
    A\r\n  def x\r\n    10\r\n  end\r\n\r\n  module_function :x \r\n\r\n  def x\r\n
    \   12\r\n  end\r\nend\r\n\r\np A.x\r\n\r\nclass B\r\n  include A\r\nend\r\n\r\np
    B.new.x\r\n```\r\n\r\nIf you managed to run this example without thinking that
    `module_function` is an abomination that should be removed from the Ruby language
    post-haste, please leave a convincing argument in the comments section. But you
    may want to first look at `module_function`'s slightly less awkward cousin, `extend
    self`.\r\n\r\n### Using a module with `extend self`\r\n\r\nThe main problem with
    `module_function` is that it has so many moving parts. You need to really understand
    a fairly broad range of Ruby concepts in order to use it effectively. But if we
    accept the notion that it's sometimes useful for a singleton object to double
    as a mixin, we can try another approach that behaves similar to `module_function`
    without too many special cases to consider.\r\n\r\nWe can start by exploring a
    contrived example that demonstrates what happens when you use `extend` to mix
    a module into itself. If it's not immediately obvious what the `extend self` line
    does, treat it as a black box for now and focus on how the objects behave as we
    call methods on them.\r\n\r\n```ruby\r\nmodule A\r\n  extend self\r\n\r\n  def
    x\r\n    y\r\n  end\r\n  \r\n  private\r\n\r\n  def y\r\n    \"yay!\"\r\n  end\r\nend\r\n\r\nclass
    B\r\n  include A\r\nend\r\n\r\nA.x      #=> \"yay!\"\r\nA.y      #=> raises NoMethodError:
    private method `y' called for A:Module\r\nB.new.x  #=> \"yay!\"\r\nB.new.y  #=>
    raises NoMethodError: private method `y' called for #<B:...>\r\n```\r\n\r\nSpeaking
    purely from the perspective of the externally visible behavior, we see that the
    key difference between `module_function` and `extend self` is that `extend self`
    results in identical behavior at both the module level and the mixin level when
    it comes to access control. Both private methods and public methods get mixed
    into the target object, and their access control is kept the same as whatever
    it was in the module definition. This is good because it means that your module
    can actually define private methods without any consequences. The main technical
    downside of this approach is that if `Math` were implemented in this way, including
    the `Math` module in a given object would add all the functions that can be called
    on the `Math` module to the public API of that object. There are workarounds to
    get that sort of behavior without `module_function`, but they're cumbersome and
    not really worth talking about. Assuming that we don't care about this subtle
    distinction, the following code will implement a working `SimpleLogger` singleton
    object that's a bit easier to reason about than the `module_function` version:\r\n\r\n```ruby\r\nmodule
    SimpleLogger\r\n  extend self\r\n\r\n  def output\r\n    @output ||= []\r\n  end\r\n\r\n
    \ def error(message)\r\n    output << formatted_message(message, \"ERROR\")\r\n
    \ end\r\n\r\n  def info(message)\r\n    output << formatted_message(message, \"INFO\")\r\n
    \ end\r\n\r\n  def write(filename)\r\n    File.open(filename, \"a\") { |f| f <<
    output.join }\r\n  end\r\n\r\n  private\r\n\r\n  def formatted_message(message,
    message_type)\r\n    \"#{Time.now} | #{message_type}: #{message}\\n\"\r\n  end\r\nend\r\n```\r\n\r\nEven
    if the `extend self` approach is more fundamentally simple than `module_function`,
    it is not necessarily easy to learn or easy to understand. I go into great detail
    explaining exactly how this technique works in [Practicing Ruby 1.10](http://blog.rubybestpractices.com/posts/gregory/040-issue-10-uses-for-modules.html),
    but the two pages it takes me to explain it at a very high level serve as a hint
    that we're probably trying too hard to be clever when we write code this way.
    \r\n\r\nSo far, we've gone down a deep bunny hole because each alternative approach
    we've attempted was about solving a problem with the previous implementation.
    But for every improvement we make, we lose something in return. Much of our struggle
    has to do with the costs involved in trying to implement a singleton object that
    conforms to the expectations we have about classes and modules. To sidestep this
    issue, we can think about a solution that works directly with an individual object
    instead. \r\n\r\n### Using a bare instance of `Object`\r\n\r\nThe following code
    shows how to implement the singleton pattern by adding methods to a bare instance
    of `Object`. This code may look a bit strange at first but is at its core the
    same as defining methods on any other Ruby object, including instances of the
    `Module` and `Class` classes.\r\n\r\n```ruby\r\nSimpleLogger = Object.new\r\nclass
    << SimpleLogger\r\n  def output\r\n    @output ||= []\r\n  end\r\n\r\n  def error(message)\r\n
    \   output << formatted_message(message, \"ERROR\")\r\n  end\r\n\r\n  def info(message)\r\n
    \   output << formatted_message(message, \"INFO\")\r\n  end\r\n\r\n  def write(filename)\r\n
    \   File.open(filename, \"a\") { |f| f << output.join }\r\n  end\r\n\r\n  private\r\n\r\n
    \ def formatted_message(message, message_type)\r\n    \"#{Time.now} | #{message_type}:
    #{message}\\n\"\r\n  end\r\nend\r\n```\r\n\r\nAlthough we didn't have to store
    the object in the `SimpleLogger` constant, doing so makes the familiar runner
    code we've been using over and over work exactly as expected.\r\n\r\n```ruby\r\nSimpleLogger.error(\"Some
    serious problem\")\r\nSimpleLogger.info(\"Something you might want to know\")\r\nSimpleLogger.write(\"log.txt\")\r\n```\r\n\r\nThe
    code looks and feels the same from the end-user's perspective, but we know that
    there is something quite different hiding under the hood. The good news is that
    this approach makes it so that our `SimpleLogger` is not a factory for creating
    new objects like classes are and cannot be mixed into other objects or part of
    a hierarchy. The bad news is that the resulting object is very opaque. When we
    inspect a class or module object, it at least gives us back its name. However,
    when we inspect this object, what we get is the following:\r\n\r\n```\r\n>> SimpleLogger\r\n=>
    #<Object:0x0000010084bc18>\r\n```\r\n\r\nDocumenting this object using something
    like RDoc would be similarly frustrating, as it wouldn't be able to infer much
    about the object without lots of explicit directives. Although Ruby is designed
    in terms of ordinary objects, its infrastructure is surely defined in terms of
    classes and modules.\r\n\r\nWe can't do anything about the documentation problem
    without major changes to Ruby, but we might be able to build our own custom construct
    that takes these basic ideas and adds better debugging support.\r\n\r\n### Using
    a hand-rolled construct\r\n\r\nA few days before writing this article, I complained
    on Twitter about the lack of a good way to implement the singleton pattern in
    Ruby and suggested that perhaps we needed a new first-order construct for these
    purposes. Someone was quick to point out that [Scala has such a construct](http://hestia.typepad.com/flatlander/2009/01/scala-for-c-programmers-part-2-singletons.html),
    which got the wheels turning in my head. As a point of reference, here's what
    the construct looks like in Scala:\r\n\r\n```\r\nobject Universe {\r\n  def contains(obj:
    Any): Boolean = true  \r\n}\r\n\r\nval v = Universe.contains(42)\r\n```\r\n\r\nNow,
    there is a big difference between having built-in support for something in a language
    and building some sort of hand-rolled approximation. However, I couldn't resist
    implementing a construct in Ruby that works roughly the same way as this Scala
    code. After some tinkering, I settled on this syntax:\r\n\r\n```ruby\r\nobject
    \"Universe\" do\r\n  def contains?(anything)\r\n    true\r\n  end\r\nend\r\n\r\np
    Universe.contains?(42) #=> true\r\np Universe #=> #<Universe:2156157600>  \r\n```\r\n\r\nBecause
    the call to `object` hides the actual object creation, I was able to add nice
    `inspect` output in a way that is transparent to the user. Similar debugging and
    introspection features could be added just as easily. Under the hood, I used an
    approach similar to working with bare objects, so I retain all the benefits of
    that approach while getting rid of some of the downsides. (NOTE: I've decided
    to leave implementing this construct as a homework exercise, but please let me
    know if you get stuck and want to see how I did it.)\r\n\r\nLooking back on this
    code, I like the way the experiment went, but I am stuck wondering whether it
    makes sense to take it any farther. Without first-order support in the Ruby language
    for this construct, documentation would still be a struggle. Also, the awkward
    syntax breaks consistency with `Class` and `Module`. What we'd really want to
    be able to type is something like the following definition:\r\n\r\n```ruby\r\nobject
    Universe \r\n  def contains?(anything)\r\n    true\r\n  end\r\nend\r\n```\r\n\r\nAlthough
    the previous example is syntactically pleasing to me, I wonder if encouraging
    us to use more global functionality (and on a related note, more constants) is
    a good idea. At a minimum, such a change would need to also be mirrored in `Object.new`
    by adding a block form similar to the way that `Module` and `Class` work. This
    approach would end up looking something like this:\r\n\r\n```ruby\r\nuniverse
    = Object.new do\r\n  def contains?(anything)\r\n    true\r\n  end\r\nend\r\n```\r\n\r\nThe
    thing we have to ask ourselves is whether these features would really make Ruby
    a better language to work in. To answer that question, we need to consider the
    costs and benefits of avoiding the singleton pattern entirely.\r\n\r\n### Avoiding
    the singleton pattern entirely\r\n\r\nPretty much everything discussed so far
    is about avoiding explictly instantiating objects, which makes it possible for
    us to put off potentially expensive setup work and also makes it easier for us
    to prevent multiple instances of a given object from being instantiated within
    our applications. Some of our implementations do a good job of communicating these
    desires to the user by preventing them from creating instances. Others encourage
    a limited form of code reuse through module mixins, but with a number of caveats
    attached.\r\n\r\nBut in the end, we must not forget that the singleton pattern
    is essentially just a fancy way of managing global state. If we converted our
    `SimpleLogger` into an ordinary class and then did something like `$logger = SimpleLogger.new`,
    there would be marginal practical difference in the way things worked in our codebase.
    Things change slightly when we think of function bags like the `Math` module,
    but not as much as you might think. We must remember that no matter what form
    our singleton objects take, each one we add to our system is by definition less
    reusable and less testable due to its singular, global nature.\r\n\r\nThe question
    of whether to implement the singleton pattern really depends on the context, but
    it's safe to say that it's a bad default. However, this is a genuinely hard problem
    in object-oriented programming, which may explain why we've seen so many different
    attempts in Ruby without a real consensus on which way is best. We've also been
    unable to eliminate the pattern entirely, which is a sign that we can't simply
    write it off as one of those bad Java imports that real Rubyists freely ignore.\r\n\r\n###
    Reflections\r\n\r\nThe process of writing this article has taught me a few things.
    First of all, most of the approaches we take to implement the singleton pattern
    are way too complicated. Although this grail quest for object-oriented purity
    is entertaining from an academic perspective, it isn't something we should need
    to think about in our daily coding lives.\r\n\r\nThat said, it seems like a first-order
    construct that lets us define individual objects in an elegant way would be an
    interesting addition to Ruby. If we gravitated toward a more prototype-based design
    style via these standalone objects while using modules for our code reuse, we
    might end up with very nice solutions that would make this \"singleton object\"
    problem just disappear. But then again, that would be a huge shift in the way
    we write Ruby code, and I'm not sure the juice is worth the squeeze.\r\n\r\nIn
    the end, it amazes me that I was able to write so much on this topic, but not
    in a good way. As powerful as Ruby-the-language is, it seems that we're still
    far from being able to balance that power with responsibility. Every approach
    I criticized in this article is one I've advocated for at some earlier point,
    and now I'm not so sure I like any of them.\r\n\r\nMy hope is that you got two
    things from reading this article: a deeper understanding of the complexity of
    Ruby's object system and an awareness of the trade-offs of various approaches
    to this problem, so that you can be better equipped when you encounter this sort
    of design in the wild. If I've accomplished that, then this article was well worth
    the effort it took to write up. If not, don't worry: we'll return to more practical
    content next week! :)"
- :slug: building-unix-style-command-line-applications
  :title: Building Unix-style command line applications
  :summary: Build a basic clone of the 'cat' utility while learning some Ruby idioms
    for command line applications.
  :published: 2011-10-18 00:00:00.000000000 Z
  :issue_number: '2.9'
  :volume: 2
  :body: "Ruby is best known as a web development language, but in its early days
    it was\r\nmainly used on the command line. In this article, we'll get back to
    those roots by building a partial implementation of the standard Unix command
    `cat`.\r\n\r\nThe core purpose of the `cat` utility is to read in a list of input
    files, concatenate them, and output the resulting text to the command line. You
    can also use `cat` for a few other useful things, such as adding line numbers
    and suppressing extraneous whitespace. If we stick to these commonly used features,
    the core functionality of `cat` is something even a novice programmer would be
    able to implement without too much effort.\r\n\r\nThe tricky part of building
    a `cat` clone is that it involves more than just\r\nsome basic text manipulation;
    you also need to know about some \r\nstream processing and error handling techniques
    that are common in Unix\r\nutilities. The [acceptance tests](https://gist.github.com/1293709)
    \r\nthat I've used to compare the original `cat` utility to my Ruby-based `rcat`
    \r\ntool reveal some of the extra details that need to be considered when\r\nbuilding
    this sort of command line application.\r\n\r\nIf you are already fairly comfortable
    with building command line tools, you may\r\nwant to try implementing your own
    version of `rcat` before reading on. But don't\r\nworry if you wouldn't even know
    where to start: I've provided a \r\ndetailed walkthrough of my solution that will
    teach you everything \r\nthat you need to know.\r\n\r\n> **NOTE:** You'll need
    to have the source code for [my implementation of rcat](https://github.com/elm-city-craftworks/rcat)
    easily accessible as you work through the rest of this article. Please either
    clone the repository now or keep the GitHub file browser open while reading.\r\n\r\n###
    Building an executable script\r\n\r\nOur first task is to make it possible to
    run the `rcat` script without having to type something like `ruby path/to/rcat`
    each time we run it. This task can be done in three easy steps.\r\n\r\n**1) Add
    a shebang line to your script.**\r\n\r\nIf you look at `bin/rcat` in my code,
    you'll see that it starts with the following line:\r\n\r\n```\r\n#!/usr/bin/env
    ruby\r\n```\r\n\r\nThis line (commonly called a shebang line) tells the shell
    what interpreter to use to process the rest of the file. Rather than providing
    a path directly to the Ruby interpreter, I instead use the path to the standard
    `env` utility. This step allows `env` to figure out which `ruby` executable is
    present in our current environment and to use that interpreter to process the
    rest of the file. This approach is preferable because it is [more portable](http://en.wikipedia.org/wiki/Shebang_line#Portability)
    than hard-coding a path to a particular Ruby install. Although Ruby can be installed
    in any number of places, the somewhat standardized location of `env` makes it
    reasonably dependable.\r\n\r\n**2) Make your script executable.**\r\n\r\nOnce
    the shebang line is set up, it's necessary to update the permissions on the `bin/rcat`
    file. Running the following command from the project root will make `bin/rcat`
    executable:\r\n\r\n```\r\n$ chmod +x bin/rcat\r\n```\r\n\r\nAlthough the executable
    has not yet been added to the shell's lookup path, it is now possible to test
    it by providing an explicit path to the executable.\r\n\r\n```\r\n$ ./bin/rcat
    data/gettysburg.txt\r\nFour score and seven years ago, our fathers brought forth
    on this continent a\r\nnew nation, conceived in Liberty and dedicated to the proposition
    that all men\r\nare created equal.\r\n\r\n... continued ...\r\n```\r\n\r\n**3)
    Add your script to the shell's lookup path.**\r\n\r\nThe final step is to add
    the executable to the shell's lookup path so that it can be called as a simple
    command. In Bash-like shells, the path is updated by modifying the `PATH` environment
    variable, as shown in the following example:\r\n\r\n```\r\n$ export PATH=/Users/seacreature/devel/rcat/bin:$PATH\r\n```\r\n\r\nThis
    command prepends the `bin` folder in my rcat project to the existing contents
    of the `PATH`, which makes it possible for the current shell to call the `rcat`
    command without specifying a direct path to the executable, similar to how we
    call ordinary Unix commands:\r\n\r\n```\r\n$ rcat data/gettysburg.txt\r\nFour
    score and seven years ago, our fathers brought forth on this continent a\r\nnew
    nation, conceived in Liberty and dedicated to the proposition that all men\r\nare
    created equal.\r\n\r\n... continued ...\r\n```\r\n\r\nTo confirm that you've followed
    these steps correctly and that things are working as expected, you can now run
    the acceptance tests. If you see anything different than the following output,
    retrace your steps and see whether you've made a mistake somewhere. If not, please
    leave a comment and I'll try to help you out.\r\n\r\n```\r\n$ ruby tests.rb \r\nYou
    passed the tests, yay!\r\n```\r\n\r\nAssuming that you have a working `rcat` executable,
    we can now move on to talk about how the actual program is implemented.\r\n\r\n###
    Stream processing techniques\r\n\r\nWe now can turn our focus to the first few
    acceptance tests from the _tests.rb_ file. The thing that all these use cases
    have in common is that they involve very simple processing of input and output
    streams, and nothing more. \r\n\r\n```ruby\r\ncat_output  = `cat #{gettysburg_file}`\r\nrcat_output
    = `rcat #{gettysburg_file}`\r\n\r\nfail \"Failed 'cat == rcat'\" unless cat_output
    == rcat_output\r\n\r\n############################################################################\r\n\r\ncat_output
    \ = `cat #{gettysburg_file} #{spaced_file}`\r\nrcat_output = `rcat #{gettysburg_file}
    #{spaced_file}`\r\n\r\nfail \"Failed 'cat [f1 f2] == rcat [f1 f2]'\" unless cat_output
    == rcat_output\r\n\r\n############################################################################\r\n\r\ncat_output
    \ = `cat < #{spaced_file}`\r\nrcat_output = `rcat < #{spaced_file}`\r\n\r\nfail
    \"Failed 'cat < file == rcat < file\" unless cat_output == rcat_output\r\n```\r\n\r\nIf
    we needed only to pass these three tests, we'd be in luck. Ruby provides a special
    stream object called `ARGF` that combines multiple input files into a single stream
    or falls back to standard input if no files are provided. Our entire script could
    look something like this:\r\n\r\n```ruby\r\nARGF.each_line { |line| print line
    }\r\n```\r\n\r\nHowever, the real `cat` utility does a lot more than what `ARGF`
    provides,\r\nso it was necessary to write some custom code to handle stream processing:\r\n\r\n```ruby\r\nmodule
    RCat\r\n  class Application\r\n    def initialize(argv)\r\n      @params, @files
    = parse_options(argv)\r\n\r\n      @display        = RCat::Display.new(@params)\r\n
    \   end\r\n\r\n    def run\r\n      if @files.empty?\r\n        @display.render(STDIN)\r\n
    \     else\r\n        @files.each do |filename|\r\n          File.open(filename)
    { |f| @display.render(f) }\r\n        end \r\n      end\r\n    end\r\n\r\n    def
    parse_options(argv)\r\n      # ignore this for now\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe
    main difference between this code and the `ARGF`-based approach is that `RCat::Application#run`
    creates a new stream for each file. This comes in handy later when working on
    support for empty line suppression and complex line numbering but also complicates
    the implementation of the `RCat::Display` object. In the following example, I've
    stripped away the code that is related to these more complicated features to make
    it a bit easier for you to see the overall flow of things:\r\n\r\n```ruby\r\nmodule
    RCat\r\n  class Display\r\n    def render(data)\r\n      lines = data.each_line\r\n
    \     loop { render_line(lines) }\r\n    end\r\n\r\n    private\r\n\r\n    def
    render_line(lines)\r\n      current_line = lines.next \r\n      print current_line\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nThe use of `loop` instead of an ordinary
    Ruby iterator might feel a bit strange here, but it works fairly well in combination
    with `Enumerator#next`. The following irb session demonstrates how the two interact
    with one another:\r\n\r\n```\r\n>> lines = \"a\\nb\\nc\\n\".each_line\r\n=> #<Enumerator:
    \"a\\nb\\nc\\n\":each_line>\r\n>> loop { p lines.next }\r\n\"a\\n\"\r\n\"b\\n\"\r\n\"c\\n\"\r\n=>
    nil\r\n\r\n>> lines = \"a\\nb\\nc\\n\".each_line\r\n=> #<Enumerator: \"a\\nb\\nc\\n\":each_line>\r\n>>
    lines.next\r\n=> \"a\\n\"\r\n>> lines.next\r\n=> \"b\\n\"\r\n>> lines.next\r\n=>
    \"c\\n\"\r\n\r\n>> lines.next\r\nStopIteration: iteration reached an end\r\n  from
    (irb):8:in `next'\r\n  from (irb):8\r\n  from /Users/seacreature/.rvm/rubies/ruby-1.9.3-rc1/bin/irb:16:in
    `<main>'\r\n\r\n>> loop { raise StopIteration }\r\n=> nil\r\n```\r\n\r\nUsing
    this pattern makes it possible for `render_line` to actually consume more\r\nthan
    one line from the input stream at once. If you work through the logic that\r\nis
    necessary to get the following test to pass, you might catch a glimpse of the\r\nbenefits
    of this technique:\r\n\r\n```ruby\r\ncat_output  = `cat -s #{spaced_file}`\r\nrcat_output
    = `rcat -s #{spaced_file}`\r\n\r\nfail \"Failed 'cat -s == rcat -s'\" unless cat_output
    == rcat_output\r\n```\r\n\r\nTracing the executation path for `rcat -s` will lead
    you to this line of code in\r\n`render_line`, which is the whole reason I decided
    to use this\r\n`Enumerator`-based implementation:\r\n\r\n```ruby\r\nlines.next
    while lines.peek.chomp.empty?\r\n```\r\n\r\nThis code does an arbitrary amount
    of line-by-line lookahead until either a nonblank line is found or the end of
    the file is reached. It does so in a purely stateless and memory-efficient manner
    and is perhaps the most interesting line of code in this entire project. The downside
    of this approach is that it requires the entire `RCat::Display` object to be designed
    from the ground up to work with `Enumerator` objects. However, I struggled to
    come up with an alternative implementation that didn't involve some sort of complicated
    state machine/buffering mechanism that would be equally cumbersome to work with.\r\n\r\nAs
    tempting as it is to continue discussing the pros and cons of the different\r\nways
    of solving this particular problem, it's probably best for us to get back on\r\ntrack
    and look at some more basic problems that arise when working on\r\ncommand-line
    applications. I will now turn to the `parse_options` method that I asked you \r\nto
    treat as a black box in our earlier examples.\r\n\r\n### Options parsing\r\n\r\nRuby
    provides two standard libraries for options parsing: `GetoptLong` and `OptionParser`.
    Though both are fairly complex tools, `OptionParser` looks and feels a lot more
    like ordinary Ruby code while simultaneously managing to be much more powerful.
    The implementation of `RCat::Application#parse_options` makes it clear what a
    good job `OptionParser` does when it comes to making easy things easy:\r\n\r\n```ruby\r\nmodule
    RCat\r\n  class Application\r\n    # other code omitted\r\n\r\n    def parse_options(argv)\r\n
    \     params = {}\r\n      parser = OptionParser.new \r\n\r\n      parser.on(\"-n\")
    { params[:line_numbering_style] ||= :all_lines         }\r\n      parser.on(\"-b\")
    { params[:line_numbering_style]   = :significant_lines }\r\n      parser.on(\"-s\")
    { params[:squeeze_extra_newlines] = true               }\r\n      \r\n      files
    = parser.parse(argv)\r\n\r\n      [params, files]\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe
    job of `OptionParser#parse` is to take an arguments array and match it against
    the callbacks defined via the `OptionParser#on` method. Whenever a flag is matched,
    the associated block for that flag is executed. Finally, any unmatched arguments
    are returned. In the case of `rcat`, the unmatched arguments consist of the list
    of files we want to concatenate and display. The following example demonstrates
    what's going on in `RCat::Application`:\r\n\r\n```ruby\r\nrequire \"optparse\"\r\n\r\nputs
    \"ARGV is #{ARGV.inspect}\"\r\n\r\nparams = {}\r\nparser = OptionParser.new \r\n\r\nparser.on(\"-n\")
    { params[:line_numbering_style] ||= :all_lines         }\r\nparser.on(\"-b\")
    { params[:line_numbering_style]   = :significant_lines }\r\nparser.on(\"-s\")
    { params[:squeeze_extra_newlines] = true               }\r\n\r\nfiles = parser.parse(ARGV)\r\n\r\nputs
    \"params are #{params.inspect}\"\r\nputs \"files are #{files.inspect}\"\r\n```\r\n\r\nTry
    running this script with various options and see what you end up with. You should
    get something similar to the output shown here:\r\n\r\n````\r\n$ ruby option_parser_example.rb
    -ns data/*.txt\r\nARGV is [\"-ns\", \"data/gettysburg.txt\", \"data/spaced_out.txt\"]\r\nparams
    are {:line_numbering_style=>:all_lines, :squeeze_extra_newlines=>true}\r\nfiles
    are [\"data/gettysburg.txt\", \"data/spaced_out.txt\"]\r\n\r\n$ ruby option_parser_example.rb
    data/*.txt\r\nARGV is [\"data/gettysburg.txt\", \"data/spaced_out.txt\"]\r\nparams
    are {}\r\nfiles are [\"data/gettysburg.txt\", \"data/spaced_out.txt\"]\r\n```\r\n\r\nAlthough
    `rcat` requires us to parse only the most basic form of arguments, `OptionParser`
    is capable of a whole lot more than what I've shown here. Be sure to check out
    its [API documentation](http://ruby-doc.org/stdlib-1.9.2/libdoc/optparse/rdoc/OptionParser.html#method-i-parse)
    to see the full extent of what it can do.\r\n\r\nNow that I've covered how to
    get data in and out of our `rcat` application, we can talk a bit about how it
    does `cat`-style formatting for line numbering.\r\n\r\n### Basic text formatting
    \r\n\r\nFormatting text for the console can be a bit cumbersome, but some things
    are easier than they seem. For example, the tidy output of `cat -n` shown here
    is not especially hard to implement:\r\n\r\n<pre style=\"font-size: 0.8em\">\r\n$
    cat -n data/gettysburg.txt \r\n   1  Four score and seven years ago, our fathers
    brought forth on this continent a\r\n   2  new nation, conceived in Liberty and
    dedicated to the proposition that all men\r\n   3  are created equal.\r\n   4
    \ \r\n   5  Now we are engaged in a great civil war, testing whether that nation,
    or any\r\n   6  nation so conceived and so dedicated, can long endure. We are
    met on a great\r\n   7  battle-field of that war. We have come to dedicate a portion
    of that field as a\r\n   8  final resting place for those who here gave their
    lives that that nation might\r\n   9  live. It is altogether fitting and proper
    that we should do this.\r\n  10  \r\n  11  But, in a larger sense, we can not
    dedicate -- we can not consecrate -- we can\r\n  12  not hallow -- this ground.
    The brave men, living and dead, who struggled here\r\n  13  have consecrated it
    far above our poor power to add or detract. The world will\r\n  14  little note
    nor long remember what we say here, but it can never forget what\r\n  15  they
    did here. It is for us the living, rather, to be dedicated here to the\r\n  16
    \ unfinished work which they who fought here have thus far so nobly advanced.
    It\r\n  17  is rather for us to be here dedicated to the great task remaining
    before us --\r\n  18  that from these honored dead we take increased devotion
    to that cause for which\r\n  19  they gave the last full measure of devotion --
    that we here highly resolve that\r\n  20  these dead shall not have died in vain
    -- that this nation, under God, shall\r\n  21  have a new birth of freedom --
    and that government of the people, by the people,\r\n  22  for the people, shall
    not perish from the earth.\r\n</pre>\r\n\r\nOn my system, `cat` seems to assume
    a fixed-width column with space for up to six digits. This format looks great
    for any file with fewer than a million lines in it, but eventually breaks down
    once you cross that boundary.\r\n\r\n```\r\n$ ruby -e \"1_000_000.times { puts
    'blah' }\" | cat -n | tail\r\n999991    blah\r\n999992    blah\r\n999993    blah\r\n999994
    \   blah\r\n999995    blah\r\n999996    blah\r\n999997    blah\r\n999998    blah\r\n999999
    \   blah\r\n1000000    blah\r\n```\r\n\r\nThis design decision makes implementing
    the formatting code for this feature a whole lot easier. The `RCat::Display#print_labeled_line`
    method shows that it's possible to implement this kind of formatting with a one-liner:\r\n\r\n```ruby\r\ndef
    print_labeled_line(line)\r\n  print \"#{line_number.to_s.rjust(6)}\\t#{line}\"
    \r\nend\r\n```\r\n\r\nAlthough the code in this example is sufficient for our
    needs in `rcat`, it's worth mentioning that `String` also supports the `ljust`
    and `center` methods. All three of these justification methods can optionally
    take a second argument, which causes them to use an arbitrary string as padding
    rather than a space character; this feature is sometimes useful for creating things
    like ASCII status bars or tables.\r\n\r\nI've worked on a lot of different command-line
    report formats before, and I can tell you that streamable, fixed-width output
    is the easiest kind of reporting you'll come by. Things get a lot more complicated
    when you have to support variable-width columns or render elements that span multiple
    rows and columns. I won't get into the details of how to do those things here,
    but feel free to leave a comment if you're interested in hearing more on that
    topic.\r\n\r\n### Error handling and exit codes\r\n\r\nThe techniques we've covered
    so far are enough to get most of `rcat`'s tests passing, but the following three
    scenarios require a working knowledge of how Unix commands tend to handle errors.
    Read through them and do the best you can to make sense of what's going on.\r\n\r\n```ruby\r\n`cat
    #{gettysburg_file}`\r\ncat_success = $?\r\n\r\n`rcat #{gettysburg_file}`\r\nrcat_success
    = $?\r\n\r\nunless cat_success.exitstatus == 0 && rcat_success.exitstatus == 0\r\n
    \ fail \"Failed 'cat and rcat success exit codes match\"\r\nend\r\n\r\n############################################################################\r\n\r\ncat_out,
    cat_err, cat_process    = Open3.capture3(\"cat some_invalid_file\")\r\nrcat_out,
    rcat_err, rcat_process = Open3.capture3(\"rcat some_invalid_file\") \r\n\r\nunless
    cat_process.exitstatus == 1 && rcat_process.exitstatus == 1\r\n  fail \"Failed
    'cat and rcat exit codes match on bad file\"\r\nend\r\n\r\nunless rcat_err ==
    \"rcat: No such file or directory - some_invalid_file\\n\"\r\n  fail \"Failed
    'cat and rcat error messages match on bad file'\"\r\nend\r\n\r\n############################################################################\r\n\r\n\r\ncat_out,
    cat_err, cat_proccess  = Open3.capture3(\"cat -x #{gettysburg_file}\")\r\nrcat_out,rcat_err,
    rcat_process = Open3.capture3(\"rcat -x #{gettysburg_file}\") \r\n\r\nunless cat_process.exitstatus
    == 1 && rcat_process.exitstatus == 1\r\n  fail \"Failed 'cat and rcat exit codes
    match on bad switch\"\r\nend\r\n\r\nunless rcat_err == \"rcat: invalid option:
    -x\\nusage: rcat [-bns] [file ...]\\n\"\r\n  fail \"Failed 'rcat provides usage
    instructions when given invalid option\"\r\nend\r\n```\r\n\r\nThe first test verifies
    exit codes for successful calls to `cat` and `rcat`. In Unix programs, exit codes
    are a means to pass information back to the shell about whether a command finished
    successfully. The right way to signal that things worked as expected is to return
    an exit code of 0, which is exactly what Ruby does whenever a program exits normally
    without error.\r\n\r\nWhenever we run a shell command in Ruby using backticks,
    a `Process::Status` object is created and is then assigned to the `$?` global
    variable. This object contains (among other things) the exit status of the command
    that was run. Although it looks a bit cryptic, we're able to use this feature
    to verify in our first test that both `cat` and `rcat` finished their jobs successfully
    without error.\r\n\r\nThe second and third tests require a bit more heavy lifting
    because in these scenarios, we want to capture not only the exit status of these
    commands, but also whatever text they end up writing to the STDERR stream. To
    do so, we use the `Open3` standard library. The `Open3.capture3` method runs a
    shell command and then returns whatever was written to STDOUT and STDERR, as well
    as a `Process::Status` object similar to the one we pulled out of `$?` earlier.
    \r\n\r\nIf you look at _bin/rcat_, you'll find the code that causes these tests
    to pass:\r\n\r\n```ruby\r\nbegin\r\n  RCat::Application.new(ARGV).run\r\nrescue
    Errno::ENOENT => err\r\n  abort \"rcat: #{err.message}\"\r\nrescue OptionParser::InvalidOption
    => err\r\n  abort \"rcat: #{err.message}\\nusage: rcat [-bns] [file ...]\"\r\nend\r\n```\r\n\r\nThe
    `abort` method provides a means to write some text to STDERR and then exit with
    a nonzero code. The previous code provides functionality equivalent to the following,
    more explicit code:\r\n\r\n```ruby\r\nbegin\r\n  RCat::Application.new(ARGV).run\r\nrescue
    Errno::ENOENT => err\r\n  $stderr.puts \"rcat: #{err.message}\"\r\n  exit(1)\r\nrescue
    OptionParser::InvalidOption => err\r\n  $stderr.puts \"rcat: #{err.message}\\nusage:
    rcat [-bns] [file ...]\"\r\n  exit(1)\r\nend\r\n```\r\n\r\nLooking back on things,
    the errors I've rescued here are somewhat low level, and\r\nit might have been
    better to rescue them where they occur and then reraise\r\ncustom errors provided
    by `RCat`. This approach would lead to code similar to\r\nwhat is shown below:\r\n\r\n```ruby\r\nbegin\r\n
    \ RCat::Application.new(ARGV).run\r\nrescue RCat::Errors::FileNotFound => err\r\n
    \ # ...\r\nrescue RCat::Errors::InvalidParameter => err\r\n  # ..\r\nend\r\n```\r\n\r\nRegardless
    of how these exceptions are labeled, it's important to note that I intentionally
    let them bubble all the way up to the outermost layer and only then rescue them
    and call `Kernel#exit`. Intermingling `exit` calls within control flow or modeling
    logic makes debugging nearly impossible and also makes automated testing a whole
    lot harder.\r\n\r\nAnother thing to note about this code is that I write my error
    messages to `STDERR` rather than `STDOUT`. Unix-based systems give us these two
    different streams for a reason: they let us separate debugging output and functional
    output so that they can be redirected and manipulated independently. Mixing the
    two together makes it much more difficult for commands to be chained together
    in a pipeline, going against the [Unix philosophy](http://en.wikipedia.org/wiki/Unix_philosophy).\r\n\r\nError
    handling is a topic that could easily span several articles. But when it comes
    to building command-line applications, you'll be in pretty good shape if you remember
    just two things: use `STDERR` instead of `STDOUT` for debugging output, and make
    sure to exit with a nonzero status code if your application fails to do what it
    is supposed to do. Following those two simple rules will make your application
    play a whole lot nicer with others.\r\n\r\n### Reflections\r\n\r\nHoly cow, this
    was a hard article to write! When I originally decided to write a `cat` clone,
    I worried that the example would be too trivial and boring to be worth writing
    about. However, once I actually implemented it and sat down to write this article,
    I realized that building command-line applications that respect Unix philosophy
    and play nice with others is harder than it seems on the surface.\r\n\r\nRather
    than treating this article as a definitive reference for how to build good command-line
    applications, perhaps we can instead use it as a jumping-off point for future
    topics to cover in a more self-contained fashion. I'd love to hear your thoughts
    on what topics in particular interested you and what areas you think should have
    been covered in greater detail.\r\n\r\n> NOTE: If you'd like to learn more about
    this topic, consider doing the Practicing Ruby self-guided course on [Streams,
    Files, and Sockets](https://practicingruby.com/articles/study-guide-1?u=dc2ab0f9bb).
    You've already completed one of its reading exercises by working through this
    article!\r\n"
- :slug: from-requirements-discovery-to-release
  :title: From requirements discovery to release
  :summary: Watch a small game project develop from the brainstorming phase to its
    first public release.
  :published: 2011-10-27 00:00:00.000000000 Z
  :issue_number: '2.10'
  :volume: 2
  :body: "Every time we start a greenfield software project, we are faced with the
    overwhelming responsibility of creating something from nothing. Because the path
    from the requirements discovery phase to the first release of a product has so
    many unexpected twists and turns, the whole process can feel a bit unforgiving
    and magical. This feeling is a big part of what makes programming hard, even for
    experienced developers.\r\n\r\nFor the longest time, I relied heavily on my intuition
    to get myself kick-started on new projects. I didn't have a clear sense of what
    my creative process was, but I could sense that my fear of the unknown started
    to melt away as I gained more experience as a programmer. Having a bit of confidence
    in my own abilities made me more productive, but not knowing where that confidence
    came from made it impossible for me to cultivate it in others. Treating my creative
    process as a black box also made it meaningless for me to compare my approach
    to anyone else's. Eventually, I got fed up with these limitations and decided
    that I wanted to do something to overcome them.\r\n\r\nMy angle of approach was
    fairly simple: I decided to take a greenfield project from the idea phase to an
    initial open source release while documenting the entire process. I thought this
    information might provide a useful starting point for identifying patterns in
    how I work and also a basis of comparison for other folks. As I reviewed my notes
    from this exercise and compared them to my previous experiences, I was thrilled
    to see that a clear pattern did emerge. This article summarizes what I learned
    about my own process; I hope it will also be helpful to you.\r\n\r\n### Brainstorming
    for project ideas\r\n\r\nThe process of coming up with an idea for a software
    project (or perhaps any creative work) is highly dynamic. The best ideas tend
    to evolve quite a bit from whatever the original spark of inspiration was. If
    you are not constrained to solving a particular problem, it can be quite rewarding
    to allow yourself to wander a bit and see where you end up. Evolving an idea is
    like starting with a base recipe for a dish and then tweaking a couple ingredients
    at a time until you end up with something delicious. The story of how this particular
    project started should illustrate just how much mutation can happen in the early
    stages of creating something new.\r\n\r\nA few days before writing this article,
    I was trying to come up with ideas for another Practicing Ruby article I had planned
    to write. I wanted to do something on event-driven programming and thought that
    some sort of tower defense game might be a fun example to play with. However,
    the ideas I had in mind were too complicated, so I gradually simplified my game
    ideas until they turned into something vaguely resembling a simple board game.\r\n\r\nEventually,
    I forgot that my main goal was to get an article written and decided to focus
    on developing my board game ideas instead. With my wife's help, over the course
    of a weekend I managed to come up with a fairly playable board game that bore
    no resemblence to a tower defense game and would serve as a terrible event-driven
    programming exercise. However, I still wanted to implement a software version
    of the game because it would make the experience much easier for us to analyze
    and share with others.\r\n\r\nMy intuition said that the project would take me
    a day or so to build and that it'd be sufficiently interesting to take notes on
    for my \"documenting the creative process\" exercise. This gut feeling was enough
    to convince me to take the plunge, so I cleared the whiteboards in my office in
    preparation for an impromptu design session.\r\n\r\n### Establishing the 10,000-foot
    view\r\n\r\nWhether you're building a game or modeling a complex business process,
    you need to define lots of terms before you can go about describing the interactions
    of your system. When you consider the fact that complex dependencies can make
    it hard to change names later, it's hard to overstate the importance of this stage
    of the process. For this reason, it's always a good idea to start a new project
    by defining some terms for some of the most important components and interactions
    that you'll be working with. My first whiteboard sketch focused on exactly that:\r\n\r\n![](https://farm7.static.flickr.com/6229/6283525185_35bd4c96a8_z.jpg)\r\n\r\nHaving
    a sense of the overall structure of the game in somewhat more formal terms made
    it possible for me to begin mapping these concepts onto object relationships.
    The following image shows my first crack at figuring out what classes I'd need
    and how they would interact with each other:\r\n\r\n![](https://farm7.static.flickr.com/6049/6283524127_032ab93d77_z.jpg)\r\n\r\nIt's
    worth noting that in both of these diagrams, I was making no attempt at being
    exhaustive, nor was I expecting these designs to survive beyond an initial spike.
    But because moving boxes and arrows around on a whiteboard is easier than rewriting
    code, I tend to start off any moderately complex project this way.\r\n\r\nWith
    just these two whiteboard sketches, I had most of what I needed to start coding.
    The only important thing left to be done before I could fire up my text editor
    was coming up with a suitable name for the game. After trying and failing at finding
    a variant of \"All your base\" that wasn't an existing gem name, I eventually
    settled on \"Stack Wars.\" I picked this name because \r\na big part of the physical
    game has to do with building little stacks of army tiles in the territories you
    control. Despite the fact that the name doesn't mean much in the electronic version,
    it was an unclaimed name that could easily be _CamelCased_ and _snake_cased_,
    so I decided to go with it.\r\n\r\nAs important as naming considerations are,
    getting bogged down in them can be just as harmful as paying no attention to the
    problem at all. For this reason, I decided to leave some of the details of the
    game in my head so that I could postpone some naming decisions until I saw how
    the code was coming together. That decision allowed me to start coding a bit earlier
    at the cost of having a bit of an incomplete roadmap.\r\n\r\n### Picking some
    low-hanging fruit\r\n\r\nEvery time I start a new project, I try to identify a
    small task that I can finish quickly so that I can get some instant gratification.
    I find an early success to be important for my morale, and it also serves as a
    gentle way to test some of my assumptions about the project.\r\n\r\nI try to avoid
    starting with the boring stuff like setting up boilerplate code and building trivial
    container objects. Instead, I typically attempt to build a small but useful end-to-end
    feature. For the purposes of this game, an ASCII representation of the battlefield
    seemed like a good place to start. I started this task by creating a file called
    _sample_ui.txt_ with the contents you see here:\r\n\r\n```\r\n       0      1
    \     2      3      4      5      6      7      8 \r\n    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\n
    0  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n      |      |
    \     |      |      |      |      |      |      |\r\n 1  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \     |      |      |      |      |      |      |      |      |\r\n 2  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \     |      |      |      |      |      |      |      |      |\r\n 3  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \     |      |      |      |      |      |      |      |      |\r\n 4  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \     |      |      |      |      |      |      |      |      |\r\n 5  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \     |      |      |      |      |      |      |      |      |\r\n 6  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \     |      |      |      |      |      |      |      |      |\r\n 7  (B 2)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \     |      |      |      |      |      |      |      |      |\r\n 8  (___)--(W
    2)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n    WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\r\n```\r\n\r\nIn
    order to implement this visualization, I needed to make some decisions about how
    the battlefield data was going to be represented, but I wanted to defer as much
    of that work as possible. After [asking for some feedback about this problem](https://gist.github.com/1310883),
    I opted to write the visualization code against a simple array of arrays of Ruby
    primitives that could be trivially be transformed to and from JSON. Within a few
    minutes, I had a script that was generating similar output to my original sketch:\r\n\r\n```ruby\r\nrequire
    \"json\"\r\n\r\ndata = JSON.parse(File.read(ARGV[0]))\r\n\r\ncolor_to_symbol =
    { \"black\" => \"B\", \"white\" => \"W\" }\r\n\r\nheader    = \"       0      1
    \     2      3      4      5      6      7      8\\n\"\r\nseparator = \"       |
    \     |      |      |      |      |      |      |      |\\n\"\r\n\r\nborder_b
    \ = \"     BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n\"\r\nborder_w
    \ = \"     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\\n\"\r\n\r\nbattlefield_text
    = data.map.with_index do |row, row_index|\r\n  row_text = row.map do |color, strength|\r\n
    \   if color == \"unclaimed\"\r\n      \"(___)\"\r\n    else\r\n      \"(#{color_to_symbol[color]}#{strength.to_s.rjust(2)})\"\r\n
    \   end\r\n  end.join(\"--\")\r\n\r\n  \"#{row_index.to_s.rjust(3)}  #{row_text}\\n\"\r\nend.join(separator)\r\n\r\nputs
    [header, border_b, battlefield_text, border_w].join\r\n```\r\n\r\nAlthough this
    script is a messy little hack, it got me started on the project in a way that
    was immediately useful. In the process of creating this visualization tool, I
    ended up thinking about a lot of tangentially related issues. In particular, I
    started to brainstorm about the following topics:\r\n\r\n* What fixture data I
    would need for testing various game actions\r\n* What the coordinate system for
    the `Battlefield` would be\r\n* What data the `Territory` object would need to
    contain\r\n* What format to use for inputting moves via the command-line interface\r\n\r\nThe
    fact that I was thinking about all of these things was a sign that my initial
    spike was successful. However, it was also a sign that I should spend some time
    laying out the foundation for a real object-oriented project rather than continuing
    to hack things together as if I were writing a ball of Perl scripts.\r\n\r\n###
    Laying out some scaffolding\r\n\r\nAlthough you don't necessarily need to worry
    about writing super-clean code for a first release of a project, it is important
    to at least lay down the basic groundwork, which makes it possible to replace
    bad code with good code later. By introducing a `TextDisplay` object, I was able
    to reduce the _stackwars-viewer_ script to the following code:\r\n\r\n```ruby\r\n#!/usr/bin/env
    ruby\r\n\r\nrequire \"json\"\r\nrequire_relative \"../lib/stack_wars\"\r\n\r\ndata
    = JSON.parse(File.read(ARGV[0]))\r\n\r\nputs StackWars::TextDisplay.new(data)\r\n```\r\n\r\nAfter
    the initial extraction of the code from my script, I thought about how much time
    I wanted to invest in refactoring `TextDisplay`. I ended up deciding that because
    this game will eventually have a GUI that completely replaces its command-line
    interface, I shouldn't put too much effort into code that would soon be deleted.
    However, I couldn't resist making it at least a tiny bit more readable for the
    time being:\r\n\r\n```ruby\r\nmodule StackWars\r\n  class TextDisplay\r\n    COLOR_SYM
    = { \"black\" => \"B\", \"white\" => \"W\" }\r\n    HEADER    = \"#{' '*7}#{(0..8).to_a.join('
    '*6)}\"\r\n    SEPARATOR = \"#{' '*6} #{9.times.map { '|' }.join(' '*6)}\"\r\n\r\n
    \   BLACK_BORDER  = \"#{' '*5}#{COLOR_SYM['black']*61}\"\r\n    WHITE_BORDER  =
    \"#{' '*5}#{COLOR_SYM['white']*61}\"\r\n\r\n    def initialize(battlefield)\r\n
    \     @battlefield = battlefield\r\n    end\r\n\r\n    def to_s\r\n      battlefield_text
    = @battlefield.map.with_index do |row, row_index|\r\n        row_text = row.map
    do |color, strength|\r\n          if color == \"unclaimed\"\r\n            \"(___)\"\r\n
    \         else\r\n            \"(#{COLOR_SYM[color]}#{strength.to_s.rjust(2)})\"\r\n
    \         end\r\n        end.join(\"--\")\r\n\r\n        \"#{row_index.to_s.rjust(3)}
    \ #{row_text}\\n\"\r\n      end.join(\"#{SEPARATOR}\\n\")\r\n\r\n      [HEADER,
    BLACK_BORDER, battlefield_text.chomp, WHITE_BORDER].join(\"\\n\")\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nAfter writing this code, I wondered whether I should
    tackle the building of a proper `Battlefield` class that would take the raw data
    for each cell and wrap it in a `Territory` object. I was hesitant to make both
    of these changes at once, so I ended up compromising by creating a `Battlefield`
    class that simply wrapped the nested array of primitives for now:\r\n\r\n```ruby\r\nmodule
    StackWars\r\n  class Battlefield\r\n    def self.from_json(json_file)\r\n      new(JSON.parse(File.read(json_file)))\r\n
    \   end\r\n\r\n    def initialize(territories)\r\n      @territories = territories\r\n
    \   end\r\n\r\n    def to_a\r\n      Marshal.load(Marshal.dump(@territories))\r\n
    \   end\r\n\r\n    # loses instance variables, but better than hitting to_s()
    by default\r\n    alias_method :inspect, :to_s\r\n\r\n    def to_s\r\n      TextDisplay.new(to_a).to_s\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nWith this new object in place, I was able
    to further simplify the _stackwars-viewer_ script, leading to the trivial code
    shown here:\r\n\r\n```ruby\r\nrequire_relative \"../lib/stack_wars\"\r\n\r\nputs
    StackWars::Battlefield.from_json(ARGV[0])\r\n```\r\n\r\nThe benefit of doing these
    minor extractions is that it makes it possible to focus on the relationships between
    the objects in a system rather than their implementations. You can always refactor
    implementation code later, but interfaces are hard to untangle once you start
    wiring things up to them. This is why it is important to start thinking about
    the ingress and egress points of your objects as early as possible, even if you're
    still allowing yourself to write quick and dirty implementation code.\r\n\r\nThe
    benefits of laying the proper groundwork for your project and keeping things nicely
    organized are hard to see in the early stages but are extremely clear later when
    things get more complex.\r\n\r\n### Starting to chip away at the hard parts\r\n\r\nUnless
    you are an incredibly good software designer, odds are good that some aspects
    of your project will be harder to work on than others. There is even a funny quote
    that hints at this phenomenon: _\"The first 90 percent of the code accounts for
    the first 90 percent of the development time. The remaining 10 percent of the
    code accounts for the other 90 percent of the development time.\"_\r\n\r\nTo avoid
    this sort of situation, it is important to maintain a balance between easy tasks
    and more difficult tasks. Starting a project with an easy task is a great way
    to get the ball rolling, but if you don't tackle some challenging aspects of your
    project early on, you may find yourself having to rewrite a ton of code later.
    The hard parts of your project are what test your overall design as well as your
    understanding of the problem domain.\r\n\r\nWith this in mind, I knew it was time
    to take a closer look at some of the game actions in Stack Wars. Because the FORTIFY
    action must be implemented before any of the other game actions become meaningful,
    I decided to start there. The following code was my initial stab at figuring out
    what I needed to build in order to get this feature working:\r\n\r\n```ruby\r\ndef
    fortify(position)\r\n  position.add_army(active_player.color)\r\n  active_player.reserves
    -= 1\r\nend\r\n```\r\n\r\nUntil this point in the project, I had been avoiding
    writing formal tests because I had a mixture of trivial code and throwaway code.
    But now that I was about to work on some Serious Business, I decided to try test-driving
    things. After a fair amount of struggling, I decided to add _mocha_ into the mix
    and begin test-driving a `Game` class through the use of mock objects:\r\n\r\n```ruby\r\nrequire_relative
    \"../test_helper\"\r\n\r\ndescribe \"StackWars::Game\" do\r\n\r\n  let(:territory)
    \  { mock(\"territory\") }\r\n  let(:battlefield) { mock(\"battlefield\") }\r\n\r\n
    \ subject { StackWars::Game.new(battlefield) }\r\n\r\n  it \"must be able to alternate
    players\" do\r\n    subject.active_player.color.must_equal :black\r\n\r\n    subject.start_new_turn\r\n
    \   subject.active_player.color.must_equal :white\r\n\r\n    subject.start_new_turn\r\n
    \   subject.active_player.color.must_equal :black\r\n  end\r\n\r\n  it \"must
    be able to fortify positions\" do\r\n    subject.expects(:territory_at).with([0,1]).returns(territory)\r\n
    \   territory.expects(:fortify).with(subject.active_player)\r\n\r\n    subject.fortify([0,1])\r\n
    \ end\r\nend\r\n```\r\n\r\nTaking this approach made it possible for me to test
    whether the `Game` class was able to delegate `fortify` calls to territories,
    even though I had not yet implemented the `Territory` class. It gave me a pretty
    nice way to look at the problem from the outside in and resulted in a clean-looking
    `Game` class:\r\n\r\n```ruby\r\nmodule StackWars\r\n  class Game\r\n    def initialize(battlefield)\r\n
    \     @players         = [Player.new(\"black\"), Player.new(\"white\")].cycle\r\n
    \     @battlefield     = battlefield\r\n      start_new_turn \r\n    end\r\n\r\n
    \   attr_reader :active_player\r\n\r\n    def fortify(position)\r\n      territory
    = territory_at(position)     \r\n      \r\n      territory.fortify(active_player)\r\n
    \   end\r\n\r\n    def start_new_turn\r\n      @active_player  = @players.next\r\n
    \   end\r\n\r\n    private\r\n\r\n    def territory_at(position)\r\n      @battlefield[*position]\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nHowever, the problem remained that this
    code hinged on a number of features that were not implemented yet. This frustration
    caused me to begin working on getting the basic functionality in place for a `Territory`
    class without writing tests for its behaviors up front. I used a combination of
    the _stackwars-viewer_ tool and irb to verify that the `Territory` objects that
    I had shoehorned into the system were working as expected.\r\n\r\nAfter making
    it so that the `Battlefield` object contained a nested array of `Territory` objects,
    I went back and wrote some unit tests for `Territory`. The tests ended up being
    fairly long and tedious, but the implementation code for `Territory#fortify` ended
    up being quite simple and worked as expected:\r\n\r\n```ruby\r\nmodule StackWars\r\n
    \ class Territory\r\n    # other methods omitted\r\n\r\n    def fortify(player)\r\n
    \     if controlled_by?(player)\r\n        player.deploy_army\r\n\r\n        @army_strength
    += 1\r\n        @occupant ||= player.color\r\n      else\r\n        raise Errors::IllegalMove\r\n
    \     end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nGetting the `Territory` tests
    to go green felt good, but I wasn't satisfied. Now that I had implemented a game
    action, I wanted to see it in real use. This itch lead me to write a simple script
    that simulated players fortifying their positions, which resulted in the following
    output:\r\n\r\n```\r\n       0      1      2      3      4      5      6      7
    \     8\r\n     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\r\n
    \ 0  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n       |
    \     |      |      |      |      |      |      |      |\r\n  1  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  2  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  3  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  4  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  5  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  6  (B 2)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  7  (___)--(W
    2)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n       |      |      |
    \     |      |      |      |      |      |\r\n  8  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\n\r\nFortifying
    black position at (0,6)\r\n\r\n       0      1      2      3      4      5      6
    \     7      8\r\n     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\r\n
    \ 0  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n       |
    \     |      |      |      |      |      |      |      |\r\n  1  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  2  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  3  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  4  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  5  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  6  (B 3)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  7  (___)--(W
    2)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n       |      |      |
    \     |      |      |      |      |      |\r\n  8  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\n\r\nFortifying
    white baseline position at (2,0)\r\n\r\n       0      1      2      3      4      5
    \     6      7      8\r\n     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\r\n
    \ 0  (___)--(___)--(W 1)--(___)--(___)--(___)--(___)--(___)--(___)\r\n       |
    \     |      |      |      |      |      |      |      |\r\n  1  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  2  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  3  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  4  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  5  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  6  (B 3)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \      |      |      |      |      |      |      |      |      |\r\n  7  (___)--(W
    2)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n       |      |      |
    \     |      |      |      |      |      |\r\n  8  (___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)--(___)\r\n
    \    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\n```\r\n\r\nSeeing
    this example run gave me a great feeling because it was the first sign that something
    resembling a game was under development. However, the path to get to this point
    was long and arduous, even though this was by far the easiest action to implement.
    \r\n\r\n### Slamming into the wall\r\n\r\nThere comes a time in every reasonably
    complicated project at which you end up biting off more than you can chew. The
    exact reason for this will vary from project to project: perhaps you overlooked
    something in your design, or misunderstood a key requirement, or maybe you just
    let your code get too messy and it reached a point where it could no longer be
    extended without heavy refactoring. This sort of thing is normal and to be expected,
    but is also a critical turning point in your project. \r\n\r\nIf you aren't careful,
    the setbacks caused by slamming into the wall can really shake your spirits and
    negatively affect your productivity. Having unrealistic expectations that a certain
    task will be easy to complete is a surefire way to trigger this effect. That's
    what happened to me on this project; I hope the following story will serve as
    a cautionary tale.\r\n\r\nAfter implementing the FORTIFY action, I thought I would
    be able to repeat the process for MOVE, ATTACK, and INVADE. Anticipating this
    approach, I roughed out a replacement for `Game#fortify()` called `Game#play()`,
    which took into account all game actions and selected the right one based on the
    circumstances:\r\n\r\n```ruby\r\ndef play(pos1, pos2=nil)\r\n  if pos2.nil?\r\n
    \   territory = territory_at(pos1)\r\n    \r\n    territory.fortify(active_player)\r\n
    \ else\r\n    from = territory_at(pos1)\r\n    to = territory_at(pos2)\r\n\r\n
    \   raise Errors::IllegalMove unless battlefield.adjacent?(from, to)\r\n\r\n    if
    to.occupied_by?(opponent)\r\n      attack(from, to)\r\n    else\r\n      move_army(from,
    to)\r\n    end\r\n  end\r\n  \r\n  start_new_turn\r\nend\r\n```\r\n\r\nHowever,
    as soon as I looked at this method definition, I knew for sure that testing this
    code with mocks would be at best brittle and at worst downright misleading. On
    top of that, the code introduced several new concepts that would need to trickle
    down into the rest of the system. I tried to think through how to simplify things
    so that this could be more easily tested, but quickly grew frustrated and ended
    up abandoning the idea of test-driving this functionality.\r\n\r\nInstead, I decided
    that the problem was that I didn't have a running game console that displayed
    the battlefield and accepted inputs. I thought that even a buggy system that allowed
    me to interact with the game in a tangible way would be better than writing a
    ton of tedious tests against what might end up being the wrong interface. This
    decision caused me to begin to modify the system in any number of haphazard ways
    until I got a functioning game console.\r\n\r\nI did eventually get something
    working, but it was so fragile that I ended up enlisting my wife's help in QA
    testing it until it sort of looked and felt like a working game. Unfortunately,
    the hot fixes I was applying while she found new ways to break things caused more
    bugs to surface. Eventually, I gave up on the project for the evening and decided
    to come back to it with fresh eyes in the morning.\r\n\r\n### Searching for a
    pragmatic middle path\r\n\r\nConventional wisdom says that if a particular bit
    of code is especially hard to test, a structural flaw in your design might be
    to blame. Because testability and extensibility are linked together, it is a good
    idea to listen to your tests when they make life hard for you. But there certainly
    are times when we need to temporarily sacrifice purity in the name of practicality.\r\n\r\nThe
    fact that I had a working Stack Wars implementation but no confidence that it
    wasn't super buggy left me in a sticky position: I wanted to make sure that the
    code would stabilize, but I didn't want to rework the design from scratch. The
    base design of the code was more than good enough for a first release; I just
    wanted to iron the wrinkles out and find a way to refactor with a bit of confidence
    that each change I made wasn't going to break everything all over again.\r\n\r\nTo
    accomplish this goal, I started by making my manual testing process more efficient.
    I made it so that my game console would fire up a game in which each player had
    only 2 armies in reserve rather than 27. This change made it possible to play
    an entire game in a fraction of the time that a real game would take, but still
    allowed me to test all the game actions. I used this faster manual feedback loop
    to quickly eliminate the bugs that I had introduced the night before, and I also
    tried to be more careful about the fixes I applied.\r\n\r\nOnce I got things to
    a reasonable level of stability, I realized that I could then build a fairly good
    integration test by replaying moves from a real, complete game. After a few more
    tweaks, my wife and I managed to make it through a game without a crash. I then
    set up a demo script that would replay these moves one by one until it reached
    the end of the game. Once I got that stage working, I extracted it into an integration
    test that reads the moves from a JSON file, calls `Game#play` for each one, and
    then does some validations to make sure the game ended as expected:\r\n\r\n```ruby\r\ndescribe
    \"A full game of stack wars\" do\r\n  let(:moves) do\r\n    moves_file = \"#{File.dirname(__FILE__)}/../fixtures/moves.json\"\r\n
    \   JSON.load(File.read(moves_file))\r\n  end\r\n\r\n  let(:battlefield) { StackWars::Battlefield.new
    }\r\n\r\n  let(:game) { StackWars::Game.new(battlefield) }\r\n\r\n  it \"must
    end as expected\" do\r\n    message = catch(:game_over) do\r\n      moves.each
    { |move| game.play(*move) }\r\n    end\r\n\r\n    message.must_equal \"white won!\"\r\n\r\n
    \   white = game.active_player\r\n    black = game.opponent\r\n\r\n    battlefield.deployed_armies(white).must_equal(4)\r\n
    \   battlefield.deployed_armies(black).must_equal(0)\r\n\r\n    white.reserves.must_equal(0)\r\n
    \   black.reserves.must_equal(0)\r\n\r\n    white.successful_invasions.must_equal(6)\r\n
    \   black.successful_invasions.must_equal(4)\r\n  end\r\nend\r\n```\r\n\r\nHaving
    this integration test in place will make it possible for me to come back later
    and refactor the codebase to make it more testable without the fear of breaking
    things. Although unit tests offer more in the way of documenting how the codebase
    is meant to work and provide more precisely located feedback upon failure, this
    single test is good enough to ensure that I don't introduce new critical bugs
    into the application without noticing them.\r\n\r\nIn retrospect, it seems like
    integration testing is more important than exhaustive unit testing in the very
    early phases of a hard-to-test project. It is less of a time investment to create
    some black box testing and such testing is less likely to be thrown out as subsystems
    change rapidly during the initial phases of development.\r\n\r\n### Shipping the
    0.1.0 release\r\n\r\nIt is important to remember that a 0.1.0 release of an open
    source project is basically just a way to communicate an idea to your fellow programmers.
    If you label a release 0.1.0, no one is going to expect feature completeness,
    stability, or even a particularly high level of code quality. What they will expect
    is for you to have attempted to make your project comprehensible to them and ideally
    to have done a good job of making it easy to get involved in your project. I tried
    to keep these priorities in mind while preparing Stack Wars for release. \r\n\r\nAdding
    the full game test was an important first step for making the codebase release-ready.
    People who try out the game are going to want to be able to submit bug reports
    and possibly add new bits of functionality. Without tests to verify that their
    changes don't break stuff, it would be much harder to safely accept their contributions.\r\n\r\nSome
    additional code cleanup was also necessary: I removed a bunch of tests and examples
    that were no longer relevant and shifted around some of the code within each class
    to make it easier to read. In general, it is a good idea to remove anything that
    is not actively in use, as well as anything that isn't quite working correctly
    whenever you release code. This step lessens the chances of confusion and frustration
    when someone tries to read your code. \r\n\r\nI did not bother with API documentation
    just yet because so much is still subject to change, but I did write up a basic
    [README](https://github.com/sandal/stack_wars/blob/master/README.md) with instructions
    for those who want to play-test the game as well as those who might want to hack
    on its code. I also wrote a detailed writeup of the [game rules](https://github.com/sandal/stack_wars/blob/master/RULES.txt)
    because folks will need to learn the game before they can understand how this
    program works.\r\n\r\nIn addition to documentation and cleanup, I did what I could
    to make it very easy to try out the game. Running `stack_wars rules` will display
    the game rules so that you don't need to go back to the source code or your web
    browser to know how the game is played. Additionally, I made it possible to run
    through the sample game that Jia and I played just by typing `stack_wars demo`.
    The sole reason these features exist is to make the software more accessible to
    new users, which I hope will increase the chance that those users become contributors
    at some point in the future. But even if most people download my software without
    ever contributing to it in some way, I still care a lot about the experience they
    have while using something I created.\r\n\r\nYou can try things out for yourself
    by following the instructions in the [README](https://github.com/sandal/stack_wars/blob/master/README.md);
    this video will give you a sense of what the first release of this project ended
    up looking like:\r\n\r\n<iframe width=\"640\" height=\"480\" src=\"//www.youtube-nocookie.com/embed/oom5n4Azq2I?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nAlthough in the grand scheme
    of things it may not look like much, I am pretty happy with it for a 0.1.0 release!\r\n\r\n###
    Reflections\r\n\r\nThe more I think about it, the more I realize that the cycle
    I've outlined in this article is pretty much the one I go through whenever I'm
    starting a new project. There are some things about my process that I like, and
    some things that I don't. However, knowing that there is a pattern I tend to follow
    makes me think that I can now work towards optimizing it over time.\r\n\r\nThe
    thing I found fascinating about this exercise is that it really drove home the
    point that software development is about a lot more than just writing code. There
    are a whole range of skills involved in bringing a software project from the idea
    phase to even the most humble first release, and it seems like it'd be good for
    us to spend time optimizing the whole process rather than just our purely code-oriented
    skills.\r\n\r\nBecause I've never attempted anything quite like this exercise
    before, I'm really curious to hear your thoughts on this article. Please leave
    a comment, even if you're the type that typically lurks, with whatever your initial
    gut reaction may be. If this is a topic that interests you, please also share
    your thoughts on how we might be able to dig even deeper in future experiments."
- :slug: domain-specific-apis
  :title: Domain specific API construction
  :summary: Master classic Ruby DSL design patterns by ripping off well-known libraries
    and tools.
  :published: 2011-11-02 00:00:00.000000000 Z
  :issue_number: '2.11'
  :volume: 2
  :body: "Many people are attracted to Ruby because of its flexible syntax. Through
    various tricks and techniques, it is possible for Ruby APIs to blend seamlessly
    into a wide range of domains. \r\n\r\nIn this article, we will investigate how
    domain-specific APIs are constructed by implementing simplified versions of popular
    patterns seen in the wild. Hopefully, this exploration will give you a better
    sense of the tools you have at your disposal as well as a chance to see various
    Ruby metaprogramming concepts being used in context.\r\n\r\n### Implementing `attr_accessor`\r\n\r\nOne
    of the first things every beginner to Ruby learns is how to use `attr_accessor`.
    It has the appearance of a macro or keyword, but is actually just an ordinary
    method defined at the module level. To illustrate that this is the case, we can
    easily implement it ourselves.\r\n\r\n```ruby\r\nclass Module\r\n  def attribute(*attribs)\r\n
    \   attribs.each do |a|\r\n      define_method(a) { instance_variable_get(\"@#{a}\")
    }\r\n      define_method(\"#{a}=\") { |val| instance_variable_set(\"@#{a}\", val)
    }\r\n    end\r\n  end\r\nend\r\n\r\nclass Person\r\n  attribute :name, :email\r\nend\r\n\r\nperson
    = Person.new\r\nperson.name = \"Gregory Brown\"\r\n\r\np person.name #=> \"Gregory
    Brown\"\r\n```\r\n\r\nIn order to understand what is going on here, you need to
    think a little bit about what a class object in Ruby actually is. A class object
    is an instance of the class called `Class`, which is in turn a subclass of the
    `Module` class. When an instance method is added to the `Module` class definition,
    that method becomes available as a class method on all classes.\r\n\r\nAt the
    class/module level, it is possible to call `define_method`, which will in turn
    add new instance methods to the class/module that it gets called on. So when the
    `attribute()` method gets called on `Person`, a pair of methods get defined on
    `Person` for each attribute. The end result is that functionally equivalent code
    to what is shown below gets dynamically generated:\r\n\r\n```ruby\r\nclass Person\r\n
    \ def name\r\n    @name\r\n  end\r\n\r\n  def name=(val)\r\n    @name = val\r\n
    \ end\r\n\r\n  def email\r\n    @email\r\n  end\r\n\r\n  def email=(val)\r\n    @email
    = val\r\n  end\r\nend\r\n```\r\n\r\nThis is powerful stuff. As soon as you recognize
    that things like `attr_accessor` are not some special keywords or macros that
    only the Ruby interpreter can define, a ton of possibilities open up.\r\n\r\n###
    Implementing a Rails-style `before_filter` construct\r\n\r\nRails uses class methods
    all over the place to make it look and feel like its own dialect of Ruby. As a
    single example, it is possible to register callbacks to be run before a given
    controller action is executed using the `before_filter` feature. The simplified
    example below is a rough approximation of what this functionality looks like in
    Rails.\r\n\r\n```ruby\r\nclass ApplicationController < BasicController\r\n  before_filter
    :authenticate\r\n\r\n  def authenticate\r\n    puts \"authenticating current user\"\r\n
    \ end\r\nend\r\n\r\nclass PeopleController < ApplicationController \r\n  before_filter
    :locate_person, :only => [:show, :edit, :update]\r\n\r\n  def show\r\n    puts
    \"showing a person's data\"\r\n  end\r\n\r\n  def edit\r\n    puts \"displaying
    a person edit form\"\r\n  end\r\n\r\n  def update\r\n    puts \"committing updated
    person data to the database\"\r\n  end\r\n\r\n  def create\r\n    puts \"creating
    a new person\"\r\n  end\r\n\r\n  def locate_person\r\n    puts \"locating a person\"\r\n
    \ end\r\nend\r\n```\r\n\r\nSuppose that `BasicController` provides us with the
    `before_filter` method as well as an `execute` method which will execute a given
    action, but first trigger any `before_filter` callbacks. Then we'd expect the
    `execute` method to have the following behavior. \r\n\r\n```ruby\r\ncontroller
    = PeopleController.new\r\n\r\nputs \"EXECUTING SHOW\"\r\ncontroller.execute(:show)\r\n\r\nputs\r\n\r\nputs
    \"EXECUTING CREATE\"\r\ncontroller.execute(:create)\r\n\r\n=begin -- expected
    output --\r\n\r\nEXECUTING SHOW\r\nauthenticating current user\r\nlocating a person\r\nshowing
    a person's data\r\n\r\nEXECUTING CREATE\r\nauthenticating current user\r\ncreating
    a new person \r\n\r\n=end \r\n```\r\n\r\nImplementing this sort of behavior isn't
    as trivial as implementing a clone of `attr_accessor`, because in this scenario
    we need to manipulate some class level data. Things are further complicated by
    the fact that we want filters to propagate down through the inheritance chain,
    allowing a given class to apply both its own filters as well as the filters of
    its ancestors. Fortunately, Ruby provides facilities to deal with both of these
    concerns, resulting in the following implementation of our `BasicController` class:\r\n\r\n```ruby\r\nclass
    BasicController\r\n  def self.before_filters\r\n    @before_filters ||= []\r\n
    \ end\r\n\r\n  def self.before_filter(callback, params={})\r\n    before_filters
    << params.merge(:callback => callback)\r\n  end\r\n\r\n  def self.inherited(child_class)\r\n
    \   before_filters.reverse_each { |f| child_class.before_filters.unshift(f) }\r\n
    \ end\r\n\r\n  def execute(action)\r\n    matched_filters = self.class.before_filters.select
    do |f| \r\n      f[:only].nil? || f[:only].include?(action) \r\n    end\r\n\r\n
    \   matched_filters.each { |f| send f[:callback] }\r\n    send(action)\r\n  end\r\nend\r\n```\r\n\r\nIn
    this code, we store our filters as an array of hashes on each class, and use the
    `before_filters` method as a way of lazily initializing that array. Whenever a
    subclass gets created, the parent class copies its filters to the front of list
    of filters that the child class will continue to build up. This allows downward
    propagation of filters through the inheritance chain. If that sounds confusing,
    exploring in irb a bit might help clear up what ends up happening as a result
    of this `inherited` hook.\r\n\r\n```\r\n>> BasicController.before_filters.map
    { |e| e[:callback] }\r\n=> []\r\n>> ApplicationController.before_filters.map {
    |e| e[:callback] }\r\n=> [:authenticate]\r\n>> PeopleController.before_filters.map
    { |e| e[:callback] }\r\n=> [:authenticate, :locate_person]\r\n```\r\n\r\nFrom
    here, it should be pretty easy to see how the `execute` method works. It simply
    looks up this list of filters and selects the ones relevant to the provided action.
    It then uses `send` to call each callback that was matched, and finally calls
    the target action. \r\n\r\nWhile we've only gone through two examples of class
    level macros so far, the techniques used between the two of them cover most of
    what you'll need to know to understand virtually all uses of this pattern in other
    scenarios. If we really wanted to dig in deeper, we could go over some other tricks
    such as using class methods to mix modules into classes on-demand (a common pattern
    in Rails plugins), but instead I'll leave those concepts for you to explore on
    your own and move on to some other interesting patterns.\r\n\r\n### Implementing
    a cheap counterfeit of Mail's API\r\n\r\nHistorically, sending email in Ruby has
    always been an ugly and cumbersome process. However, the Mail gem changed all
    of that not too long ago. Using Mail, sending a message can be as simple as the
    code shown below.\r\n\r\n```ruby\r\nMail.deliver do\r\n  from    \"gregory.t.brown@gmail.com\"\r\n
    \ to      \"test@test.com\"\r\n  subject \"Hello world\"\r\n  body    \"Hi there!
    This isn't spam, I swear\"\r\nend\r\n```\r\n\r\nThe nice thing about Mail is that
    in addition to this convenient syntax, it is still possible to work with a more
    ordinary looking API as well.\r\n\r\n```ruby\r\nmail         = Mail::Message.new\r\n\r\nmail.from
    \   = \"gregory.t.brown@gmail.com\"\r\nmail.to      = \"test@test.com\"\r\nmail.body
    \   = \"Hi there! This isn't spam, I swear\"\r\nmail.subject = \"Hello world\"\r\n\r\nmail.deliver\r\n```\r\n\r\nIf
    we ignore the actual sending of email and focus on the interface to the object,
    implementing a dual purpose API like this is surprisingly easy. The code below
    defines a class that provides a matching API to the examples shown above.\r\n\r\n```ruby\r\nclass
    FakeMail\r\n  def self.deliver(&block)\r\n    mail = Message.new(&block)\r\n    mail.deliver\r\n
    \ end\r\n\r\n  class Message\r\n    def initialize(&block)\r\n      instance_eval(&block)
    if block\r\n    end\r\n\r\n    attr_writer :from, :to, :subject, :body\r\n\r\n
    \   def from(text=nil)\r\n      return @from unless text \r\n\r\n      self.from
    = text\r\n    end\r\n\r\n    def to(text=nil)\r\n      return @to unless text\r\n\r\n
    \     self.to = text\r\n    end\r\n\r\n    def subject(text=nil)\r\n      return
    @subject unless text\r\n\r\n      self.subject = text\r\n    end\r\n\r\n    def
    body(text=nil)\r\n      return @body unless text\r\n\r\n      self.body = text\r\n
    \   end\r\n\r\n    # this is just a placeholder for a real delivery method\r\n
    \   def deliver\r\n      puts \"Delivering a message from #{from} to #{to} \"+\r\n
    \     \"with the subject '#{subject}' and \"+\r\n      \"the body '#{body}'\"\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nThere are only two things that make this
    class definition different from that of the ordinary class definitions we see
    in elementary Ruby textbooks. The first is that the constructor for `FakeMail::Message`
    accepts an optional block to run through `instance_eval`, and the second is that
    the class provides accessor methods which can act as both a reader and a writer
    depending on whether an argument is given or not. These two special features go
    hand in hand, as the following example demonstrates:\r\n\r\n```ruby\r\n  FakeMail.deliver
    do \r\n    # this looks ugly, but would be necessary if using ordinary attr_accessors\r\n
    \   self.from = \"gregory.t.brown@gmail.com\"\r\n\r\n  end\r\n\r\n  mail = FakeMail::Message.new\r\n\r\n
    \ # when you strip away the syntactic sugar, this looks ugly too.\r\n  mail.from
    \"gregory.t.brown@gmail.com\"\r\n```\r\n\r\nThis approach to implementing this
    pattern is fairly common and shows up in a lot of different Ruby projects, including
    my own libraries. By accepting a bit more complexity in our accessor code, we
    end up with a more palatable API in both scenarios, and it feels like a good trade.
    However, the dual purpose accessors always felt like a bit of a hack to me, and
    I recently found a different approach that is I think is a bit more solid. The
    code below shows how I would attack this problem in new projects:\r\n\r\n```ruby\r\nclass
    FakeMail\r\n\r\n  def self.deliver(&block)\r\n    mail = MessageBuilder.new(&block).message\r\n
    \   mail.deliver\r\n  end\r\n\r\n  class MessageBuilder\r\n    def initialize(&block)\r\n
    \     @message = Message.new\r\n      instance_eval(&block) if block\r\n    end\r\n\r\n
    \   attr_reader :message\r\n\r\n    def from(text)\r\n      message.from = text\r\n
    \   end\r\n\r\n    def to(text)\r\n      message.to = text\r\n    end\r\n\r\n
    \   def subject(text)\r\n      message.subject = text\r\n    end\r\n\r\n    def
    body(text)\r\n      message.body = text\r\n    end\r\n  end\r\n\r\n  class Message\r\n
    \   attr_accessor :from, :to, :subject, :body\r\n\r\n    def deliver\r\n      puts
    \"Delivering a message from #{from} to #{to} \"+\r\n      \"with the subject '#{subject}'
    and \"+\r\n      \"the body '#{body}'\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis
    code is a drop-in replacement for what I wrote before, but is quite different
    under the hood. Rather than putting the syntactic sugar directly onto the `Message`
    object, I create a `MessageBuilder` object for this purpose. When `FakeMail.deliver`
    is called, the `MessageBuilder` object ends up being the target context for the
    block to be evaluated in rather than the `Message` object. This effectively splits
    the code the implements the sugary interface from the code that implements the
    domain model, eliminating the need for dual purpose accessors.\r\n\r\nThere is
    another benefit that comes along with taking this approach, but it is more subtle.
    Whenever we use `instance_eval`, it evaluates the block as if you were executing
    your statements within the object it was called on. This means it is possible
    to bypass private methods and otherwise mess around with objects in ways that
    are typically reserved for internal use. By switching the context to a simple
    facade object whose only purpose is to provide some domain specific API calls
    for the user, it's less likely that someone will accidentally call internal methods
    or otherwise stomp on the internals of the system's domain objects.\r\n\r\nIt's
    worth mentioning that even this improved approach to implementing an `instance_eval`
    based interface comes with its own limitations. For example, whenever you use
    `instance_eval`, it makes it so that `self` within the block points to the object
    the block is being evaluated against rather than the object in the the surrounding
    scope. The closure property of Ruby code blocks makes it possible to access local
    variables, but if you reference instance variables, they will refer to the object
    your block is being evaluated against. This can confuse beginners and even some
    more experienced Ruby developers. \r\n\r\nIf you want to use this style of API,
    your best bet is to reserve it for things that are relatively simple and configuration-like
    in nature. As things get more complex the limitations of this approach become
    more and more painful to deal with. That having been said, valid use cases for
    this pattern occur often enough that you should be comfortable implementing it
    whenever it makes sense to do so.\r\n\r\nThe next pattern is one that you probably
    WON'T use all that often, but is perhaps the best example of how far you can stretch
    Ruby's syntax and behaviors to fit your own domain.\r\n\r\n### Implementing a
    shoddy version of XML Builder\r\n\r\nOne of the first libraries that impressed
    me as a Ruby newbie was Jim Weirich's XML Builder. The fact that you could create
    a single Ruby object that magically knew how to convert arbitrary method calls
    into an XML structure seemed like pure voodoo to me at the time. \r\n\r\n```ruby\r\nrequire
    \"builder\"\r\n\r\nbuilder = Builder::XmlMarkup.new\r\n\r\nxml = builder.class
    do |roster|\r\n  roster.student { |s| s.name(\"Jim\");    s.phone(\"555-1234\")
    }\r\n  roster.student { |s| s.name(\"Jordan\"); s.phone(\"123-1234\") }\r\n  roster.student
    { |s| s.name(\"Greg\");   s.phone(\"567-1234\") }\r\nend\r\n\r\nputs xml\r\n\r\n=begin
    -- expected output --\r\n\r\n<class><student><name>Jim</name><phone>555-1234</phone></student>\r\n<student><name>Jordan</name><phone>123-1234</phone></student>\r\n<student><name>Greg</name><phone>567-1234</phone></student></class>
    \ \r\n\r\n=end\r\n```\r\n\r\nSome time much later in my career, I was impressed
    again by how easy it is to implement this sort of behavior if you cut a few corners.
    While it's mostly smoke and mirrors, the snippet below is sufficient for replicating
    the behavior of the previous example.\r\n\r\n```ruby\r\nmodule FakeBuilder\r\n
    \ class XmlMarkup < BasicObject\r\n    def initialize\r\n      @output = \"\"\r\n
    \   end\r\n    \r\n    def method_missing(id, *args, &block)\r\n      @output
    << \"<#{id}>\"\r\n      \r\n      block ? block.call(self) : @output << args.first\r\n\r\n
    \     @output << \"</#{id}>\"\r\n\r\n      return @output\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nDespite
    how compact this code is, it gives us a lot to talk about. The heart of the implemenation
    relies on the use of a `method_missing` hook to convert unknown method calls into
    XML tags. There are few special things to note about this code, even if you are
    already familiar with `method_missing`.\r\n\r\nTypically it is expected that if
    you implement a `method_missing` hook, you should be as conservative as possible
    about what you handle in your hook and then use `super` to delegate everything
    else upstream. For example, if you were to write dynamic finders similar to the
    ones that ActiveRecord provides (i.e. something like `find_by_some_attribute`),
    you would make it so that your `method_missing` hook only handled method calls
    which matched the pattern `/^find_by_(.*)/`. However, in the case of Builder all
    method calls captured by `method_missing` are potentially valid XML tags, and
    so `super` is not needed in its `method_missing` hook.\r\n\r\nOn a somewhat similar
    note, certain methods that are provided by `Object` are actually valid XML tag
    names that wouldn't be too rare to come across. In my example, I intentionally
    used XML data representing a class of students to illustrate this point, because
    it forces us to call `builder.class`. By inheriting from `BasicObject` instead
    of `Object`, we end up with far fewer reserved words on our object, which decreases
    the likelihood that we will accidentally call a method that does exist. While
    we don't think about it often, all `method_missing` based APIs hinge on the idea
    that your hook will only be triggered by calls to undefined methods. In many cases
    we don't need to think about this, but in the case of Builder (and perhaps when
    building proxy objects), we need to work with a blank slate object.\r\n\r\nThe
    final thing worth pointing out about this code is that it uses blocks in a slightly
    surprising way. Because the `method_missing` call yields the builder object itself
    whenever the block is given, it does not serve a functional purpose. To illustrate
    this point, it's worth noting that the code below is functionally equivalent to
    our original example:\r\n\r\n```ruby\r\nxml = builder.class do \r\n  builder.student
    { builder.name(\"Jim\");    builder.phone(\"555-1234\") }\r\n  builder.student
    { builder.name(\"Jordan\"); builder.phone(\"123-1234\") }\r\n  builder.student
    { builder.name(\"Greg\");   builder.phone(\"567-1234\") }\r\nend\r\n\r\nputs xml\r\n```\r\n\r\nHowever,
    Builder cleverly exploits block local variable assignment to allow contextual
    abbreviations so that the syntax more closely mirrors the underlying structure.
    These days we occasionally see `Object#tap` being used for similar purposes, but
    at the time that Builder did this it was quite novel.\r\n\r\nWhile it's tempting
    to write Builder off as just a weird little bit of Ruby magic, it has some surprisingly
    practical benefits to its design. Unlike my crappy prototype, the real Builder
    library will automatically escape your strings so that they're XML safe. Also,
    because Builder essentially uses Ruby to build up an abstract syntax tree (AST)
    internally, it could possibly be used to render to multiple different output formats.
    While I've not actually tried it out myself, it looks like someone has already
    made a [JSON builder](https://github.com/nov/jsonbuilder) which matches the same
    API but emits JSON hashes instead of XML tags.\r\n\r\nWith those benefits in mind,
    this is a good pattern to use for problems that involve outputting documents that
    nicely map to Ruby syntax as an intermediate format. But as I mentioned before,
    those circumstances are rare in most day to day programming work, and so you shouldn't
    be too eager to use this technique as often as possible. That having been said,
    you could have some fantastic fun adding this sort of freewheeling code to various
    classes that don't actually need it in your production applications and then telling
    your coworkers I told you to do it. I'll leave it up to you to decide whether
    that's a good idea or not :)\r\n\r\nWith four tough examples down and only two
    more to go, we're on the home stretch. Take a quick break if you're feeling tired,
    and then let's move on to the next pattern. \r\n\r\n### Implementing Contest on
    top of MiniTest\r\n\r\nWhen I used to write code for Ruby 1.8, I liked using the
    Test::Unit standard library for testing, but I wanted context support and full
    text test cases similar to what was found in RSpec. I eventually settled on using
    the [contest](https://github.com/citrusbyte/contest) library, because it gave
    me exactly what I needed in a very simple an elegant way.\r\n\r\nWhen I moved
    to Ruby 1.9 and MiniTest, I didn't immediately invest the time in learning `MiniTest::Spec`,
    which provides similar functionality to contest as well as few other RSpec-style
    goodies. Instead, I looked into porting contest to MiniTest. After finding a [gist](https://gist.github.com/25455)
    from Chris Wanswrath and customizing it heavily, I ended up with a simple little
    test helper that made it possible for me to write tests in minitest which looked
    like this.\r\n\r\n```ruby\r\ncontext \"A Portal\" do\r\n  setup do\r\n    @portal
    = Portal.new\r\n  end\r\n\r\n  test \"must not be open by default\" do\r\n    refute
    @portal.open?\r\n  end\r\n\r\n  test \"must not be open when just the orange endpoint
    is set\" do\r\n    @portal.orange = [3,3,3]\r\n    refute @portal.open?\r\n  end\r\n\r\n
    \ test \"must not be open when just the blue endpoint is set\" do\r\n    @portal.blue
    = [5,5,5]\r\n    refute @portal.open?\r\n  end\r\n\r\n  test \"must be open when
    both endpoints are set\" do\r\n    @portal.orange = [3,3,3]\r\n    @portal.blue
    = [5,5,5]\r\n\r\n    assert @portal.open?\r\n  end\r\n\r\n  # a pending test\r\n
    \ test \"must require endpoints to be a 3 element array of numbers\"\r\nend\r\n```\r\n\r\nWithout
    having to install any third party libraries, I was able to support this kind of
    test syntax via a single function in my test helpers file.\r\n\r\n```ruby\r\ndef
    context(*args, &block)\r\n  return super unless (name = args.first) && block\r\n\r\n
    \ context_class = Class.new(MiniTest::Unit::TestCase) do\r\n    class << self\r\n
    \     def test(name, &block)\r\n        block ||= lambda { skip(name) }\r\n\r\n
    \       define_method(\"test: #{name} \", &block)\r\n      end\r\n\r\n      def
    setup(&block)\r\n        define_method(:setup, &block)\r\n      end\r\n\r\n      def
    teardown(&block)\r\n        define_method(:teardown, &block)\r\n      end\r\n\r\n
    \      def to_s\r\n         name\r\n       end\r\n    end\r\n  end\r\n\r\n   context_class.singleton_class.instance_eval
    do\r\n     define_method(:name) { name }\r\n   end\r\n\r\n  context_class.class_eval(&block)\r\nend\r\n```\r\n\r\nIf
    you look past some of the dynamic class generation noise, you'll see that a good
    chunk of this is quite similar to how I implemented a clone of `attr_accessor`
    earlier. The `test`, `setup`, and `teardown` methods are nothing more than class
    methods which delegate to `define_method`. The only slightly interesting detail
    worth noting here is that in the `test` method I define methods which are not
    callable using ordinary Ruby method calling syntax. The use of `define_method`
    allows us to bypass the ordinary syntactic limits of using `def`, and because
    these methods are only ever invoked dynamically, this works without any issues.
    The reason I don't bother to normalize the strings is because you end up getting
    more humanized output from the test runner this way.\r\n\r\nIf you turn your focus
    back onto the dynamic class generation, you can see that this code creates an
    anonymous subclass of `MiniTest::Unit::TestCase` and then eventually uses `class_eval`
    to evaluate the provided block in the context of this class. This code is what
    enables us to write `context \"foo\" do ... end` and get something that works
    similar to the way an ordinary class definition works.\r\n\r\nIf you're focusing
    on really subtle details, you'll notice that this code goes through a bunch of
    hoops to define meaningful `name` and `to_s` methods on the class it dynamically
    generates. This is in part a bunch of massaging to get better output from MiniTest's
    runner, and in part to make it so that our anonymous classes don't look completely
    anonymous during debugging. The irb session below might make some sense of what's
    going on here, but if it doesn't you can feel free to chalk this up as an edge
    case you probably don't need to worry about.\r\n\r\n```\r\n>> Class.new\r\n=>
    #<Class:0x00000101069260>\r\n>> name = \"A sample class\"\r\n=> \"A sample class\"\r\n>>
    Class.new { singleton_class.instance_eval { define_method(:to_s) { name } } }\r\n=>
    A sample class\r\n```\r\n\r\nGetting away from these ugly little details and returning
    to the overall pattern, it is relatively common to see domain-specific APIs which
    dynamically create modules or classes and then wrap certain kinds of method definitions
    in block based APIs as well. It's a handy pattern when used correctly, and could
    be useful in your own projects. But even if you never end up using it yourself,
    it's good to know how this all works as it'll make code reading easier for you.\r\n\r\nWhile
    this example was perfect for having a discussion about the pattern of dynamic
    class creation in general, I'd strongly recommend against using my helper in your
    MiniTest code at this point. You'll find everything you need in `MiniTest::Spec`,
    and that is a much more standard solution than using some crazy hack I cooked
    up simply because I could.\r\n\r\nWith that disclaimer out of the way, we can
    move on to our final topic.\r\n\r\n### Implement your own Gherkin parser, or criticize
    mine!\r\n\r\nSo far, we've talked about various tools which enable the use of
    domain specific language (DSL) within your Ruby applications. However, there is
    a whole other category of DSL techniques which involve parsing external languages
    and then converting them into meaningful structures within the host language.
    This is a topic that deserves an entire article of its own.\r\n\r\nBut because
    it'll be a while before I get around to writing that article, we can wrap up this
    article with a little teaser of things to come. To do so, I am challenging you
    to implement a basic story runner that parses the Gherkin language which is used
    by [Cucumber](http://cukes.info/) and other similar tools.\r\n\r\nYour mission,
    if you chose to accept it, is to take the following feature file and process it
    with Cucumber-style step definitions. You can feel free to simplify your prototype
    as much as you'd like, as long as you capture the core idea of processing the
    steps in the feature file and executing arbitrary code for each of those steps.\r\n\r\n```\r\nFeature:
    Addition\r\n  Scenario: Add two numbers\r\n    Given I have entered 70 into the
    calculator\r\n    And I have entered 50 into the calculator\r\n    When I press
    add\r\n    Then the result should be 120\r\n```\r\n\r\nIf that sounds like too
    much work for you, you can take on a slightly easier task instead. In preparation
    for this article, I build two different implementations that capture the essence
    of the way that that Cucumber story runner works. [One implementation uses global
    functions](https://github.com/elm-city-craftworks/dsl_construction/blob/master/cucumber/global-dsl/fake_cuke.rb),
    and the [other implementation uses eval() with a binding](https://github.com/elm-city-craftworks/dsl_construction/blob/master/cucumber/binding-dsl/fake_cuke.rb).
    I'd like you to examine these two approachs and share your thoughts on what the
    functional differences between them are.\r\n\r\nWhile I know not everyone will
    have the time to try out this exercise, if a few of you work on this and share
    your results, it will lead to a good discussion which could help me gauge interest
    in a second article about external DSLs. So if you have a few spare moments, please
    participate! \r\n\r\n### Reflections\r\n\r\nWe've now reached the end of a whirlwind
    tour of several powerful tools Ruby provides for bending its syntax and semantics
    to meet domain-specific needs. While I tried to pick examples which illustrated
    natural uses of domain specific API construction patterns, I am left feeling that
    these are advanced techniques which even experienced developers have a hard time
    evaluating the tradeoffs of.\r\n\r\nThere are two metrics to apply before trying
    out anything you've seen in this article in your own projects. The first thing
    to remember is that any deviation from ordinary method definitions and ordinary
    method calls should offer a benefit that is at least proportional to how exotic
    your approach is. Cleverness for the sake of cleverness can be a real killer if
    you're not careful. The second thing to remember is that whenever if you provide
    nice domain-specific APIs for convenience or aesthetic reasons, you should always
    make sure to build it as a facade over a boring and vanilla API. This will help
    make sure your objects are easier to test and easier to work with in scenarios
    that your domain specific interface did not anticipate.\r\n\r\nIf you follow these
    two bits of advice, you can have fun using Ruby's sharp knives without getting
    cut too often. But if you do slip up from time to time, don't be afraid to abandon
    fancy interfaces in favor of having something a bit dull but easier to maintain
    and understand. It can be tempting to layer dynamic features on top of one another
    to \"simplify\" things, but that only hides the underlying problem which is that
    perhaps you were trying too hard. This is something that used to happen to me
    all the time, so don't feel bad when it happens to you. Just do what you can to
    learn from your mistakes as you try out new designs.\r\n\r\n_NOTE: If you want
    to experiment with the examples in this article a bit more, you can find all of
    them in [this git repository](https://github.com/elm-city-craftworks/dsl_construction).
    If you fork the code and submit pull requests with improvements, I will review
    your changes and eventually make a note of them here if we stumble across some
    good ideas that I didn't cover._\r\n"
- :slug: binary-file-formats
  :title: Working with binary file formats
  :summary: Read and write bitmap files using only a few dozen lines of Ruby code.
  :published: 2011-11-09 00:00:00.000000000 Z
  :issue_number: '2.12'
  :volume: 2
  :body: "Even if we rarely give them much thought, binary file formats are everywhere.\r\nRanging
    from images to audio files to nearly every other sort of media you can\r\nimagine,
    binary files are used because they are an efficient way of\r\nstoring information
    in a ready-to-process format.\r\n\r\nDespite their usefulness, binary files are
    cryptic and appear to be \r\ndifficult to understand on the surface. Unlike a\r\ntext-based
    data format, simply looking at a binary file won't give you any \r\nhints about
    what its contents are. To even begin to understand a binary\r\nencoded file, you
    need to read its format specification. These specifications \r\ntend to include
    lots of details about obscure edge cases, and that makes for\r\nchallenging reading
    unless you already have spent a fair amount of time \r\nworking in the realm of
    bits and bytes. For these reasons, it's probably better\r\nto learn by example
    rather than taking a more formal approach.\r\n\r\nIn this article, I will show
    you how to encode and decode the bitmap image\r\nformat. Bitmap images have a
    simple structure, and the format is well documented. \r\nDespite the fact that
    you'll probably never need to work with bitmap images \r\nat all in your day-to-day
    work, the concepts involved in both reading and \r\nwriting a BMP file are pretty
    much the same as any other file format you'll encounter.\r\n\r\n### The anatomy
    of a bitmap\r\n\r\nA bitmap file consists of several sections of metadata followed
    by a pixel array that represents the color and position of every pixel in the
    image. \r\nThe example below demonstrates that even if you break the sequence
    up into its different parts, it would still be a real \r\nchallenge to understand
    without any documentation handy:\r\n\r\n```ruby\r\n# coding: binary\r\n\r\nhex_data
    = %w[\r\n  42 4D \r\n  46 00 00 00 \r\n  00 00 \r\n  00 00 \r\n  36 00 00 00\r\n\r\n
    \ 28 00 00 00 \r\n  02 00 00 00 \r\n  02 00 00 00 \r\n  01 00 \r\n  18 00 \r\n
    \ 00 00 00 00 \r\n  10 00 00 00 \r\n  13 0B 00 00 \r\n  13 0B 00 00\r\n  00 00
    00 00 \r\n  00 00 00 00\r\n\r\n  00 00 FF\r\n  FF FF FF \r\n  00 00 \r\n  FF 00
    00 \r\n  00 FF 00 \r\n  00 00\r\n]\r\n\r\nout = hex_data.each_with_object(\"\")
    { |e,s| s << Integer(\"0x#{e}\") }\r\n\r\nFile.binwrite(\"example1.bmp\", out)\r\n```\r\n\r\nOnce
    you learn what each section represents, you can start\r\nto interpret the data.
    For example, if you know that this is a\r\n24-bit per pixel image that is two
    pixels wide, and two pixels high, you might\r\nbe able to make sense of the pixel
    array data shown below:\r\n\r\n```\r\n00 00 FF\r\nFF FF FF \r\n00 00 \r\nFF 00
    00 \r\n00 FF 00 \r\n00 00\r\n```\r\n\r\nIf you run this example script and open
    the image file it produces, you'll see\r\nsomething similar to what is shown below
    once you zoom in close enough to see\r\nits pixels:\r\n\r\n![Pixels](http://i.imgur.com/XhKW1.png)\r\n\r\n\r\nBy
    experimenting with changing some of the values in the pixel array by hand, you
    will fairly quickly discover the overall structure of the array and the way pixels
    are represented. After figuring this out, you might also be able to look back
    on the rest of the file and determine what a few of the fields in the headers
    are without looking at the documentation.\r\n\r\nAfter exploring a bit on your
    own, you should check out the [field-by-field walkthrough of a 2x2 bitmap file](http://en.wikipedia.org/wiki/BMP_file_format#Example_1)
    that this example was based on. The information in that table is pretty much all
    you'll need to know in order to make sense of the bitmap reader and writer implementations
    I've built for this article.\r\n\r\n### Encoding a bitmap image\r\n\r\nNow that
    you've seen what a bitmap looks like in its raw form, I can demonstrate\r\nhow
    to build a simple encoder object that allows you to generate bitmap images\r\nin
    a much more convenient way. In particular, I'm going to show what I did to\r\nget
    the following code to output the same image that we rendered via a raw\r\nsequence
    of bytes earlier:\r\n\r\n```ruby\r\nbmp = BMP::Writer.new(2,2)\r\n\r\n# NOTE:
    Bitmap encodes pixels in BGR format, not RGB!\r\nbmp[0,0] = \"ff0000\"\r\nbmp[1,0]
    = \"00ff00\"\r\nbmp[0,1] = \"0000ff\"\r\nbmp[1,1] = \"ffffff\"\r\n\r\nbmp.save_as(\"example_generated.bmp\")\r\n```\r\n\r\nLike
    most binary formats, the bitmap format has a tremendous amount of options\r\nthat
    make building a complete implementation a whole lot more complicated than\r\njust
    building a tool which is suitable for generating a single type of image. I\r\nrealized
    shortly after skimming the format description that you can skip out on\r\na lot
    of the boilerplate information if you stick to 24bit-per-pixel images, so\r\nI
    decided to do exactly that.\r\n\r\nLooking at the implementation from the outside-in,
    you can see the general\r\nstructure of the `BMP::Writer` class. Pixels are stored
    in a two-dimensional\r\narray, and all the interesting things happen at the time
    you write the image out\r\nto file:\r\n\r\n```ruby\r\nclass BMP \r\n  class Writer\r\n
    \   def initialize(width, height)\r\n      @width, @height = width, height\r\n\r\n
    \     @pixels = Array.new(@height) { Array.new(@width) { \"000000\" } }\r\n    end\r\n\r\n
    \   def []=(x,y,value)\r\n      @pixels[y][x] = value\r\n    end\r\n\r\n    def
    save_as(filename)\r\n      File.open(filename, \"wb\") do |file|\r\n        write_bmp_file_header(file)\r\n
    \       write_dib_header(file)\r\n        write_pixel_array(file)\r\n      end\r\n
    \   end\r\n\r\n    # ... rest of implementation details omitted for now ...\r\n
    \ end\r\nend\r\n```\r\n\r\nAll bitmap files start out with the bitmap file header,
    which consists of the\r\nfollowing things:\r\n\r\n* A two character signature
    to indicate the file is a bitmap file (typically \"BM\").\r\n* A 32bit unsigned
    little-endian integer representing the size of the file itself.\r\n* A pair of
    16bit unsigned little-endian integers reserved for application specific uses.\r\n*
    A 32bit unsigned little-endian integer representing the offset to where the pixel
    array starts in the file.\r\n\r\nThe following code shows how `BMP::Writer` builds
    up this header and writes it\r\nto file:\r\n\r\n```ruby\r\nclass BMP \r\n  class
    Writer\r\n    PIXEL_ARRAY_OFFSET = 54\r\n    BITS_PER_PIXEL     = 24\r\n\r\n    #
    ... rest of code as before ...\r\n\r\n    def write_bmp_file_header(file)\r\n
    \     file << [\"BM\", file_size, 0, 0, PIXEL_ARRAY_OFFSET].pack(\"A2Vv2V\")\r\n
    \   end\r\n\r\n    def file_size\r\n      PIXEL_ARRAY_OFFSET + pixel_array_size
    \r\n    end\r\n\r\n    def pixel_array_size\r\n      ((BITS_PER_PIXEL*@width)/32.0).ceil*4*@height\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nOut of the five fields in this header, only
    the file size ended up being\r\ndynamic. I was able to treat the pixel array offset
    as a constant because the\r\nheaders for 24 bit color images take up a fixed amount
    of space. The file size\r\ncomputations[^1] will make sense later once we examine
    the way that the pixel \r\narray gets encoded.\r\n\r\nThe tool that makes it possible
    for us to convert these various field values\r\ninto binary sequences is `Array#pack`.
    If you note that the file size of our\r\nreference image is 2x2 bitmap is 70 bytes,
    it becomes clear what `pack`\r\nis actually doing for us when we examine the byte
    by byte values \r\nin the following example:\r\n\r\n```ruby\r\nheader = [\"BM\",
    70, 0, 0, 54].pack(\"A2Vv2V\") \r\np header.bytes.map { |e| \"%.2x\" % e }\r\n\r\n=begin
    expected output (NOTE: reformatted below for easier reading)\r\n  [\"42\", \"4d\",
    \r\n   \"46\", \"00\", \"00\", \"00\", \r\n   \"00\", \"00\", \r\n   \"00\", \"00\",
    \r\n   \"36\", \"00\", \"00\", \"00\"]\r\n=end\r\n```\r\nThe byte sequence for
    the file header exactly matches that of our reference image, \r\nwhich indicates
    that the proper bitmap file header is being generated. \r\nBelow I've listed out
    how each field in the header encoded:\r\n\r\n```\r\n  \"A2\" -> arbitrary binary
    string of width 2 (packs \"BM\" as: 42 4d)\r\n  \"V\"  -> a 32bit unsigned little
    endian int (packs 70 as: 46 00 00 00)\r\n  \"v2\" -> two 16bit unsigned little
    endian ints (packs 0, 0 as: 00 00 00 00)\r\n  \"V\"  -> a 32bit unsigned little
    endian int (packs 54 as: 36 00 00 00)\r\n```\r\n\r\nWhile I went to the effort
    of expanding out the byte sequences to make it easier\r\nto see what is going
    on, you don't typically need to do this at all while\r\nworking with `Array#pack`
    as long as you craft your template strings carefully.\r\nBut like anything else
    in Ruby, it's nice to be able to write little scripts or\r\nhack around a bit
    in `irb` whenever you're trying to figure out how your\r\ncode is actually working.\r\n\r\nAfter
    figuring out how to encode the file header, the next step was to work on\r\nthe
    DIB header, which includes some metadata about the image and how it should\r\nbe
    displayed on the screen:\r\n\r\n```ruby\r\nclass BMP \r\n  class Writer\r\n    DIB_HEADER_SIZE
    \   = 40\r\n    PIXELS_PER_METER   = 2835 # 2835 pixels per meter is basically
    72dpi\r\n\r\n    # ... other code as before ...\r\n\r\n   def write_dib_header(file)\r\n
    \     file << [DIB_HEADER_SIZE, @width, @height, 1, BITS_PER_PIXEL,\r\n               0,
    pixel_array_size, PIXELS_PER_METER, PIXELS_PER_METER, \r\n               0, 0].pack(\"Vl<2v2V2l<2V2\")\r\n
    \ end\r\nend\r\n```\r\n\r\nBecause we are only working on a very limited subset
    of BMP features, it's\r\npossible to construct the DIB header mostly from preset
    constants combined with\r\na few values that we already computed for the BMP file
    header.\r\n\r\nThe `pack` statement in the above code works in a very similar
    fashion as the\r\ncode that writes out the BMP file header, with one exception:
    it needs to handle\r\nsigned 32-bit little endian integers. This data type does
    not have a pattern of its own, \r\nbut instead is a composite pattern made up
    of two\r\ncharacters: `l<`. The first character (`l`) instructs Ruby to read a
    32-bit\r\nsigned integer, and the second character (`<`) tells it to read it in\r\nlittle-endian
    byte order.\r\n\r\nIt isn't clear to me at all why a bitmap image could contain
    negative values for\r\nits width, height, and pixel density -- this is just how
    the format is\r\nspecified. Because our goal is to learn about binary file processing
    and not\r\nimage format esoterica, it's fine to treat that design decision as
    a black\r\nbox for now and move on to looking at how the pixel array is processed.\r\n\r\n```ruby\r\nclass
    BMP \r\n  class Writer\r\n    # .. other code as before ...\r\n\r\n    def write_pixel_array(file)\r\n
    \     @pixels.reverse_each do |row|\r\n        row.each do |color|\r\n          file
    << pixel_binstring(color)\r\n        end\r\n\r\n        file << row_padding\r\n
    \     end\r\n    end\r\n\r\n    def pixel_binstring(rgb_string)\r\n      raise
    ArgumentError unless rgb_string =~ /\\A\\h{6}\\z/\r\n      [rgb_string].pack(\"H6\")\r\n
    \   end\r\n\r\n    def row_padding\r\n      \"\\x0\" * (@width % 4)\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nThe most interesting thing to note about this code
    is that each row of pixels ends up getting padded with some null characters. This
    is to ensure that each row of pixels is aligned on WORD boundaries (4 byte sequences).
    This is a semi-arbitrary limitation that has to do with file storage constraints,
    but things like this are common in binary files. \r\n\r\nThe calculations below
    show how much padding is needed to bring rows of various widths up to a multiple
    of 4, and explains how I derived the computation for the `row_padding` method:\r\n\r\n```\r\nWidth
    2 : 2 * 3 Bytes per pixel = 6 bytes  + 2 padding  = 8\r\nWidth 3 : 3 * 3 Bytes
    per pixel = 9 bytes  + 3 padding  = 12\r\nWidth 4 : 4 * 3 Bytes per pixel = 12
    bytes + 0 padding  = 12\r\nWidth 5 : 5 * 3 Bytes per pixel = 15 bytes + 1 padding
    \ = 16\r\nWidth 6 : 6 * 3 Bytes per pixel = 18 bytes + 2 padding  = 20\r\nWidth
    7 : 7 * 3 Bytes per pixel = 21 bytes + 3 padding  = 24\r\n...\r\n```\r\n\r\nSometimes
    calculations like this are provided for you in format specifications,\r\nother
    times you need to derive them yourself. Choosing to work\r\nwith only 24bit per
    pixel images allowed me to skirt the question of how to\r\ngeneralize this computation
    to an arbitrary amount of bits per pixel.\r\n\r\nWhile the padding code is definitely
    the most interesting aspect of the pixel array, there are a couple other details
    about this implementation worth discussing. In particular, we should take a closer
    look at the `pixel_binstring` method:\r\n\r\n```ruby\r\ndef pixel_binstring(rgb_string)\r\n
    \ raise ArgumentError unless rgb_string =~ /\\A\\h{6}\\z/\r\n  [rgb_string].pack(\"H6\")\r\nend\r\n```\r\n\r\nThis
    is the method that converts the values we set in the pixel array via lines like
    `bmp[0,0] = \"ff0000\"` into actual binary sequences. It starts by matching the
    string with a regex to ensure that the input string is a valid sequence of 6 hexadecimal
    digits. If the validation succeeds, it then packs those values into a binary sequence,
    creating a string with three bytes in it. The example below should make it clear
    what is going on here:\r\n\r\n```\r\n>> [\"ffa0ff\"].pack(\"H6\").bytes.to_a\r\n=>
    [255, 160, 255]\r\n```\r\n\r\nThis pattern makes it possible for us to specify
    color values directly in hexadecimal strings and then convert them to their numeric
    value just before they get written to the file.\r\n\r\nWith this last detail explained,
    you should now understand how to build a\r\nfunctional bitmap encoder for writing
    24bit color images. If seeing things\r\nbroken out step by step caused you to
    lose a sense of the big picture, you can\r\ncheck out the [source code for BMP::Writer](https://gist.github.com/1351737).
    Feel free to play around with it a bit before moving on to the next section: the
    best way to learn is to actually run these code samples and try to extend them
    and/or break them in various ways.\r\n\r\n### Decoding a bitmap image\r\n\r\nAs
    you might expect, there is a nice symmetry between encoding and decoding binary
    files. To show just to what extent this is the case, I will walk you through the
    code which makes the following example run:\r\n\r\n```ruby\r\nbmp = BMP::Reader.new(\"example1.bmp\")\r\np
    bmp.width  #=> 2\r\np bmp.height #=> 2\r\n\r\np bmp[0,0] #=> \"ff0000\"   \r\np
    bmp[1,0] #=> \"00ff00\" \r\np bmp[0,1] #=> \"0000ff\" \r\np bmp[1,1] #=> \"ffffff\"
    \r\n```\r\n\r\nThe general structure of `BMP::Reader` ended up being quite similar
    to what I did for `BMP::Writer`. The code below shows the methods which define
    the public interface:\r\n\r\n```ruby\r\nclass BMP\r\n  class Reader\r\n    def
    initialize(bmp_filename) \r\n      File.open(bmp_filename, \"rb\") do |file|\r\n
    \       read_bmp_header(file) # does some validations\r\n        read_dib_header(file)
    # sets @width, @height\r\n        read_pixels(file)     # populates the @pixels
    array\r\n      end\r\n    end\r\n\r\n    attr_reader :width, :height\r\n\r\n    def
    [](x,y)\r\n      @pixels[y][x]\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis time,
    we still are working with an ordinary array of arrays to store the\r\npixel data,
    and most of the work gets done as soon as the file is read in the\r\nconstructor.
    Because I decided to support only a single image type, most of the\r\nwork of
    reading the headers is just for validation purposes. In fact, the\r\n`read_bmp_header`
    method does nothing more than some basic sanity checking, as\r\nshown below:\r\n\r\n```ruby\r\nclass
    BMP\r\n  class Reader\r\n    PIXEL_ARRAY_OFFSET = 54\r\n\r\n    # ...other code
    as before ...\r\n\r\n    def read_bmp_header(file)\r\n      header = file.read(14)\r\n
    \     magic_number, file_size, reserved1,\r\n      reserved2, array_location =
    header.unpack(\"A2Vv2V\")\r\n      \r\n      fail \"Not a bitmap file!\" unless
    magic_number == \"BM\"\r\n\r\n      unless file.size == file_size\r\n        fail
    \"Corrupted bitmap: File size is not as expected\" \r\n      end\r\n\r\n      unless
    array_location == PIXEL_ARRAY_OFFSET\r\n        fail \"Unsupported bitmap: pixel
    array does not start where expected\"\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe
    key thing to notice about this code is that it reads from the file just the bytes
    it needs in order to parse the header. This makes it possible to validate a very
    large file without loading much data into memory. Reading entire files into memory
    is rarely a good idea, and this is especially true when it comes to binary data
    because doing so will actually make your job harder rather than easier. \r\n\r\nOnce
    the header data is loaded into a string, the `String#unpack` method is used to
    extract some values from it. Notice here how `String#unpack` uses the same template
    syntax as `Array#pack` and simply provides the inverse operation. While the `pack`
    operation converts an array of values into a string of binary data, the `unpack`
    operation converts a binary string into an array of processed values. This allows
    us to recover the information packed into the bitmap file header as Ruby strings
    and fixnums.\r\n\r\nOnce these values have been converted into Ruby objects, it's
    easy to do some\r\nordinary comparisons to check to see if they're what we'd expect
    them to be.\r\nBecause they help detect corrupted files, clearly defined validations
    are an\r\nimportant part of writing any decoder for binary file formats. If you
    do not do\r\nthis sort of sanity checking, you will inevitably run into \r\nsubtle
    processing errors later on that will be much harder to debug.\r\n\r\nAs you might
    expect, the implementation of `read_dib_header` involves more of\r\nthe same sort
    of extractions and validations. It also sets the `@width` and\r\n`@height` variables,
    which we use later to determine how to traverse the encoded\r\npixel array.\r\n\r\n```ruby\r\nclass
    BMP \r\n  class Reader\r\n    # ... other code as before ...\r\n\r\n    BITS_PER_PIXEL
    \    = 24\r\n    DIB_HEADER_SIZE    = 40\r\n\r\n    def read_dib_header(file)\r\n
    \     header = file.read(40)\r\n\r\n      header_size, width, height, planes,
    bits_per_pixel, \r\n      compression_method, image_size, hres, \r\n      vres,
    n_colors, i_colors = header.unpack(\"Vl<2v2V2l<2V2\") \r\n\r\n      unless header_size
    == DIB_HEADER_SIZE\r\n        fail \"Corrupted bitmap: DIB header does not match
    expected size\"\r\n      end\r\n\r\n      unless planes == 1\r\n        fail \"Corrupted
    bitmap: Expected 1 plane, got #{planes}\"\r\n      end\r\n\r\n      unless bits_per_pixel
    == BITS_PER_PIXEL\r\n        fail \"#{bits_per_pixel} bits per pixel bitmaps are
    not supported\"\r\n      end\r\n\r\n      unless compression_method == 0\r\n        fail
    \"Bitmap compression not supported\"\r\n      end\r\n\r\n      unless image_size
    + PIXEL_ARRAY_OFFSET == file.size\r\n        fail \"Corrupted bitmap: pixel array
    size isn't as expected\"\r\n      end\r\n\r\n      @width, @height = width, height\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nBeyond what has already been said about
    this example and the DIB header itself, there isn't much more to discuss about
    this particular method. That means we can finally take a look at how `BMP::Reader`
    converts the encoded pixel array into a nested Ruby array structure.\r\n\r\n```ruby\r\nclass
    BMP \r\n  class Reader\r\n    def read_pixels(file)\r\n      @pixels = Array.new(@height)
    { Array.new(@width) }\r\n\r\n      (@height-1).downto(0) do |y|\r\n        0.upto(@width
    - 1) do |x|\r\n          @pixels[y][x] = file.read(3).unpack(\"H6\").first\r\n
    \       end\r\n        advance_to_next_row(file)\r\n      end\r\n    end\r\n\r\n
    \   def advance_to_next_row(file)\r\n      padding_bytes = @width % 4\r\n      return
    if padding_bytes == 0\r\n\r\n      file.pos += padding_bytes\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nOne
    interesting aspect of this code is that it uses explicit numerical iterators.
    These are relatively rare in idiomatic Ruby, but I did not see a better way to
    approach this particular problem. Rows are listed in the pixel array from the
    bottom up, while the image itself still gets indexed from the top down (with 0
    at the top). This makes it necessary to iterate over the row numbers in reverse
    order, and the use of `downto` is the best way I could find to do that.\r\n\r\nThe
    other thing worth noticing about this code is that in the `advance_to_next_row`
    method, we actually move the pointer ahead in the file rather than reading the
    padding bytes between each row. This makes little difference when you're dealing
    with a maximum of three bytes of padding per row (two in this case), but is a
    good practice for writing more efficient code that consumes less memory.\r\n\r\nWhen
    you take all these code examples and glue them together into a single class\r\ndefinition,
    you'll end up with a `BMP::Reader` object that is capable giving you\r\nthe width
    and height of a 24bit BMP image as well as the color of each and every\r\npixel
    in the image. For those who'd like to experiment further, the [source code\r\nfor
    BMP::Reader](https://gist.github.com/1352294) is available.\r\n\r\n### Reflections\r\n\r\nThe
    thing that makes me appreciate binary file formats is that if you just learn\r\na
    few basic computing concepts, there are few things that could be more\r\nfundamentally
    simple to work with. But simple does not necessarily mean easy, and in the process
    of writing this article I realized that some aspects of binary file processing
    are not quite as trivial or intuitive as I originally thought they were.\r\n\r\nWhat
    I can say is that this kind of work gets a whole lot easier with practice.\r\nDue
    to my work on [Prawn](http://prawnpdf.org) I have written\r\nimplementations for
    various different binary formats including PDF, PNG, JPG,\r\nand TTF. These formats
    each have their differences, but my experience tells me \r\nthat if you fully
    understand the examples in this article, then you are already \r\nwell on your
    way to tackling pretty much any binary file format.\r\n\r\n[^1]: To determine
    the storage space needed for the pixel array in BMP images, I used the computations
    described in the [Wikipedia article on bitmap images](http://en.wikipedia.org/wiki/BMP_file_format#Pixel_storage).\r\n\r\n>
    NOTE: If you'd like to learn more about this topic, consider doing the Practicing
    Ruby self-guided course on [Streams, Files, and Sockets](https://practicingruby.com/articles/study-guide-1?u=dc2ab0f9bb).
    You've already completed one of its reading exercises by working through this
    article!"
- :slug: arguments-and-results-1
  :title: Thoughts on "Arguments and Results", Part 1
  :summary: Work through argument objects inspired by James Noble's classic "Arguments
    and Results" paper.
  :published: 2011-11-23 00:00:00.000000000 Z
  :issue_number: '2.14'
  :volume: 2
  :body: "Back in 1997, James Noble published a paper called [Arguments and Results](http://www.laputan.org/pub/patterns/noble/noble.pdf)
    which outlined several useful patterns for designing better object protocols.
    Despite the fact that this paper was written nearly 15 years ago, it addresses
    design problems that programmers still struggle with today. In this two part article,
    I show how the patterns James came up with can be applied to modern Ruby programs.\r\n\r\n<u>Arguments
    and Results</u> is written in such a way that it is natural to split the patterns
    it describes into two separate groups: patterns about method arguments and patterns
    about the results returned by methods. I've decided to split this Practicing Ruby
    article in the same manner in order to make it easier for me to write and easier
    for you to read. \r\n\r\nIn this first installment, we will explore the patterns
    James lays out for working with method arguments, and in Issue 2.15 we'll look
    into results objects. If you read this part, be sure to read the second part once
    it comes out, because the two concepts complement each other nicely.\r\n\r\n###
    Establishing a context \r\n\r\nIt is very difficult to study design patterns without
    applying them within a particular context. When I am trying to learn new patterns,
    I tend to start by looking for a realistic scenario that the pattern might be
    applicable to. I then examine the benefits and drawbacks of the design changes
    within that context. James uses a lot of graphics programming examples in his
    paper and this is for good reason: it's an area where designing good interfaces
    for your objects can quickly become challenging.\r\n\r\nI've decided to follow
    in James's footsteps here and use a trivial [SVG](http://www.w3.org/TR/SVG/) generator
    as the common theme for the examples in this article. The following code illustrates
    the interface that I started with before applying any special patterns:\r\n\r\n```ruby\r\n#
    image dimensions are provided to `Drawing` in cm, \r\n# all other measurements
    are done in units of 0.01 cm\r\n\r\ndrawing = Drawing.new(4,4)\r\n\r\ndrawing.line(:x1
    => 100, :y1 => 100, :x2 => 200, :y2 => 250,\r\n             :stroke_color => \"blue\",
    :stroke_width => 2)\r\n\r\ndrawing.line(:x1 => 300, :y1 => 100, :x2 => 200, :y2
    => 250,\r\n             :stroke_color => \"blue\", :stroke_width => 2)\r\n\r\nFile.write(\"sample.svg\",
    drawing.to_svg)\r\n```\r\n\r\nThe implementation details are not important here,
    but if you would like to see how this code works, you can check out the [source
    code for the Drawing class](https://github.com/elm-city-craftworks/pr-arguments-and-results/blob/7656768680b6a940a5ccf569fc0e0dce48a5dbfe/drawing.rb).
    The interface for `Drawing#line` uses keyword-style arguments in a similar fashion
    to most other Ruby libraries. Because keyword arguments are easier to remember
    and more flexible than ordinal arguments, this style of interface has become very
    popular among Ruby programmers. However, the more arguments a method takes, the
    more unwieldy this sort of API becomes. That tipping point is where design patterns
    about arguments come into play.\r\n\r\n### Arguments object\r\n\r\nAs the number
    of arguments to a method increase, the amount of code within the method to handle
    those arguments tends to increase as well. This is because complex protocols typically
    require  arguments to be validated and transformed before they can be operated
    on. By introducing new objects to wrap related sets of arguments, it is possible
    to keep your argument processing logic somewhat separated from your business logic.
    The following code demonstrates how to use this concept to simplify the interface
    of the `Drawing#line` method:\r\n\r\n```ruby\r\ndrawing = Drawing.new(4,4)\r\n\r\nline1
    = Drawing::Shape.new([100, 100], [200, 250])\r\nline2 = Drawing::Shape.new([300,
    100], [200, 250])\r\n\r\nline_style = Drawing::Style.new(:stroke_color => \"blue\",
    :stroke_width => \"2\")\r\n\r\ndrawing.line(line1, line_style)\r\n\r\ndrawing.line(line2,
    line_style)\r\n\r\nFile.write(\"sample.svg\", drawing.to_svg)\r\n```\r\n\r\nThis
    approach takes a single complex method call on a single object and replaces it
    with several less complex method calls distributed across several objects. In
    the early stages of development, applying this pattern feels ugly because it involves
    writing a lot more code for both the library developer and application developer.
    However, as the complexity of the argument processing increases, the benefits
    of this approach begin to shine. The following example demonstrates how the newly
    introduced arguments objects raise the `Drawing#line` code up to a higher level
    of abstraction.\r\n\r\n```ruby\r\ndef line(data, style)\r\n  unless data.bounded_by?(@viewbox_width,
    @viewbox_height)\r\n    raise ArgumentError, \"shape is not within view box\"\r\n
    \ end\r\n\r\n  @lines << { :x1 => data[0].x.to_s, :y1 => data[0].y.to_s,\r\n              :x2
    => data[1].x.to_s, :y2 => data[1].y.to_s,\r\n              :style => style.to_css
    }\r\nend\r\n```\r\n\r\nThe cost of making `Drawing#line` so concise is a big chunk
    of boilerplate code that on the surface feels a bit overkill at this stage in
    the game. However, it does not take a very wild imagination to see how these new
    objects set the stage for future extensions:\r\n\r\n```ruby\r\nclass Point\r\n
    \ def initialize(x, y)\r\n    @x, @y = x, y\r\n  end\r\n\r\n  attr_reader :x,
    :y\r\nend\r\n\r\nclass Shape\r\n  def initialize(*point_data)\r\n    @points =
    point_data.map { |e| Point.new(*e) }\r\n  end\r\n\r\n  def [](index)\r\n    @points[index]\r\n
    \ end\r\n\r\n  def bounded_by?(x_max, y_max)\r\n    @points.all? { |p| p.x <=
    x_max && p.y <= y_max }\r\n  end\r\nend\r\n\r\nclass Style\r\n  def initialize(params)\r\n
    \   @stroke_width  = params.fetch(:stroke_width, 5)\r\n    @stroke_color  = params.fetch(:stroke_color,
    \"black\")\r\n  end\r\n\r\n  attr_reader :stroke_width, :stroke_color\r\n\r\n
    \ def to_css\r\n    \"stroke: #{@stroke_color}; stroke-width: #{@stroke_width}\"\r\n
    \ end\r\nend\r\n```\r\n\r\nThe interesting thing about these objects is that they
    actually represent domain models even though their original purpose was simply
    to wrap up some arguments to a single method defined on the `Drawing` object.
    James mentions in his paper that this phenomena is common and would call these
    \"Found objects\", i.e. objects that are part of the domain model that were found
    through refactoring rather than accounted for in the original design.\r\n\r\nYou
    might have noticed that in the previous example, I set some default values for
    some of the variables on the `Style` object. If you compare this to setting defaults
    directly within the `Drawing#line` method itself, it becomes obvious that there
    is a benefit here. Properties like\r\nthe color and thickness of the lines drawn
    to form a shape are universal properties, not things specific to straight lines
    only. Centralizing the defaults makes it so that they do not need to be repeated
    for each type of shape that the `Drawing` object supports.\r\n\r\n### Selector
    object\r\n\r\nSometimes we end up with objects that have many methods that take
    similar arguments. While these methods may actually do different things, the only
    difference in the object protocol is the name of the message being sent. After
    adding a method for rendering polygons to my `Drawing` object, I ended up in exactly
    this situation. The following example shows just how similar the `Drawing#line`
    interface is to the newly created `Drawing#polygon` method:\r\n\r\n```ruby\r\ndrawing
    = Drawing.new(4,4)\r\n\r\nline1 = Drawing::Shape.new([100, 100], [200, 250])\r\nline2
    = Drawing::Shape.new([300, 100], [200, 250])\r\n\r\ntriangle = Drawing::Shape.new([350,
    150], [250, 300], [150,150])\r\n\r\nstyle = Drawing::Style.new(:stroke_color =>
    \"blue\", :stroke_width => 2)\r\n\r\ndrawing.line(line1, style)\r\n\r\ndrawing.line(line2,
    style)\r\n\r\ndrawing.polygon(triangle, style)\r\n\r\nFile.write(\"sample.svg\",
    drawing.to_svg)\r\n```\r\n\r\nTaking a look at the implementation of both methods,
    it is easy to see that there are deep similarities in structure between the two:\r\n\r\n```ruby\r\nclass
    Drawing\r\n  # NOTE: other code omitted, not important...\r\n\r\n  def line(data,
    style)\r\n    unless data.bounded_by?(@viewbox_width, @viewbox_height)\r\n      raise
    ArgumentError, \"shape is not within view box\"\r\n    end\r\n\r\n    @elements
    << [:line, { :x1    => data[0].x.to_s, \r\n                           :y1    =>
    data[0].y.to_s, \r\n                           :x2    => data[1].x.to_s, \r\n
    \                          :y2    => data[1].y.to_s,\r\n                           :style
    => style.to_css }] \r\n  end\r\n\r\n  def polygon(data, style)\r\n    unless data.bounded_by?(@viewbox_width,
    @viewbox_height)\r\n       raise ArgumentError, \"shape is not within view box\"
    \    \r\n    end\r\n\r\n    @elements << [:polygon, { \r\n      :points => data.each.map
    { |point| \"#{point.x},#{point.y}\" }.join(\" \"),\r\n      :style  => style.to_css\r\n
    \   }]\r\n  end\r\nend\r\n```\r\n\r\nTo make this code more DRY, James recommends
    converting our arguments object into what he calls a selector object. A selector
    object is an object which uses similar arguments to do different things depending
    on the type of message it is meant to represent. James recommends using double
    dispatch or multi-methods to implement this pattern, but that approach is not
    appropriate for Ruby because the language does not provide built-in semantics
    for function overloading. The good news is that he also mentions that inheritance
    can be used as an alternative, and in this case it was a perfect fit.\r\n\r\nTo
    simplify and clean up the previous example, I introduced `Line` and `Polygon`
    which inherit from `Shape`. I then combined the `Drawing#line` method and `Drawing#polygon`
    method into a single method called `Drawing#draw`. The following example demonstrates
    what the API ended up looking like as a result of this change:\r\n\r\n```ruby\r\ndrawing
    = Drawing.new(4,4)\r\n\r\nline1 = Drawing::Line.new([100, 100], [200, 250])\r\nline2
    = Drawing::Line.new([300, 100], [200, 250])\r\n\r\ntriangle = Drawing::Polygon.new([350,
    150], [250, 300], [150,150])\r\n\r\nstyle = Drawing::Style.new(:stroke_color =>
    \"blue\", :stroke_width => 2)\r\n\r\ndrawing.draw(line1, style)\r\ndrawing.draw(line2,
    style)\r\ndrawing.draw(triangle, style)\r\n\r\nFile.write(\"sample.svg\", drawing.to_svg)\r\n```\r\n\r\nThe
    changes to the API are small but make the code a lot easier to read. This rearrangement
    introduces even more objects into the system, but simplifies the protocol between
    those objects. In large systems, this leads to greater maintainability and learnability
    at the cost of having a few more moving parts.\r\n\r\nIn order to implement this
    new interface, some non-trivial changes needed to be made under the hood. You
    can check out the [exact commit](https://github.com/elm-city-craftworks/pr-arguments-and-results/commit/47924901552d0509f97a3083737709980139feba)
    to see the details about what changed implementation-wise between this example
    and the last one, but most of the changes were just boring housekeeping. The general
    idea is that the `Drawing#draw` method now simply asks each shape object to represent
    itself as a hash which ultimately ends up getting converted into an XML tag within
    the SVG document. As an example, here is what the definition for the `Line` object
    looks like:\r\n\r\n```ruby\r\nclass Drawing\r\n  class Line < Shape\r\n    def
    to_hash(style)\r\n      { :tag_name => :line,\r\n        :params => { :x1    =>
    self[0].x.to_s,\r\n                     :y1    => self[0].y.to_s,\r\n                     :x2
    \   => self[1].x.to_s,\r\n                     :y2    => self[1].y.to_s,\r\n                     :style
    => style.to_css } }\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAs you can imagine,
    the `Polygon` object uses a similar approach and this general pattern would be
    applicable for new types of shapes as well.\r\n\r\n\r\n### Curried object\r\n\r\nWhile
    method arguments exist to allow us to vary the objects we pass in, its not uncommon
    for the same method to be called many times with some of its arguments being held
    constant. In fact, all of the examples in this article have shown the same `Style`
    object being passed to the same method again and again, with only the shape varying.
    This has resulted in some repetitive code that looks ugly, and could be improved.\r\n\r\nJames
    recommends creating a curried object to deal with this sort of problem. The curried
    object acts as a lightweight proxy over the original object, but keeps the constant
    data stored in variables so that you do not need to keep repeating it. The following
    code applies this concept to clean up our previous example:\r\n\r\n```ruby\r\nline1
    = Drawing::Line.new([100, 100], [200, 250])\r\nline2 = Drawing::Line.new([300,
    100], [200, 250])\r\n\r\ntriangle = Drawing::Polygon.new([350, 150], [250, 300],
    [150,150])\r\n\r\ndrawing = Drawing.new(4,4)\r\nstyle   = Drawing::Style.new(:stroke_color
    => \"blue\", :stroke_width => 2)\r\npen     = Drawing::Pen.new(drawing, style)\r\n\r\npen.draw(line1)\r\npen.draw(line2)\r\npen.draw(triangle)\r\n\r\nFile.write(\"sample.svg\",
    drawing.to_svg)\r\n```\r\n\r\nWhile introducing the new `Pen` object requires
    a change in the calling code so that `Pen#draw` gets called instead of `Drawing#draw`,
    no change to the implementation of `Drawing` was needed to introduce this new
    object. The following class definition will do the trick:\r\n\r\n```ruby\r\nclass
    Drawing\r\n  class Pen\r\n    def initialize(drawing, style)\r\n      @drawing,
    @style = drawing, style\r\n    end\r\n\r\n    def draw(shape)\r\n      drawing.draw(shape,
    style)\r\n    end\r\n    \r\n    private\r\n\r\n    attr_reader :drawing, :style\r\n
    \ end\r\nend\r\n```\r\n\r\nIn this particular case, `Pen` is easy to write because
    the interface on `Drawing` is so small. In more complicated cases, it would make
    sense to use some of Ruby's metaprogramming features to implement a dynamic proxy
    of some sort. However, if you find yourself simultaneously facing a broad interface
    that has arguments that often remain constant in many of its functions, you may
    want to evaluate whether you have a flawed design before going down that road.\r\n\r\nAn
    interesting thing to note is that curried objects are not necessarily limited
    to arguments that remain constant. This pattern can also be applied in situations
    where method calls made in sequence have a clear pattern in the way that one or
    more arguments are varied. The example James gives in his paper describes some
    logic for a text editor in which lines of text are rendered to the screen with
    all the same style attributes from line to line, but with the line number incremented
    as each new line is rendered. Taking inspiration from that example, I decided
    to build a simple turtle graphics system to demonstrate how curried objects can
    be used for predictably varying arguments as well as constant arguments. The code
    below generates an image of an X when run:\r\n\r\n```ruby\r\ndrawing = Drawing.new(4,4)\r\nstyle
    \  = Drawing::Style.new(:stroke_color => \"blue\", :stroke_width => 2)\r\nturtle
    \ = Drawing::Turtle.new(drawing, style)\r\n\r\nturtle.move_to([0, 400])\r\n\r\nturtle.pen_down\r\nturtle.move_to([400,
    0])\r\n\r\nturtle.pen_up\r\nturtle.move_to([0,0])\r\n\r\nturtle.pen_down\r\nturtle.move_to([400,400])\r\n\r\nFile.write(\"sample.svg\",
    drawing.to_svg)\r\n```\r\n\r\nThe implementation code to make the previous example
    work was very easy to write and required no changes to the rest of the system:\r\n\r\n```ruby\r\nclass
    Drawing\r\n  class Turtle\r\n    def initialize(drawing, style)\r\n      @drawing
    \ = drawing\r\n      @style    = style\r\n      @inked    = false\r\n      @position
    = [0,0]\r\n    end\r\n\r\n    def move_to(next_position)\r\n      if inked\r\n
    \       drawing.draw(Line.new(position, next_position), style)\r\n      end\r\n
    \     \r\n      self.position = next_position\r\n    end\r\n\r\n    def pen_up\r\n
    \     self.inked = false\r\n    end\r\n\r\n    def pen_down \r\n      self.inked
    = true\r\n    end\r\n\r\n    private\r\n\r\n    attr_reader   :drawing, :style\r\n
    \   attr_accessor :position, :inked \r\n  end\r\nend\r\n```\r\n\r\nAfter taking
    a look at the finished `Turtle` object, I did wonder a little bit about whether
    the idea of a curried object in Ruby is nothing more than an ordinary object making
    use of object composition. However, because the name of the pattern is helpful
    for describing the intent of this sort of object in a succinct way, it may be
    a good label for us to use when discussing the merits of different design options.\r\n\r\n###
    Reflections\r\n\r\nApplying these various argument patterns to a realistic example
    made it much easier for me to see the power behind these ideas. I have gradually
    picked up bits and pieces of the various techniques shown here before reading
    this paper largely due to my trial and error work on the Prawn PDF generator.
    \r\n\r\nIn lots of places in Prawn, we let hash arguments grow to an insanely
    large size and it created a lot of problems for us. We also ignored using curried
    objects in a lot of places by instead placing instance variables directly on the
    target objects and then mutating the state within them over time to vary things.
    This led to complicated transactional code and made it easy for things to end
    up in an inconsistent state. The solutions to these problems tended to be refactorings
    that are quite similar to what you've seen in this article, even if we didn't
    call them by a special name at the time.\r\n\r\nStill, I do have some concern
    that these patterns might be overkill for any interfaces that you are reasonably
    sure won't get too complex over time. If we apply these patterns overzealously,
    you might end up needing to go through level after level of indirection just to
    accomplish anything useful, and that will make Ruby start to feel like Java. However,
    it seems like using some sort of formalized arguments object is obviously beneficial
    for highly complex interactions, and likely to be at least somewhat useful for
    medium complexity protocols as well.\r\n\r\nNo matter what the complexity of the
    problem I was working on, it's unlikely that I would make it so that the application
    developer needed to jump through so many hoops just to use my library. Instead,
    I would probably build a simple facade or DSL that made their life easier, even
    if a rich object structure was lurking under the hood. If I were really building
    an SVG generator, I might end up building a DSL for it that looked something like
    this:\r\n\r\n```ruby\r\ndrawing do\r\n  style :stroke_color => \"blue\", :stroke_width
    => 2 do\r\n    line    [100, 100], [200, 250]\r\n    line    [300, 100], [200,
    250]\r\n    polygon [350, 150], [250, 300], [150,150]\r\n  end\r\n\r\n  save_as
    \"sample.svg\"\r\nend\r\n```\r\n\r\nIf I implemented this as a thin veneer on
    top of code similar to what we ended up with in this article, I think that would
    be a pretty well designed library. The end user gets convenience for the normal
    case, but the underlying system would be easier to maintain, test, and learn.
    It would also give the user flexibility to interact with the system in ways I
    didn't anticipate.\r\n\r\nBe sure to tune in next week for the second part of
    this article, where I'll focus on the results side of the method interface. Until
    then, I'd love to hear any questions or thoughts you have about this topic."
- :slug: arguments-and-results-2
  :title: Thoughts on "Arguments and Results", Part 2
  :summary: Work through result objects inspired by James Noble's classic "Arguments
    and Results" paper.
  :published: 2011-11-30 00:00:00.000000000 Z
  :issue_number: '2.15'
  :volume: 2
  :body: "Back in 1997, James Noble published a paper called [Arguments and Results](http://www.laputan.org/pub/patterns/noble/noble.pdf)
    which outlined several useful patterns for designing better object protocols.
    Despite the fact that this paper was written nearly 15 years ago, it addresses
    design problems that programmers still struggle with today. In this two part article,
    I show how the patterns James came up with can be applied to modern Ruby programs.\r\n\r\n<u>Arguments
    and Results</u> is written in such a way that it is natural to split the patterns
    it describes into two separate groups: patterns about method arguments and patterns
    about the results returned by methods. I've decided to split this Practicing Ruby
    article in the same manner in order to make it easier for me to write and easier
    for you to read. \r\n\r\nIn [Issue 2.14](http://practicingruby.com/articles/14)
    I outlined various kinds of arguments objects that can be used to simplify the
    messages being sent within a system. In this issue, I will show how results objects
    can provide similar flexibility on the response side of things.\r\n\r\n### Results
    objects\r\n\r\nResults objects are similar to argument objects in that they simplify
    the interface of one object at the cost of introducing new objects into the system.
    The `Report` class I built for [Issue 2.13](http://practicingruby.com/articles/13)
    is a good example of this sort of object. If we start with its class definition
    and work our way backwards to what the code would have looked like without it,
    we will be able to see the reason why this object was introduced in the first
    place.\r\n\r\n```ruby\r\nmodule SubscriptionCounter\r\n  class Report\r\n    def
    initialize(series)\r\n      @series = series\r\n\r\n      @issue_numbers = series.map(&:number)\r\n
    \     @weekly_counts = series.map(&:count)\r\n      @weekly_deltas = series.map(&:delta)\r\n
    \     @average_delta = Statistics.adjusted_mean(@weekly_deltas)\r\n    end\r\n
    \r\n    attr_reader :issue_numbers, :weekly_counts, :weekly_deltas, \r\n                :average_delta,
    :summary, :series\r\n\r\n    def table(*fields)\r\n      series.map { |e| fields.map
    { |f| e.send(f) } }\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe following code
    outlines how `Report` is actually used by client code. It essentally serves as
    a bridge between `Series` and `Report::PDF`.\r\n\r\n```ruby\r\ncampaigns = SubscriptionCounter::Campaign.all\r\nseries
    \   = SubscriptionCounter::DataSeries.new(campaigns, 10)\r\nreport    = SubscriptionCounter::Report.new(series)\r\n\r\nSubscriptionCounter::Report::PDF.new(report).save_as(\"pr-subscribers.pdf\")\r\n```\r\n\r\nIf
    we pretend that `Report` never existed and that its methods were implemented directly
    on `DataSeries`, we would end up with something similar to the following client
    code:\r\n\r\n```ruby\r\ncampaigns = SubscriptionCounter::Campaign.all\r\nseries
    \   = SubscriptionCounter::DataSeries.new(campaigns, 10)\r\n\r\nSubscriptionCounter::Report::PDF.new(series).save_as(\"pr-subscribers.pdf\")\r\n```\r\n\r\nThis
    example actually looks a bit cleaner than the previous one, but results in six
    new methods getting added to `DataSeries` and introduces tighter coupling between
    the `DataSeries` and `PDF` objects. Due to the increased coupling, a change in
    the interface of the `DataSeries` object will directly impact the presentation
    code in the `PDF` object, whereas before the `Report` object provided a buffer
    zone between the two classes.\r\n\r\nWhile it is still possible to substitute
    a `DataSeries` object with some other object that provides an equivalent interface,
    we have lost the flexibility of reusing the code that actually does the aggregation
    work. Before removing the `Report` object, it was possible to use it to wrap any
    pretty much any `Enumerable` collection of objects which provided `number`, `count`,
    and `delta` methods. Now we must either do the aggregation ourselves or use a
    `DataSeries` object directly.\r\n\r\nThese downsides are why I introduced the
    `Report` object in the first place, and they make the case for using an object
    that exists simply to aggregate some results based on the data contained in another
    object. If I wanted to make the integration of this results object a bit tighter
    and simplify the client code, I could have introduced a `DataSeries#report` method
    such as the one shown below:\r\n\r\n```ruby\r\nmodule SubscriptionCounter\r\n
    \ class DataSeries\r\n    def report\r\n      Report.new(self)\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nWith this method added, I could either have the `Report::PDF`
    accept an object that responds to `report`, or call the method explicitly in my
    client code. If I went with the former approach I could use the same client code
    as shown in the previous example, making the `Report` object completely transparent
    to the end user. However, the latter approach still looks a bit cleaner than what
    I had originally without introducing too much coupling into the system:\r\n\r\n```ruby\r\ncampaigns
    = SubscriptionCounter::Campaign.all\r\nseries    = SubscriptionCounter::DataSeries.new(campaigns,
    10)\r\n\r\nSubscriptionCounter::Report::PDF.new(series.report).save_as(\"pr-subscribers.pdf\")\r\n```\r\n\r\nWhile
    this pattern certainly has its benefits, it may feel a bit unexciting to Ruby
    developers. When results objects are introduced simply to reduce coupling between
    two different subsystems in your project or to provide a bit of encapsulation
    for some cached values, they feel like ordinary objects that don't require a special
    name. However, explictly thinking of results objects as an abstraction opens the
    door for more interesting techniques as well.\r\n\r\n### Lazy objects\r\n\r\nOne
    interesting aspect of introducing results objects into a system is that it helps
    facilitate lazy evaluation. Ruby's own `Enumerator` object provides an excellent
    example of how powerful this combination can be. Laziness allows `Enumerator`
    objects to efficiently chain different transformations together. This makes it
    possible to do things like `map.with_index` without having to iterate over the
    collection multiple times or store an intermediate representation of the indexed
    data:\r\n\r\n```ruby\r\n>> [1,2,3,4].map.with_index { |e,i| \"#{i}. #{e}\" }\r\n=>
    [\"0. 1\", \"1. 2\", \"2. 3\", \"3. 4\"]\r\n```\r\n\r\nLazy objects can also represent
    infinite or repeating sequences in a very elegant way. The examples below show
    some bits of functionality baked into `Enumerator` that make modeling these kinds
    of sequences a whole lot easier.\r\n\r\n```ruby\r\n>>  players = [:red, :black].cycle\r\n=>
    #<Enumerator: [:red, :black]:cycle>\r\n>> players.next\r\n=> :red\r\n>> players.next\r\n=>
    :black\r\n>> players.next\r\n=> :red\r\n>> players.next\r\n=> :black\r\n>> odds
    = Enumerator.new { |y| k = 0; loop { y << 2*k + 1; k += 1 } }\r\n=> #<Enumerator:
    #<Enumerator::Generator:0x00000100972b50>:each>\r\n>> odds.next\r\n=> 1\r\n>>
    odds.next\r\n=> 3\r\n>> odds.next\r\n=> 5\r\n>> odds.take(10)\r\n=> [1, 3, 5,
    7, 9, 11, 13, 15, 17, 19]\r\n```\r\n\r\nWhile infinite sequences may seem like
    a very academic topic, they show up in some practical applications as well. For
    example, some video games use procedural generation to produce seemingly infinite
    randomly generated maps. The video below demonstrates that technique being used
    in a very crude manner, but the same general approach could be used to build rich
    three dimensional environments as well, such as the ones found in [MineCraft](http://www.minecraft.net/).
    (_NOTE: I accidentally uploaded this video with ambient sounds rather than muted,
    and won't be able to fix this until I return from vacation after December 15th.
    If you don't like the sound of keyboard motions, heavy breathing, and some weird
    beeping noise: mute your audio before playing this video. Sorry!_)\r\n\r\n<div
    align=\"center\">\r\n<iframe width=\"640\" height=\"480\" src=\"//www.youtube.com/embed/fg-dYZfd6Y4?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n</div>\r\n\r\nTo implement the
    map generation code, I put together a simple `Location` object which is essentially
    an infinite two dimensional doubly linked list. Notice how the class definition
    below makes extensive use of the common `||=` idiom to handle the lazy evaluation
    and caching.\r\n\r\n```ruby\r\nclass Location\r\n  def self.[](x,y)\r\n    @locations
    \       ||= {}\r\n    @locations[[x,y]] ||= new(x,y)\r\n  end \r\n\r\n  def initialize(x,y)\r\n
    \   @x     = x\r\n    @y     = y\r\n    @color = [:green, :green, :blue].sample\r\n
    \ end\r\n\r\n  def ==(other)\r\n    [x,y] == [other.x, other.y]\r\n  end  \r\n\r\n
    \ attr_reader :x, :y, :color\r\n\r\n  def north\r\n    @north ||= Location[@x,@y-1]
    \r\n  end\r\n\r\n  def south\r\n    @south ||= Location[@x,y+1]\r\n  end\r\n\r\n
    \ def east\r\n    @east ||= Location[@x+1, @y] \r\n  end\r\n\r\n  def west\r\n
    \   @west ||= Location[@x-1, @y] \r\n  end\r\n\r\n  def neighbors\r\n    [north,
    south, east, west]\r\n  end\r\nend\r\n```\r\n\r\nWhile this technique works fine
    and is the traditional way to achieve lazy evaluation in Ruby, it feels a bit
    primitive. Ruby does not provide a general purpose construct for lazy evaluation,
    but if it did, it would allow us to write code similar to what you see below:\r\n\r\n```ruby\r\nclass
    Location\r\n  def self.[](x,y)\r\n    @locations        ||= {}\r\n    @locations[[x,y]]
    ||= new(x,y)\r\n  end \r\n\r\n  def initialize(x,y)\r\n    @x     = x\r\n    @y
    \    = y\r\n    @color = [:green, :green, :blue].sample\r\n\r\n    @north = LazyObject.new
    { Location[@x,@y-1] }\r\n    @south = LazyObject.new { Location[@x,y+1] }\r\n
    \   @east  = LazyObject.new { Location[@x+1, @y] }\r\n    @west  = LazyObject.new
    { Location[@x-1, @y] }\r\n  end\r\n\r\n  def ==(other)\r\n    [x,y] == [other.x,
    other.y]\r\n  end  \r\n\r\n  def neighbors\r\n    [north, south, east, west]\r\n
    \ end\r\n\r\n  attr_reader :x, :y, :color, :north, :south, :east, :west\r\nend\r\n```\r\n\r\nSuch
    an object can be implemented as a simple proxy which delays the execution of a
    callback until the results are actually needed. The following code illustrates
    one way to do that:\r\n\r\n```ruby\r\nclass LazyObject < BasicObject\r\n  def
    initialize(&callback)\r\n    @callback = callback\r\n  end\r\n\r\n  def __result__\r\n
    \   @__result__ ||= @callback.call\r\n  end\r\n\r\n  def method_missing(*a, &b)\r\n
    \   __result__.send(*a, &b)\r\n  end\r\nend\r\n```\r\n\r\nAnother option would
    be to use [lazy.rb](http://moonbase.rydia.net/software/lazy.rb/), which provides
    similar functionality via `Lazy::Promise` objects that get instantiated via the
    `Lazy.promise` method:\r\n\r\n```ruby\r\nrequire \"lazy\"\r\n\r\nclass Location\r\n
    \ def self.[](x,y)\r\n    @locations        ||= {}\r\n    @locations[[x,y]] ||=
    new(x,y)\r\n  end \r\n\r\n  def initialize(x,y)\r\n    @x     = x\r\n    @y     =
    y\r\n    @color = [:green, :green, :blue].sample\r\n\r\n    @north = Lazy.promise
    { Location[@x,@y-1] }\r\n    @south = Lazy.promise { Location[@x,y+1] }\r\n    @east
    \ = Lazy.promise { Location[@x+1, @y] }\r\n    @west  = Lazy.promise { Location[@x-1,
    @y] }\r\n  end\r\n\r\n  def ==(other)\r\n    [x,y] == [other.x, other.y]\r\n  end\r\n\r\n
    \ def neighbors\r\n    [north, south, east, west]\r\n  end\r\n\r\n  attr_reader
    :x, :y, :color, :north, :south, :east, :west\r\nend\r\n```\r\n\r\nThis approach
    provides a thread safe solution and prevents us from having to reinvent the wheel.
    The only downside is that _lazy.rb_ is a bit dated and generates some warnings
    on Ruby 1.9 due to the way it implements its core proxy object. But whether you
    use _lazy.rb_ or roll your own lazy object, it is important to understand that
    the difference between this pattern and the common Ruby idiom of delaying execution
    via cached method calls is more than just a matter of aesthetics. To illustrate
    why that is the case, we can can consider the difference in behavior between the
    two approaches when `Location#neighbors` is called.\r\n\r\nIn the original example
    that explictly defines the `north`, `south`, `east`, and `west` methods, the first
    time the `neighbors` method is called, four `Location` objects are created. This
    means that the following line of code will generate all four neighboring `Location`
    objects even if not all of them are needed to answer the question it asks:\r\n\r\n```ruby\r\ngreen_neighbor
    = location.neighbors.find { |loc| loc.color == :green }\r\n```\r\n\r\nBy contrast,
    a `Location` object that uses some form of lazy object would behave differently
    here. Because `Enumerable#find` returns as soon as it finds a single object which
    matches its conditions, the `Location#color` method will not necessarily get called
    on each of the neighboring locations. This means that in the best case scenario,
    only one new `Location` object would end up getting created. While this particular
    example is a bit contrived, it's not hard to see why this is a desireable characteristic
    of lazy objects that cannot be easily emulated via the standard Ruby idiom for
    delayed execution.\r\n\r\n### Future objects\r\n\r\nLazy objects provide certain
    performance benefits in the sense that they make it possible to avoid unnecessary
    computation, but they don't do anything to improve the perceived waiting time
    for any computations that actually need to be run. This is where future objects
    come in handy.\r\n\r\nA future object is essentially an object which immediately
    begins doing some processing in the background but only blocks if the results
    are demanded before the thread has finished executing. The example below demonstrates
    how this sort of object can come in handy for building a simple non-blocking download
    manager:\r\n\r\n```ruby\r\nrequire \"open-uri\"\r\nrequire \"lazy\"\r\n\r\nclass
    DownloadManager\r\n  def initialize\r\n    @downloads = []\r\n  end\r\n\r\n  def
    save(url, filename)\r\n    downloads << Lazy.future { File.binwrite(filename,
    open(url).read) }\r\n  end\r\n\r\n  def finish_all_downloads\r\n    downloads.each
    { |d| Lazy.demand(d) }\r\n  end\r\n\r\n  private\r\n\r\n  attr_reader :downloads\r\nend\r\n\r\ndownloader
    = DownloadManager.new \r\n\r\ndownloader.save(\"http://prawn.majesticseacreature.com/manual.pdf\",
    \"manual.pdf\")\r\nputs \"Starting Prawn manual download\"\r\n\r\ndownloader.save(\"http://sandal.github.com/rbp-book/pdfs/rbp_1-0.pdf\",
    \"rbp_1-0.pdf\")\r\nputs \"Starting download of Ruby Best Practices book\"\r\n\r\nputs
    \"Waiting for downloads to finish...\"\r\ndownloader.finish_all_downloads\r\n```\r\n\r\nIn
    this particular example the callback doesn't return a meaningful value, and so
    the `DownloadManager#finish_all_downloads` method makes use of `Lazy.demand` to
    force each future to wrap up its computations. However, the following example
    demonstrates that the future objects that _lazy.rb_ provides can also be used
    as transparent proxy objects:\r\n\r\n```ruby\r\nrequire \"open-uri\"\r\nrequire
    \"lazy\"\r\n\r\nclass Download\r\n  def initialize(url, filename)\r\n    @filename
    = filename\r\n    @contents = open(url).read\r\n  end\r\n\r\n  def save\r\n    File.binwrite(@filename,
    @contents)\r\n  end\r\nend\r\n\r\nclass DownloadManager\r\n  def initialize\r\n
    \   @downloads = []\r\n  end\r\n\r\n  def save(url, filename)\r\n    downloads
    << Lazy.future { Download.new(url, filename) }\r\n  end\r\n\r\n  def finish_all_downloads\r\n
    \   downloads.each { |d| d.save }\r\n  end\r\n\r\n  private\r\n\r\n  attr_reader
    :downloads\r\nend\r\n\r\ndownloader = DownloadManager.new \r\n\r\ndownloader.save(\"http://prawn.majesticseacreature.com/manual.pdf\",
    \r\n                \"manual.pdf\")\r\nputs \"Starting Prawn manual download\"\r\n\r\ndownloader.save(\"http://sandal.github.com/rbp-book/pdfs/rbp_1-0.pdf\",
    \r\n                \"rbp_1-0.pdf\")\r\nputs \"Starting download of Ruby Best
    Practices book\"\r\n\r\nputs \"Waiting for downloads to finish...\"\r\ndownloader.finish_all_downloads\r\n```\r\n\r\nIn
    both examples, the future object will block as long as necessary to allow the
    computations to complete, but only when it is forced to do so. Until this occurs,
    other operations can continue in parallel and/or block the execution of these
    future objects. This means in the best case scenario, a computation will end up
    being completed before it is actually needed, and the results will be returned
    from the future object's cache at that time.\r\n\r\nWhile implementing a generic
    future object from scratch would not be difficult for anyone who has experience
    working with threads, concurrency is a weak point for me and I rather not confuse
    folks by giving potentially bad advice through a naive implementation of my own.
    Those who are really itching to see how such an object is implemented should look
    at the [lazy.rb source code](https://github.com/mental/lazy/blob/master/lib/lazy.rb#L138-146),
    but if you treat future objects as black boxes you just need to know a few basic
    things about Ruby's thread model to make use of this construct effectively.\r\n\r\nThe
    most important thing to keep in mind is that thread scheduling in standard Ruby
    is affected by a global interpreter lock (GIL) which makes it so that most computations
    end up blocking the execution of other threads. Alternative implementations such
    as JRuby and Rubinius remove this lock, but in standard Ruby this basically means
    that threads are mostly useful for backgrounding operations such as file and network
    I/O. This is because unlike most computations, I/O operations will give other
    threads a chance to run while waiting on their data to become available. Because
    lazy.rb's implementation is thread based, future objects inherit the same set
    of restrictions. The other thing to be aware of is that Ruby does not explicitly
    join all of its threads once the main execution thread completes. This means that
    if I did not explicitly call `downloader.finish_all_downloads` in the previous
    example, the threads spun up by my future objects would be terminated if the main
    thread finished up before the downloads were completed. This may be obvious to
    anyone with a background in concurrency, but I scratched by head for a bit because
    of this issue.\r\n\r\nOther than those issues, future objects pretty much allow
    you to solve some basic concurrency problems without knowing a whole lot about
    how to work with low level concurrency primitives. While the example I've shown
    here is a bit dull, I can imagine this technique might come in handy for things
    like sending emails or doing some time intensive computations that are part of
    an interactive reporting system. Both of these are problems I've had to solve
    before using tools like [Resque](https://github.com/defunkt/resque), but simple
    future objects might prove to be a lightweight \r\nalternative. I'd be curious
    to hear from our readers who have some concurrency experience whether that seems
    like a good idea or not, and also whether you have ideas for other potential applications
    of future objects.\r\n\r\n## Reflections\r\n\r\nThe general concept of wrapping
    data in results objects isn't that exciting, but the notion of lazy objects and
    future objects show that results objects can be imbued with rich behaviors that
    can make our code more flexible and easier to understand. \r\n\r\nWhile Rubyists
    are no strangers to benefits of lazy evaluation, the process of writing this article
    has lead me to believe that we can probably benefit from having some higher level
    constructs to work with. However, explaining my thoughts on that would take a
    whole other article.\r\n\r\nSimilarly, it seems that Ruby provides all the basic
    tooling necessary for concurrency, even when you take into account the limitations
    of standard Ruby due to its GIL. It would be nice if we could establish some good
    patterns and constructs for making this kind of programming more accessible to
    the amateur. Such constructs may end up hiding some of the details that experienced
    developers care about, but would likely lead to more performant code without sacrificing
    maintainability or learnability.\r\n\r\nOn a closing note, the fact that there
    are two interesting subcategories of results objects hints that there may be more
    left to discover. This is similarly true for patterns about arguments. I can feel
    in my gut that there are other patterns out there just waiting to be discovered,
    but cannot think of any off the top of my head at the moment. Have you seen anything
    in the wild that hints at how we can expand on these ideas? If so, please leave
    a comment! \r\n\r\n"
- :slug: qualities-of-great-software
  :title: The qualities of great software
  :summary: See what ISO/IEC 9126 has to say about software quality, and how its metrics
    apply to Ruby code.
  :published: 2012-01-03 00:00:00.000000000 Z
  :issue_number: '3.1'
  :volume: 3
  :body: "I ended the second volume of Practicing Ruby by launching an exploration
    into the uncomfortable question of what it means to write good code. To investigate
    the topic, I began to compile a wiki full of small case studies for each of the
    different properties outlined by [ISO/IEC 9126](http://en.wikipedia.org/wiki/ISO/IEC_9126)
    -- an international standard for evaluating software quality. While I made good
    headway on this project before taking a break for the holidays, I left some of
    it unfinished and promised to kick off this new volume by presenting my completed
    work.\r\n\r\nWhile it is possible to read through the wiki by [starting at the
    overview on the homepage](https://github.com/elm-city-craftworks/code_quality/wiki)
    and then clicking through it page by page, there is a tremendous amount of content
    there on lots of disjoint topics. To help find your way through these materials,
    I've summarized their contents below so that you know what to expect.\r\n\r\n###
    Functionality concerns\r\n\r\nWhile we all know that getting our software to work
    correctly is important, the functional qualities of our software are often not
    emphasized as much as they should be. Issues to consider in this area include:\r\n\r\n*
    The [suitability](https://github.com/elm-city-craftworks/code_quality/wiki/Suitability)
    of our software for serving its intended purpose. As an example, I note the differences
    between the _open-uri_ vs. _net/http_ standard libraries and suggest that while
    they have some overlap in functionality, they are aimed at very different use
    cases.\r\n\r\n* The [accuracy](https://github.com/elm-city-craftworks/code_quality/wiki/Accuracy)
    of our software in meeting its requirements. As an example, I discuss how a small
    bug in Gruff made the entire library unusable for running a particular report,
    even though it otherwise was well suited for the problem.\r\n\r\n* The [interoperability](https://github.com/elm-city-craftworks/code_quality/wiki/Interoperability)
    of our software and how it effects our ability to fit seamlessly into the user's
    environment. As an example, I discuss at a high level the benefits of using the
    Rack webserver interface as compared to writing adapters that directly connect
    web frameworks with web servers.\r\n\r\n* The [security](https://github.com/elm-city-craftworks/code_quality/wiki/Security)
    of our software and how it affects the safety of our users and the systems our
    software runs on. As an example, I discuss a small twitter bot I wrote for demonstration
    purposes that had a operating system command injection vulnerability, and also
    show how I fixed the problem.\r\n\r\n### Reliability concerns\r\n\r\nEven if our
    software does what it is supposed to do, if it does not do so reliably, it will
    not do a good job at making users happy. Issues to consider in this area include:\r\n\r\n*
    The [maturity](https://github.com/elm-city-craftworks/code_quality/wiki/Maturity)
    of our software, i.e. the gradual reduction of unexpected defects over time. As
    an example, I discuss some regression tests we've written for the Practicing Ruby
    web application.\r\n\r\n* The [fault tolerance](https://github.com/elm-city-craftworks/code_quality/wiki/Fault-Tolerance)
    of our software, i.e. how easy it is for us to mitigate the impact of failures
    in our code. As an example, I discuss at a high level about how ActiveRecord implements
    error handling around failed validations, and show a pure Ruby approximation for
    how to build something similar.\r\n\r\n* The [recoverability](https://github.com/elm-city-craftworks/code_quality/wiki/Recoverability)
    of our software when dealing with certain kinds of failures. As an example, I
    discuss various features that resque-retry provide for trying to recover from
    background job failures.\r\n\r\n### Usability concerns\r\n\r\nOnce we have code
    that does it's job correctly and does it well, we still need to think about how
    pleasant of an experience we create for our users. Issue to consider in this area
    include: \r\n\r\n* The [understandability](https://github.com/elm-city-craftworks/code_quality/wiki/Understandability)
    of our software, in particular how well its functionality is organized and how
    well documented it is. As an example, I extract some guidelines for writing a
    good README file using Sinatra's README as a reference.\r\n\r\n* The [learnability](https://github.com/elm-city-craftworks/code_quality/wiki/Learnability)
    of our software, i.e. how easy it is to discover new ways of using the software
    based on what the user already knows. As an example, I discuss a change we made
    to the Prawn graphics API to make things more consistent and easier to learn.\r\n\r\n*
    The [operability](https://github.com/elm-city-craftworks/code_quality/wiki/Operability)
    of our software, particularly whether we give our users the control and flexibility
    they need to get their job done. As an example, I discuss how most Markdown processors
    in Ruby function as black boxes, and how RedCarpet 2 takes a different approach
    that makes it much easier to customize.\r\n\r\n* The [attractiveness](https://github.com/elm-city-craftworks/code_quality/wiki/Attractiveness)
    of our software. As an example, I show the difference between low level and high
    level interfaces for interacting with the Cairo graphics library, and illustrate
    how the use of syntactic sugar can influence user behavior.\r\n\r\n### Efficiency
    concerns\r\n\r\nRuby has had a reputation for being a slow, resource intensive
    programming language. As a result, we need to rely on some special tricks to make
    sure that our code is fast enough to meet the needs of our users. Issues to consider
    in this area include:\r\n\r\n* The [performance](https://github.com/elm-city-craftworks/code_quality/wiki/Performance)
    of our software. As an example, I talk at a very high level about the computationally
    expensive nature of PNG alpha channel splitting, and how C extensions can be used
    to solve that problem.\r\n\r\n* The [resource utilization](https://github.com/elm-city-craftworks/code_quality/wiki/Resource-Utilization)
    characteristics of our software. While this most frequently means memory and disk
    space usage, there are lots of different resources our programs use. As an example,
    I talk about the fairly elegant use of file locking in the PStore standard library.\r\n\r\n###
    Maintainability concerns\r\n\r\nNo matter how good our software is, it will ultimately
    be judged by how well it can change and grow over time. This is the area we tend
    to spend most of our time studying, because difficult to maintain projects make
    us miserable as programmers. Issues to consider in this area include:\r\n\r\n*
    The [analyzability](https://github.com/elm-city-craftworks/code_quality/wiki/Analyzability)
    of our software, i.e. how easy it is for us to reason about our code. As an example,
    I discuss at a high level how the Flog utility assigns scores to methods based
    on their complexity, and how that can be used to identify areas of your code that
    need refactoring.\r\n\r\n* The [changeability](https://github.com/elm-city-craftworks/code_quality/wiki/Changeability)
    of our software, which is commonly considered the holy grail of software design.
    As an example, I point out connascence as a mental model for reasoning about the
    relationships between software components and how easy or hard they are to change.\r\n\r\n*
    The [stability](https://github.com/elm-city-craftworks/code_quality/wiki/Stability)
    of our software, in particular how much impact changes have on users. As an example,
    I talk about the merits of designing unobtrusive APIs for reducing the amount
    of moving parts in our code.\r\n\r\n* The [testability](https://github.com/elm-city-craftworks/code_quality/wiki/Testability)
    of our software. As an example, I discuss how useful the SOLID principles are
    in making our code easier to test.\r\n\r\n### Portability concerns\r\n\r\nOne
    thing we don't think about often in Ruby, perhaps not often enough, is how easy
    it is for folks to get our software up and running in environments other than
    our own. While writing code in a high level language does get us away from some
    of the problems that system programmers need to consider, there are still platform
    and environment issues that deserve our attention. Issues to consider in this
    area include:\r\n\r\n* The [adaptability](https://github.com/elm-city-craftworks/code_quality/wiki/Adaptability)
    of our software to the user's environment. As an example, I discuss at a high
    level the approach HighLine takes to shield the user from having to write low
    level console interaction code.\r\n\r\n* The [installability](https://github.com/elm-city-craftworks/code_quality/wiki/Installability)
    of our software. As an example, I discuss some general thoughts about the state
    of installing Ruby software, and look into an interesting approach to setting
    up a Rails application in Jordan Byron's Mission of Mercy clinic management project.\r\n\r\n*
    The [co-existence](https://github.com/elm-city-craftworks/code_quality/wiki/Co-existence)
    of our software with other software in the user's environment. As an example,
    I discuss how conflicting monkey patches led me on a wild goose chase in one of
    my Rails applications.\r\n\r\n* The [replaceability](https://github.com/elm-city-craftworks/code_quality/wiki/Replaceability)
    of our software as well as the ability for our software to act as a drop in replacement
    for other tools. Because I feel this concept is one baked into the UNIX and open
    source culture, I don't provide a specific case study but instead point out several
    applications of this idea in the wild.\r\n\r\n### Reflections\r\n\r\nSpending
    several weeks studying this topic just so I can *start* a discussion with our
    readers has been a painful, but enlightening experience for me. As you can see
    from the giant laundry list of concerns listed above, the concept of software
    quality is much deeper than something like [The Four Simple Rules of Design](http://www.c2.com/cgi/wiki?XpSimplicityRules)
    might imply. \r\n\r\nIt is no surprise that we yearn for something more simple
    than what I've outlined here, but I cannot in good conscience remove any of the
    focus areas outlined by ISO/IEC 9126 as being unimportant when it comes to software
    quality. While we cannot expect that all of our software will be shining examples
    of all of these properties all of the time, we do have a responsibility for knowing
    how to spot the tensions between these various concerns and we must do our best
    to resolve them in a smart way.\r\n\r\nWhile our intuition and experience may
    allow us to address most of the issues I've outlined here at a subconscious level,
    I feel that more work needs to be done for us to seriously consider ourselves
    good engineers. The real challenge for me personally is to figure out how to continue
    to study these topics without stifling my creativity, willingness to experiment,
    and ability to make decisions without becoming overwhelmed.\r\n\r\nI look forward
    to hearing your own thoughts on this topic, because it is one that we probably
    need to work through together if we want to make any real progress."
- :slug: patterns-for-building-excellent-examples
  :title: Patterns for building excellent examples
  :summary: Learn how to write code samples that clearly communicate ideas to other
    programmers.
  :published: 2012-01-10 00:00:00.000000000 Z
  :issue_number: '3.2'
  :volume: 3
  :body: "Good code examples are the secret sauce that makes Practicing Ruby a high-quality
    learning resource. That said, the art of building excellent examples is one that
    I think all programmers should practice, not just those folks out there trying
    to teach for a living. The ability to express ideas clearly through well-focused
    snippets of code is key to writing good tests, documentation, bug reports, code
    reviews, demonstrations, and a whole lot of other stuff, too.\r\n\r\nIn this article,
    I've identified five patterns I use for expressing ideas through code examples.
    These techniques run the gamut from building contrived \"Hello World\" programs
    to crafting full-scale sample applications using a literate programming style.
    Each technique has its own strengths and weaknesses, and I've done what I could
    to outline them where possible.\r\n\r\nAlthough this isn't necessarily a comprehensive
    list, it can help you start to improve the way you write your examples and also
    serves as a good jumping-off point for further discussion on the topic.\r\n\r\n###
    Contrived examples\r\n\r\nFor any given programming language or software library,
    the odds are pretty good that the first example you'll run is a contrived \"Hello
    World\" program. The following example is taken from the Sinatra web framework
    but is similar in spirit to pretty much every other \"Hello World\" application
    out there:\r\n\r\n```ruby\r\nrequire 'sinatra'\r\n\r\nget '/hi' do\r\n  \"Hello
    World!\"\r\nend\r\n```\r\n\r\nThis kind of example seems quite useless on the
    surface and is neither interesting nor educational. As it turns out, these characteristics
    are precisely what make this \"Hello World\" program perfect! The contrived nature
    of the example allows it to serve as a simple sanity check for someone who is
    trying out Sinatra for the first time.\r\n\r\nIf you try to run this example and
    find that it doesn't work correctly, there are only a few possible points of failure.
    In most cases, not even getting a \"Hello World\" program to run correctly can
    be blamed on one of three things: out-of-date documentation, issues with your
    environment, or user error. The fact that there are very few moving parts makes
    it much easier for you to determine the source of your problem than it would be
    if the example were significantly more complex. This ease of debugging is precisely
    why most introductory tutorials start off with a \"Hello World\" program rather
    than something more exciting.\r\n\r\nAlthough the most common use case for contrived
    examples is to construct \"Hello World\" applications, there are other use cases
    for this technique as well. In particular, contrived examples are a good fit for
    discussions about syntactic or structural differences between two pieces of code.
    As an example, consider a short tutorial that explains why a user might want to
    use Ruby's `attr_reader` functionality. It could start by showing a `Person` class
    that implements accessors explicitly:\r\n\r\n```ruby\r\nclass Person\r\n  def
    initialize(name, email)\r\n    @name  = name\r\n    @email = email\r\n  end\r\n\r\n
    \ def name\r\n    @name\r\n  end\r\n\r\n  def email \r\n    @email\r\n  end\r\nend\r\n```\r\n\r\nA
    followup example could then be provided to show how to simplify the code via `attr_reader`:\r\n\r\n```ruby\r\nclass
    Person\r\n  def initialize(name, email)\r\n    @name  = name\r\n    @email = email\r\n
    \ end\r\n\r\n  attr_reader :name, :email\r\nend\r\n```\r\n\r\nThis scenario is
    very simplistic when compared to the class definitions we write in real projects,
    but the absence of complicated functionality makes it easier for the reader to
    focus on the syntactic differences between the two examples. It also allows the
    novice Ruby programmer to think of the difference between explicitly defining
    accessors and using `attr_reader` as a simple structural transformation rather
    than something with complex semantic differences. Although this mental model is
    not 100 percent accurate, it emphasizes the big picture, which is what actually
    matters for a novice programmer. The simplicity of these examples makes the general
    pattern much easier to remember, which justifies hiding a few things behind the
    curtain to be revealed later.\r\n\r\nUnfortunately, the ability of contrived examples
    to hide the semantics of our programming constructs is just as often a drawback
    as it is an asset. The more complex a concept is, the more dangerous it is to
    present simplistic examples rather than working through more realistic scenarios.
    For example, it is common for object-oriented programming tutorials to use real-world
    objects and hierarchies to explain how class inheritance works, but the disconnect
    between these models and the kinds that real software projects implement is so
    great that this approach completely obfuscates the real power and purpose of object-oriented
    programming. By choosing a scenario that may feel natural to the reader but does
    not fit naturally with the underlying programming constructs, this sort of tutorial
    fails to emphasize the right details and leaves the door open for a wide range
    of misconceptions. These incorrect assumptions end up getting in the way of learning
    real object-oriented programming techniques rather than helping develop an understanding
    of them.\r\n\r\nI could easily rant on this topic, but someone else did it for
    me by writing a great mailing list post entitled [Goodbye, shitty Car extends
    Vehicle object-orientation tutorial](http://lists.canonical.org/pipermail/kragen-tol/2011-August/000937.html).
    Despite the somewhat inflammatory title, it is a very insightful post, and I strongly
    recommend reading it if you want to see a strong argument for the limitations
    of contrived examples as teaching tools.\r\n\r\nFiguring out where to draw the
    line between when it is appropriate to use a contrived example and when to use
    one that is based on a practical application is tricky. In general, I try to keep
    in mind that the purpose of a contrived example is specifically to remove context
    from the picture. Outside of \"Hello World\" programs and simple syntactic transformations,
    a lack of context hurts more than it helps, and so I try to avoid contrived examples
    as much as I can for pretty much every other use case. \r\n\r\n### Cheap counterfeits\r\n\r\nOne
    of my favorite techniques for teaching programming concepts is to construct cheap
    counterfeits that emulate the surface-level behavior of a more complicated structure.
    These \"poor man's implementations\" are similar to contrived examples in that
    they can hide as much complexity as they'd like from the reader but, because they
    are grounded by some realistic scenario, do not suffer from being totally disconnected
    from practical applications.\r\n\r\nI have used this technique extensively throughout
    Practicing Ruby and my other written works, and it almost always works out well.
    In fact, the issue on [Implementing Enumerable and Enumerator in Ruby](http://practicingruby.com/articles/4)
    was entirely based on this strategy and turned out to be one of the most popular
    articles I've written for this journal. Although you are probably already very
    familiar with this pattern as a Practicing Ruby reader, I can still provide a
    bit of extra insight by decomposing it for you.\r\n\r\nThe purpose of building
    a cheap counterfeit is not to gain a deep understanding of how a certain construct
    actually works. Instead, the purpose of a counterfeit is to teach people how to
    steal ideas from other interesting bits of code for their own needs. For example,
    take the previous `attr_reader` example:\r\n\r\n```ruby\r\nclass Person\r\n  def
    initialize(name, email)\r\n    @name  = name\r\n    @email = email\r\n  end\r\n\r\n
    \ attr_reader :name, :email\r\nend\r\n```\r\n\r\nThis is a great feature, because
    it replaces tedious boilerplate methods with a concise declarative statement.
    But without some sort of explanation as to how it works, `attr_reader` feels pretty
    magical and might be perceived as a special case that the Ruby internals are responsible
    for handling. This misconception can easily be cleared up by showing how to implement
    a cheap counterfeit version of `attr_reader` in application code:\r\n\r\n```ruby\r\nclass
    Module\r\n  def my_attr_reader(*args)\r\n    args.each do |a|\r\n      define_method(a)
    { instance_variable_get(\"@#{a}\") }\r\n    end\r\n  end\r\nend\r\n\r\nclass Person\r\n
    \ def initialize(name, email)\r\n    @name  = name\r\n    @email = email\r\n  end\r\n\r\n
    \ my_attr_reader :name, :email\r\nend\r\n```\r\n\r\nIf teaching programmers how
    to use `attr_reader` is like treating them to a nice fish dinner, teaching them
    how to implement it is like giving them a fishing pole and showing them how to
    catch their own meals. Seeing a practical use of `define_method` opens the doors
    for a huge range of other applications, all of which hinge on the simple concept
    of dynamic method definition. For example, a similar technique could be used to
    convert hideous method names like `test_a_user_must_be_able_to_log_in` into the
    elegant syntax shown here:\r\n\r\n```ruby\r\ntest \"A user must be able to log
    in\" do\r\n  # your test code here\r\nend\r\n```\r\n\r\nThere are countless other
    applications of dynamic method definition, many of which I expect Practicing Ruby
    readers are already familiar with. The point here is that a single example that
    demystifies a certain technique can make a huge difference in what possibilities
    someone sees in a given system. This payoff is what makes cheap counterfeits such
    a tremendously good teaching tool.\r\n\r\nAn important thing to keep in mind,
    however, is that this technique is useful mostly for teaching concepts, as opposed
    to showing someone how a feature is really implemented. If you actually look into
    the implementation of `attr_reader`, you'll find a number of edge cases that this
    cheap counterfeit example does not take into consideration. Although these subtleties
    are not especially relevant if you're just trying to give a contextualized example
    of how `define_method` can be used, they would be important to point out if you
    were trying to write a specification for how `attr_reader` is meant to work, which
    is why cheap counterfeits are not a substitute for case studies of real code but
    instead serve a different purpose entirely.\r\n\r\n### Simplified examples\r\n\r\nDigging
    directly into the source code of a project is the most direct way to understand
    how its features are implemented, but it can be a somewhat disorienting process.
    Production code in all but the most trivial projects tends to accumulate edge
    cases, error-checking code, and other bits of cruft that make it harder to see
    what the core ideas are. When giving a talk about how something is implemented
    or writing documentation for potential contributors, it is sometimes helpful to
    provide simplified examples that demonstrate the key functionality while minimizing
    distractions.\r\n\r\nSuppose I want to do a lightning talk about how [MiniTest](https://github.com/seattlerb/minitest)
    is implemented, with the goal of attracting new contributors to the project. In
    a talk like that, I'd definitely need to discuss a bit about how assertions work.
    A logical place to start might be the `Assertions#assert` method:\r\n\r\n```ruby\r\ndef
    assert test, msg = nil\r\n  msg ||= \"Failed assertion, no message given.\"\r\n
    \ self._assertions += 1\r\n  unless test then\r\n    msg = msg.call if Proc ===
    msg\r\n    raise MiniTest::Assertion, msg\r\n  end\r\n  true\r\nend\r\n```\r\n\r\nThe
    implementation of `assert` is simple enough that I could probably show it as-is
    without losing my audience. But if I keep in mind that this code is going to be
    shown on a slide for just a few seconds, I might show the following simplified
    example instead:\r\n\r\n```ruby\r\ndef assert(test, msg=nil)\r\n  msg ||= \"Failed
    assertion, no message given.\"\r\n\r\n  raise(MiniTest::Assertion, msg) unless
    test\r\n  true\r\nend\r\n```\r\n\r\nThis code omits some implementation details,
    but it preserves the main idea, which is that MiniTest's assertions work by raising
    an exception when a test fails. The fact that `assert` is where the number of
    assertions is counted is fairly obvious and only adds noise when you want to get
    a rough idea for how the code works at a glance. Likewise, the fact that a message
    can be passed in as a `Proc` object rather than a string is an interesting but
    obscure edge case that does not need to be emphasized. By removing these two statements
    from the method definition, the core behavior is easier to notice.\r\n\r\nThe
    process of creating a simplified example starts with looking at the original source
    code and then determining which details are essential to expressing the idea you
    want to express and which details can be considered background noise. The next
    step is to construct an example that serves as a functional subset of the original
    implementation when used within a certain context. You don't want to deviate too
    much from the original idea, but you can clean up the syntax a bit where appropriate
    to make the example easier to understand. From there, you can treat the example
    as a substitute for the real implementation for the purposes of demonstration;
    you just need to make sure to point out that you have simplified things a bit.\r\n\r\nWith
    this MiniTest example, the simplified version of the code is only slightly less
    complicated than the original, so the benefits of using this technique are a bit
    subdued. In practice, you're much more likely to run into situations in which
    there are dozens of lines of implementation code but only a handful of them are
    central to the idea that you are trying to express. In those situations, this
    pattern is especially effective at cutting through the cruft to get at the real
    meat of the problem you want to focus on. However, it's worth keeping in mind
    that even relatively small and easy-to-understand chunks of code can be simplified
    if they happen to include statements that are not directly relevant to the point
    you are trying to make.\r\n\r\n### Reduced examples\r\n\r\nA reduced example is
    one that reproduces a certain behavior in the most simple possible way. This technique
    is most commonly used for putting together bug reports and is one of the most
    important skills you can have as a software developer.\r\n\r\nIn the [Ruby Best
    Practices](http://rubybestpractices.com/) book, I told a story about a bug that
    was spotted in Prawn and how we reduced the original report to something much
    more simple in order to discover the root cause of the problem. Because this is
    still the best example I've found of this process in action, I'll summarize that
    story here rather than telling a new one.\r\n\r\nA developer sent us the following
    bug report to demonstrate that our code for generating fixed-width columns of
    text had a problem that was causing page breaks to be inserted unnecessarily:\r\n\r\n```ruby\r\nPrawn::Document.generate(\"span.pdf\")
    do\r\n  span(350, :position => :center) do \r\n    text \"Here's some centered
    text in a 350 point column. \" * 100\r\n  end\r\n  \r\n  text \"Here's my sentence.\"\r\n\r\n
    \ bounding_box([50,300], :width => 400) do \r\n    text \"Here's some default
    bounding box text. \" * 10 \r\n\r\n    pos = bounds.absolute_left - margin_box.absolute_left\r\n
    \   span(bounds.width, :position => pos) do\r\n      text \"The rain in Spain
    falls mainly on the plains. \" * 300 \r\n    end\r\n  end\r\n\r\n  text \"Here's
    my second sentence.\"\r\nend\r\n```\r\n\r\nIn this example, he expected all of
    his text to be rendered on one page and was trying to show that each time he used
    the `span` construct, an unnecessary page break was created. He showed that this
    was the case both within the default page boundaries and within a manually specified
    bounding box. As far as user reports go, this example was pretty good, because
    it was specifically designed to show the problem he was having and was clearly
    not just some broken production code that he wanted help with.\r\n\r\nThat having
    been said, an understanding of how Prawn works under the hood made it possible
    to simplify this example quite a bit, even before investigating further. Because
    the default page boundaries in Prawn are implemented in terms of bounding boxes
    and the `bounding_box` method just temporarily swaps those dimensions with new
    ones, the second part of this report was superfluous. Removing it got the reproducible
    sample down to the example shown here:\r\n\r\n```ruby\r\nPrawn::Document.generate(\"span.pdf\")
    do\r\n  span(350) do \r\n    text \"Here's some text in a 350pt wide column. \"
    * 20\r\n  end\r\n\r\n  text \"This text should appear on the same page as the
    spanning text\"\r\nend\r\n```\r\n\r\nIn making this reduction, I also did some
    other minor cleanup chores such as reworking the text to be self-documenting and
    removing the `:position => :center` option for `span`, because it didn't affect
    the outcome. At this point, even someone without experience in how Prawn works
    would be able to more easily spot the problem in the example.\r\n\r\nAlthough
    `span` is not a trivial construct, it had only two possible points of failure:
    the `bounding_box` method and the `canvas` method. Because `bounding_box` is fundamental
    to pretty much everything Prawn does and we had plenty of evidence that it was
    working as expected, we turned our attention to `canvas`.\r\n\r\nThe purpose of
    `canvas` is  to execute the contents of a block while ignoring all document margins
    and bounding boxes in place, essentially converting everything to absolute coordinates
    on the page. After the block is executed, it is supposed to keep the text pointer
    wherever it left off, which means that it should not trigger a pagebreak unless
    the text flows beyond the bottom of the page. To test this behavior, we coded
    up the following example:\r\n\r\n```ruby\r\nPrawn::Document.generate(\"canvas_sets_y_to_0.pdf\")
    do \r\n  canvas { text \"Some text at the absolute top left of the page\" }\r\n
    \ text \"This text should not be after a pagebreak\" \r\nend\r\n```\r\n\r\nAfter
    running this example, we noticed that it exhibited the same defect that we saw
    in the user's bug report. Because this method is almost as deep down the Prawn
    call chain as you can go, it became clear that at this point we had our reduced
    example. The benefit of drilling down like this became apparent when we converted
    our sample code into a regression test:\r\n\r\n```ruby\r\nclass CanvasTest < Test::Unit::TestCase\r\n
    \ def setup \r\n    @pdf = Prawn::Document.new\r\n  end\r\n\r\n  def test_canvas_should_not_reset_y_to_zero
    \r\n    after_text_position = nil\r\n\r\n    @pdf.canvas do \r\n      @pdf.text
    \"Hello World\" \r\n      after_text_position = @pdf.y\r\n    end\r\n\r\n    assert_equal
    after_text_position, @pdf.y \r\n  end\r\nend\r\n```\r\n\r\nAfter seeing this test
    fail and applying a quick patch that got it to go green, we went back and ran
    the original bug report the user provided us with. As predicted, the bad behavior
    went away and things were once again working as expected.\r\n\r\nThe benefits
    of reducing the example before writing a regression test were tremendous. Not
    only was the test easier to write, but it also ended up capturing the problem
    at a much lower level than it would have if we immediately set in with codifying
    the bug report as a unit test. In addition to these benefits, the reduction process
    itself greatly simplified the debugging process, as it allowed us to proceed methodically
    to find the root of the problem.\r\n\r\nI've mostly used this reduction technique
    while debugging, but it can also be a useful way to find your way around a complex
    codebase. By starting with a practical example that exercises the system from
    the outermost layer, you can drill down into the code and trace your way through
    the call chains to find how some particular aspect of the software works. Although
    this is a less direct approach than just reading the documentation, it will give
    you a better fundamental understanding of how the system hangs together, and it's
    a fun way to practice code reading.\r\n\r\nWhether you are exploring a new codebase
    or tracking down a bug, the reduction process limits the scope of the things you
    need to think about, allowing you to dedicate your attention in a more focused
    way. This effect is somewhat similar to what we find when we make use of simplified
    examples but is more of a drilling down process than it is a pruning process.
    Both have their merits, and they can even be used in combination at times.\r\n\r\n###
    Sample applications \r\n\r\nAlthough all of the techniques I've discussed so far
    can be quite useful for studying, investigating, and teaching about specific issues,
    none of them are particularly suitable for demonstrating big-picture topics. When
    you want to emphasize how things come together, as opposed to how each individual
    part works, nothing beats the combination of a sample application with a good
    walkthrough tutorial. Several issues from Practicing Ruby Volume 2 made use of
    this format and were very well received by the readers here.\r\n\r\nIn [Learning
    new things step-by-step](http://practicingruby.com/articles/6), I built a small
    game for the purpose of demonstrating how to develop software in tiny bite-sized
    chunks. The nice thing about this approach is that it allows the reader to follow
    along at home (either mentally or by literally running the code themselves), while
    proceeding at their own pace. I hope it also encourages folks to experiment and
    draw their own conclusions rather than just rigidly following a predefined script.\r\n\r\nIn
    [Building Unix-style command line applications](http://practicingruby.com/articles/9),
    I tackled the creation of a Ruby clone of the Unix `cat` utility by focusing on
    distinct areas of functionality, one at a time. This is a slightly less linear
    format than the step-by-step approach of the game development article, but it
    allows readers to look at the complete application from several different angles,
    depending on the topics that interested them most.\r\n\r\nFinally, in [Designing
    business reporting applications](http://practicingruby.com/articles/13), I totally
    break away from linearity by presenting the source code of a full application
    in literate programming style. This approach allows readers to study the real
    implementation code and my commentary side by side and to bounce around as they
    see fit. This lack of explicit structure encourages readers to explore in a free-form
    fashion rather than focusing on some predefined areas of interests.\r\n\r\nAlthough
    these articles were some of the most successful ones that I've published here
    at Practicing Ruby, they were also among the most challenging to write. I had
    to apply a much higher standard of writing clear and concise code than I would
    if I were simply trying to make a project easy enough for me to maintain on my
    own. The prose was tricky to organize, because it's hard to decide which areas
    to emphasize and which to gloss over in a complete application. For these reasons,
    sample applications can be a cumbersome and time-consuming learning resource to
    produce. However, the investment seems to be well worth it in the end.\r\n\r\n###
    Reflections\r\n\r\nWriting good examples can be seriously hard work. This is why
    all too often we see people overusing contrived examples or simply attempting
    to pass off unrefined snippets of production code as learning materials. However,
    code examples in all of their myriad forms lay the foundation for how we communicate
    our ideas as software developers.\r\n\r\nAn important thing to remember when writing
    code examples is that the process is in many ways similar to writing prose. If
    we simply spit out a brain dump without thinking about how it will be interpreted
    and understood by others, we will end up with crappy results. But if we remember
    that the main goal of writing our examples is to communicate an idea to our fellow
    programmers, we naturally begin to ask the questions that lead us to improve our
    work.\r\n\r\nI hope that by sharing these few patterns with you, I've given you
    some useful ideas for how to improve your code communication skills. Following
    the patterns I've outlined here will lead you to writing better examples for your
    documentation, bug reports, unit tests, tutorials, and quite a few other things
    as well. \r\n\r\nThough the techniques I've shown here are ones that work well
    in a wide range of contexts, I am sure there are other approaches worth learning
    about. If you've seen a novel use of code examples in the wild, please let me
    know! I'd also be happy to hear any other thoughts you have on this topic, and
    I wouldn't mind helping a few folks come up with good examples for the projects
    they're working on. If you've got something you want me to take a look at, just
    leave a comment and I'll be sure to get back to you.\r\n"
- :slug: exploring-a-turing-tarpit
  :title: Exploring the depths of a Turing tarpit
  :summary: Read the code for a simple Brainf*ck interpreter and think about how it
    might be improved.
  :published: 2012-01-17 00:00:00.000000000 Z
  :issue_number: '3.3'
  :volume: 3
  :body: "> NOTE: This article describes an interactive challenge that was done in\r\n>
    realtime at the time it was published. You can still make use of it\r\n> by starting
    from the initial version of the code, but if you'd\r\n> rather skip to the end
    results, be sure to read [Issue 3.4](https://practicingruby.com/articles/spiral-staircase-of-refactoring).\r\n\r\nA
    programming language that is endlessly flexible but difficult to use because\r\nof
    its lack of support for common operations is known as a [Turing\r\ntarpit](http://en.wikipedia.org/wiki/Turing_tarpit).
    While a range of esoteric\r\nprogramming languages fall under this category, the
    [Brainfuck\r\nlanguage](http://en.wikipedia.org/wiki/Brainfuck) is one that stands
    out for its\r\nextreme minimalism.\r\n\r\nBrainfuck manages to be Turing complete
    in only 8 operations, which means that\r\ndespite being functionally equivalent
    to Ruby in a theoretical sense, it offers\r\nvirtually none of the conveniences
    that a modern programmer has come to expect.\r\nYou don't need to go any farther
    than its \"Hello World\" program to see that it\r\nisn't a language that any sane
    person would want to work in:\r\n\r\n```ruby\r\n++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.\r\n<<+++++++++++++++.>.+++.------.--------.>+.>.\r\n```\r\n\r\nHowever,
    the simplicity of the language is not without at least some merit. A\r\nconsequence
    of having a somewhat trivial to parse syntax and very basic\r\nsemantics is that
    while Brainfuck may be one of the hardest languages to *use*,\r\nit simultaneously
    happens to be one of the easiest languages to *implement*.\r\nWhile it's not quite
    as easy a task as working on a code kata, it takes roughly\r\nthe same order of
    magnitude of effort to produce a fully functioning Brainfuck\r\ninterpreter. The
    key difference is that you end up with some software that is\r\nmuch deeper than
    your average bowling score calculator after you've completed\r\nthe exercise.\r\n\r\nA
    functioning Brainfuck interpreter is complex enough where you can begin to ask\r\nserious
    questions about code quality and overall design. It is also something\r\nthat
    you can build new functionality on top of in a ton of interesting ways. So\r\nin
    this exercise, the real payoff comes after you've run your first \"Hello\r\nWorld\"
    example and have a working interpreter to play with. The downside is that\r\nit
    might take you a day or two of work to get to that point, and after all that\r\neffort,
    you might need to think about doing something that's just a bit more\r\nmeaningful
    with your life. But like most things that involve this sort of\r\ndrudgery, being
    a Practicing Ruby subscriber can help you skip the boring stuff\r\nand get right
    to the juicy parts.\r\n\r\nRather than a typical article, this issue is instead
    an interactive challenge\r\nfor our readers to try at home. I've posted a [simple
    and functional Brainfuck\r\ninterpreter](https://github.com/elm-city-craftworks/turing_tarpit/tree/starting_point)
    on GitHub,\r\nand I'm inviting all of you to look for ways of improving it. The
    code itself is\r\ngood in places and not so good in others, and I've intentionally
    left in some\r\nthings that can be improved. Your challenge, if you choose to
    accept it, is as\r\nfollows:\r\n\r\n* If you spot things in the code that can
    be improved, let me know!\r\n* If you spot a bug, file a bug report via github
    issues and optionally send a pull request that includes a failing test.\r\n* If
    you have time to make a refactoring or improvement yourself, fork the project
    and submit pull requests\r\n* If you want to add documentation patches, those
    are welcome too!\r\n* Feel free to work on this with friends and colleagues, even
    if they aren't Practicing Ruby subscribers.\r\n\r\nIn [Issue 3.4](https://practicingruby.com/articles/spiral-staircase-of-refactoring),
    I will\r\ngo over the improvements we made to this project as a group, and discuss
    why\r\nthey're worthwhile. Because I know there are several things that need\r\nimprovement
    in this code that are pretty general in nature, I'm reasonably sure\r\nthat article
    will be a generally interesting discussion on software design and\r\nRuby idioms,
    as opposed to a collection of esoterica. But since I don't know\r\nwhat to expect
    from your contributions, the exact contents will be a surprise\r\neven to me."
- :slug: spiral-staircase-of-refactoring
  :title: Building a better Turing tarpit
  :summary: In this issue, we improve the design of the Brainf*ck interpreter that
    was introduced in Issue 3.3
  :published: 2012-01-25 00:00:00.000000000 Z
  :issue_number: '3.4'
  :volume: 3
  :body: "In [Issue 3.3](http://practicingruby.com/articles/shared/bwgflabwncjv),
    I presented a proof-of-concept Ruby implementation of the [Brainfuck programming
    language](http://en.wikipedia.org/wiki/Brainfuck) and challenged Practicing Ruby
    readers to improve upon it. After receiving several patches that helped move things
    along, I sat down once again to clean up the code even further. What I came to
    realize as I worked on my revisions is that the refactoring process is very similar
    to climbing a spiral staircase. Each structural change to the code simultaneously
    left the project back where it started along one vector while moving it forward
    along another.\r\n\r\nBecause we often look at the merits of a given refactoring
    technique within the context of a single transition from worse code to better
    code, it's easy to mistakenly assume that the refactoring process is much more
    linear than it actually is. In this article, I've tried to capture a much wider
    angle view of how refactoring really works in the wild. The end result is a story
    which I hope will spark some good discussions about how we can improve our code
    quality over time.\r\n\r\n### Prologue. Everything has to start somewhere\r\n\r\nI
    decided to name my interpreter [Turing Tarpit](http://en.wikipedia.org/wiki/Turing_tarpit),
    because that term is perfectly apt for describing languages like Brainfuck. In
    a nutshell, the term refers to any language which is infinitely flexible, yet
    nearly impossible to use for anything practical. It turns out that building this
    sort of mind trap for programmers is quite easy to do.\r\n\r\nMy first iteration
    was easy enough to build, and consisted of three objects: a `Tape`, an `Interpreter`,
    and a `Scanner`. The rough breakdown of responsibilities was something like this:\r\n\r\n*
    The [Tape object](https://github.com/elm-city-craftworks/turing_tarpit/blob/starting_point/lib/turing_tarpit.rb#L103-149)
    implemented something similar to the storage mechanism in a [Turing machine](http://en.wikipedia.org/wiki/Turing_machine#Informal_description).
    It provided mechanisms for accessing and modifying numeric values in cells, as
    well as a way to increment and decrement the pointer that determined which cell
    to operate on.\r\n\r\n* The [Interpreter object](https://github.com/elm-city-craftworks/turing_tarpit/blob/starting_point/lib/turing_tarpit.rb#L7-34)
    served as a mapping between Brainfuck's symbolic operators and the operations
    provided by the `Tape` object. It also implemented the I/O functionality required
    by Brainfuck.\r\n\r\n* The [Scanner object](https://github.com/elm-city-craftworks/turing_tarpit/blob/starting_point/lib/turing_tarpit.rb#L36-69)
    was responsible for taking a Brainfuck source file as input and transforming it
    into a stream of operations that could be handled by the `Interpreter` object.
    For the most part this simply meant reading the source file one character at a
    time, but this object also needed to account for Brainfuck's forward and backward
    jump operations.\r\n\r\nWhile my initial implementation was reasonably clean for
    a proof-of-concept, it definitely had room for improvement. I decided to ask for
    feedback early in the hopes that folks would find and fix the things I knew were
    problematic while simultaneously checking my blindspots for issues that I hadn't
    noticed myself.\r\n\r\n### Act I. Getting a fresh perspective on the problem\r\n\r\nSome
    of the issues brought up by contributors were fairly obvious housekeeping chores,
    but nonetheless made the project nicer to work with:\r\n\r\n* Steve Klabnik [requested
    a way to run the whole test suite at once](https://github.com/elm-city-craftworks/turing_tarpit/pull/3)
    instead of file by file. He had provided a patch with a Rakefile, but since the
    project didn't have any immediate need for other rake tasks, we ended up deciding
    that a simple _test/suite.rb_ file would be sufficient. Notes were added to the
    README on how to run the tests.\r\n\r\n* Renato Riccieri [broke the classes out
    into individual files](https://github.com/elm-city-craftworks/turing_tarpit/pull/6).
    The original implementation had everything in _lib/turing_tarpit.rb_, simply for
    convenience reasons while spiking. Breaking the classes into individual files
    brought the project more in line with [standard Ruby packaging conventions](http://chneukirchen.github.com/rps/).\r\n\r\n*
    Benoit Daloze [refactored some ugly output code](https://github.com/elm-city-craftworks/turing_tarpit/pull/2)
    to use `putc(char)` instead of `print(\"\" << char)`. Since the latter was obviously
    a hack due to my lack of awareness of the `putc` method, this was a welcome contribution.\r\n\r\nAfter
    this initial round of cleanup, we ended up thinking through a pair of more substantial
    problems: the inconsitent use of private accessors, and a proposed refactoring
    to break up the `Scanner` object into two separate objects, a `Tokenizer` and
    a `Scanner`.\r\n\r\n**The story behind my recent private accessor experiments**\r\n\r\nRyan
    LeCompte was the one to bring up [the question about private accessors](https://github.com/elm-city-craftworks/turing_tarpit/issues/1),
    and was curious about why I had used them in some places but referenced instance
    variables directly in others. The main reason for this was simply that the use
    of private accessors is a new experiment for me, and so in my haste of getting
    a first version out the door, I remembered to use them in some places but not
    in others.\r\n\r\nThis project in particular posed certain challenges for using
    private accessors conveniently. A specific example of where I ran into some weird
    edge cases can easily be seen in the `Tape` object:\r\n\r\n```ruby\r\nmodule TuringTarpit\r\n
    \ class Tape\r\n    def initialize\r\n      self.pointer_position = 0\r\n      #
    ...\r\n    end\r\n\r\n    def increment_pointer\r\n      self.pointer_position
    = pointer_position + 1\r\n    end\r\n\r\n    # ...\r\n\r\n    private\r\n\r\n
    \   attr_writer :pointer_position\r\n  end\r\nend\r\n```\r\n\r\nIf you just glance
    quickly at this class definition, it is very tempting to try to refactor `increment_pointer`
    so that it uses convenient `+=` syntax, resulting in something like the code below:\r\n\r\n```ruby\r\ndef
    increment_pointer\r\n  self.pointer_position += 1\r\nend\r\n```\r\n\r\nIn most
    cases, this refactoring would be a good one because it makes the code slightly
    less verbose without sacrificing readability. However, it turns out that Ruby
    does not extend the same private method special casing to `self.foo += something`
    as it does to `self.foo = something`. This means that if you attempt to refactor
    this code to use `+=` it ends up raising a `NoMethodError`. Because this is definitely
    a downside of using private accessors, it's reasonable to ask why you'd bother
    to use them in the first place rather than using public accessors or simply referring
    to instance variables directly.\r\n\r\nThe best reason I can find for making use
    of accessors in general vs. instance variables is simply that the former are much
    more flexible. New behavior such as validations or transformations can be added
    later by changing what used to be vanilla accessors into ordinary method definitions.
    Additionally, if you accidentally introduce a typo into your code, you will get
    a `NoMethodError` right away rather than having to track down why your attribute
    is `nil` when you didn't expect it to be in some completely different place in
    your code.\r\n\r\nThe problem with making accessors public is that it hints to
    the consumer that it is meant to be touched and used, which is often not the case
    at all, especially for writers. While Ruby makes it trivial to circumvent privacy
    protections, a private method communicates to the user that it is meant to be
    treated as an implementation detail and should not be depended on. So the reason
    for using a private accessor is the same as the reason for using a private method:
    to mark the accessor as part of the internals of the object.\r\n\r\nThe interesting
    thing I stumbled across in this particular project is that if you take this technique
    to the extreme, it is possible to build entire applications without ever explicitly
    referencing an instance variable. It comes at the cost of the occasional weird
    edge case when calling private methods internally, but makes it possible to treat
    instance variables as a whole as a _language implementation detail_, rather than
    an _application implementation detail_. Faced with the opportunity to at least
    experiment with that idea, I decided to make the entire Turing Tarpit codebase
    completely free of instance variables, which ended up taking very little effort.\r\n\r\nThe
    jury is still out on whether or not this is a good idea, but I plan to keep trying
    the idea out in my projects and see whether I run into any more issues. If I don't
    experience problems, I'd say this technique is well worth it because it emphasizes
    message-passing rather than state manipulation in our objects. \r\n\r\n**Splitting
    up the Scanner object**\r\n\r\nAfter helping out with a few of the general housekeeping
    chores, Steve Klabnik then turned his attention to one of the weakest spots in
    the code, the `Scanner` object. He pointed out that having an object with dependencies
    on a whole lot of private methods is a bit of a code smell, and focused specifically
    on the `Scanner#next` method. The original implementation looked like this:\r\n\r\n```ruby\r\nmodule
    TuringTarpit\r\n  class Scanner\r\n    # ...\r\n\r\n    def next(cell_value)\r\n
    \     validate_index\r\n\r\n      element = @chars[@index]\r\n      \r\n      case
    element\r\n      when \"[\"\r\n        jump_forward if cell_value.zero?\r\n\r\n
    \       consume\r\n        element = @chars[@index]\r\n      when \"]\"\r\n        if
    cell_value.zero?\r\n          while element == \"]\"\r\n            consume\r\n
    \           element = @chars[@index]\r\n            validate_index\r\n          end\r\n
    \       else\r\n          jump_back\r\n          consume\r\n          element
    = @chars[@index]\r\n        end\r\n      end\r\n      \r\n      consume\r\n      element\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nSteve pointed out that the `Scanner#next`
    method was really doing more of a tokenizing operation, and that most of the scanning
    work was actually being done by the various private methods that were being used
    to traverse the underlying string. He prepared a patch which made this relationship
    explicit by introducing a `Tokenizer` object which would provide a method to replace
    `Scanner#next`. His newly introduced object allowed for a re-purposing of the
    `Scanner` object which allowed its methods to become public:\r\n\r\n```ruby\r\nmodule
    TuringTarpit\r\n  class Tokenizer\r\n    # ...\r\n\r\n    def next(cell_value)\r\n
    \     scanner.validate_index\r\n\r\n      element = scanner.current_char\r\n\r\n
    \     case element\r\n      when \"[\"\r\n        scanner.jump_forward if cell_value.zero?\r\n\r\n
    \       scanner.consume\r\n        element = scanner.current_char\r\n      when
    \"]\"\r\n        if cell_value.zero?\r\n          while element == \"]\"\r\n            scanner.consume\r\n
    \           element = scanner.current_char\r\n            scanner.validate_index\r\n
    \         end\r\n        else\r\n          scanner.jump_back\r\n          scanner.consume\r\n
    \         element = scanner.current_char\r\n        end\r\n      end\r\n\r\n      scanner.consume\r\n
    \     element\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe thing in particular
    I liked about this patch is that it abstracted away some of the tedious index
    operations that were originally present in `Scanner#next`. As much as possible
    I prefer to isolate anything that can cause off-by-one errors or other such nonsense,
    and this refactoring did a good job of addressing that issue.\r\n\r\nThe interesting
    thing about this refactoring is that while I intended to work on the same area
    of the code if no one else patched it, I had planned to approach it in a very
    different way. My original idea was to implement some sort of generic stream datastructure
    and reuse it in both `Scanner` and `Tape`. However, seeing that Steve's patch
    at least partly addressed my concerns while possibly opening some new avenues
    as well, I abandoned that idea and merged his work instead.\r\n\r\n### Act II.
    Building a better horse\r\n\r\nAfter applying the various patches from the folks
    who participated in this challenge, the code was in a much better place than where
    it started. However, much work was still left to be done!\r\n\r\nIn particular,
    the code responsible for turning Brainfuck syntax into a stream of operations
    still needed a lot of work. The `Tokenizer` class that Steve introduced was an
    improvement, but without further revisions would simply serve as a layer of indirection
    rather than as an abstraction. Zed Shaw describes the difference between these
    two concepts very eloquently in his essay [Indirection Is Not Abstraction](http://zedshaw.com/essays/indirection_is_not_abstraction.html)
    by stating that _\"Abstraction is used to reduce complexity. Indirection is used
    to reduce coupling or dependence.\"_\r\n\r\nAs far as the `Tokenizer` object goes,
    Steve's patch reducing coupling somewhat by pushing some of the implementation
    details down into the `Scanner` object. However, the procedure is pretty much
    identical with the exception of the lack of explicit indexing code, and so the
    baseline complexity actually increases because what was once done by one object
    is now split across two objects.\r\n\r\nTo address this problem, the dividing
    lines between the two objects needed to be leveraged so that they could interact
    with each other at a higher level. It took me a while to think through the problem,
    but in doing so I realized that I could now push more functionality down into
    the `Scanner` object so that `Tokenizer#next` ended up with fewer moving parts.
    After some major gutting and re-arranging, I ended up with a method that looked
    like this:\r\n\r\n```ruby\r\nmodule TuringTarpit\r\n  class Tokenizer\r\n    #
    ...\r\n\r\n    def next(cell_value)\r\n      case scanner.next_char\r\n      when
    Scanner::FORWARD_JUMP\r\n        if cell_value.zero?\r\n          scanner.jump_forward\r\n
    \       else\r\n          scanner.next_char\r\n        end\r\n      when Scanner::BACKWARD_JUMP\r\n
    \       if cell_value.zero?\r\n          scanner.skip_while(Scanner::BACKWARD_JUMP)\r\n
    \       else\r\n          scanner.jump_back\r\n        end\r\n      end\r\n\r\n
    \     scanner.current_char\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAfter this
    refactoring, the `Tokenizer#next` method was a good deal more abstract in a number
    of ways:\r\n\r\n* It expected the `Scanner` to handle validations itself rather
    than telling it when to check the index \r\n\r\n* It no longer referenced Brainfuck
    syntax and instead used constants provided by the `Scanner`\r\n\r\n* It eliminated
    a lot of cumbersome assignments by reworking its algorithm so that `Scanner#current_char`
    always referenced the right character at the end of the scanning routine.\r\n\r\n*
    It expected the `Scanner` to remain internally consistent, rather than handling
    edge cases itself.\r\n\r\nThese reductions in complexity made a hugely positive
    impact on the readability and understandability of the `Tokenizer#next` method.
    While all of these changes could have technically been made before the split between
    the `Scanner` and `Tokenizer` happened, cutting the knot into two pieces certainly
    made untangling things easier. This is why indirection and abstraction often go
    hand in hand, despite the fact that they are very different concepts from one
    another.\r\n\r\n### Act III. Mountains are once again merely mountains\r\n\r\nAfter
    building on top of Steve's work to simplify the syntax-processing code even further,
    I finally felt like that part of the project was in decent shape. I then decided
    to turn my attention back to the `Interpreter` object, since it had not received
    any love from the challenge participants. The original code for it looked something
    like this:\r\n\r\n```ruby\r\nmodule TuringTarpit\r\n  class Interpreter\r\n    def
    run\r\n      loop do\r\n        case tokenizer.next(tape.cell_value)\r\n        when
    \"+\"\r\n          tape.increment_cell_value\r\n        when \"-\"\r\n          tape.decrement_cell_value\r\n
    \       when \">\"\r\n          tape.increment_pointer\r\n        when \"<\"\r\n
    \         tape.decrement_pointer\r\n        when \".\"\r\n          putc(tape.cell_value)\r\n
    \       when \",\"\r\n          value = STDIN.getch.bytes.first\r\n          next
    if value.zero?\r\n\r\n          tape.cell_value = value\r\n        end\r\n      end\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nWhile this implementation wasn't too bad,
    there were two things I didn't like about it. The first issue was that it directly
    referenced Brainfuck syntax, which sort of defeated the purpose of having the
    tokenizer be syntax independent. The second problem was that I found the case
    statement to feel a bit brittle and limiting. What I really wanted was a dynamic
    dispatcher similar to the following method:\r\n\r\n```ruby\r\ndef run\r\n  loop
    do\r\n    if operation = tokenizer.next(evaluator.cell_value)\r\n      tape.send(operation)\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nIn order to introduce this kind of functionality,
    I'd need to find a place to introduce a simple mapping from Brainfuck syntax to
    operation names. I already had the keys and values in mind, I just needed to find
    a place to put them:\r\n\r\n```ruby\r\nOPERATIONS = { \"+\" => :increment_cell_value,\r\n
    \              \"-\" => :decrement_cell_value,\r\n               \">\" => :increment_pointer,\r\n
    \              \"<\" => :decrement_pointer,\r\n               \".\" => :output_cell_value,\r\n
    \              \",\" => :input_cell_value }\r\n```\r\n\r\nFiguring out how to
    make this work was surprisingly challenging. I found that the extra layers of
    indirection between the `Tape` and the `Scanner` meant that any change made too
    far down the chain would need to be echoed all the way up it, and that changes
    made towards the top felt tacked on and out of place. This eventually led me to
    question what the separation between `Scanner` and `Tokenizer` was really gaining
    me, as well as the separation between `Interpreter` and `Tape`.\r\n\r\nAfter a
    fair amount of ruminating, I decided to take my four objects and join them together
    at the seams so that only two remained. The `Scanner` and `Tokenizer` ended up
    getting joined back together to form a new `Interpreter` class. The job of the
    `Interpreter` is to take Brainfuck syntax and turn it into a stream of operations.
    You can get a rough idea of how it all came together by checking out the following
    code:\r\n\r\n```ruby\r\nmodule TuringTarpit\r\n  class Interpreter\r\n    FORWARD_JUMP
    = \"[\"\r\n    BACKWARD_JUMP = \"]\"\r\n\r\n    OPERATIONS = { \"+\" => :increment_cell_value,\r\n
    \                  \"-\" => :decrement_cell_value,\r\n                   \">\"
    => :increment_pointer,\r\n                   \"<\" => :decrement_pointer,\r\n
    \                  \".\" => :output_cell_value,\r\n                   \",\" =>
    :input_cell_value }\r\n\r\n    def next_operation(cell_value)\r\n      case next_char\r\n
    \     when FORWARD_JUMP\r\n        if cell_value.zero?\r\n          jump_forward\r\n
    \       else\r\n          skip_while(FORWARD_JUMP)\r\n        end\r\n      when
    BACKWARD_JUMP\r\n        if cell_value.zero?\r\n          skip_while(BACKWARD_JUMP)\r\n
    \       else\r\n          jump_back\r\n        end\r\n      end\r\n\r\n      OPERATIONS[current_char]\r\n
    \   end\r\n\r\n    # ... lots of private methods are back, but now fine-tuned.\r\n
    \ end\r\nend\r\n```\r\n\r\nThe old `Interpreter` object and `Tape` object were
    also merged together, forming a single object I ended up calling `Evaluator`.
    The job of the `Evaluator` object is to take a stream of operations provided by
    the newly defined `Interpreter` object and then execute them against a Turing
    Machine like data structure. In essence, the `Evaluator` object is nothing more
    than the original `Tape` object I implemented along with a few extra methods which
    account for the things the original `Interpreter` object was meant to do:\r\n\r\n```ruby\r\nmodule
    TuringTarpit\r\n  class Evaluator \r\n    def self.run(interpreter)\r\n      evaluator
    = new\r\n\r\n      loop do\r\n        if operation = interpreter.next_operation(evaluator.cell_value)\r\n
    \         evaluator.send(operation)\r\n        end\r\n      end\r\n    end\r\n\r\n
    \   def output_cell_value\r\n      putc(cell_value)\r\n    end\r\n\r\n    def
    input_cell_value\r\n      value = $stdin.getch.ord\r\n      return if value.zero?\r\n\r\n
    \     self.cell_value = value\r\n    end\r\n\r\n    # other methods same as original
    Tape methods\r\n  end\r\nend\r\n```\r\n\r\nI had mixed feelings about recombining
    these objects, because to some extent it felt like a step backwards to me. In
    particular, I think this refactoring resulted in some minor violations of the
    [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle),
    and increased the overall coupling of the system somewhat. However, the independence
    of the four different objects the system previously consisted of seemed artificial
    at best. To the extent that they could be changed easily or swapped out for one
    another, I could not think of a single practical reason why I'd actually want
    that kind of flexibility. In this particular situation it turned out that recombining
    the objects greatly reduced their communications overhead, and so was worth the
    loss in generality.\r\n\r\n### Epilogue. Sending the ship out to sea\r\n\r\nI
    was really tempted to keep noodling on the design of this project, because even
    in my final version of the code I still felt that I could have done better. But
    at a certain point I decided that I could end up getting caught in this trap forever,
    and the only way to free myself from it was to wrap up my work and just ship the
    damn thing. This ultimately meant that I had to take care of several chores that
    neither I nor the various participants in this challenge bothered to work on earlier:\r\n\r\n*
    I added a [set of integration tests](https://github.com/elm-city-craftworks/turing_tarpit/blob/act3/test/integration/evaluator_test.rb)
    which ran the `Evaluator` against a couple sample Brainfuck programs to make sure
    we had some decent end-to-end testing support. Found a couple bugs that way.\r\n\r\n*
    I set up and ran [simplecov](https://github.com/colszowka/simplecov) to check
    whether my tests were at least *running* all the implementation code, and ended
    up spotting a faulty test which wasn't actually getting run.\r\n\r\n* I added
    a [bin/turing_tarpit](https://github.com/elm-city-craftworks/turing_tarpit/blob/act3/bin/turing_tarpit)
    file so that you can execute Brainfuck programs without building a Ruby shim first.
    \r\n\r\n* Did the usual gemspec + Gemfile dance and pushed a 1.0.0 gem to rubygems.org.
    Typically I'd call a project in its early stages a 0.1.0 release, but I honestly
    don't see myself working on this much more so I might as well call it 'production
    ready'.\r\n\r\nAfter I wrapped up all these chores, I decided to go back and check
    out what my [flog](https://github.com/seattlerb/flog) complexity scores were for
    each stage in this process. It turns out that the final version was the least
    complex, with the lowest overall score, lowest average score, and lowest top-score
    by method. The original implementation came in second place, and the other two
    iterations were in a distant third and fourth place. While that gave me some reassurances,
    it doesn't mean much except for that Flog seems to really hate external method
    calls.\r\n\r\n### Reflections\r\n\r\nThis has been one of my favorite articles
    to write for Practicing Ruby so far. It forced me to look at the refactoring process
    in a much more introspective way than I have typically done in the past, and gave
    me a chance to interact with some of our awesome readers. I do think it ended
    up raising more questions and challenges in my mind than it did give me answers
    and reassurances, but I suppose that's a sign that learning happened.\r\n\r\nWhile
    I found it very hard to summarize the refactoring lifecycle for this project,
    my hope is that I've at least given you a glimpse of the spiral staircase metaphor
    I chose to name this article after. If it didn't end up making you feel too dizzy,
    I'd love to hear your thoughts about this exercise as well as what your own process
    is like when it comes to refactoring code.\r\n"
- :slug: framework-design-and-implementation-1
  :title: Framework design and implementation, Part 1
  :summary: Dig through the Newman mail framework's source code in search of useful
    patterns and practices.
  :published: 2012-02-02 00:00:00.000000000 Z
  :issue_number: '3.5'
  :volume: 3
  :body: "Ruby is a great language for building application frameworks, particularly
    micro-frameworks. The sad thing is that by the time most frameworks become popular,
    they end up quite complicated. To discover the joy of building reusable scaffolding
    for others, it's necessary to take a look at where the need for that scaffolding
    comes from in the first place.\r\n\r\nIn the January 2012 core skills session
    at Mendicant University, I asked our students to each build multi-user email based
    applications. While the students were working on very different projects, there
    was a ton of boilerplate that was common between them all. Because it was too
    painful to watch the same bits of code get written again and again in slightly
    different ways, I decided to build a tiny framework to solve this problem.\r\n\r\nIn
    this issue of Practicing Ruby and the one that follows it, I'm going to have you
    work through the code I wrote and help me figure out what goes into building a
    good application framework. The goal for this issue is to generate ideas and questions
    about the codebase. All of what we learn from this exercise will be neatly packaged
    up and synthesized in time for Issue 3.6, but for now I'm looking for folks to
    get their hands dirty.\r\n\r\n## The Challenge\r\n\r\nI would like you to spend
    at least the same amount of time you'd ordinarily spend reading a Practicing Ruby
    article actively reading and working through [Newman 0.1.1](https://github.com/mendicant-original/newman/tree/v0.1.1),
    my micro-framework for email based applications. I have intentionally left the
    source uncommented for two reasons: to get you to practice your code reading skills
    and to get your candid feedback on the strengths and weaknesses of my overall
    design without influencing you too much.\r\n\r\nAs you read the code, don't just
    passively click through files on github! Instead, pull down the source and play
    with it: Run the examples if you can, or even better, build your own examples.
    Try to break stuff if you think you might be able to find a bug or two, or try
    to add a new feature you find interesting. This is an open sandbox to play in!\r\n\r\nOnce
    you have managed to find your way around, you're encouraged to start actively
    collaborating. I'll be available via the #newman IRC channel and [newman@librelist.org](newman@librelist.org)
    to listen to any ideas or questions you have. Of course, feel free to use Github
    for bug reports, feature requests, and comments on pull requests / commits.\r\n\r\nIn
    this code I've tried to apply pretty much everything I've ever taught via Practicing
    Ruby whenever there was an opportunity to do so. I've also broken away from established
    Ruby conventions in places to explore new ideas. Reading it will be worth your
    time, and if you actively involve yourself in the conversations around it, you'll
    be sure to level up your Ruby skills in no time. \r\n\r\n**One last thing: Don't
    be afraid to ask where to get started if you feel stuck. The purpose of this exercise
    is to learn, and I will do what I can to help you get a lot out of this challenge.**"
- :slug: framework-design-and-implementation-2
  :title: Framework design and implementation, Part 2
  :summary: Explore some lessons learned the hard way in developing the Newman mail
    framework.
  :published: 2012-02-08 00:00:00.000000000 Z
  :issue_number: '3.6'
  :volume: 3
  :body: "In [Issue 3.5](http://practicingruby.com/articles/22), I  challenged Practicing
    Ruby subscribers to read through and play with the uncommented source code of
    [Newman 0.1.1](https://github.com/mendicant-original/newman/tree/v0.1.1), the
    first release of my micro-framework for building email-centric applications. My
    hope was that by looking through the implementation of a framework in its very
    early stages of development, readers would be able to familiarize themselves with
    the kinds of challenges involved in building this sort of project.\r\n\r\nIf you
    didn't participate in that challenge, I recommend spending an hour or two working
    through it now before reading the rest of this article. My feeling was (and is)
    that because framework development is about taking care of a thousand tiny details,
    it's important to see where this kind of project begins before you can really
    appreciate where it ends up. Assuming you've gone ahead and done that, we can
    move on to this week's exercise.\r\n\r\n### The challenge revisited\r\n\r\nI had
    originally planned to provide a nice annotated walk-through of Newman's implementation
    up front, but then decided it'd be better if you had a chance to explore it without
    much guidance before sharing my own explanations of how it all hangs together.\r\n\r\nHowever,
    this would be little more than an exercise in code reading if I didn't revisit
    that challenge and provide you with comprehensive implementation notes. With that
    in mind, you can now read [the fully documented source code](http://mendicant-original.github.com/newman/lib/newman.html),
    complete with little bits of design ruminations peppered throughout the code.
    This ought to answer some of the questions that were rattling around in the back
    of your mind, and even if it didn't, it may spark new questions or ideas that
    you can share with me as they arise.\r\n\r\nJust reading through the documented
    codebase should teach you a lot about how a micro-framework can be built in Ruby.
    But the process of doing so might still leave you feeling a bit disoriented because
    it provides a view of the big picture in terms of dozens of microscopic snapshots
    rather than exposing a handful of bright-line items to focus on.  With that in
    mind, I've decided to outline a few of the recurring obstacles I kept running
    into even in the first week of development on this project, as I think they'll
    be friction points for frameworks of all varieties.\r\n\r\n### Lessons learned
    the hard way\r\n\r\nThere is a ton of content to read in that source walk-through,
    so I'll try to keep these points brief in the hopes that they'll spark some discussions
    that might possibly lead to further investigation in future articles. But these
    are the main things to watch out for if you're designing your own framework or
    contributing to someone else's early stage project:\r\n\r\n**1) Dealing with global
    state sucks**\r\n\r\nIn the context of Newman, I had to deal with global state
    in the form of configuration settings, logging, mailer objects, and persistence
    layers. The first version of Newman had to resort to turning many of its objects
    into singleton objects because any object which manipulates global state can have
    global side effects. \r\n\r\nThe viral nature of singleton objects was something
    that I rarely encountered in application or even library code, but became blindingly
    apparent in working on this framework. For example, Newman's first version shipped
    with a `Newman::Mailer` object, but because this object was using Mail's global
    settings functionality, it was not practical to ever create more than one `Newman::Mailer`
    object. This was really annoying, because it meant that Newman would be limited
    to monitoring a single inbox per process, which seems like an artificial restriction.
    But because a `Newman::Server` object is essentially a router designed to work
    bridge our mailer object to our application objects, it too needed to become a
    singleton object!\r\n\r\nWe eventually were able to work around this for the most
    part by using some low level APIs provided by the mail gem, and this will pave
    the way for multi-inbox support in Newman in the near future. But I was sort of
    shocked at how much impact depending on a singleton object can have on the overall
    flexibility of a framework, because I had not experienced this problem in my usual
    work on applications and libraries.\r\n\r\nFor the things that'd be ordinarily
    implemented as singleton objects, such as loggers or configuration objects, I
    took care to make it so that even if in practice the system makes use of globally
    available state, the structure allows for that to be changed with minimal impact.
    As an example of this, you can see that Newman actually passes its setting objects,
    data storage objects, and loggers down the call chain to any object that needs
    them rather than having those objects reference a constant or global variable.
    This makes it possible for isolation to occur at any point in the chain, and makes
    it so that Newman has very few hard dependencies on shared state, with its use
    only being a matter of convenience. The unfortunate side effect of this sort of
    design is a bit of repetitive code, but I've tried to minimize that where possible
    by providing convenience constructors and factory methods that make this job easier.\r\n\r\n**2)
    Handling application errors in server software is hard**\r\n\r\nIn the first version
    of Newman, any application error would cause the whole server to come crashing
    down with it. This is definitely not the right way to do things, at least not
    by default, as it means that a problem with a single callback in a single application
    can bring down a whole process that is otherwise working as expected.\r\n\r\nYou
    might think that the solution to this is to simply rescue application errors and
    log them, and that is more-or-less the approach I chose to solving this problem.
    However, I quickly ran into an issue with this in testing. I didn't want a bunch
    of verbose log output while running my integration tests, so I ran the server
    with logging turned off. But soon enough, I was getting tests which were failing
    but giving me no feedback at all as to why that was happening. I eventually discovered
    that this was due to application errors being swallowed silently, causing the
    application to fail to respond but not give any feedback that would help with
    debugging them. The code was not raising an exception, so the tests were not halting
    with an error, they were just failing.\r\n\r\nTo solve this issue, I added a server
    configuration object which allowed toggling exception raising on and off. When
    that setting was enabled, the server would halt, which is exactly the behavior
    I wanted in my tests. This did the trick and it's been mostly smooth sailing since
    then. But the question remains: what are the best defaults to use for this sort
    of thing? I'm thinking that for test mode, logging should be off and exception
    raising should be on, and for the default runtime behavior, it should be exactly
    the opposite. Is that sane? I don't really know, but I suppose it's worth a try.\r\n\r\nAnother
    open question I have here is how much effort should be put into only rescuing
    certain kinds of errors. In most cases, \"log and move on\" seems like the right
    behavior from the server's perspective, but could this lead to weird edge cases?
    As the framework designer, it's my job to help make it hard for the application
    developer to shoot himself in the foot. But unfortunately right now I don't really
    know where to aim. More research is required here.\r\n\r\n**3) Frameworks are
    tricky to test**\r\n\r\nThe whole point of a framework is to tie together a bunch
    of loose odds and ends to produce a cohesive environment for application development.
    Writing tests for applications developed within a framework should be *easier*
    than writing tests for applications developed standalone, but writing tests for
    the framework itself present new and interesting challenges that aren't typically
    encountered in ordinary application development.\r\n\r\nWhen I first started working
    on Newman, I wasn't writing any tests at all because I had no faith that any of
    the objects I was creating were going to survive first contact with real use cases.
    Instead, I focused on building little example applications which moved the functionality
    along and served as a way of manual testing the code in a fairly predictable way.
    But after even a modest amount of functionality was built, the lack of automated
    testing made it so that each new change to the system involved a long, cumbersome,
    and error prone manual testing session, to the point where it was no longer practical.\r\n\r\nFrom
    there, I decided to build some simple \"live tests\" that would essentially script
    away the manual checking I was doing, running the example programs automatically,
    and automating the sending and checking of email to give me a simple red/green
    check. The process of introducing these changes required me to make some changes
    to the system, such as allowing the system to run tick by tick rather than in
    a busy-wait loop, among other things. This cut down some of the manual testing
    time and made the test plan more standardized, but was still very brittle because
    cleaning up after a failed test was still a manual process.\r\n\r\nSooner or later,
    we introduced some surface-level test doubles, such as a simple TestMailer which
    could serve as a stand-in replacement for the real mail object. With this object
    in place it was possible to convert some of the live tests to a set of acid tests
    which were capable of testing the system from end to end reaching all systems
    except for the actual mail interactions. This was a huge improvement because it
    made basically the same tests run in fractions of a second rather than half a
    minute, but I'm still glad it's not where we started at. Why? Simply because email
    is a super messy domain to work in and five minutes of manual testing will expose
    many problems that hours of work on finely crafted automated tests would never
    catch unless you happen to be an email expert (I'm not). The only thing I regret
    is that I should have developed these tests concurrently with my manual testing,
    rather than waiting until the pain became so great that the project just ground
    to a halt.\r\n\r\nEven after these improvements, Newman 0.2.0 still ended up shipping
    with no unit tests. Part of this is because of the lack of available time I had
    to write them, but the other part is that it still feels like a challenge for
    me to meaningfully test isolated portions of the framework since they literally
    will never be useful in isolation. I'm stuck in between a rock and a hard place,
    because the use of mock objects feels too artificial, but dragging in the real
    dependencies is an exercise in tedium. I'd love some guidance on how to test this
    sort of code effectively and will be looking into how things like Sinatra and
    Rails do their testing to see if I can learn anything there.\r\n\r\nBut one thing
    is for sure, I wouldn't suggest trying to build a framework unit test by unit
    test. The problem domain is way too messy with way too many interlocking parts
    for that to be practical. I think if I took the TDD approach I'd still be working
    on getting the most basic interactions working in Newman today rather than talking
    about it's second major release. Still, maybe I'm just doing it wrong?\r\n\r\n**4)
    Defining a proper workflow takes more effort than it seems**\r\n\r\nThis obstacle
    is hard to describe succinctly, so I won't try to do so. But the main point I
    want to stress is that many frameworks are essentially nothing more than a glorified
    tool for ferrying a bunch of request data around and building up a response in
    the end. But deciding where to sneak in extension points, and where to give the
    application developer control vs. where to make a decision for them is very challenging.
    \r\n\r\nTry to start with one of Newman's examples and trace the path from the
    point where an email is received to the point where a response gets sent out.
    Then let me know what you think of what I've done, and perhaps give me some ideas
    for how I can do it better. I'm still not happy with the decomposition as it is,
    but I'm struggling to figure out how to fix it.\r\n\r\n**5) Modularity is great,
    but comes at a cost**\r\n\r\nAs soon as you decide to make things modular, you
    have to be very careful about baking assumptions into your system. This means
    making interfaces between objects as simple as possible, limiting the amount of
    dependencies on shared state, and providing generic adapter objects to wrap specific
    implementation details in some contexts. This is another thing that's hard to
    express in a concise way, but the point is that modularity is a lot more complicated
    when you are not just concerned about reusability/replaceability within a single
    application, but instead within an entire class of applications, all with somewhat
    different needs.\r\n\r\nI've been trying to ask myself the question of whether
    a given bit of functionality really will ever be customized by a third-party extension,
    and if I think it will be, I've been trying to imagine a specific use case. If
    I can't find one, I decide to avoid generalizing my constructs. However, this
    is a dangerous game and finding the right balance between making a system highly
    customizable and making it cohesive is a real challenge. It's where all the fun
    problems come from with framework design, but is also the source of a lot of headaches.\r\n\r\n###
    Reflections\r\n\r\nI'm afraid dear Practicing Rubyist that once again I've raised
    more questions than answers. I always worry when I find myself over my own head
    that perhaps I've lost some of you in the process. But I want to emphasize the
    fact that this journal is meant to chronicle a collective learning process for
    all of us, not just a laundry list of developer protips that I can pull off the
    top of my head. Even if this series of articles was hard to digest, it will pave
    the way for more neatly synthesized works in the future. \r\n\r\nAlso, don't underestimate
    your ability to contribute something to this conversation! If any ideas or questions
    popped up in your head while reading through these notes, please share them without
    thinking about whether or not your insights would be worth sharing. I've been
    continuously impressed by the quality of the feedback around here, so I'd love
    to hear what you think."
- :slug: disciplined-inheritance-1
  :title: Criteria for disciplined inheritance, Part 1
  :summary: See how M. Sakkinen's notion of "Disciplined Inheritance" in 1989 still
    applies to modern Ruby code.
  :published: 2012-02-15 00:00:00.000000000 Z
  :issue_number: '3.7'
  :volume: 3
  :body: "Inheritance is a key concept in most object-oriented languages, but applying
    it skillfully can be challenging in practice. Back in 1989, [M. Sakkinen](http://users.jyu.fi/~sakkinen/)
    wrote a paper called [Disciplined inheritance](http://scholar.google.com/scholar?cluster=5893037045851782349&hl=en&as_sdt=0,7&sciodt=0,7)
    that addresses these problems and offers some useful criteria for working around
    them. Despite being more than two decades old, this paper is extremely relevant
    to the modern Ruby programmer. \r\n\r\nSakkinen's central point seems to be that
    most traditional uses of inheritance lead to poor encapsulation, bloated object
    contracts, and accidental namespace collisions. He provides two patterns for disciplined
    inheritance and suggests that by normalizing the way that we model things, we
    can apply these two patterns to a very wide range of scenarios. He goes on to
    show that code that conforms to these design rules can easily be modeled as ordinary
    object composition, exposing a solid alternative to traditional class-based inheritance.\r\n\r\nThese
    topics are exactly what this two-part article will cover, but before we can address
    them, we should establish what qualifies as inheritance in Ruby. The general term
    is somewhat overloaded, so a bit of definition up front will help start us off
    on the right foot. \r\n\r\n### Flavors of Ruby inheritance\r\n\r\nAlthough classical
    inheritance is centered on the concept of class-based hierarchies, modern object-oriented
    programming languages provide many different mechanisms for code sharing. Ruby
    is no exception: it provides four common ways to model inheritance-based relationships
    between objects.\r\n\r\n* Classes provide a single-inheritance model similar to
    what is found in many other object-oriented languages, albeit lacking a few privacy
    features.\r\n\r\n* Modules provide a mechanism for modeling multiple inheritance,
    which is easier to reason about than C++ style class inheritance but is more powerful
    than Java's interfaces.\r\n\r\n* Transparent delegation techniques make it possible
    for a child object to dynamically forward messages to a parent object. This technique
    has similar effects as class-/module-based modeling on the child object's contract
    but preserves encapsulation between the objects.\r\n\r\n* Simple aggregation techniques
    make it possible to compose objects for the purpose of code sharing. This technique
    is most useful when the subobject is not meant to be a drop-in replacement for
    the superobject.\r\n\r\nAlthough most problems can be modeled using any one of
    these techniques, they each have their own strengths and weaknesses. Throughout
    both parts of this article, I'll point out the trade-offs between them whenever
    it makes sense to do so.\r\n\r\n### Modeling incidental inheritance \r\n\r\nSakkinen
    describes **incidental inheritance** as the use of an inheritance-based modeling
    approach to share implementation details between dissimiliar objects. That is
    to say that child (consumer) objects do not have an _is-a_ relationship to their
    parents (dependencies) and therefore do not need to provide a superset of their
    parent's functionality.\r\n\r\nIn theory, incidental inheritance is easy to implement
    in a disciplined way because it does not impose complex constraints on the relationships
    between objects within a system. As long as the child object is capable of working
    without errors for the behaviors it is meant to provide, it does not need to take
    special care to adhere to the [Liskov Substitution Principle](http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html).
    In fact, the child needs only to expose and interact with the bits of functionality
    from the parent object that are specifically relevant to its domain.\r\n\r\nRegardless
    of the model of inheritance used, Sakkinen's paper suggests that child objects
    should rely only on functionality provided by immediate ancestors. This is essentially
    an inheritance-oriented parallel to the [Law of Demeter](http://en.wikipedia.org/wiki/Law_of_Demeter)
    and sounds like good advice to follow whenever it is practical to do so. However,
    this constraint would be challenging to enforce at the language level in Ruby
    and may not be feasible to adhere to in every imaginable scenario. In practice,
    the lack of adequate privacy controls in Ruby make traditional class hierarchies
    or module mixins quite messy for incidental inheritance, which complicates things
    a bit. But before we discuss that problem any further, we should establish what
    incidental inheritance looks like from several different angles in Ruby.\r\n\r\nIn
    the following set of examples, I construct a simple `Report` object that computes
    the sum and average of numbers listed in a text file. I break this problem into
    three distinct parts: a component that provides functionality similar to Ruby's
    `Enumerable` module, a component that uses those features to do simple calculations
    on numerical data, and a component that outputs the final report. The contrived
    nature of this scenario should make it easier to examine the structural differences
    between Ruby's various ways of implementing inheritance relationships, but be
    sure to keep some more realistic scenarios in the back of your mind as you work
    through these examples. \r\n\r\nThe classical approach of using a class hierarchy
    for code sharing is worth looking at, even if most practicing Rubyists would quickly
    identify this as the wrong approach to this particular problem. It serves as a
    good baseline for identifying the problems introduced by inheritance and how to
    overcome them. As you read through the following code, think of its strengths
    and weaknesses, as well as any alternative ways to model this scenario that you
    can come up with.\r\n\r\n```ruby\r\nclass EnumerableCollection\r\n  def count\r\n
    \   c = 0\r\n    each { |e| c += 1 }\r\n    c\r\n  end\r\n\r\n  # Samnang's implementation
    from Issue 2.4\r\n  def reduce(arg=nil) \r\n    return reduce {|s, e| s.send(arg,
    e)} if arg.is_a?(Symbol)\r\n\r\n    result = arg\r\n    each { |e| result = result
    ? yield(result, e) : e }\r\n\r\n    result\r\n  end\r\nend\r\n\r\nclass StatisticalCollection
    < EnumerableCollection\r\n  def sum\r\n    reduce(:+) \r\n  end\r\n\r\n  def average\r\n
    \   sum / count.to_f\r\n  end \r\nend\r\n\r\nclass StatisticalReport < StatisticalCollection\r\n
    \ def initialize(filename)\r\n    self.input = filename\r\n  end\r\n\r\n  def
    to_s\r\n    \"The sum is #{sum}, and the average is #{average}\"\r\n  end\r\n\r\n
    \ private \r\n\r\n  attr_accessor :input\r\n\r\n  def each\r\n    File.foreach(input)
    { |e| yield(e.chomp.to_i) }\r\n  end\r\nend\r\n\r\nputs StatisticalReport.new(\"numbers.txt\")\r\n```\r\n\r\nThrough
    its inheritance-based relationships, `StatisticalReport` is able to act as a simple
    presenter object while relying on other reusable components to crunch the numbers
    for it. The `EnumerableCollection` and `StatisticalCollection` objects do most
    of the heavy lifting while managing to remain useful for a wide range of different
    applications. The division of responsibilities between these components is reasonably
    well defined, and if you ignore the underlying mechanics of the style of inheritance
    being used here, this example is a good demonstration of effective code reuse.\r\n\r\nUnfortunately,
    the devil is in the details. When viewed from a different angle, it's easy to
    see a wide range of problems that exist even in this very simple application of
    class-based inheritance:\r\n\r\n1. It is possible to create instances of `EnumerableCollection`
    and `StatisticalCollection` but not possible to do anything meaningful with them
    as they are currently written. Although it's not necessarily a bad idea to make
    use of abstract classes, valid uses of that pattern typically invert the relationship
    shown here, with the child object filling in a missing piece so that its parent
    can do a complex job.\r\n\r\n2. Although `StatisticalReport` relies on only two
    relatively generic methods from `StatisticalCollection` and `StatisticalCollection`
    similarly relies on only two methods from `EnumerableCollection`, the use of class
    inheritance forces a rigid hierarchical relationship between the objects. Even
    if it's not especially awkward to say a `StatisticalCollection` is an `EnumerableCollection`,
    it's definitely weird to say that a `StatisticalReport` is also an `EnumerableCollection`.
    What makes matters worse is that this sort of modeling prevents `StatisticalReport`
    from inheriting from something more topically related to its domain such as a
    `HtmlReport` or something similar. As my [favorite OOP rant](http://lists.canonical.org/pipermail/kragen-tol/2011-August/000937.html)
    proclaims, class hierarchies do not exist simply to satisfy our inner Linnaeus.\r\n\r\n3.
    There is no encapsulation whatsoever between the components in this system. The
    purely functional nature of both `EnumerableCollection` and `Statistics` make
    this less of a practical concern in this particular example but is a dangerous
    characteristic of all code that uses class-based inheritance in Ruby. Any instance
    variables created within a `StatisticalReport` object will be directly accessible
    in method calls all the way up its ancestor chain, and the same goes for any methods
    that `StatisticalReport` defines. Although a bit of discipline can help prevent
    this from becoming a problem in most simple uses of class inheritance, deep method
    resolution paths can make accidental collisions of method definitions or instance
    variable names a serious risk. Such a risk might be mitigated somewhat by the
    introduction of class-specific privacy controls, but they do not currently exist
    in Ruby. \r\n\r\n4. As a consequence of points 2 and 3, the `StatisticalReport`
    object ends up with a bloated contract that isn't representative of its domain
    model. It'd be awkward to call `StatisticalReport#count` or `StatisticalReport#reduce`,
    but if those inherited methods are not explicitly marked as private in the `StatisticalReport`
    definition, they will still be callable by clients of the `StatisticalReport`
    object. Once again, the stateless nature of this program makes the effects less
    damning in this particular example, but it doesn't take much effort to imagine
    the inconsistencies that could arise due to this problem. In addition to real
    risks of unintended side effects, this kind of modeling makes it harder to document
    the interface of the `StatisticalReport` in a natural way and diminishes the usefulness
    of Ruby's reflective capabilities.\r\n\r\nAt least some of these issues can be
    resolved through the use of Ruby's module-based mixin functionality. The following
    example shows how our class-based code can be trivially refactored to use modules
    instead. Once again, as you read through the code, think of its strengths and
    weaknesses as well as how you might approach the problem differently if it were
    up to you to design this system.\r\n\r\n```ruby\r\nmodule SimplifiedEnumerable\r\n
    \ def count\r\n    c = 0\r\n    each { |e| c += 1 }\r\n    c\r\n  end\r\n\r\n
    \ # Samnang's implementation from Issue 2.4\r\n  def reduce(arg=nil) \r\n    return
    reduce {|s, e| s.send(arg, e)} if arg.is_a?(Symbol)\r\n\r\n    result = arg\r\n
    \   each { |e| result = result ? yield(result, e) : e }\r\n\r\n    result\r\n
    \ end\r\nend\r\n\r\nmodule Statistics\r\n  def sum\r\n    reduce(:+) \r\n  end\r\n\r\n
    \ def average\r\n    sum / count.to_f\r\n  end \r\nend\r\n\r\nclass StatisticalReport\r\n
    \ include SimplifiedEnumerable\r\n  include Statistics\r\n\r\n  def initialize(filename)\r\n
    \   self.input = filename\r\n  end\r\n\r\n  def to_s\r\n    \"The sum is #{sum},
    and the average is #{average}\"\r\n  end\r\n\r\n  private \r\n\r\n  attr_accessor
    :input\r\n\r\n  def each\r\n    File.foreach(input) { |e| yield(e.chomp.to_i)
    }\r\n  end\r\nend\r\n\r\nputs StatisticalReport.new(\"numbers.txt\")\r\n```\r\n\r\nUsing
    module mixins does not improve the encapsulation of the components in the system
    or solve the problem of `StatisticalReport` inheriting methods that aren't directly
    related to its problem domain, but it does alleviate some of the other problems
    that Ruby's class-based inheritance causes. In particular, it makes it no longer
    possible to create instances of objects that wouldn't be useful to use as standalone
    objects and also loosens the dependencies between the components in the system.\r\n\r\nAlthough
    the `Statistics` and `SimplifiedEnumerable` modules are still not capable of doing
    anything useful without being tied to some other object, the relationship between
    them is much looser. When the two are mixed into the `StatisticalReport` object,
    an implicit relationship between `Statistics` and `SimplifiedEnumerable` exists
    due to the calls to `reduce` and `count` from within the `Statistics` module,
    but this relationship is an implementation detail rather than a structural constraint.
    To see the difference yourself, think about how easy it would be to switch `StatisticalReport`
    to use Ruby's `Enumerable` module instead of the `SimplifiedEnumerable` module
    I provided and compare that to the class-based implementation of this scenario.\r\n\r\nThe
    bad news is that the way that modules solve some of the problems that we discovered
    about class hierarchies in Ruby ends up making some of the other problems even
    worse. Because modules tend to provide a whole lot of functionality based on a
    very thin contract with the object they get mixed into, they are one of the leading
    causes of child obesity. For example, swapping my `SimplifiedEnumerable` module
    for Ruby's `Enumerable` method would cause a net increase of 42 new methods that
    could be directly called on `StatisticalReport`. And now, rather than having a
    single path to follow in `StatisticalReport` to determine its ancestry chain,
    there are two. A nice feature of mixins is that they have fairly simple rules
    about how they get added to the method lookup path to avoid some of the complexities
    involved in class-based multiple inheritance, but you still need to memorize those
    rules and be aware of the combinatorial effects of module inclusion.\r\n\r\nAs
    it turns out, modules are a pragmatic compromise that is convenient to use but
    only slightly more well-behaved than traditional class inheritance. In simple
    situations, they work just fine, but for more complex systems they end up requiring
    an increasing amount of discipline to use effectively. Nonetheless, modules tend
    to be used ubiquitously in Ruby programs despite these problems. A nave observer
    might assume that this is a sign that we don't have a better way of doing things
    in Ruby, but they would be mostly wrong.\r\n\r\nAll the problems discussed so
    far with inheritance can be solved via simple aggregation techniques. For strong
    evidence of that claim, take a look at the refactored code shown here. As in the
    previous examples, keep an eye out for the pros and cons of this modeling strategy,
    and think about what you might do differently.\r\n\r\n```ruby\r\nclass StatisticalCollection\r\n
    \ def initialize(data)\r\n    self.data = data\r\n  end\r\n\r\n  def sum\r\n    data.reduce(:+)
    \r\n  end\r\n\r\n  def average\r\n    sum / data.count.to_f\r\n  end \r\n\r\n
    \ private\r\n\r\n  attr_accessor :data\r\nend\r\n\r\nclass StatisticalReport\r\n
    \ def initialize(filename)\r\n    self.input = filename\r\n    \r\n    self.stats
    = StatisticalCollection.new(each)\r\n  end\r\n\r\n  def to_s\r\n    \"The sum
    is #{stats.sum}, and the average is #{stats.average}\"\r\n  end\r\n\r\n  private
    \r\n\r\n  attr_accessor :input, :stats\r\n\r\n  def each\r\n    return to_enum(__method__)
    unless block_given?\r\n\r\n    File.foreach(input) { |e| yield(e.chomp.to_i) }\r\n
    \ end\r\nend\r\n\r\nputs StatisticalReport.new(\"numbers.txt\")\r\n```\r\n\r\nThe
    first thing you'll notice is that the code is much shorter, as if by magic, but
    really it's because I completely cheated here and got rid of my counterfeit `Enumerable`
    object so that I could expose a potentially good idiom for dealing with iteration
    in an aggregation-friendly way. Feel free to mentally replace the object passed
    to `StatisticalCollection`'s constructor with something like the code shown here
    if you don't want me to get away with parlor tricks:\r\n\r\n```ruby\r\nrequire
    \"forwardable\"\r\n\r\nclass EnumerableCollection\r\n  extend Forwardable\r\n\r\n
    \ # Forwardable bypasses privacy, which is what we want here.\r\n  delegate :each
    => :data\r\n\r\n  def initialize(data)\r\n    self.data = data\r\n  end\r\n\r\n
    \ def count\r\n    c = 0\r\n    each { |e| c += 1 }\r\n    c\r\n  end\r\n\r\n
    \ # Samnang's implementation from Issue 2.4\r\n  def reduce(arg=nil) \r\n    return
    reduce {|s, e| s.send(arg, e)} if arg.is_a?(Symbol)\r\n\r\n    result = arg\r\n
    \   each { |e| result = result ? yield(result, e) : e }\r\n\r\n    result\r\n
    \ end\r\n\r\n  private\r\n\r\n  attr_accessor :data\r\nend\r\n```\r\n\r\nRegardless
    of what iteration strategy we end up using, the following points are worth noting
    about the way we've modeled our system this time around:\r\n\r\n1. There are three
    components in this system, all of which are useful and testable as standalone
    objects.\r\n\r\n2. The relationships between all three components are purely indirect,
    and the coupling between the objects is limited to the names and behavior of the
    methods called on them rather than their complete surfaces.\r\n\r\n3. There is
    strict encapsulation between the three components: each have their own namespace,
    and each can enforce their own privacy controls. It's possible of course to side-step
    these protections, but they are at least enabled by default. The issue of accidental
    naming collisions between methods or variables of objects is completely eliminated.\r\n\r\n4.
    As a result of points 2 and 3, the surface of each object is kept narrowly in
    line with its own domain. In fact, the public interface of `StatisticalReport`
    has been reduced to its constructor and the `to_s` method, making it about as
    thin as possible while still being useful. \r\n\r\nThere are certainly downsides
    to using aggregation; it is not a golden hammer by any means. But when it comes
    to **incidental inheritance**, it seems to be the right tool for the job more
    often than not. I'd love to hear counterarguments to this claim, though, so please
    do share them if you have something in mind that you don't think would gracefully
    fit this style of modeling.\r\n\r\n### Reflections\r\n\r\nAlthough it may be a
    bit hard to see why disciplined inheritance matters in the trivial scenario we've
    been talking about throughout this article, it become increasingly clear as systems
    become more complex. Most scenarios that involve incidental inheritance are actually
    relatively horizontal problems in nature, but the use of class-based inheritance
    or module mixins forces a vertical method lookup path that can become very unwieldy,
    to say the least. When taken to the extremes, you end up with objects like `ActiveRecord::Base`,
    which has a path that is 43 levels deep, or `Prawn::Document`, which has a 26-level-deep
    path. In the case of Prawn, at least, this is just pure craziness that I am ashamed
    to have unleashed upon the world, even if it seemed like a good idea at the time.\r\n\r\nIn
    a language like Ruby that lacks both multiple inheritance and true class-specific
    privacy for variables and methods, using class-based hierarchies or module mixins
    for complex forms of incidental inheritance requires a tremendous amount of discipline.
    For that reason, the extra effort involved in refactoring towards an aggregation-based
    design pales in comparison to the maintenance headaches caused by following the
    traditional route. For example, in both `Prawn` and `ActiveRecord`, aggregation
    would make it possible to flatten that chain by an order of magnitude while simultaneously
    reducing the chance of namespace collisions, dependencies on lookup order, and
    accidental side effects due to state mutations. It seems like the cost of somewhat
    more verbose code would be well worth it in these scenarios.\r\n\r\nIn Issue 3.8,
    we will move on to discuss an essential form of inheritance that Sakkinen refers
    to as **completely consistent inheritance**. Exploring that topic will get us
    closer to the concept of mathematical subtypes, which are much more interesting
    at the theoretical level than incidental inheritance relationships are. But because
    Ruby's language features make even the simple relationships described in this
    issue somewhat challenging to manage in an elegant way, I am still looking forward
    to hearing your ideas and questions about the things I've covered so far.\r\n\r\nA
    major concern I have about incidental inheritance is that I still don't have a
    clear sense of where to draw the line between the two extremes I've outlined in
    this article. I definitely want to look further into this area, so please leave
    a comment if you don't mind sharing your thoughts on this."
- :slug: disciplined-inheritance-2
  :title: Criteria for disciplined inheritance, Part 2
  :summary: Discover how Barbara Liskov's concept of "behavioral subtypes" apply to
    object modeling in Ruby.
  :published: 2012-02-21 00:00:00.000000000 Z
  :issue_number: '3.8'
  :volume: 3
  :body: "In [Issue 3.7](http://practicingruby.com/articles/24), I started to explore
    the criteria laid out by Sakkinen's\r\n[Disciplined Inheritance](http://scholar.google.com/scholar?cluster=5893037045851782349&hl=en&as_sdt=0,7&sciodt=0,7),
    \r\na language-agnostic paper published more than two decades ago that is surprisingly
    \r\nrelevant to the modern Ruby programmer. In this issue, we continue where Issue
    3.7 \r\nleft off: on the question of how to maintain complete compatibility between\r\nparent
    and child objects in inheritance-based domain models. Or, to put it another way,\r\nthis
    article explores how to reuse code safely within a system\r\nwithout it becoming
    a maintenance nightmare.\r\n\r\nAfter taking a closer look at what Sakkinen exposed
    regarding this topic, I came to\r\nrealize that the ideas he presented were strikingly
    similar to the [Liskov Substitution\r\nPrinciple](http://en.wikipedia.org/wiki/Liskov_Substitution_Principle).
    In fact,\r\nthe extremely dynamic nature of Ruby makes \r\nestablishing [a behavioral
    notion of subtyping](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.1223)
    (Liskov and Wing 1993)\r\na prerequisite for developing disciplined inheritance
    practices. \r\nAs a result, this article refers to Liskov's work more than Sakkinen's,
    \r\neven though both papers have extremely interesting things to say on this topic.
    \r\n\r\n### Defining a behavioral subtype \r\n\r\nBoth Sakkinen and Liskov describe
    the essence of the inheritance relationship as \r\nthe ability of a child object
    to serve as a drop-in replacement wherever\r\nits parent object can be used. I've
    greatly simplified the concept by\r\nstating it in such a general fashion, but
    this is the thread that ties\r\ntheir independent works together. \r\n\r\nLiskov
    goes a step farther than Sakkinen by defining two kinds of \r\nbehavioral subtypes:
    children that extend the behavior specified by their \r\nparents, and children
    that constrain the behavior specified by their parents. \r\nThese concepts are
    not mutually exclusive, but because each brings up\r\nits own set of challenges,
    it is convenient to separate them in this\r\nfashion.\r\n\r\nBoth Sakkinen and
    Liskov emphasize that the abstract concept of subtyping \r\nis  much more about
    the observable behavior of objects than it is about\r\nwhat exactly is going on
    under the hood. This concept is a natural way of thinking\r\nfor Rubyists, and
    it is worth keeping in mind as you read through the rest\r\nof this article. In
    particular, when we talk about the type of an object,\r\nwe are focusing on what
    that object *does*, not what it *is*.\r\n\r\nAlthough the concept of a behavioral
    subtype sounds like a direct analogue for\r\nwhat we commonly refer to as \"duck
    typing\" in Ruby, the former is about\r\nthe full contract of an object rather
    than how it acts under certain\r\ncircumstances. I go into more detail about the
    differences between\r\nthese concepts toward the end of this article,\r\nbut before
    we can discuss them meaningfully, we need to take a look\r\nat Liskov's two types
    of behavioral subtyping and how they can\r\nbe implemented.\r\n\r\n### Behavioral
    subtypes as extensions\r\n\r\nWhether you realize it or not, odds are good that
    you are already familiar with using behavioral subtypes as extensions. Whenever
    we inherit from `ActiveRecord::Base` or mix `Enumerable` into one of our objects,
    we're making use of this concept. In essence, the purpose of an extension is to
    bolt new behavior on top of an existing type to form a new subtype.\r\n\r\nTo
    ensure that our child objects maintain the substitution principle, we need to
    make sure that any new behavior and modifications introduced by extensions follow
    a few simple rules. In particular, all new functionality must be either completely
    transparent to the parent object or defined in terms of the parent object's functionality.
    Changing the signature of a method provided by the parent object would be considered
    an incompatible change, as would directly modifying instance variables referenced
    by the parent object. These strict rules may seem like overkill, but they are
    the only way to guarantee that your extended subtypes will be drop-in replacements
    for their supertypes.\r\n\r\nIn practice, obeying these rules is not as hard as
    it seems. For example, suppose we wanted to extend `Prawn::Document` so that it
    implements some helpers for article typesetting:\r\n\r\n```ruby\r\nPrawn::Article.generate(\"test.pdf\")
    do\r\n  h1 \"Criteria for Disciplined Inheritance\"\r\n \r\n  para %{\r\n    This
    is an example of building a Prawn-based article\r\n    generator through the use
    of a behavioral subtype as\r\n    an extension. It's about as wonderful and self-referential\r\n
    \   as you might expect.\r\n  }\r\n\r\n  h2 \"Benefits of behavioral subtyping\"\r\n\r\n
    \ para %{\r\n    The benefits of behavioral subtyping cannot be directly\r\n    known
    without experiencing them for yourself.\r\n  }\r\n\r\n  para %{\r\n    But if
    you REALLY get stuck, try asking Barbara Liskov.\r\n  }\r\nend\r\n```\r\n\r\nThe
    most simple way to implement this sort of domain language would be to create a
    subclass of `Prawn::Document`, as shown in the following example:\r\n\r\n```ruby\r\nmodule
    Prawn\r\n  class Article < Document\r\n    include Measurements\r\n\r\n    def
    h1(contents)\r\n      text(contents, :size => 24)\r\n      move_down in2pt(0.3)\r\n
    \   end\r\n\r\n    def h2(contents)\r\n      move_down in2pt(0.1)\r\n      text(contents,
    :size => 16)\r\n      move_down in2pt(0.2)\r\n    end\r\n\r\n    def para(contents)\r\n
    \     text(contents.gsub(/\\s+/, \" \"))\r\n      move_down in2pt(0.1)\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nAs far as Liskov is concerned, `Prawn::Article` is
    a perfectly legitimate extension because instances of it are drop-in substitutes
    for `Prawn::Document` objects. In fact, this sort of extension is trivial to prove
    to be a behavioral subtype because it is defined purely in terms of public methods
    that are provided by its parents (`Prawn::Document` and `Prawn::Measurements`).
    Because the functionality added is so straightforward, the use of subclassing
    here might just be the right tool for the job. \r\n\r\nThe downside of using subclassing
    is that even minor alterations to program requirements can cause encapsulation-related
    issues to become a real concern. For example, if we decide that we want to add
    a pair of instance variables that control the fonts used for headers and paragraphs,
    it would be hard to guarantee that these variables wouldn't clash with the data
    contained within `Prawn::Document` objects. We can assume that calls to public
    methods provided by the parent object are safe, but we cannot say the same about
    referencing instance variables, so a delegation-based model starts to look more
    appealing.\r\n\r\nSuppose we wanted to support the following API, but through
    the use of delegation rather than subclassing:\r\n\r\n```ruby\r\nPrawn::Article.generate(\"test.pdf\")
    do\r\n  header_font    \"Courier\"\r\n  paragraph_font \"Helvetica\"\r\n\r\n  h1
    \"Criteria for Disciplined Inheritance\"\r\n \r\n  para %{\r\n    This is an example
    of building a Prawn-based article\r\n    generator through the use of a behavioral
    subtype as\r\n    an extension. It's about as wonderful and self-referential\r\n
    \   as you might expect.\r\n  }\r\n\r\n  h2 \"Benefits of behavioral subtyping\"\r\n\r\n
    \ para %{\r\n    The benefits of behavioral subtyping cannot be directly\r\n    known
    without experiencing them for yourself.\r\n  }\r\n\r\n  para %{\r\n    But if
    you REALLY get stuck, try asking Barbara Liskov.\r\n  }\r\nend\r\n```\r\n\r\nUsing
    a `method_missing` hook and a bit of manual delegation for the `Prawn::Article.generate`
    class method, it is fairly easy to implement this DSL:\r\n\r\n```ruby\r\nmodule
    Prawn\r\n  class Article\r\n    def self.generate(*args, &block)\r\n      Prawn::Document.generate(*args)
    do |pdf|\r\n        new(pdf).instance_eval(&block)\r\n      end\r\n    end\r\n\r\n
    \   def initialize(document)\r\n      self.document = document      \r\n      document.extend(Prawn::Measurements)\r\n\r\n
    \     # set defaults so that @paragraph_font and @header_font are never nil.\r\n
    \     paragraph_font \"Times-Roman\"\r\n      header_font    \"Times-Roman\"\r\n
    \   end\r\n\r\n    def h1(contents)\r\n      font(header_font) do\r\n        text(contents,
    :size => 24)\r\n        move_down in2pt(0.3)\r\n      end\r\n    end\r\n\r\n    def
    h2(contents)\r\n      font(header_font) do\r\n        move_down in2pt(0.1)\r\n
    \       text(contents, :size => 16)\r\n        move_down in2pt(0.2)\r\n      end\r\n
    \   end\r\n\r\n    def para(contents)\r\n      font(paragraph_font) do\r\n        text(contents.gsub(/\\s+/,
    \" \"))\r\n        move_down in2pt(0.1)\r\n      end\r\n    end\r\n\r\n    def
    paragraph_font(font=nil)\r\n      return @paragraph_font = font if font\r\n\r\n
    \     @paragraph_font\r\n    end\r\n\r\n    def header_font(font=nil)\r\n      return
    @header_font = font if font\r\n\r\n      @header_font\r\n    end\r\n\r\n    def
    method_missing(id, *args, &block)\r\n      document.send(id, *args, &block)\r\n
    \   end\r\n\r\n    private\r\n\r\n    attr_accessor :document\r\n  end\r\nend\r\n```\r\n\r\nTaking
    this approach involves writing more code and adds some complexity. However, that
    is a small price to pay for the peace of mind that comes with cleanly separating
    the data contained within the `Prawn::Article` and `Prawn::Document` objects.
    This design also makes it harder for `Prawn::Article` to have name clashes with
    `Prawn::Document`'s private methods and forces any private method calls to `Prawn::Document`
    to be done explicitly. Because transparent delegation exposes the full contract
    of the parent object, it is still necessary for the child object to maintain full
    compatibility with those methods in the same manner that a class-inheritance-based
    model would. Nonetheless, this pattern provides a safer way to implement subtypes
    because it avoids incidental clashes, which could otherwise occur easily.\r\n\r\nAlthough
    the examples we've looked at so farcombined with your own experiencesshould
    give you a good sense of how to extend code via behavioral subtypes, there are
    some common pitfalls I have glossed over in order to keep things simple. I'll
    get back to those before the end of the article, but for now let's turn our attention
    to the other kind of subtypes Liskov describes in her paper. She refers to them
    as _constrained subtypes_, but I call them _restriction subtypes_ as an easy-to-remember
    mirror image of the _extension subtype_ concept.\r\n\r\n### Behavioral subtypes
    as restrictions\r\n\r\nJust as subtypes can be used to extend the behavior of
    a supertype, they can also be used to restrict generic behaviors by providing
    more specific implementations of them. The example Liskov uses in her paper illustrates
    how a stack structure can be viewed as a restriction on the more general concept
    of a bag.\r\n\r\nIn its most simple form, a bag is essentially nothing more than
    a set that can contain duplicates. Items can be added and removed from a bag,
    and it is possible to determine whether the bag contains a given item. However,
    much like with a set, order is not guaranteed. The following code, which is somewhat
    of a contrived example, implements a `Bag` object similar to the one described
    in Liskov's paper:\r\n\r\n```ruby\r\nContainerFullError  = Class.new(StandardError)\r\nContainerEmptyError
    = Class.new(StandardError)\r\n\r\nclass Bag\r\n  def initialize(limit)\r\n    self.items
    \ = [] \r\n    self.limit = limit\r\n  end\r\n\r\n  def push(obj)\r\n    raise
    ContainerFullError unless data.length < limit\r\n\r\n    data.shuffle!\r\n    data.push(obj)\r\n
    \ end\r\n\r\n  def pop\r\n    raise ContainerEmptyError if data.empty?\r\n\r\n
    \   data.shuffle!\r\n    data.pop\r\n  end\r\n\r\n  def include?(obj)\r\n    data.include?(obj)\r\n
    \ end\r\n\r\n  private\r\n\r\n  attr_accessor :items, :limit\r\nend\r\n```\r\n\r\nThe
    challenge in determining whether a `Stack` object can meaningfully be considered
    a subtype of this sort of structure is that we need to find a way to describe
    the functionality of a bag so that it is general enough to allow for interesting
    subtypes to exist but specific enough to allow the `Bag` object to be used on
    its own in a predictable way. Because Ruby lacks the design-by-contract features
    that Liskov depends on in her paper, we need to describe this specification verbally
    rather than relying on our tools to enforce them for us. Something like the following
    list of rules is roughly similar to what she describes more formally in her work:\r\n\r\n1)
    A bag has `items` and a size `limit`.\r\n\r\n2) A bag has a `push` operation,
    which adds a new object to the bag's `items`.\r\n\r\n* If the current number of
    `items` is less than the `limit`, the new object is added to the bag's `items`.\r\n\r\n*
    Otherwise, a `ContainerFullError` is raised.\r\n\r\n3) A bag has a `pop` operation,
    which removes an object from the bag's `items` and returns it as a result.\r\n\r\n*
    If the bag has no `items`, a `ContainerEmptyError` is raised.\r\n\r\n* Otherwise,
    one object is removed from the bag's `items` and returned.\r\n\r\n4) A bag has
    an `include?` operation, which indicates whether the provided object is one of
    bag's `items`.\r\n\r\n* If the bag's `items` contains the provided object, `true`
    is returned.\r\n\r\n* Otherwise, `false` is returned.\r\n\r\nWith these rules
    in mind, we can see that the following `Stack` object satisfies the definition
    of a bag while simultaneously introducing a predictable ordering to `items`:\r\n\r\n```ruby\r\nContainerFullError
    \ = Class.new(StandardError)\r\nContainerEmptyError = Class.new(StandardError)\r\n\r\nclass
    Stack\r\n  def initialize(limit)\r\n    self.items  = [] \r\n    self.limit =
    limit\r\n  end\r\n\r\n  def push(obj)\r\n    raise ContainerFullError unless data.length
    < limit\r\n\r\n    data.push(obj)\r\n  end\r\n\r\n  def pop\r\n    raise ContainerEmptyError
    if data.empty?\r\n\r\n    data.pop\r\n  end\r\n\r\n  def include?(obj)\r\n    data.include?(obj)\r\n
    \ end\r\n\r\n  private\r\n\r\n  attr_accessor :items, :limit\r\nend\r\n```\r\n\r\nWith
    this example code in mind, we can specify the behavior of a stack in the following
    way:\r\n\r\n1) A stack is a bag.\r\n\r\n2) A stack's `pop` operation follows a
    last-in, first-out (LIFO) order.\r\n\r\nBecause the ordering requirements of a
    stack don't conflict with the defining characteristics of a bag, a stack can be
    substituted for a bag without any issues. The key thing to keep in mind here is
    that restriction subtypes can create additional constraints on top of what was
    specified by their supertypes but cannot loosen the constraints put upon them
    by their ancestors in any way. For example, based on the way we defined bag objects,
    we would not be able to return `nil` instead of raising `ContainerEmptyError`
    when `pop` is called on an empty stack, even if that seems like a fairly innocuous
    change.\r\n\r\nOnce again, maintaining this sort of discipline may seem on the
    surface to be more trouble than it is worth. However, these kinds of assumptions
    are baked into useful patterns such as the [template method pattern](http://en.wikipedia.org/wiki/Template_method_pattern)
    and are also key to designing type hierarchies for all sorts of data structures.
    A good example of these concepts in action can be found in the way Ruby organizes
    its numeric types. The class hierarchy is shown here, but be sure to check out
    Ruby's documentation if you want to get a sense of how exactly these classes hang
    together.\r\n\r\n<img src=\"http://i.imgur.com/ObKrf.jpg\" width=800/>\r\n\r\nWhether
    you are designing extension subtypes or restriction subtypes, it is unfortunately
    easier to get things wrong than it is to get them right, due to all the subtle
    issues that need to be considered. For that reason, we'll now take a look at a
    few examples of flawed behavioral subtypes and how to go about fixing them.\r\n\r\n###
    Examples of flawed behavioral subtypes\r\n\r\nTo test your understanding of behavior
    subtype compatibility while simultaneously exposing some common pitfalls, I provide
    the following three flawed examples for you to study. As you read through them,
    try to figure out what the subtype compatibility problem is and how you might
    go about solving it.\r\n\r\n1) Suppose we want to add an equality operator to
    the bag structure. A sample operator is provided here for the `Bag` object, which
    conforms to the following newly specified\r\nfeature: \"Two bags are considered
    equal if they have equivalent items and size limits\". What problems will we encounter
    in implementing a bag-compatible equality operator for the `Stack` object? \r\n\r\n```ruby\r\nclass
    Bag\r\n  # other code similar to before\r\n\r\n  def ==(other)\r\n    [data.sort,
    limit] == [other.sort, other.limit]\r\n  end\r\n\r\n  protected \r\n  \r\n  #
    NOTE: Implementing == is one of the few legitimate uses of \r\n  # protected methods
    / attributes\r\n  attr_accessor :data, :limit\r\nend\r\n```\r\n\r\n2) Suppose
    we have two mutable objects, a `Rectangle` and a `Square`, and we wish to implement
    `Square` as a restriction of `Rectangle`. Given the following implementation of
    a `Rectangle` object, what problems will be encountered in defining a `Square`
    object?\r\n\r\n```ruby\r\nclass Rectangle\r\n  def area\r\n    width * height\r\n
    \ end\r\n\r\n  attr_accessor :width, :height\r\nend\r\n```\r\n\r\n3) Suppose we
    have a `PersistentSet` object that delegates all method calls to the `Set` object
    provided by Ruby's standard library, as shown in the following code. Why is this
    not a compatible subtype, even though it does not explicitly modify the behavior
    of any of `Set`'s operations?\r\n\r\n```ruby\r\nrequire \"set\"\r\nrequire \"pstore\"\r\n\r\nclass
    PersistentSet \r\n  def initialize(filename)\r\n    self.store = PStore.new(filename)\r\n\r\n
    \   store.transaction { store[:data] ||= Set.new }\r\n  end\r\n\r\n  def method_missing(name,
    *args, &block)\r\n    store.transaction do \r\n      store[:data].send(name, *args,
    &block)\r\n    end\r\n  end\r\n\r\n  private\r\n\r\n  attr_accessor :store\r\nend\r\n```\r\n\r\nTo
    avoid spoiling the fun of finding and fixing the defects with these examples yourself,
    I've hidden my explanation of the [problems](https://gist.github.com/15b50f918c88bccd6eac)
    and [solutions](https://gist.github.com/3f53d4094759c0508e19) on a pair of gists.
    Please spend some time on this exercise before reading the spoilers, as you'll
    learn a lot more that way!\r\n\r\nA huge hint is that the first problem is based
    on an issue discussed in [Liskov's paper](http://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf)
    and the second and third problems are discussed in an [article about LSP](http://www.objectmentor.com/resources/articles/lsp.pdf)
    by Bob Martin. However, please note that their solutions are not exactly the most
    natural fit for Ruby, so there is still room for some creativity here.\r\n\r\n###
    Behavioral subtyping versus duck typing\r\n\r\nBetween this article and the topics
    discussed in [Issue 3.7](http://practicingruby.com/articles/24), this two-part
    series offers a fairly comprehensive view of disciplined inheritance practices
    for the Ruby programmer. However, as I hinted toward the beginning of this article,
    there is the somewhat looser concept of duck typing that deserves a mention if
    we really want to see the whole picture.\r\n\r\nWhat duck typing and behavioral
    subtypes have in common is that both concepts rely on what an object can do rather
    than what exactly it is. They differ in that behavioral subtypes seem to be more
    about the behavior of an entire object and duck typing is about how a given object
    behaves within a certain context. Duck typing can be a good deal more flexible
    than behavioral subtyping in that sense, because typically it involves an object
    implementing a meaningful response to a single message rather than an entire suite
    of behaviors. You can find a ton of examples of duck typing in use in Ruby, but
    perhaps the easiest to spot is the ubiquitous use of the `to_s` method.\r\n\r\nBy
    implementing a `to_s` method in our objects, we are able to indicate to Ruby that
    our object has a meaningful string representation, which can then be used in a
    wide range of contexts. Among other things, the `to_s` method is automatically
    called by irb when an `inspect` method is not also provided, called by the `Kernel#puts`
    method on whatever object you pass to it, and called automatically on the result
    of any expression executed via string interpolation. Implementing a meaningful
    `to_s` method is not exactly a form of behavioral subtyping but is still a very
    useful form of code sharing. [Issue 1.14](http://blog.rubybestpractices.com/posts/gregory/046-issue-14-duck-typing.html)
    and [Issue 1.15](http://blog.rubybestpractices.com/posts/gregory/047-issue-15-duck-typing-2.html)
    cover duck typing in great detail, but this single example is enough to point
    out the merits of this technique and how much simpler it is than the topics discussed
    in this article.\r\n\r\n### Reflections\r\n\r\nA true challenge for any practicing
    Rubyist is finding a balance between the free-wheeling culture of Ruby development
    and the more rigorous approaches of our predecessors. Disciplined inheritance
    techniques will make our lives easier, and knowing what a behavioral subtype is
    and how to design one will surely come in handy on any moderately complex project.
    However, we should keep our eyes trained on how these issues relate to maintainability,
    understandability, and changeability rather than obsessing about how they can
    lead us to mathematically pure designs.\r\n\r\nI think there is room for another
    article on the practical applications of these ideas, in which I might talk about
    applying some design-by-contract concepts to Ruby programs or how to develop shared
    unit tests that make it easier to test for compatibility when implementing subtypes.
    But I don't plan to work on that article immediately, so for now we can sort out
    those issues via comments on this article. If you have any suggestions for how
    to tie these ideas back to real problems, or questions on how to apply them to
    the things you've been working on, please share your thoughts. "
- :slug: using-games-to-practice-domain-modeling
  :title: Using games to practice domain modeling
  :summary: Learn about modeling non-trivial business logic by implementing Minecraft's
    crafting table.
  :published: 2012-02-28 00:00:00.000000000 Z
  :issue_number: '3.9'
  :volume: 3
  :body: "As programmers, it is literally our job to make [domain models](http://en.wikipedia.org/wiki/Domain_model)
    understandable to computers. While this can be some of the most creative work
    we do, it also tends to be the most challenging. The inherent difficulty of designing
    and implementing conceptual models leads many to develop their problem solving
    skills through a painful process of trial and error rather than some form of deliberate
    practice. However, that is a path paved with sorrows, and we can do better.\r\n\r\nDefining
    problem spaces and navigating within them does get easier as you become more experienced.
    But if you only work with complex domain models while you are knee deep in production
    code, you'll find that many useful modeling patterns will blend in with application-specific
    details and quickly fade into the background without being noticed. Instead, what
    is needed is a testbed for exploring these ideas that is complex enough to mirror
    some of the problems you're likely to encounter in your daily work, but inconsequential
    enough to ensure that your practical needs for working code won't get in the way
    of exploring new ideas. \r\n\r\nWhile there are a number of ways to create a good
    learning environment for studying domain modeling, my favorite approach is to
    try to clone bits of functionality from various games I play when I'm not coding.
    In this article, I'll walk you through an example of this technique by demonstrating
    how to model a simplified version of the [Minecraft crafting system](http://www.minecraftwiki.net/wiki/Crafting).\r\n\r\n###
    Defining the problem space\r\n\r\n> **NOTE:** Those who haven't played Minecraft
    before may want to spend a few minutes watching this video [tutorial about crafting](http://www.youtube.com/watch?v=AKktiCsCPWE)
    or skimming [the game's wiki page](http://www.minecraftwiki.net/wiki/Crafting)
    on the topic before continuing. However, because I only focus on a few very basic
    ideas about the system for this exercise, you don't need to be a Minecraft player
    in order to enjoy this article.\r\n\r\nThe crafting table is a key component in
    Minecraft because it provides the player with a way to turn natural resources
    into useful tools, weapons, and construction materials. Stripped down to its bare
    essence, the function of the crafting table is essentially to convert various
    input items laid out in a 3x3 grid into some quantity of a different type of item.
    For example, a single block of wood can be converted into four wooden planks,
    a pair of wooden planks can be combined to produce four sticks, and a stick combined
    with a piece of coal will produce four torches. Virtually all objects in the Minecraft
    world can be built in this fashion, as long as the player has the necessary materials
    and knows the rules about how to combine them together. \r\n\r\nBecause positioning
    of input items within the crafting table's grid is significant, players need to
    make use of recipes to learn how various input items can be combined to produce
    new objects. To make recipes easier for the player to memorize, the game allows
    for a bit of flexibility in the way things are arranged, as long as the basic
    structure of the layout is preserved. In particular, the input items for recipes
    can be horizontally and vertically shifted as long as they remain within the 3x3
    grid, and the system also knows how to match mirror images as well. However, after
    accounting for these variants, there is a direct mapping from the inputs to the
    outputs in the crafting system.\r\n\r\nAs of 2012-02-27, Minecraft supports 174
    crafting recipes. This is a small enough number where even a nave data model
    would likely be fast enough to not cause any usability problems, even if you consider
    the fact that most of those recipes can be shifted around in various ways. But
    in the interest of showing off some neat Ruby data modeling tricks, I've decided
    to try to implement this model in an efficient way. In doing so, I found out that
    inputs can be checked for corresponding outputs in constant time, and that there
    are some useful constraints that make it so that only a few variants need to be
    checked in most cases in order to find a match for the player's input items.\r\n\r\nMy
    [finished model](https://github.com/elm-city-craftworks/crafting_table) ended
    up consisting of three parts: A `Recipe` object responsible for codifying the
    layout of input items and generating variants based on that layout, a `Cookbook`
    object which maps recipes to their outputs, and an `Importer` object which generates
    a cookbook object from CSV formatted recipe data. In the following sections, I
    will take a look at each of these objects and point out any interesting details
    about them.\r\n\r\n### Modeling recipes \r\n\r\n> **NOTE:** To keep my implementation
    code easy to follow, I have simplified the recipe model somewhat so that it does
    not consider mirror images of recipes to be equivalent. Implementing that sort
    of behavior could be a fun exercise for the reader, and would make this model
    a closer match to what Minecraft actually implements.\r\n\r\nThe challenge involved
    in modeling Minecraft recipes is that you need to treat horizontal and vertically
    shifted item sets as being equivalent to one other. Or in other words, as long
    as the shape of an item set is preserved, there is a bit of flexibility about
    where you can place items on the table. For example, all of the recipes below
    are considered to be equivalent to one another:\r\n\r\n![](http://i.imgur.com/HSop9.png)\r\n\r\nA
    nave approach to the problem will lead you to checking up to 25 variants for
    each recipe, only to find out that most of them are invalid mutations of the original
    item set that place at least one item outside of the 3x3 grid. Some simple checks
    can be put in place to throw out invalid variants, but it is better to never generate
    them at all. \r\n\r\n> **UPDATE 2012-03-01**: Based on a suggestion by [Shane
    Emmons](http://community.mendicantuniversity.org/people/semmons99), I worked on
    a better approach to this problem after this article was published. The basic
    idea is that rather than generating recipe variants, you instead normalize the
    recipes into a single common layout on demand. Check out the [updated code here](https://github.com/elm-city-craftworks/crafting_table/blob/607a4d8fc958c2e746b899c43b5cbb01301b3c6b/lib/crafting_table/recipe.rb).
    The solution described below is still interesting though, so feel free to read
    on anyway!\r\n\r\nThe approach I ended up taking is to compute margins surrounding
    each item that indicate how they can be shifted. As each new item gets added to
    the recipe, its margins and the margins of the current item set are intersected
    to obtain a new set of boundaries. The following diagram demonstrates the process
    of adding three items (B, C, A) to the grid sequentially, with each newly added
    item reducing the number of equivalent recipes that can be generated:\r\n\r\n![](http://i.imgur.com/SEen2.png)\r\n\r\nThis
    process is very efficient because it involves simple numerical computations at
    insert time, rather than processing the whole item set at once. With that in mind,
    my implementation of `Recipe#[]=` updates the margins for the item set right away
    whenever a new item is added:\r\n\r\n```ruby\r\nrecipe[0,0] = \"B\"\r\np recipe.send(:margins)
    #=> {:top=>2, :left=>0, :right=>2, :bottom=>0}\r\n\r\nrecipe[1,0] = \"C\"\r\np
    recipe.send(:margins) #=> {:top=>2, :left=>0, :right=>1, :bottom=>0} \r\n\r\nrecipe[0,1]
    = \"A\"\r\np recipe.send(:margins) #=> {:top=>1, :left=>0, :right=>1, :bottom=>0}
    \r\n```\r\n\r\nThe following code shows how `Recipe#[]=` is implemented. In particular,
    it demonstrates that item set margins are directly updated on insert, but variant
    layouts are not generated until later.\r\n\r\n```ruby\r\nmodule CraftingTable\r\n
    \ class Recipe\r\n    TABLE_WIDTH = 3\r\n    TABLE_HEIGHT = 3\r\n\r\n    def initialize\r\n
    \     self.ingredients = {}\r\n      self.margins     = { :top    => Float::INFINITY,
    \r\n                           :left   => Float::INFINITY, \r\n                           :right
    \ => Float::INFINITY,\r\n                           :bottom => Float::INFINITY
    }\r\n\r\n      self.variants = Set.new\r\n      self.variants_need_updating =
    false\r\n    end\r\n\r\n    # ... various unrelated details omitted ...\r\n\r\n
    \   def []=(x,y,ingredient_type)\r\n      raise ArgumentError unless (0...TABLE_WIDTH).include?(x)\r\n
    \     raise ArgumentError unless (0...TABLE_HEIGHT).include?(y)\r\n\r\n      #
    storing positions as vectors makes variant computations easier\r\n      ingredients[Vector[x,y]]
    = ingredient_type\r\n\r\n      update_margins(x,y)\r\n\r\n      self.variants_need_updating
    = true\r\n    end\r\n\r\n    private\r\n\r\n    attr_accessor :margins, :ingredients,
    :variants_need_updating\r\n\r\n    def update_margins(x,y)\r\n      margins[:left]
    \  = [x,                margins[:left]  ].min\r\n      margins[:right]  = [TABLE_WIDTH-x-1,
    \ margins[:right] ].min\r\n      margins[:bottom] = [y,                margins[:bottom]].min\r\n
    \     margins[:top]    = [TABLE_HEIGHT-y-1, margins[:top]   ].min\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nI deferred the process of generating variants simply
    because doing so at insert time would cause many unnecessary intermediate computations
    to be done for multi-item recipes. While such a small number of possible variations
    pretty much guarantees there won't be performance issues whether or not lazy evaluation
    is used, I wanted to use this situation as a chance to think through how I would
    model variant generation if efficiency was a real concern. In production code,
    premature optimization is the root of all evil, but when you're in deliberate
    practice mode it can be quite fun.\r\n\r\nI ultimately decided to generate the
    variants on demand when two `Recipe` objects are compared to one another. As you
    can see from the following code, my implementation of `Recipe#==` causes both
    recipe objects involved in the test to update their variants if necessary:\r\n\r\n```ruby\r\nmodule
    CraftingTable\r\n  class Recipe\r\n    # ... various unrelated details omitted
    ...\r\n\r\n    def ==(other)\r\n      return false unless self.class == other.class\r\n\r\n
    \     variants == other.variants\r\n    end\r\n\r\n    protected\r\n\r\n    def
    variants\r\n      update_variants if variants_need_updating\r\n\r\n      @variants\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nWhile the high level interface for `Recipe`
    comparison is easy to follow, the way I ended up generating the underlying variant
    data is a bit messy. The implementation details for `Recipe#update_variants` are
    shown below, but the rough idea here is that I compute a set of `valid_offsets`
    and then use them to do vector addition to translate items to different coordinates
    within the grid. After performing this transformation, I wrap the variant data
    in a `Set` object so that they can easily be compared in an order-independent
    fashion. Assuming all this happens successfully, the `variants_need_updating`
    flag gets set to `false` to indicate that the variant data is now up to date.
    \r\n\r\n```ruby\r\nmodule CraftingTable\r\n  class Recipe\r\n    \r\n    # ...
    various unrelated details omitted ...\r\n\r\n    private\r\n\r\n    attr_accessor
    :margins, :ingredients, :variants_need_updating\r\n    attr_writer   :variants\r\n\r\n
    \   def update_variants\r\n      raise InvalidRecipeError if ingredients.empty?\r\n\r\n
    \     variant_data = valid_offsets.map do |x,y|\r\n        ingredients.each_with_object({})
    do |(position, content), variant|\r\n          new_position = position + Vector[x,y]\r\n\r\n
    \         variant[new_position] = content\r\n        end\r\n      end\r\n\r\n
    \     self.variants                  = Set[*variant_data]\r\n      self.variants_need_updating
    \   = false\r\n    end\r\n\r\n    def valid_offsets\r\n      horizontal = (-margins[:left]..margins[:right]).to_a\r\n
    \     vertical   = (-margins[:bottom]..margins[:top]).to_a\r\n\r\n      horizontal.product(vertical)\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nAn interesting thing to note about this
    design is that variants are purely implementation details that are not exposed
    via the public API. While the large amount of code I've shelved in private methods
    seems to indicate that there might be an object to extract here, I like the idea
    that from the outside perspective, the equivalence relationship between recipes
    is established without having to do any sort of explicit check to see whether
    two different layouts share a common variant. To see the true benefits of this
    kind of information hiding, we can take a look at how it affects the design of
    the cookbook.\r\n\r\n### Modeling a cookbook\r\n\r\nOne of the first things I
    noticed about this problem domain was that the mapping of inputs to outputs were
    a natural fit for a hash structure. While it took a while to sort out the details,
    I eventually was able to put together a `Cookbook` object that works in the manner
    shown below:\r\n\r\n```ruby\r\ncookbook     = CraftingTable::Cookbook.new\r\ntorch_recipe
    = CraftingTable::Recipe.new\r\n\r\ntorch_recipe[1,1] = \"coal\"\r\ntorch_recipe[1,0]
    = \"stick\"\r\n\r\ncookbook[torch_recipe] = [\"torch\", 4]\r\n\r\n# ---\r\n\r\nuser_recipe
    = CraftingTable::Recipe.new\r\nuser_recipe[2,2] = \"coal\"\r\nuser_recipe[2,1]
    = \"stick\"\r\n\r\np cookbook[user_recipe] #=> [\"torch\", 4]\r\n```\r\n\r\nThe
    final implementation of this object turned out to be incredibly simple, although
    it required some minor extensions to the `Recipe` object in order to work correctly.
    Take a look at the following class definition to see just how little `CraftingTable::Cookbook`
    is doing under the hood:\r\n\r\n```ruby\r\nmodule CraftingTable\r\n\r\n  # This
    is the complete definition of my Cookbook object, with no omissions!\r\n\r\n  class
    Cookbook\r\n    def initialize\r\n      self.recipes = {}\r\n    end\r\n\r\n    def
    [](recipe)\r\n      recipes[recipe]\r\n    end\r\n\r\n    def []=(recipe, output)\r\n
    \     if recipes[recipe]\r\n        raise ArgumentError, \"A variant of this recipe
    is already defined!\"\r\n      end\r\n\r\n      recipes[recipe] = output\r\n    end\r\n\r\n
    \   private\r\n\r\n    attr_accessor :recipes\r\n  end\r\nend\r\n```\r\n\r\nOn
    the surface, the class seems to have only two tangible features to it: it severely
    narrows the interface to the hash it wraps so that it becomes nothing more than
    a simple key/value store, and it forces single assignment semantics. However,
    when we look at how the object is actually used, we see that there is an implicit
    dependency on some deeper, more domain specific logic. Revisiting the usage example
    from before, you can see that the `Cookbook` object treats variants of the same
    recipes as if they were the same hash key. \r\n\r\n```ruby\r\n# ... unimportant
    boilerplate omitted\r\n\r\ntorch_recipe[1,1] = \"coal\"\r\ntorch_recipe[1,0] =
    \"stick\"\r\n\r\ncookbook[torch_recipe] = [\"torch\", 4]\r\n\r\n# ---\r\n\r\nuser_recipe[2,2]
    = \"coal\"\r\nuser_recipe[2,1] = \"stick\"\r\n\r\np cookbook[user_recipe] #=>
    [\"torch\", 4]\r\n```\r\n\r\nIf you haven't already dug into the source to locate
    where this bit of magic comes from, it has to do with the fact that Ruby provides
    hooks that allow you to use complex objects as hash keys. In particular, customizing
    the way that objects are used as hash keys involves overriding the `Object#hash`
    and `Object#eql?` methods. If you take a closer look at the `Recipe` object, you'll
    see it does define both of these methods:\r\n\r\n```ruby\r\nmodule CraftingTable\r\n
    \ # ... various unrelated details omitted ...\r\n\r\n  class Recipe\r\n    def
    ==(other)\r\n      return false unless self.class == other.class\r\n\r\n      variants
    == other.variants\r\n    end\r\n\r\n    # this is the standard idiom, as in most
    cases == should be the same as eql?\r\n    alias_method :eql?, :==\r\n\r\n    def
    hash\r\n      variants.hash\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhile I don't
    want to get bogged down in the details of how these hooks work, the basic idea
    is that the `hash` method returns a numeric identifier which determines which
    bucket to store the value in. When a provided key hashes to the same number of
    an object already in the hash, the `eql?` method determines whether the keys are
    actually equivalent. Because `Recipe#hash` simply delegates to `Set#hash`, all
    item sets with the same elements have the same hash value, even if their order
    differs. Likewise, when `eql?` is called, it ends up delegating to `Set#==` which
    has the same semantics. If you trace your way through the usage example, you'll
    find that because `torch_recipe` and `user_recipe` generate the same variants,
    they also can stand in for one another as hash keys due to these overridden methods.\r\n\r\nWithout
    a doubt, this is a *clever* technique. But I'm still on the fence about whether
    it is a good approach or not. On the one hand, it makes use of a well defined
    hook that Ruby provides which seems to be well suited for the problem we're trying
    to model. On the other hand, it is not a very explicit way of building an API
    at all, and requires a non-trivial understanding of low level features of Ruby
    to fully understand this code. This is a common tension whenever designing Ruby
    objects: Matz assumes we're all a lot smarter and a lot more responsible than
    we might consider ourselves. \r\n\r\nI decided to go this route because in learning
    exercises I like to push my boundaries a bit and see where it takes me. But if
    this were production code, I would think about going with a slighly less elegant
    but more explicit approach. For example, I might have made the `Recipe#variants`
    method public and then did something similar to the following code in the `Cookbook#[]`
    method:\r\n\r\n```ruby\r\nmodule CraftingTable\r\n  class Cookbook\r\n    def
    [](recipe)\r\n      variant = recipe.variants.find { |v| recipes[v] }\r\n\r\n
    \     recipes[variant]\r\n    end\r\n\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nThat
    said, I would love to hear your thoughts on this particular pattern. Sometimes
    when a technique is rare, it's hard to tell whether it seems unintuitive because
    it is actually hard to understand, or if it just feels that way because it isn't
    familiar territory.\r\n\r\n### Modeling a recipe importer\r\n\r\nWith the interesting
    modeling out of the way, all that remains to talk about is how to get data imported
    into cookbooks in a way that doesn't require a lot of tedious assignment statements.
    For this purpose, I built a simple `Importer` object which takes a CSV file as
    input and builds up a `Cookbook` object from it.\r\n\r\nThe data format consists
    of multiline records separated by an empty line, as shown below:\r\n\r\n```ruby\r\ntorch,4\r\n-,-,-\r\n-,coal,-\r\n-,stick,-\r\n\r\ncrafting_table,1\r\n-,-,-\r\nwooden_plank,wooden_plank,-\r\nwooden_plank,wooden_plank,-\r\n```\r\n\r\nWhile
    the data isn't pretty as a raw CSV file, this format makes it convenient to edit
    the data via a spreadsheet program, and doing so provides a pretty nice layout
    of the input grid. Once the file is written up, it ends up getting used in the
    manner shown below:\r\n\r\n```ruby\r\ncookbook      = CraftingTable::Importer.cookbook_from_csv(recipe_file)\r\nuser_recipe_1
    = CraftingTable::Recipe.new\r\n\r\nuser_recipe_1[1,0] = \"stick\"\r\nuser_recipe_1[1,1]
    = \"coal\"\r\n\r\np cookbook[user_recipe_1] #=> [\"torch\", 4]\r\n\r\nuser_recipe_2
    = CraftingTable::Recipe.new\r\n\r\nuser_recipe_2[0,0] = \"wooden_plank\"\r\nuser_recipe_2[0,1]
    = \"wooden_plank\"\r\nuser_recipe_2[1,0] = \"wooden_plank\"\r\nuser_recipe_2[1,1]
    = \"wooden_plank\"\r\n\r\np cookbook[user_recipe_1] #=> [\"crafting_table\", 1]\r\n```\r\n\r\nThe
    implementation of the `Importer` object is mostly an uninspired procedural hack,
    with the only interesting detail of it being that it manually iterates over the
    CSV data using `CSV.new` in combination with a `File` object as yet another unnecessary-yet-educational
    efficiency optimization:\r\n\r\n```ruby\r\nmodule CraftingTable\r\n  Importer
    = Object.new\r\n\r\n  class << Importer\r\n    def cookbook_from_csv(filename)\r\n
    \     cookbook = Cookbook.new\r\n\r\n      File.open(filename) do |f|\r\n        csv
    = CSV.new(f)\r\n\r\n        until f.eof?\r\n          product, quantity = csv.gets\r\n\r\n
    \         grid = [csv.gets, csv.gets, csv.gets]\r\n\r\n          cookbook[recipe_from_grid(grid)]
    = [product, quantity.to_i]\r\n          \r\n          csv.gets\r\n        end\r\n
    \     end\r\n\r\n      cookbook\r\n    end\r\n\r\n    def recipe_from_grid(grid)\r\n
    \     recipe = Recipe.new\r\n\r\n      last_row = Recipe::TABLE_WIDTH  - 1\r\n
    \     last_col = Recipe::TABLE_HEIGHT - 1\r\n\r\n      ((0..last_row).to_a).product((0..last_col).to_a)
    do |x,y|\r\n        row = x\r\n        col = last_col - y\r\n        \r\n        next
    if grid[col][x] =~ /-/\r\n\r\n        recipe[x,y] = grid[col][x]\r\n      end\r\n\r\n
    \     recipe\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis object is boring enough
    that I originally had planned to not implement it at all, in favor of having a
    `Cookbook.from_csv` method and perhaps a `Recipe.from_grid` method. However, I
    am increasingly growing suspicious of the presence of too many factory methods
    on objects, and worried that I'd be mixing the concerns of data extraction and
    data manipulation too much by doing that. In particular, I would have had to figure
    out a way to avoid directly referencing the \"-\" string as an indicator of an
    empty cell in `Recipe.from_grid`, and I didn't want to focus my energy on that
    because it felt like a waste of time.\r\n\r\nThis code represents a small compromise
    in that it isolates something that doesn't quite have a natural home so that it
    can be refactored later into something more elegant. Because this is a bolt-on
    feature, I felt comfortable making that trade so that I could focus more on the
    heart of the problem. However, if data import needs became more complex, this
    code would almost certainly need to be refactored into something more well organized.\r\n\r\n###
    Reflections\r\n\r\nHopefully this article has given you a strong sense of how
    deep even seemingly simple game constructs can be if you really think them through.
    In my experience, this phenomenon is strikingly similar to the kinds of complexity
    that arise naturally in even moderately complicated business applications. The
    main difference is that in a practice environment, you don't need to worry about
    how much money you're costing someone else by spending as much time thinking about
    the problem as you do writing implementation code.\r\n\r\nWhile doing deliberate
    practice of this variety, it is perfectly acceptable to actively seek out ways
    to induce analysis paralysis, premature optimization, and extreme over-engineering.
    In fact, the closer you get to feeling like your solution is completely overkill
    for the problem at hand, the more likely it is that you're going to learn something
    useful from the exercise. Experiencing the tensions that arise from this kind
    of perfectionism in a low-risk environment can make it a lot easier to take a
    middle of the road path when dealing with your day to day work.\r\n\r\nThe thing
    I like most about this sort of exercise is that it will often lead you to come
    across patterns or techniques that actually are directly applicable in practical
    scenarios. Whenever I stumble across a technique which is just as easy to implement
    as a more commonly used alternative but is more robust in some way, I tend to
    experiment with introducing those ideas into my production code to see how they
    work out for me. Sometimes these experiments work and other times they don't,
    but they always improve my understanding of why I do things the way I do.\r\n\r\nWhile
    I remain a firm believer in the idea that deliberate practice should be done only
    in moderation and that there is no substitute for working on real problems that
    matter to you, the occasional sitting or two spent on shaking up what you think
    you know about this craft is well worth the effort. There are lots of different
    ways to do that, but this is the way that works for me. I'd love to hear what
    you think of it, and would also like to hear what other ways you've tried to hone
    your problem solving skills. \r\n"
- :slug: coding-in-the-danger-zone
  :title: Lessons learned from coding in the danger zone
  :summary: Establish a few survival skills for working in hostile programming environments.
  :published: 2012-03-13 00:00:00.000000000 Z
  :issue_number: '3.10'
  :volume: 3
  :body: "Writing robust code is always challenging, even when dealing with extremely
    well controlled environments. But when you enter the danger zone where software
    failures can result in data loss or extended service interruptions, coding for
    robustness becomes essential even if it is inconvenient to do so. \r\n\r\nIn this
    article, I will share some of the lessons I've learned about building\r\nstable
    software through my work on the [Newman mail framework](https://github.com/mendicant-original/newman).
    While the techniques I've discovered so far are fairly ordinary, it was easy to
    underestimate their importance in the early stages of the project's development.
    My hope is that by exposing my stumbling points, it will save others from making
    the same mistakes.\r\n\r\n### Lesson 1: Collect enough information about your
    workflow.\r\n\r\nIn many contexts, collecting the information you need to analyze
    a failure is the easy part of the debugging process. When your environment is
    well controlled, a good stack trace combined with a few well placed `puts` statements
    are often all you need to start reproducing an error in your development environment.
    Unfortunately, these well-worn strategies are not nearly as effective for debugging
    application frameworks.\r\n\r\nTo get a clearer sense of the problem, consider
    that Newman's server software knows almost nothing about the applications it runs,
    nor does it know much of anything about the structures of the emails it is processing.
    It also cannot assume that its interactions with external IMAP and SMTP servers
    will be perfectly stable. In this kind of environment, something can go wrong
    at every possible turn. This means that in order to find out where and why a failure
    occured, it is necessary to make the sequence of events easier to analyze by introducing
    some sort of logging system.\r\n\r\nA good place to start when introducing event
    logging is with the outermost layer of the system. In Newman's case, this means
    tracking information about every incoming and outgoing email, as shown below:
    \r\n\r\n```\r\nI, [2012-03-10T12:46:57.274091 #9841]  INFO -- REQUEST: \r\n{:from=>[\"gregory_brown@letterboxes.org\"],
    :to=>[\"test+ping@test.com\"],\r\n:bcc=>nil, :subject=>\"hi there!\", :reply_to=>nil}\r\n\r\nI,
    [2012-03-10T12:46:57.274896 #9841]  INFO -- RESPONSE: \r\n{:from=>[\"test@test.com\"],
    :to=>[\"gregory_brown@letterboxes.org\"], \r\n:bcc=>nil, :subject=>\"pong\", :reply_to=>nil}\r\n```\r\n\r\nBecause
    Newman currently only understands how to filter messages based on their TO and
    SUBJECT fields, the standard log information is fairly helpful for basic application
    debugging needs. However, when dealing with complex problems, it is nice to be
    able to see [the raw contents of the messages](https://raw.github.com/gist/01fbab481a21f4d43bbf/0778e1a0ae887e6423bce985298e3f8d60eb37a0/gistfile1.txt).
    Rather than choosing one or the other, Newman handles both log formats by outputting
    them at different log levels:\r\n\r\n```ruby\r\nmodule Newman\r\n  module EmailLogger\r\n
    \   def log_email(logger, prefix, email)\r\n      logger.debug(prefix) { \"\\n#{email}\"
    }\r\n      logger.info(prefix) { email_summary(email) }\r\n    end\r\n\r\n    private\r\n\r\n
    \   def email_summary(email)\r\n      { :from     => email.from,\r\n        :to
    \      => email.to,\r\n        :bcc      => email.bcc,\r\n        :subject  =>
    email.subject,\r\n        :reply_to => email.reply_to }\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nHaving
    the ability to dynamically decide what level of detail your log output should
    contain is one of the main advantages of using a proper logging system instead
    of directly outputting messages to the console. While it would be possible to
    implement some sort of information filtering mechanism without using a formal
    logging system, doing so would involve reinventing many of the things that the
    `Logger` standard library already provides for you.\r\n\r\nThe cost of introducing
    a logging system is that once you depend on logs for your debugging information,
    some form of exception logging becomes absolutely necessary. Because failures
    can be very context-dependent, deciding how handle them can be tricky. \r\n\r\n###
    Lesson 2: Plan for various kinds of predictable failures.\r\n\r\nBecause Newman
    does not know anything about the applications it runs except that they all implement
    a `call` method, it is not possible to be selective about what kinds of errors
    to handle. Instead, a catch-all mechanism is implemented in the `process_request`
    method:\r\n\r\n```ruby\r\nmodule Newman\r\n  class Server\r\n    def process_request(request,
    response)\r\n      apps.each do |app|\r\n        app.call(:request  => request,
    \r\n                 :response => response, \r\n                 :settings =>
    settings,\r\n                 :logger   => logger)\r\n      end\r\n\r\n      return
    true\r\n    rescue StandardError => e\r\n      if settings.service.raise_exceptions\r\n
    \       raise\r\n      else\r\n        logger.info(\"APP ERROR\")  { e.inspect
    }\r\n        logger.debug(\"APP ERROR\") { \"#{e.inspect}\\n\" + e.backtrace.join(\"\\n
    \ \") }\r\n\r\n        return false\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIf
    you trace the execution path through this method, you'll find that there are three
    possible outcomes. If everything worked as expected, the method simply returns
    true. However, if an exception is raised by one of the applications, then the
    `raise_exceptions` configuration setting is used to determine whether to simply
    re-raise the exception or log the error and return false.\r\n\r\nThe reason `Newman::Server#process_request`
    is implemented in this somewhat awkward way is that it is necessary to let the
    application developer determine whether or not application errors should crash
    the server. Generally speaking, this would be a bad behavior in production, because
    it means that a single fault in an edge case of a single feature could halt a
    whole service that is otherwise working as expected. However, when it comes to
    writing tests, it might be nice for applications to raise their exceptions rather
    than quietly writing stack traces to a log file and moving on. This pair of competing
    concerns explains why the `raise_exceptions` configuration option exists, even
    if it leads to ugly implementation code.\r\n\r\nWhile `Newman::Server#process_request`
    does a good job of handling application errors, there are a range of failures
    that can happen as a result of server operations as well. This means that `Newman::Server#tick`
    needs to implement its own exception handling and logging, as shown below:\r\n\r\n```ruby\r\nmodule
    Newman\r\n  class Server\r\n    def tick         \r\n      mailer.messages.each
    do |request| \r\n        response = mailer.new_message(:to   => request.from,
    \r\n                                      :from => settings.service.default_sender)\r\n\r\n
    \       process_request(request, response) && response.deliver\r\n      end\r\n
    \   rescue StandardError => e\r\n      logger.fatal(\"SERVER ERROR\") { \"#{e.inspect}\\n\"
    + e.backtrace.join(\"\\n  \") }\r\n      raise\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhile
    it may be possible to recover from some of the errors that occur at the server
    level, there are many problems which simply cannot be recovered from automatically.
    For this reason, `Newman::Server#tick` always re-raises the exceptions it encounters
    after logging them as fatal errors. While implementing this method in such a conservative
    way helps shield against dangerous failures, it does not completely prevent them
    from occurring. Sadly, that is a lesson I ended up learning the hard way.\r\n\r\n###
    Lesson 3: Reduce the impact of catastrophic failures. \r\n\r\nA few days before
    this article was published, I accidentally introduced an\r\ninfinite send/receive
    loop into the experimental Newman-based mailing list system [MailWhale](https://github.com/mendicant-original/mail_whale).
    I caught the problem right away, but not before my email provider banned me for
    1 hour for exceeding my send quota. In the few minutes of chaos before I figured
    out what was going wrong, there was a window of time in which any incoming emails
    would simply be dropped, resulting in data loss.\r\n\r\nIt's painful to imagine
    what would have happened if this failure occured while someone wasn't actively
    babysitting the server. While the process was crashing with a `Net::SMTPFatalError`
    each time cron ran it, this happened after reading all incoming mail. As a result,
    the incoming mail would get dropped from the inbox without any response, failing
    silently. Once the quota was lifted, a single email would cause the server to
    start thrashing again, eventually leading to a permanent ban. In addition to these
    problems, anyone using the mailing list would be bombarded with at least a few
    duplicate emails before the quota kicked in each time. Although I was fortunate
    to not live out this scenario, the mere thought of it sends chills down my spine.\r\n\r\nWhile
    the infinite loop I introduced could probably be avoided by doing some simple
    checks in Newman, the problem of the server failing repeatedly is a general defect
    that could cause all sorts of different problems down the line. To solve this
    problem, I've implemented a simplified version of the [circuit breaker](http://en.wikipedia.org/wiki/Circuit_breaker_design_pattern)
    pattern in MailWhale, as shown below:\r\n\r\n```ruby\r\nrequire \"fileutils\"\r\n\r\n#
    unimportant details omitted...\r\n\r\nbegin\r\n  if File.exists?(\"server.lock\")\r\n
    \   abort(\"Server is locked because of an unclean shutdown. Check \"+\r\n          \"the
    logs to see what went wrong, and delete server.lock \"+\r\n          \"if the
    problem has been resolved\") \r\n  end\r\n\r\n  server.tick\r\nrescue Exception
    # used to match *all* exceptions\r\n  FileUtils.touch(\"server.lock\")\r\n  raise
    \r\nend\r\n```\r\n\r\nWith this small change, any exception raised by the server
    will cause a lock file to be written out to disk, which will then be detected
    the next time the server runs. As long as the `server.lock` file is present, the
    server will immediately shut itself down rather than continuing on with its processing.
    This forces someone (or some other automated process) to intervene in order for
    the server to resume normal operations. As a result, repeated failure is a whole
    lot less likely to occur. \r\n\r\nIf this circuit breaker were in place when I
    triggered the original infinite loop, I would have still exceeded my quota, but
    the only data loss would be the first request the server failed to respond to.
    All email that was sent in the interim would remain in the inbox until the problem
    was fixed, and there would be no chance that the server would continue to thrash
    without someone noticing that an unclean shutdown had occurred. This is clearly
    a better behavior, and perhaps this is how things should have been implemented
    in the first place.\r\n\r\nOf course, we now have the problem that this code is
    a bit too aggressive. There are likely to be many kinds of failures which are
    transient in nature, and shutting down the server and hard-locking it like this
    feels overkill for those scenarios. However, I am gradually learning that it is
    better to whitelist things than blacklist them when you can't easily enumerate
    what can possibly go wrong. For that reason I've chosen to go with this extremely
    conservative solution, but I will need to put this technique through its paces
    a bit before I can decide whether it is really the right approach. \r\n\r\n###
    Reflections\r\n\r\nI originally planned to cover many more lessons in this article,
    but the more I worked on it, the more I realized my own lack of experience in
    producing truly robust software. When it comes to email, it's like the entire
    problem space is one big fuzz test: there seems to be an infinite amount of ways
    for things to crash and burn.\r\n\r\nIn addition to the few issues I have already
    outlined, Newman is going to need to jump many more hurdles before it can be considered
    stable. In particular, I need to sort out the following problems:\r\n\r\n* Sometimes
    connections via IMAP can hang indefinitely, so some sort of timeout logic needs
    to be introduced. To deal with this, I'm thinking of looking into the [retriable](https://github.com/kamui/retriable)
    gem.\r\n\r\n* In one of my test runs of our simple ping/pong application, I ended
    up causing newman to reply to a Gmail mailer daemon, which caused a request/response
    loop to occur. Thankfully, Gmail's daemon gave up after a few tries, but if it
    didn't I would have ended up melting my inbox again. This means that Newman will
    need some way to deal with bounced emails. We've looked at some options for this,
    but most involve some pretty messy heuristics that make the cure look worse than
    the disease.\r\n\r\n* Currently it is relatively straightforward to write automated
    tests to reproduce known issues, but very hard for me to come up with realistic
    test scenarios in a proactive way. This means that while we can shore up Newman's
    stability over time in this fashion, we'll always be trailing behind on the problems
    we haven't encountered yet. I need to look into whether there are some email-based
    acid tests I can run the server against.\r\n\r\n* There is still a great deal
    of ugliness / fragility in the way Newman does its exception handling. The techniques
    I've shown in this article are meant to be considered a rough starting point,
    not a set of best practices. I plan to re-read Avdi Grimm's [Exceptional Ruby](http://exceptionalruby.com/)
    and see what ideas I can apply from it. When I first read that book I thought
    many of the techniques it recommended were overkill for day to day Ruby applications,
    but several of them may be just what Newman needs.\r\n\r\nThe bad news is that
    all of the above problems seem challenging enough to deal with, but they're likely
    to be just the first set of roadblocks on the highway to the danger zone. There
    are still a lot of unknown-unknowns that may get in my way. The good news is that
    because I can take my time while working on this project, the uncertainty of things
    is part of what makes this a fun problem to work on.\r\n\r\nHave you ever had
    a similar experience of coding in a dangerous and poorly-defined environment before?
    If so, I'd love to hear your story, as well as any advice you might have for me.\r\n"
- :slug: tdd-costs-and-benefits
  :title: What are the costs and benefits of TDD?
  :summary: Think through how to evaluate the impact of test-driven development on
    your work.
  :published: 2012-04-10 00:00:00.000000000 Z
  :issue_number: '4.1'
  :volume: 4
  :body: "Over the last several years, Ruby programmers have gained a reputation of
    being\r\n*test obsessed* -- a designation that many of our community members consider
    to\r\nbe a badge of honor. While I share their enthusiasm to some extent, I can't
    help but notice\r\nhow dangerous it is to treat any single methodology as if it
    were a panacea.\r\n\r\nOur unchecked passion about [test-driven\r\ndevelopment](http://en.wikipedia.org/wiki/Test-driven_development)
    (TDD) has paved the way for deeply\r\ndogmatic thinking to become our cultural
    norm. As a result, many vocal members\r\nof our community have oversold the benefits
    of test-driven development \r\nwhile downplaying or outright ignoring some of
    its costs. While I don't doubt\r\nthe good intentions of those who have advocated
    TDD in this\r\nway, I feel strongly that this tendency to play fast and loose
    with very complex\r\nideas ends up generating more heat than light.\r\n\r\nTo
    truly evaluate the impact that TDD can have on our work, we need to go \r\nbeyond
    the anecdotes of our community leaders and seek answers to \r\ntwo important questions:\r\n\r\n>
    1) What evidence-based arguments are there for using TDD? \r\n\r\n> 2) How can
    we evaluate the costs and benefits of TDD in our own work?\r\n\r\nIn this article,
    I will address both of these questions and share with you my\r\nplans to investigate
    the true costs and benefits of TDD in a more rigorous and\r\nintrospective way
    than I have done in the past. My hope is that by considering a\r\nbroad spectrum
    of concerns with a fair amount of precision, I will be able to\r\nshare relevant
    experiences that may help you challenge and test your own \r\nassumptions about
    test-driven development.\r\n\r\n### What evidence-based arguments are there for
    using TDD? \r\n\r\nBefore publishing this article, I conducted a survey that collected
    thoughts\r\nfrom Practicing Ruby readers about the costs and benefits of test-driven\r\ndevelopment
    that they have personally experienced. Over 50 individuals responded, and\r\nas
    you might expect there was a good deal of diversity in replies. However, the\r\nfollowing
    common assumptions about TDD stood out:\r\n\r\n```diff\r\n+ Increased confidence
    in developers working on test-driven codebases\r\n+ Increased protection from
    defects, especially regressions\r\n+ Better code quality (in particular, less
    coupling and higher cohesion)\r\n+ Tests as a replacement/supplement to other
    forms of documentation\r\n+ Improved maintainability and changeability of codebases\r\n+
    Ability to refactor without fear of breaking things\r\n+ Ability of tests to act
    as a \"living specification\" of expected behavior\r\n+ Earlier detection of misunderstandings/ambiguities
    in requirements\r\n+ Smaller production codebases with more simple designs\r\n+
    Easier detection of flaws in the interactions between objects\r\n+ Reduced need
    for manual testing\r\n+ Faster feedback loop for discovering whether an implementation
    is correct\r\n- Slower per-feature development work because tests take a lot of
    time to write\r\n- Steep learning curve due to so many different testing tools
    / methodologies\r\n- Increased cost of test maintenance as projects get larger\r\n-
    Some time wasted on fixing \"brittle tests\"\r\n- Effectiveness is highly dependent
    on experience/discipline of dev team\r\n- Difficulty figuring out where to get
    started on new projects\r\n- Reduced ability to quickly produce quick and dirty
    prototypes\r\n- Difficulty in evaluating how much time TDD costs vs. how much
    it saves\r\n- Reduced productivity due to slow test runs\r\n- High setup costs\r\n```\r\n\r\nBefore
    conducting this survey, I compiled [my own list of\r\nassumptions](https://gist.github.com/2277788)
    about test-driven \r\ndevelopment, and I was initially relieved to see that there
    was a high degree of\r\noverlap between my intuition and the experiences that
    Practicing Ruby \r\nreaders had reported on. However, my hopes of finding some
    solid ground to stand\r\non were shattered when I realized that virtually all
    of these claims did not have\r\nany conclusive empirical evidence to support them.\r\n\r\nSearching
    the web for answers, I stumbled across a great [three-part\r\narticle](http://scrumology.com/the-benefits-of-tdd-are-neither-clear-nor-are-they-immediately-apparent/)\r\n
    called \"The benefits of TDD are neither clear nor are they immediately\r\napparent\",
    which presents a fairly convincing argument that we don't know as\r\nmuch about
    the effect of TDD on our craft as we think we do. The whole article is\r\nworth
    reading, but this paragraph in [part\r\n3](http://scrumology.com/the-benefits-of-tdd-why-tdd-part-3/)
    really grabbed my\r\nattention:\r\n\r\n> Eighteen months ago, I would have said
    that TDD was a slam dunk. Now that Ive taken the time to look at the papers more
    closely  and actually read more than just the introduction and conclusion  I
    would say that the only honest conclusion is that TDD results in more tests and
    by implication, fewer defects. Any other conclusions such as better design, better
    APIs, simpler design, lower complexity, increased productivity, more maintainable
    code etc., are simply not supported.\r\n\r\nThroughout the article, the author
    emphasizes that he believes in the value of\r\nTDD and seems to think that the
    inconsistency of rigor and quality in the\r\nstudies at least partially explain
    why their results do not mirror the \r\nexpectations of practitioners. He even
    offers some standards for what he \r\nbelieves would make for more reliable studies
    on TDD:\r\n\r\n> My off-the-top-of-my-head list of criteria for such a study,
    includes (a) a multi year study with a minimum of 3 years consecutive years (b)
    a study of several teams (c) team sizes must be 7 (+/-2) team members and have
    (d) at least 4 full time developers. Finally, (e) it needs to be a study of a
    product in production, as opposed to a study based on student exercises. Given
    such as study it would be difficult to argue their conclusions, whatever they
    be.\r\n\r\nHis points (c) and (d) about team size seem subject to debate, but
    it is fair\r\nto say that studies should at least consider many different team
    sizes as\r\nopposed to focusing on individual developers exclusively. All other
    points he\r\nmakes seem essential to ensuring that results remain tied to reality,
    but he\r\ngoes on to conclude that his requirements are so complicated and costly
    to \r\nimplement that it could explain why all existing studies fall short of
    this gold\r\nstandard.\r\n\r\nIntrigued by this article, I went on to look into
    whether there were other, more\r\nauthoritative sources of information about the
    overall findings of research on\r\ntest-driven development. As luck would have
    it, the O'Reilly book on\r\nevidence-based software engineering ([Making\r\nSoftware](http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321))
    had a chapter on this\r\ntopic called \"How effective is test-driven development?\"
    which followed a\r\nsimilar story arc.\r\n\r\nIn this chapter, five researchers
    present the result of their systematic review of \r\nquantitative studies on test
    driven development. After analyzing what published \r\nliterature says about internal
    quality, external quality, productivity, \r\nand correctness testing, the researchers
    found some evidence that both \r\ncorrectness  testing and external quality are
    improved through TDD. However, \r\nupon limiting the scope to well-defined studies
    only, the positive effect \r\non external quality disappears, and even the effect
    on correctness \r\ntesting weakens significantly. In other words, their conclusion
    matched the\r\nconclusions of the previously mentioned article: <u>*there is simply
    not a whole lot of\r\nscience supporting our feverish advocacy of TDD and its
    benefits.*</u>\r\n\r\nWhile the lack of rigorous and conclusive evidence is disconcerting,
    it is not \r\nnecessarily a sign that our perception of the costs and benefits
    of \r\nTDD is invalid. Instead, we should treat these findings as an invitation
    to\r\nslow down and look at our own decision making process in a more careful
    and\r\nintrospective way. \r\n\r\n### How can we evaluate the costs and benefits
    of TDD in our own work?\r\n\r\nBecause there are very few evidence-supported generalizations
    that can be made\r\nabout test-driven development, we each have the responsibility
    to discover for\r\nourselves what effects the red-green-refactor cycle truly has
    on our work. But\r\nbased on my personal experience, many of us have a long way
    to go before we can\r\neven begin to answer this question.\r\n\r\nIn the process
    of preparing this article, I ended up identifying three\r\nguidelines that I feel
    are essential for any sort of introspective evaluation. I\r\nhave listed them
    below, along with some brief notes on how I have failed\r\nmiserably at meeting
    these preconditions when it comes to analyzing TDD.\r\n\r\n---\r\n\r\n**1) We
    must be aware of our assumptions, and be willing to test them.**\r\n\r\n_How I
    failed to do this:_ As someone who learned TDD primarily because other smart people\r\ntold
    me it was the right way to do things, my personal opinions about testing\r\nwere
    developed reactively rather than proactively. As a result, I have ignored certain
    \r\nobservations and amplified others to fit a particular mental model that is\r\nmostly
    informed by gut reactions rather than reasoned choices.\r\n\r\n**2) We must be
    aware of our limitations and try to overcome them.**\r\n\r\n_How I failed to do
    this:_ My mixed feelings towards TDD are in part due to my\r\nown lack of effort
    to fully understand the methodology. \r\nWhile I may have done enough formal practice
    to have some basic intuitive sense of what\r\nthe red-green-refactor cycle is
    like, I have never been able to sustain \r\na pure TDD workflow over the entire
    lifetime of any reasonably complex\r\nproject that I have worked on. As a result,
    it is likely that I have been \r\nblaming testing tools and methodologies for
    my some of my own deficiencies.\r\n\r\n**3) We must be continuously mindful of
    context and avoid over-generalization.**\r\n\r\n_How I failed to do this:_ I have
    always been irked by the lack of sufficient context in literature about\r\ntest-driven
    development, but I have found myself guilty of committing a similar\r\ncrime on
    numerous occasions. Even when I have tried to use specific examples to support\r\nmy
    arguments, I have often failed to consider that my working environment is very\r\ndifferent
    than that of most programmers. As a result, I have made more than few\r\nsweeping
    generalizations which could be invalid at best and misleading at worst.\r\n\r\n---\r\n\r\nIf
    I had to guess why I approached TDD in such a haphazard way despite my\r\ntendency
    to treat other areas of software development with a lot more \r\ncareful attention,
    I would say it was a combination of immaturity and a \r\ndeeply overcommitted
    work schedule. When I first learned Ruby in 2004, I \r\nstudied just enough about
    software testing and the TDD workflow to get \r\nby, and then after that only
    brushed up on my software testing skills \r\nwhen it was absolutely essential
    to do so. There was simply too much to learn\r\nabout and not enough time, and
    so I never ended up giving TDD as much attention \r\nas it might have deserved.\r\n\r\nLike
    most things that get learned in this fashion, my knowledge of software\r\ntesting
    in the test-driven style is full of gaping holes and \r\ndark corners. Until recently
    this is something I have always been able to work\r\naround, but my role as a
    teacher has forced me to identify this as a real weak \r\nspot of mine that needs
    to be dealt with. \r\n\r\n### Looking at TDD from a fresh perspective\r\n\r\nRelearning
    the fundamentals of test-driven development is the only way \r\nI am ever going
    to come up with a coherent explanation for [my \r\nassumptions](https://gist.github.com/2277788)
    about the costs and benefits of this kind of workflow, \r\nand is also the only
    way that I will be able to break free from various \r\nmisconceptions that I have
    been carrying around for the better part of \r\na decade.\r\n\r\nFor a period
    of 90 days from 2012-04-10 to 2012-07-09, I plan to follow \r\ndisciplined TDD
    practices as much as possible. The exact process I want \r\nto adopt is reflected
    in the handy-dandy flow chart shown below:\r\n\r\n<div align=\"center\">\r\n<img\r\nsrc=\"http://upload.wikimedia.org/wikipedia/en/9/9c/Test-driven_development.PNG\"\r\ntitle=\"Image
    Credit: Excirial on Wikipedia CC-SA\" >\r\n</div>\r\n\r\nThis is a workflow that
    I am already quite familiar with and have practiced\r\nbefore, but the difference
    this time around is that I'm going to avoid cutting\r\ncorners. In the past, I
    have usually started projects by spiking a rough\r\nprototype before settling
    into a TDD workflow, and that may have dampened the\r\neffect that writing tests
    up front could have had on my early design process in\r\nthose projects. I have
    also practicing refactoring in the large rather than the\r\nsmall fairly often,
    favoring a Red-Green-Red-Green-...-Red-Green-Refactor\r\npattern which almost
    certainly lead to more brittle tests and implementations\r\nthan I might have
    been able to come up with if I were more disciplined.\r\nThroughout this three
    month trial period, I plan to think long and hard before\r\nmaking any deviations
    from standard practice, and will be sure to note whenever\r\nI do so.\r\n\r\nThe
    benefit of revisiting this methodology as an experienced developer is that I\r\nhave
    a whole lot more confidence in my ability to be diligent in my efforts. In\r\nparticular,
    I plan to take careful notes during each and every coding session\r\nabout my
    TDD struggles and triumphs, which I will associate with particular\r\nchangesets
    on particular projects. Before writing this article I did a test run\r\nof how
    this might work out, and you can \r\n[check out these notes](https://gist.github.com/2286918)
    to get a sense of what \r\nI am shooting for. I think the [github compare\r\nview](https://github.com/sandal/puzzlenode-solutions/compare/9070...3b79)
    will \r\nreally come in handy for this kind of note-taking, as it will allow me
    to track \r\nmy progress with a high degree of precision. \r\n\r\nI don't plan
    to simply use these notes for subjectively analyzing my own\r\nprogress, but also
    expect to use them as a way to seek out advice and help from\r\nmy friends who
    seem to have strongly integrated test-driven development into their\r\nworking
    practices. Having particular code samples to share along with some additional
    \r\ncontext will go a long way towards helping me ask the right kinds of \r\nquestions
    that will move me forward. Each time I reach a stumbling point or\r\ndiscover
    a pattern that is influencing my work (for better or for worse), I will\r\nrequest
    some feedback from someone who might be able to help. When I was\r\nlearning TDD
    the first time around I might have avoided asking \"stupid\r\nquestions\" as a
    way to hide my ignorance, but this time I am intentionally\r\ntrying to expose
    my weaknesses so that they can be dealt with.\r\n\r\nAfter this 90 day period
    of disciplined study and practice of test-driven\r\ndevelopment, I will collect
    my notes and attempt to summarize my findings.\r\nIf I have enough interesting
    results to share, I will publish them in Issue 4.12\r\nof Practicing Ruby towards
    the end of July 2012. At that time, I will also\r\nattempt to take a slightly
    more informed guess at the \"cost and benefits\"\r\nquestion that lead me to write
    this article in the first place, and will comment\r\non how this disciplined period
    of practice has influenced my assumptions about\r\nTDD.\r\n\r\n### Predictions
    about what will be discovered\r\n\r\nWhile certain things are best left to be
    a mystery, there are a few predictions\r\ncan make about the outcomes of this
    project. These are mostly \"just\r\nfor fun\", but also may help reveal some of
    my biases and expectations:\r\n\r\n* I expect that I will reverse my position
    on several criticisms of test-driven\r\n  development as I learn more about practicing
    it properly.\r\n\r\n* I expect that I will understand more of the claims that
    I feel are either\r\n  overstated or lacking in context, and will either be able
    a more balanced\r\n  view of them or meaningfully express my reservations about
    them.\r\n\r\n* I expect that I will stop exclusively doing pure test-driven development
    as\r\n  soon as this trial period is over, but think it is very likely that I
    will\r\n  use TDD more often and more skillfully in the future.\r\n\r\n* I expect
    to be just as frustrated about the extra work involved in TDD\r\n  by the end
    of this study as I am now.\r\n\r\n* I expect that simply by measuring my progress
    and reflecting on it, that I\r\n  will learn a lot of interesting things that
    aren't related to TDD at all,\r\n  and that will help me write better Practicing
    Ruby articles!\r\n\r\nI will do my best not to allow these predictions to become
    self-fulfilling\r\nprophecies and just go with the flow, but I feel it is important
    to expose \r\nthe lens that I will be viewing my experiences through.\r\n\r\n###
    Limitations of this method of study\r\n\r\nThe method I am using to reflect on
    my studies is to some extent a legitimate\r\nform of qualitative research that
    may be useful for more than just improving\r\nmy own skillset. I am essentially
    conducting a diary study, which is \r\nthe [same technique that Donald Knuth used](http://books.google.com/books?id=DxuGi5h2-HEC&lpg=PA58&dq=Reading%20Qualitative%20Research%20Knuth&pg=PA58#v=onepage&q=Reading%20Qualitative%20Research%20Knuth&f=false)\r\nin
    an attempt to categorize the different kinds of errors found in TeX. This \r\ntechnique
    is also used in marketing and usability\r\nresearch, and can provide interesting
    insights into the experiences of\r\nindividuals with sufficient context to be
    analyzed in a fairly rigorous way.\r\nHowever, I am not a scientist and this is
    not a scientific study, and so there\r\nare a ton of limitations can threaten
    the validity of any claims made about \r\nthe results of this project.\r\n\r\nThe
    first and most obvious limitation is that this is a self-study, and that I\r\nam
    already chock full of my own assumptions and biases. My main goal is to learn\r\nmore
    about TDD and come up with better reasons for the decisions I make about\r\nhow
    I practice software testing, but it is impossible for me to wipe the slate\r\ncompletely
    clean and serve as an objective source of information on this topic.\r\n\r\nOn
    top of this, I will be discussing things entirely in terms of my experiences\r\nand
    won't have many objective measures to work with. My hope is that tagging\r\nmy
    notes with links back to particular changesets will make it possibly to apply
    \r\nsome quantitative measures after this study is completed, but it is hard to
    say\r\nwhether that will be feasible or whether it would even mean anything if
    I\r\nattempted to do that. Without hard numbers, my results will not be\r\ndirectly
    comparable to anyone else's nor can it say anything about the average\r\ndeveloper's
    experience.\r\n\r\nLastly, when I look back on my notes from the 90 day period,
    it may be hard for\r\nme to reestablish the context of the early days of the study.
    This means that my\r\nfinal report may be strongly biased by whatever ends up
    happening towards the \r\nend of the trial period. While I expect that I will
    be able to make some high-level \r\ncomparisons across the whole time period,
    I will not be able to precisely \r\ncompare my experiences on day 5 with my experiences
    on day 85 even if I take\r\nvery detailed notes. This may cause some important
    insights to get lost in the\r\nshuffle.\r\n\r\nMy hope is that by staying communicative
    during this study and by sharing most\r\nor all of my raw data (code, notes, etc.),
    the effects of these limitations will\r\nbe reduced so that others can still gain
    something useful from my\r\nefforts. At the very least, this transparency will
    allow individuals \r\nto decide for themselves to what extent my conclusions match
    up with my\r\nevidence, and whether my results are relevant to other contexts.\r\n\r\n###
    Some things you can do to help me\r\n\r\nOne thing I know about Practicing Ruby
    readers is that you folks really enjoy \r\nimproving the craft of software development.
    That is the reason why I decided \r\nto announce my plans for this study via an
    article here rather than \r\nsomewhere else. If you would like to support this
    project,\r\nthere are a few ways you can contribute.\r\n\r\n**If you have a few
    seconds to spare:** You can spread the word about this\r\nproject by sharing this
    article with your friends and colleagues. This will help\r\nme make sure to get
    adequate critical review from the community, which is a key\r\npart of the improvement
    process. To create a share link, just click the handy\r\ndandy robot down in the
    bottom right corner of the screen.\r\n\r\n**If you have a few minutes to spare:**
    You can leave a comment sharing your\r\nthoughts on this article as well as any
    questions or suggestions you might have\r\nfor me. I take all reader feedback
    to heart, and comments are one of the best\r\nways that you can support my work
    on these articles. \r\n\r\n**If you have a few minutes to spare each week:** You
    can subscribe to the\r\n[mendicant-research](http://lists.rubymendicant.org/listinfo.cgi/mendicant-research-rubymendicant.org)\r\nmailing
    list, where I plan to post my questions about TDD as\r\nI study, as well as any
    interesting problems I run into or helpful learning\r\nresources I end up using.
    I am also going to invite a few folks from the Ruby\r\ncommunity that I think
    have specific skills that will help me with this study,\r\nbut I feel that every
    practicing Rubyist could be a meaningful contributor to\r\nthese discussions.\r\n\r\n**If
    you have a large amount of free time:** You can try to do this study along with
    me.\r\nI can't promise that I'll have time during the 90 day period to regularly
    review\r\nyour progress, but I can definitely help you get set up and also would
    love to\r\ncompare notes at the end of the trial period. If this is something
    that\r\ninterests you, please post to the\r\n[mendicant-research](http://lists.rubymendicant.org/listinfo.cgi/mendicant-research-rubymendicant.org)
    mailing list and I'll provide additional details.\r\n\r\nAny little bit of effort
    you spend on helping me make this project better will\r\nabsolutely be appreciated!
    Our readers are what make this journal what it is, I\r\njust work here. :wink:\r\n"
- :slug: tricks-for-working-with-text-and-files
  :title: Tricks for working with text and files
  :summary: Tear apart a minimal clone of the Jekyll blog engine in search of helpful
    Ruby idioms.
  :published: 2012-05-10 00:00:00.000000000 Z
  :issue_number: '4.4'
  :volume: 4
  :body: "While it may not seem like it at first, you can learn a great deal about
    Ruby by building something as simple as a static website generator. Although the
    task itself may seem a bit dull, it provides an opportunity to practice a wide
    range of Ruby idioms that can be applied elsewhere whenever you need to manipulate
    text-based data or muck around with the filesystem. Because text and files are
    everywhere, this kind of practice can have a profound impact on your ability to
    write elegant Ruby code.\r\n\r\nUnfortunately, there are two downsides to building
    a static site generator as a learning exercise: it involves a fairly large time
    commitment, and in the end you will probably be better off using [Jekyll](http://github.com/mojombo/jekyll)
    rather than maintaining your own project. But don't despair, I wrote this article
    specifically with those two points in mind!\r\n\r\nIn order to make it easier
    for us to study text and file processing tricks, I broke off a small chunk of
    Jekyll's functionality and implemented a simplified demo app called [Jackal](http://github.com/elm-city-craftworks/jackal).
    Although it would be a horrible idea to attempt to use this barely functional
    counterfeit to maintain a blog or website, it works great as a tiny but context-rich
    showcase for some very handy Ruby idioms.\r\n\r\n### A brief overview of Jackal's
    functionality\r\n\r\nThe best way to get a feel for what Jackal can do is to [grab
    it from Github](https://github.com/elm-city-craftworks/jackal) and follow the
    instructions in the README. However, because it only implements a single feature,
    you should be able to get a full sense of how it works from the following overview.\r\n\r\nSimilar
    to Jekyll, the main purpose of Jackal is to convert Markdown-formatted posts and
    their metadata into HTML files. For example, suppose we have a file called **_posts/2012-05-09-tiniest-kitten.markdown**
    with the following contents:\r\n\r\n```\r\n---\r\ncategory: essays\r\ntitle: The
    tiniest kitten\r\n---\r\n\r\n# The Tiniest Kitten\r\n\r\nIs not nearly as **small**
    as you might think she is.\r\n```\r\n\r\nJackal's job is to split the metadata
    from the content in this file and then generate a new file called **_site/essays/2012/05/09/tiniest_kitten.html**
    that ends up looking like this:\r\n\r\n\r\n```html\r\n<h1>The Tiniest Kitten</h1>\r\n\r\n<p>Is
    not nearly as <strong>small</strong> as you might think she is.</p>\r\n```\r\n\r\nIf
    Jackal were a real static site generator, it would support all sorts of fancy
    features like layouts and templates, but I found that I was able to generate enough
    \"teaching moments\" without those things, and so this is pretty much all there
    is to it. You may want to spend a few more minutes [reading its source](http://github.com/elm-city-craftworks/jackal)
    before moving on, but if you understand this example, you will have no trouble
    understanding the rest of this article.\r\n\r\nNow that you have some sense of
    the surrounding context, I will take you on a guided tour of through various points
    of interest in Jackal's implementation, highlighting the parts that illustrate
    generally useful techniques.\r\n\r\n### Idioms for text processing\r\n\r\nWhile
    working on solving this problem, I noticed a total of four text processing idioms
    worth mentioning.\r\n\r\n**1) Enabling multi-line mode in patterns**\r\n\r\nThe
    first step that Jackal (and Jekyll) need to take before further processing can
    be done on source files is to split the YAML-based metadata from the post's content.
    In Jekyll, the following code is used to split things up:\r\n\r\n```ruby\r\nif
    self.content =~ /^(---\\s*\\n.*?\\n?)^(---\\s*$\\n?)/m\r\n  self.content = $POSTMATCH\r\n
    \ self.data    = YAML.load($1)\r\nend\r\n```\r\n\r\nThis is a fairly vanilla use
    of regular expressions, and is pretty easy to read even if you aren't especially
    familiar with Jekyll itself. The main interesting thing about it that it uses
    the `/m` modifier to make it so that the pattern is evaluated in multiline-mode.
    In this particular example, this simply makes it so that the group which captures
    the YAML metadata can match multiple lines without explicitly specifying the intermediate
    `\\n` characters. The following contrived example should help you understand what
    that means if you are still scratching your head:\r\n\r\n```\r\n>> \"foo\\nbar\\nbaz\\nquux\"[/foo\\n(.*)quux/,
    1]\r\n=> nil\r\n>> \"foo\\nbar\\nbaz\\nquux\"[/foo\\n(.*)quux/m, 1]\r\n=> \"bar\\nbaz\\n\"\r\n```\r\n\r\nWhile
    this isn't much of an exciting idiom for those who have a decent understanding
    of regular expressions, I know that for many patterns can be a mystery, and so
    I wanted to make sure to point this feature out. It is great to use whenever you
    need to match a semi-arbritrary blob of content that can span many lines.\r\n\r\n**2)
    Using MatchData objects rather than global variables**\r\n\r\nWhile it is not
    necessarily terrible to use variables like `$1` and `$POSTMATCH`, I tend to avoid
    them whenever it is not strictly necessary to use them. I find that using `String#match`
    feels a lot more object-oriented and is more aesthetically pleasing:\r\n\r\n```ruby\r\nif
    md = self.content.match(/^(---\\s*\\n.*?\\n?)^(---\\s*$\\n?)/m)\r\n  self.content
    = md.post_match\r\n  self.data    = md[1]\r\nend\r\n```\r\n\r\nIf you combine
    this with the use of Ruby 1.9's named groups, your code ends up looking even better.
    The following example is what I ended up using in Jackal:\r\n\r\n```ruby\r\nif
    (md = contents.match(/^(?<metadata>---\\s*\\n.*?\\n?)^(---\\s*$\\n?)/m))\r\n  self.contents
    = md.post_match\r\n  self.metadata = YAML.load(md[:metadata])\r\nend\r\n```\r\n\r\nWhile
    this does lead to somewhat more verbose patterns, it helps quite a bit with readability
    and even makes it possible to directly use `MatchData` objects in a way similar
    to how we would work with a parameters hash.\r\n\r\n**3) Enabling free-spacing
    mode in patterns**\r\n\r\nI tend to be very strict about keeping my code formatted
    so that my lines are under 80 characters, and as a result of that I find that
    I am often having to think about how to break up long statements. I ended up using
    the `/x` modifier in one of Jackal's regular expressions for this purpose, as
    shown below:\r\n\r\n```ruby\r\nmodule Jackal\r\n  class Post\r\n    PATTERN =
    /\\A(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})-\r\n                (?<basename>.*).markdown\\z/x\r\n\r\n
    \   # ...\r\n  end\r\nend\r\n```\r\n\r\nThis mode makes it so that patterns ignore
    whitespace characters, making the previous pattern functionally equivalent to
    the following pattern:\r\n\r\n```ruby\r\n/\\A(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})-(?<basename>.*).markdown\\z/x\r\n```\r\n\r\nHowever,
    this mode does not exist primarily to serve the needs of those with obsessive
    code formatting habits, but instead exists to make it possible to break up and
    document long regular expressions, such as in the following example:\r\n\r\n```ruby\r\n#
    adapted from: http://refactormycode.com/codes/573-phone-number-regex\r\n\r\nPHONE_NUMBER_PATTERN
    = /^\r\n  (?:\r\n    (?<prefix>\\d)             # prefix digit\r\n    [ \\-\\.]?
    \                 # optional separator\r\n  )?\r\n  (?:\r\n    \\(?(?<areacode>\\d{3})\\)?
    \ # area code\r\n    [ \\-\\.]                   # separator\r\n  )?\r\n  (?<trunk>\\d{3})
    \            # trunk\r\n  [ \\-\\.]                     # separator\r\n  (?<line>\\d{4})
    \             # line\r\n  (?:\\ ?x?                    # optional space or 'x'\r\n
    \   (?<extension>\\d+)         # extension\r\n  )?\r\n$/x\r\n```\r\n\r\nThis idiom
    is not extremly common in Ruby, perhaps because it is easy to use interpolation
    within regular expressions to accomplish similar results. However, this does seem
    to be a handy way to document your patterns and arrange them in a way that can
    be easily visually scanned without having to chain things together through interpolation.\r\n\r\n**4)
    Making good use of Array#join**\r\n\r\nWhenever I am building up a string from
    a list of elements, I tend to use `Array#join` rather than string interpolation
    (i.e. the `#{}` operator) if I am working with more than two elements. As an example,
    take a look at my implementation of the `Jackal::Post#dirname` method:\r\n\r\n```ruby\r\nmodule
    Jackal\r\n  class Post\r\n    def dirname\r\n      raise ArgumentError unless
    metadata[\"category\"]\r\n\r\n      [ metadata[\"category\"], \r\n        filedata[\"year\"],
    filedata[\"month\"], filedata[\"day\"] ].join(\"/\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe
    reason for this is mostly aesthetic, but it gives me the freedom to format my
    code any way I would like, and is a bit easier to make changes to.\r\n\r\n> **NOTE:**
    Noah Hendrix pointed out in the [comments on this article](http://practicingruby.com/articles/57#comments)
    that for this particular example, using `File.join` would be better because it
    would take platform-specific path syntax into account.\r\n\r\n### Idioms for working
    with files and folders\r\n\r\nIn addition to the text processing tricks that we've
    already gone over, I also noticed four idioms for doing various kinds of file
    and folder manipulation that came in handy.\r\n\r\n**1) Manipulating filenames**\r\n\r\nThere
    are three methods that are commonly used for munging filenames: `File.dirname`,
    `File.basename`, and `File.extname`. In Jackal, I ended up using two out of three
    of them, but could easily imagine how to make use of all three.\r\n\r\nI expect
    that most folks will already be familiar with `File.dirname`, but if that is not
    the case, the tests below should familiarize you with one of its use cases:\r\n\r\n```ruby\r\ndescribe
    Jackal::Page do\r\n  let(:page) do\r\n    posts_dir = \"#{File.dirname(__FILE__)}/../fixtures/sample_app/_posts\"\r\n
    \   Jackal::Page.new(\"#{posts_dir}/2012-05-07-first-post.markdown\")\r\n  end\r\n\r\n
    \ it \"must extract the base filename\" do\r\n    page.filename.must_equal(\"2012-05-07-first-post.markdown\")\r\n
    \ end\r\nend\r\n```\r\n\r\nWhen used in conjunction with the special `__FILE__`
    variable, `File.dirname` is used generate a relative path. So for example, if
    the `__FILE__` variable in the previous tests evaluates to `\"test/units/page_test.rb\"`,
    you end up with the following return value from `File.dirname`:\r\n\r\n```ruby\r\n>>
    File.dirname(\"test/units/page_test.rb\")\r\n=> \"test/units\"\r\n```\r\n\r\nThen
    the whole path becomes `\"tests/units/../fixtures/sample_app/_posts\"`, which
    is functionally equivalent to `\"test/fixtures/sample_app/_posts\"`. The main
    benefit is that should you run the tests from a different folder, `__FILE__` would
    be updated accordingly to still generate a correct relative path. This is yet
    another one of those idioms that is hardly exciting to those who are already familiar
    with it, but is an important enough tool that I wanted to make sure to mention
    it.\r\n\r\nIf you feel like you understand `File.dirname`, then `File.basename`
    should be just as easy to grasp. It is essentially the opposite operation, getting
    just the filename and stripping away the directories in the path. If you take
    a closer look at the tests above, you will see that `File.basename` is exactly
    what we need in order to implement the behavior hinted at by `Jackal::Page#filename`.
    The irb-based example below should give you a sense of how that could work:\r\n\r\n```\r\n>>
    File.basename(\"long/path/to/_posts/2012-05-09-tiniest-kitten.markdown\")\r\n=>
    \"2012-05-09-tiniest-kitten.markdown\"\r\n```\r\n\r\nFor the sake of simplicity,
    I decided to support Markdown only in Jackal posts, but if we wanted to make it
    more Jekyll-like, we would need to support looking up which formatter to use based
    on the post's file extension. This is where `File.extname` comes in handy:\r\n\r\n```\r\n>>
    File.extname(\"2012-05-09-tiniest-kitten.markdown\")\r\n=> \".markdown\"\r\n>>
    File.extname(\"2012-05-09-tiniest-kitten.textile\")\r\n=> \".textile\"\r\n```\r\n\r\nTypically
    when you are interested in the extension of a file, you are also interested in
    the name of the file without the extension. While I have seen several hacks that
    can be used for this purpose, the approach I like best is to use the lesser-known
    two argument form of `File.basename`, as shown below:\r\n\r\n```\r\n>> File.basename(\"2012-05-09-tiniest-kitten.textile\",
    \".*\")\r\n=> \"2012-05-09-tiniest-kitten\"\r\n>> File.basename(\"2012-05-09-tiniest-kitten.markdown\",
    \".*\")\r\n=> \"2012-05-09-tiniest-kitten\"\r\n```\r\n\r\nWhile these three methods
    may not look especially beautiful in your code, they provide a fairly comprehensive
    way of decomposing paths and filenames into their parts. With that in mind, it
    is somewhat surprising to me how many different ways I have seen people attempt
    to solve these problems, typically resorting to some regexp-based hacks.\r\n\r\n**2)
    Using Pathname objects**\r\n\r\nWhenever Ruby has a procedural or functional API,
    it usually also has a more object-oriented way of doing things as well. Manipulating
    paths and filenames is no exception, and the example below shows that it is entirely
    possible to use `Pathname` objects to solve the same problems discussed in the
    previous section:\r\n\r\n```\r\n>> require \"pathname\"\r\n=> true\r\n>> Pathname.new(\"long/path/to/_posts/2012-05-09-tiniest-kitten.markdown\").dirname\r\n=>
    #<Pathname:long/path/to/_posts>\r\n>> Pathname.new(\"long/path/to/_posts/2012-05-09-tiniest-kitten.markdown\").basename\r\n=>
    #<Pathname:2012-05-09-tiniest-kitten.markdown>\r\n>> Pathname.new(\"long/path/to/_posts/2012-05-09-tiniest-kitten.markdown\").extname\r\n=>
    \".markdown\"\r\n```\r\n\r\nHowever, because doing so doesn't really simplify
    the code, it is hard to see the advantages of using `Pathname` objects in this
    particular example. A much better example can be found in `Jackal::Post#save`:\r\n\r\n\r\n```ruby\r\nmodule
    Jackal\r\n  class Post\r\n    def save(base_dir)\r\n      target_dir = Pathname.new(base_dir)
    + dirname\r\n      \r\n      target_dir.mkpath\r\n\r\n      File.write(target_dir
    + filename, contents)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe main reason
    why I used a `Pathname` object here is because I needed to make use of the `mkpath`
    method. This method is roughly equivalent to the UNIX `mkdir -p` command, which
    handles the creation of intermediate directories automatically. This feature really
    comes in handy for safely generating a deeply nested folder structure similar
    to the ones that Jekyll produces. I could have alternatively used the `FileUtils`
    standard library for this purpose, but personally find `Pathname` to look and
    feel a lot more like a modern Ruby library.\r\n\r\nAlthough its use here is almost
    coincidental, the `Pathname#+` method is another powerful feature worth mentioning.
    This method builds up a `Pathname` object through concatenation. Because this
    method accepts both `Pathname` objects and `String` objects as arguments but always
    returns a `Pathname` object, it makes easy to incrementally build up a complex
    path. However, because `Pathname` objects do more than simply merge strings together,
    you need to be aware of certain edge cases. For example, the following irb session
    demonstrates that `Pathname` has a few special cases for dealing with absolute
    and relative paths:\r\n\r\n```\r\n>> Pathname.new(\"foo\") + \"bar\"\r\n=> #<Pathname:foo/bar>\r\n>>
    Pathname.new(\"foo\") + \"/bar\"\r\n=> #<Pathname:/bar>\r\n>> Pathname.new(\"foo\")
    + \"./bar\"\r\n=> #<Pathname:foo/bar>\r\n>> Pathname.new(\"foo\") + \".////bar\"\r\n=>
    #<Pathname:foo/bar>\r\n```\r\n\r\nUnless you keep these issues in mind, you may
    end up introducing subtle errors into your code. However, this behavior makes
    sense as long as you can remember that `Pathname` is semantically aware of what
    a path actually is, and is not meant to be a drop in replacement for ordinary
    string concatenation.\r\n\r\n**3) Using File.write**\r\n\r\nWhen I first started
    using Ruby, I was really impressed by how simple and expressive the `File.read`
    method was. Because of that, it was kind of a shock to find out that simply writing
    some text to a file was not as simple. The following code felt like the opposite
    of elegance to me, but we all typed it for years:\r\n\r\n```ruby\r\nFile.open(filename,
    \"w\") { |f| f << contents }\r\n```\r\n\r\nIn modern versions of Ruby 1.9, the
    above code can be replaced with something far nicer, as shown below:\r\n\r\n```ruby\r\nFile.write(filename,
    contents)\r\n```\r\n\r\nIf you look back at the implementation of `Jackal::Post#save`,
    you will see that I use this technique there. While it is the simple and obvious
    thing to do, a ton of built up muscle memory typically causes me to forget that
    `File.write` exists, even when I am not concerned at all about backwards compatibility
    concerns.\r\n\r\nAnother pair of methods worth knowing about that help make some
    other easy tasks more elegant in a similar way are `File.binread` and `File.binwrite`.
    These aren't really related to our interests with Jackal, but are worth checking
    out if you ever work with binary files.\r\n\r\n**4) Using Dir.mktmpdir for testing**\r\n\r\nIt
    can be challenging to write tests for code which deals with files and complicated
    folder structures, but it doesn't have to be. The tempfile standard library provides
    a lot of useful tools for dealing with this problem, and `Dir.mktmpdir` is one
    of its most useful methods.  \r\n\r\nI like to use this method in combination
    with `Dir.chdir` to build up a temporary directory structure, do some work in
    it, and then automatically discard all the files I generated as soon as my test
    is completed. The tests below are a nice example of how that works:\r\n\r\n```ruby\r\nit
    \"must be able to save contents to file\" do\r\n  Dir.mktmpdir do |base_dir|\r\n
    \   post.save(base_dir)\r\n\r\n    Dir.chdir(\"#{base_dir}/#{post.dirname}\")
    do\r\n      File.read(post.filename).must_equal(post.contents)\r\n    end\r\n
    \ end\r\nend\r\n```\r\nThis approach provides an alternative to using mock objects.
    Even though this code creates real files and folders, the transactional nature
    of `Dir.mktmpdir` ensures that tests won't have any unexpected side effects from
    run to run. When manipulating files and folders is part of the core job of an
    object (as opposed to an implementation detail), I prefer testing in this way
    rather than using mock objects for the sake of realism.\r\n\r\nThe `Dir.mktmpdir`
    method can also come in handy whenever some complicated work needs to be done
    in a sandbox on the file system. For example, I [use it in Bookie](https://github.com/sandal/bookie/blob/45e0c4d0a575026deff79732b3c4c737f1c6f15c/lib/bookie/emitters/epub.rb#L19-46)
    to store the intermediate results of a complicated text munging process, and it
    seems to work great for that purpose.\r\n\r\n### Reflections\r\n\r\nTaken individually,
    these text processing and file management idioms only make a subtle improvement
    to the quality of your code. However, if you get in the habit of using most or
    all of them whenever you have an opportunity to do so, you will end up with much
    more maintainable code that is very easy to read.\r\n\r\nBecause many languages
    make text processing and file management hard, and because Ruby also has low level
    APIs that work in much the same way as those languages, it is often the case that
    folks end up solving these problems the hard way without ever realizing that there
    are nicer alternatives available. Hopefully this article has exposed you to a
    few tricks you haven't already seen before, but if it hasn't, maybe you can share
    some thoughts on how to make this code even better!\r\n"
- :slug: solving-the-scoring-predictions-kata
  :title: Solving the "Scoring Predictions" kata
  :summary: Work through a coding puzzle and learn some fun tricks along the way.
    (w. James Edward Gray II)
  :published: 2012-05-15 00:00:00.000000000 Z
  :issue_number: '4.5'
  :volume: 4
  :body: "*This article is written by James Edward Gray II.  James is an old friend
    of\r\nGreg's, so he was thrilled to contribute. From late 2011 to mid 2012, James
    \r\nwrote his own series of programming articles called [Rubies in the Rough][rubies].\r\nYes,
    James just stole Greg's good idea.*\r\n\r\n[rubies]: http://subinterest.com/rubies-in-the-rough\r\n\r\nIn
    this article, we will look at a fun problem that was in a couple of the [Peepcode][peepcode]
    _Play by Play_ videos. I've played around with this kata a bit and given it to
    a programming student of mine, so I know it pretty well by now. Its solution touches
    on a couple of neat programming topics, so dig in and see what you can learn.\r\n\r\n[peepcode]:
    https://peepcode.com\r\n\r\n### The challenge\r\n\r\nI'm going to simplify the
    Peepcode task a bit so that we can get right to the heart of the problem. Here's
    the challenge we're going to work on:\r\n\r\n> Write a method that accepts two
    arguments: an `Array` of five guesses for\r\n> finalists in a race and an `Array`
    of the five actual finalists.  Each\r\n> position in the lists matches a finishing
    position in the race, so first place\r\n> corresponds to index `0`.  Return an
    `Integer` score of the predictions:  `0`\r\n> or more points.  Correctly guessing
    first place is worth `15` points, second\r\n> is worth `10`, and so on down with
    `5`, `3`, and `1` point for fifth\r\n> place.  It's also worth `1` point to correctly
    guess a racer that finishes in\r\n> the top five but to have that racer in the
    wrong position.\r\n\r\nI'm going to jump right into solving this problem, but
    I encourage everyone to stop and play with the problem a little before reading
    on.  You'll get more out of what I say if you are familiar with the problem.\r\n\r\nOK,
    ready?\r\n\r\n### Complete specing\r\n\r\nI test-drove my solution to this code,
    but probably not as everyone else does it.  Let me show you a trick I like to
    use for these fixed algorithms. First, let's set up some directories for the code
    and create the needed files:\r\n\r\n```\r\n$ mkdir -p scoring_predictions/{lib,spec}\r\n$
    cd scoring_predictions/\r\n$ touch lib/race.rb\r\n$ touch spec/scoring_spec.rb\r\n```\r\n\r\nAt
    this point I opened `spec/scoring_spec.rb` in my editor and set to work.  We're
    supposed to begin with the happy path, so I wrote an example for a set of perfect
    guesses:\r\n\r\n```ruby\r\nrequire \"race\"\r\n\r\ndescribe \"Race::score\" do\r\n
    \ let(:winners) { %w[First Second Third Fourth Fifth] }\r\n\r\n  it \"add points
    for each position\" do\r\n    Race.score(winners, winners).should eq(15 + 10 +
    5 + 3 + 1)\r\n  end\r\nend\r\n```\r\n\r\nAt this point, most developers would
    start adding the library code to make this example pass.  However, I don't find
    that approach very helpful for code like this.\r\n\r\nIf I do \"the right thing,\"
    I should just return a hardcoded score.  Then I'll need to write a second example
    to force me to generalize (or consider the hardcoded score a violation of DRY
    that I need to refactor).  Either way, the tasks are just busywork that isn't
    helping me write the code.  Even having the extra example won't raise my confidence
    that it scores the scenarios correctly.\r\n\r\nWhat would help me is to have an
    example for each rule in the challenge.  I'm going to need to do some programming
    to solve thisand nothing is getting me out of that.  All I can do is to make
    it easier to do that programming.  If the examples codify the rules for me, running
    them will tell me whether I am getting closer to a right answer just by watching
    the pass/fail ratio.\r\n\r\nWith these thoughts in mind, I finished writing examples
    for the rules of the challenge:\r\n\r\n```ruby\r\nrequire \"race\"\r\n\r\ndescribe
    \"Race::score\" do\r\n  let(:winners) { %w[First Second Third Fourth Fifth] }\r\n\r\n
    \ def correct_guesses(*indexes)\r\n    winners.map.with_index { |w, i| indexes.include?(i)
    ? w : \"Wrong\" }\r\n  end\r\n\r\n  it \"add points for each position\" do\r\n
    \   Race.score(winners, winners).should eq(15 + 10 + 5 + 3 + 1)\r\n  end\r\n\r\n
    \ it \"gives 0 points for no correct guesses\" do\r\n    all_wrong = correct_guesses
    \ # none correct\r\n    Race.score(all_wrong, winners).should eq(0)\r\n  end\r\n\r\n
    \ it \"gives 15 points for first place\" do\r\n    Race.score(correct_guesses(0),
    winners).should eq(15)\r\n  end\r\n\r\n  it \"gives 10 points for second place\"
    do\r\n    Race.score(correct_guesses(1), winners).should eq(10)\r\n  end\r\n\r\n
    \ it \"gives 5 points for third place\" do\r\n    Race.score(correct_guesses(2),
    winners).should eq(5)\r\n  end\r\n\r\n  it \"gives 3 points for fourth place\"
    do\r\n    Race.score(correct_guesses(3), winners).should eq(3)\r\n  end\r\n\r\n
    \ it \"gives 1 point for fifth place\" do\r\n    Race.score(correct_guesses(4),
    winners).should eq(1)\r\n  end\r\n\r\n  it \"gives one point for a correct guess
    in the wrong place\" do\r\n    guesses = correct_guesses(0)\r\n    guesses.unshift(guesses.pop)
    \ # shift positions by one\r\n    Race.score(guesses, winners).should eq(1)\r\n
    \ end\r\n\r\n  it \"score positional and misplaced guesses at the same time\"
    do\r\n    guesses                = correct_guesses(0, 3)\r\n    guesses[3], guesses[4]
    = guesses[4], guesses[3]\r\n    Race.score(guesses, winners).should eq(15 + 1)\r\n
    \ end\r\nend\r\n```\r\n\r\nThis probably looks like a lot of code, but it's quite
    trivial.  You already saw the first example.  The next six just specify the score
    for each position (and one for no positions) with the help of a trivial method
    I wrote to generate right and wrong guesses.  The next-to-last example is the
    rule about right guesses in the wrong position.  Finally, I just wanted at least
    one example testing both scenarios at once.\r\n\r\nThis gives me plenty of red
    to work with:\r\n\r\n\r\n```\r\n$ rspec\r\nFFFFFFFF\r\n\r\nFailures:\r\n\r\n\r\n\r\nFinished
    in 0.00417 seconds\r\n9 examples, 9 failures\r\n\r\nFailed examples:\r\n\r\nrspec
    ./spec/scoring_spec.rb:8 # Race::score add points for each position\r\nrspec ./spec/scoring_spec.rb:12
    # Race::score gives 0 points for \r\n\r\n```\r\n\r\nFrom there, I played around
    with an algorithm until I saw these examples go green.  I could show my process,
    but the truth is that we all attack this stuff in different ways.\r\n\r\nInstead,
    let's look at a correct but not optimal solution.\r\n\r\n### What the iterators
    can do for you\r\n\r\nThe first pass my student made at this problem landed on
    some code like this:\r\n\r\n```ruby\r\nmodule Race\r\n  module_function\r\n\r\n
    \ def score(guesses, winners)\r\n    points = 0\r\n    guesses.each_with_index
    do |guess, i|\r\n      if guess == winners[i]\r\n        points += case i\r\n
    \                 when 0 then 15\r\n                  when 1 then 10\r\n                  when
    2 then 5\r\n                  when 3 then 3\r\n                  when 4 then 1\r\n
    \                 end\r\n      else\r\n        winners.each do |winner|\r\n          points
    += 1 if winner == guess\r\n        end\r\n      end\r\n    end\r\n    points\r\n
    \ end\r\nend\r\n```\r\n\r\nThe guy has only been studying Ruby a short while,
    so I thought this was a great first stab at the problem.  I did urge him to refine
    it, though.\r\n\r\nFirst, I mentioned that you can often tell that you have the
    wrong iterator if it does extra iterations.  The `else` code in the previous example
    is a good example of this.  It may find the `guess` in the first position of `winners`,
    but it would keep looking.  Although it's possible to add a `break` statement
    to fix this problem, there are iterators that \"short-circuit\" when they find
    an answer.  For example, `find()`, which is close to what we want, or `any?()`
    which is even closer.  What we really want though, is this:\r\n\r\n```ruby\r\nmodule
    Race\r\n  module_function\r\n\r\n  def score(guesses, winners)\r\n    points =
    0\r\n    guesses.each_with_index do |guess, i|\r\n      if guess == winners[i]\r\n
    \       points += case i\r\n                  when 0 then 15\r\n                  when
    1 then 10\r\n                  when 2 then 5\r\n                  when 3 then
    3\r\n                  when 4 then 1\r\n                  end\r\n      elsif winners.include?
    guess\r\n        points += 1\r\n      end\r\n    end\r\n    points\r\n  end\r\nend\r\n```\r\n\r\nAnother
    sign that you're on the wrong track in Ruby is the need to track an index.  Sometimes
    you really do need one, but that need is quite rare.  Assume that you don't and
    give in only when you can't find a way around it.\r\n\r\nIn this case, the path
    is almost clear.  The first thing you see the index used for is to walk two lists
    in parallel.  Ruby has an iterator for that.  It's `zip()`.\r\n\r\nUnfortunately,
    we can't switch straight to `zip()`.  If we did, we wouldn't have the score.  It
    also needs the index in this setup.  That's the problem we need to solve first.\r\n\r\nThe
    trick is that `case` statement.  It's really hiding the true nature of those scores.
    \ If you squint hard enough, you'll see that it's really just another `Array`.
    \ It would have been easier to see this if there were more of them (say, 100)
    because we would be less willing to type that out.\r\n\r\nThat gives us the first
    step.  We need to move to something more like this:\r\n\r\n```ruby\r\nmodule Race\r\n
    \ module_function\r\n\r\n  def score(guesses, winners)\r\n    points = 0\r\n    guesses.each_with_index
    do |guess, i|\r\n      if guess == winners[i]\r\n        points += [15, 10, 5,
    3, 1][i]\r\n      elsif winners.include? guess\r\n        points += 1\r\n      end\r\n
    \   end\r\n    points\r\n  end\r\nend\r\n```\r\n\r\nThis code solves one of our
    problems.  We're now working with `Array` objects all the way down.  That's nice,
    but I don't really like that change I just made.  It makes it painfully obvious
    that it's a list of magic numbers.  That makes me want to give them a name:\r\n\r\n```ruby\r\nmodule
    Race\r\n  SCORES    = [15, 10, 5, 3, 1]\r\n  MISPLACED = 1\r\n\r\n  module_function\r\n\r\n
    \ def score(guesses, winners, scores = SCORES, misplaced = MISPLACED)\r\n    points
    = 0\r\n    guesses.each_with_index do |guess, i|\r\n      if guess == winners[i]\r\n
    \       points += scores[i]\r\n      elsif winners.include? guess\r\n        points
    += misplaced\r\n      end\r\n    end\r\n    points\r\n  end\r\nend\r\n```\r\n\r\nThat's
    much better, in my opinion.  The scores now have names.  They are in constants,
    so you can reflect on them externally.  This approach allows us to update the
    specs to use these values.  (I'll leave that work as an exercise for the interested
    reader.)  Finally, because we are passing the constants as defaults to method
    arguments, they can be overridden as needed, which ends their reign as magic values.\r\n\r\nOf
    course, we took that step to get to this one:\r\n\r\n```ruby\r\nmodule Race\r\n
    \ SCORES    = [15, 10, 5, 3, 1]\r\n  MISPLACED = 1\r\n\r\n  module_function\r\n\r\n
    \ def score(guesses, winners, scores = SCORES, misplaced = MISPLACED)\r\n    points
    = 0\r\n    guesses.zip(winners, scores) do |guess, winner, score|\r\n      if
    guess == winner\r\n        points += score\r\n      elsif winners.include? guess\r\n
    \       points += misplaced\r\n      end\r\n    end\r\n    points\r\n  end\r\nend\r\n```\r\n\r\nThe
    switch to `zip()` was straightforward and makes the code read better.  Plus, we're
    rid of that index.\r\n\r\nThis code is pretty close to the code I ended up with
    while fiddling with this problem.\r\n\r\n### The point\r\n\r\nI don't want to
    tell you what to get out of this exercise, but I can tell you what I got out of
    it, which is mainly to remember the true purpose of a thing.  For example:\r\n\r\n*
    Following the proper steps of BDD is meant to **help you write code**.  If it
    turns into busywork that doesn't help, you are free to go another way.  And maybe
    you should feel compelled to go another way at that point.\r\n* Iterators are
    intended to **save you from maintenance and potential error points**, such as:
    \ tracking indexes or other variables and doing too much work.  If you find yourself
    in either of these scenarios, go spelunking in `Enumerable` to see whether there's
    a better tool for the job.  Heck, do that anyway... it's fun!  Do you know [what
    Enumerable#chunk() does][chunk] yet?\r\n* The primary purpose of code is to **communicate
    with the reader.**  Period.  No, really!  Notice that in all of the steps in this
    article, I am trying to tease out the underlying meaning of the code, then write
    the code as close to that intention as possible.  That's when we're at our best,
    if you ask me.\r\n\r\n[chunk]: http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-chunk\r\n"
- :slug: persisting-relations-in-a-polyglot-world
  :title: Persisting relations in a polyglot world
  :summary: Explore some non-traditional persistence mechanisms and their uses.  (w.
    Piotr Szotkowski)
  :published: 2012-05-21 00:00:00.000000000 Z
  :issue_number: '4.6'
  :volume: 4
  :body: "*This article is written by Piotr Szotkowski. Greg invited Piotr to contribute\r\nto
    Practicing Ruby after seeing his RubyConf 2011 talk _Persisting\r\nRelations Across
    Time and Space_\r\n([slides](http://persistence-rubyconf-2011.heroku.com),\r\n[video](http://confreaks.net/videos/657)).
    This is not a one-to-one text\r\nversion of that talk; Piotr has instead chosen
    to share some thoughts on the topics of\r\n[polyglot persistence](http://architects.dzone.com/articles/polyglot-persistence-future)\r\nand
    modeling relations between objects.*\r\n\r\n### Persistence: Your Objects Time
    Travel\r\n\r\n> If the first thing you type, when writing a Ruby app, is `rails`,
    youve\r\n> already lost the [architecture game](http://confreaks.com/videos/759).\r\n>\r\n>
    <cite>Uncle Bob Martin</cite>\r\n\r\nThe first thing we need to ask ourselves
    when thinking about object persistence\r\nis how we can dehydrate an object into
    a set of simple valuesusually\r\nstrings, numbers, dates, and boolean flagsin
    a way that will let us\r\nrehydrate it at some point, often on a completely unrelated\r\nrun
    of our application. With the bulk of contemporary Ruby programs being Rails\r\nweb
    apps, this issue is so obvious that we usually dont even think about it; the\r\npersistence
    is conveniently taken care of by ActiveRecord, and we often actually\r\n_start_
    writing the application by defining database-oriented models of our\r\nobjects:
    \r\n\r\n```bash\r\n$ rails generate model person name bio:text height:float born:date
    vip:boolean\r\n$ rake db:migrate\r\n```\r\n\r\nThis simple two-line command sequence
    takes care of all the behind-the-scenes \r\nmachinery required to persist instances
    of our `Person` class. The main \r\nproblem with the previous example is that
    it puts us into a tight tunnel\r\nof relational database-driven design. Although
    many came back saying that the\r\nlight at the end is a truly glorious meadow
    and we should speed up to\r\nget there faster, our actual options of taking detours,
    driving on the\r\nshoulders, and stopping for a bit to get a high-altitude view
    of the road ahead\r\nare even more limited than the run of this metaphor. ActiveRecords
    handling of\r\nmodel relations (`belongs_to`, `has_many`, etc.)\r\nsometimes complicates
    the problem by giving us seemingly all-purpose solutions that\r\nare often quite
    useful but end up requiring just-this-little-bit-more tweaking, which accumulates
    over time.\r\n\r\n### Persistence in practice\r\n\r\n> A database is a black hole
    into which you put your data. If youre lucky,\r\n> youll get it back again.
    If youre very lucky, youll get it back in a form\r\n> you can use.\r\n>\r\n>
    <cite>Charlie Gibbs</cite>\r\n\r\nAs mentioned previously, persisting an object
    means dehydrating it into a set of\r\nsimple values. The way we do this depends
    heavily on the database backend\r\nbeing used.\r\n\r\nWhen it comes to the most
    popular case of relational databases (such as MySQL,\r\nPostgreSQL or SQLite),
    we use tables for classes, rows for objects, and columns\r\nto hold a given object
    property across all instances of the same class. To\r\npersist an object, we serialize
    the given objects properties down into table\r\ncells with column types supported
    by the underlying databasebut even in this\r\nseemingly obvious case, its worth
    it to stop for a second and think.\r\n\r\nShould we go for the lowest common denominator
    (strings, numbers, and dates\r\neven booleans are not really cross-engine; for
    instance, MySQL presents them as one-bit\r\nintegers, `0` and `1`), should we
    use a given ORMs common ground (here\r\nbooleans are usually fair game, and
    the ORM can take care of exposing them as\r\n`true` and `false`), or should we
    actually limit the portability while\r\nleveraging a given RDBMSs features? For
    example, PostgreSQL exposes not only \r\nreal booleans but also [a lot of other
    very useful\r\ntypes](http://www.postgresql.org/docs/9.1/static/datatype.html),
    including\r\ngeometric points and paths, network addresses, and XML documents
    that\r\ncan be searched and filtered via XPath. It even supports arrays, which
    means\r\nthat we can store a given blog posts tags in a single column in the
    \r\n`posts` table and query by inclusion/exclusion just as well as we could \r\nwith
    a separate join table.\r\n\r\n> Database research has produced a number of good
    results, but the relational\r\n> database is not one of them.\r\n>\r\n> <cite>Henry
    G. Baker</cite>\r\n\r\nPersisting objects in document databases (such as CouchDB
    or MongoDB) is\r\nsomewhat similar, but often also quite a bit different; classes
    are usually mapped\r\nto collections, objects to documents, and object properties
    to these documents\r\nfields. Although strings, numbers, and dates are serialized
    similarly to relational\r\ndatabases, document databases also usually allow us
    to store properties that\r\nare arrays or hashes and allow easy storage of related
    objects as nested\r\ndocuments (the canonical example being comments for a blog
    post, in cases when\r\ntheyre most often requested only in the context of the
    given post). This\r\nresults in all sorts of trade-offs. For example, you might
    end up needing to\r\ndo fewer joins overall, but the ones you do have to do come
    at a higher \r\ncost in both performance and upfront design work.\r\n\r\nOther
    kinds of databases have still other approaches for serializing objects:\r\n\r\n*
    Key-value stores (like Redis) usually need the objects to be in an\r\nalready
    serialized form (e.g., represented as JSON strings), but there are\r\ngems like
    [ROC](https://github.com/benlund/roc) that map simple objects\r\ndirectly to their
    canonical Redis representations. \r\n\r\n* Graph databases (such as Neo4j) are
    centered around object relations \r\nand often allow persisting objects as schema-less
    nodes, akin to \r\ndocument databases. \r\n\r\n* Many other storage types have
    their own object/persistence \r\nmapping specifics as well. For example, as a
    directory service,\r\nLDAP does things in a way that is different from how general-purpose
    \r\npersistence methods tend to work. \r\n\r\nFrom just this short overview, it
    should be fairly clear that there are no\r\nshortage of options when it comes
    to deciding how your objects should\r\nbe persisted. In fact, even Ruby itself
    ships with a simple object store!\r\n\r\n### Ruby's built-in persistence mechanism
    \r\n\r\nOne of my personal favorite ways of persisting objects is the `PStore`\r\nlibrary
    (which is distributed with Ruby) coupled with YAML serialization. Despite being\r\nhighly
    inefficient (compared to powerhouses like relational or document\r\ndatabases),
    its often more than good enough for small applications, and its\r\nsimplicity
    can be quite a benefit.\r\n\r\nLets assume for a second that we want to write
    [a small application for\r\nhandling quotes](https://github.com/chastell/signore):
    what would be the\r\nsimplest way to persist them? See for yourself:\r\n\r\n```ruby\r\nrequire
    'yaml/store'\r\nstore = YAML::Store.new 'quotes.yml'\r\n\r\n# quotes are author
    + text structures\r\nQuote = Struct.new :author, :text\r\n\r\nstore.transaction
    do   # a read/write transaction...\r\n  store['db'] ||= []\r\n  store['db'] <<
    Quote.new('Charlie Gibbs',\r\n    'A database is a black hole into which you put
    your data.')\r\n  store['db'] << Quote.new('Will Jessop',\r\n    'MySQL is truly
    the PHP of the database world.')\r\nend                    # ...is atomically
    committed here\r\n\r\n# read-only transactions can be concurrent\r\n# and raise
    when you try to write anything\r\nstore.transaction(true) do\r\n  store['db'].each
    do |quote|\r\n    puts quote.text\r\n    puts '-- ' + quote.author\r\n    puts\r\n
    \ end\r\nend\r\n```\r\n\r\nSaving the previous example file and running it prints
    the two quotes just fine:\r\n\r\n```\r\n$ ruby quotes.rb\r\nA database is a black
    hole into which you put your data.\r\n-- Charlie Gibbs\r\n\r\nMySQL is truly the
    PHP of the database world.\r\n-- Will Jessop\r\n```\r\n\r\nBut a real treat awaits
    when we inspect the `quotes.yml` file:\r\n\r\n```\r\n---\r\ndb:\r\n- !ruby/struct:Quote\r\n
    \ author: Charlie Gibbs\r\n  text: A database is a black hole into which you put
    your data.\r\n- !ruby/struct:Quote\r\n  author: Will Jessop\r\n  text: MySQL is
    truly the PHP of the database world.\r\n```\r\n\r\nThis approach allows us to
    have an automated way to persist and rehydrate our `Quote`\r\nobjects while also
    allowing us to easily edit them and fix any typos right\r\nthere in the YAML file.
    Is it scalable? Maybe not, but [my current\r\ndatabase of email\r\nsignatures](https://github.com/chastell/dotfiles/blob/aee1d31618e2e4ea88186eda163f29ebd72702d1/.local/share/signore/signatures.yml)\r\nconsists
    of 4,000 entries and works fast enough.\r\n\r\n> **NOTE:** If youre eager to
    try YAML as a storage backend, check out [YAML Record](https://github.com/nico-taing/yaml_record)
    and [YAML Model](http://www.darkarts.co.za/yaml-model).\r\n\r\n### Sweet relations:
    how do they work?\r\n\r\nNow that Ive covered the idea of object persistence
    using various backends,\r\nits finally time to talk about relations between objects.
    Quite often the\r\nrelations are the crux of our application (even when were
    not building\r\nanother social network...), and the problem of their persistence
    is usually\r\noverlooked and simplified to Lets just use foreign keys and join
    tables where\r\nneeded.\r\n\r\nThe way relations are canonically persisted depends
    greatly on the type of the\r\ndatabase. Contrary to their name, relational databases
    are not an ideal\r\nsolution for storing relations: their name comes from relations
    between the\r\nrows of a single table (which translates to the assumption that
    objects of the\r\nsame class have the same property types), not from relations
    between objects of\r\npotentially different classes, which end up being rows in
    separate tables.\r\n\r\nModeling relations in relational databases is quite complicated
    and depends on\r\nthe type of relation, its directionality, and whether it carries
    any\r\nrelation-specific data. For example, an object representing a person can
    have\r\nthe relations such as having a particular gender (one-to-many relation),
    having\r\na hobby (many-to-many), having a spouse (many-to-many, with the relation\r\ncarrying
    additional data, such as start date of the relationship),\r\nparticipating in
    an event (many-to-many, with additional data such as\r\nparticipation role), being
    on two different ends of a parental relation (having\r\nparents and children),
    and so on. Some of these relations (gender) can be stored\r\nright in the `people`
    table; some need to be represented by having a foreign\r\nkey; others require
    a separate join table (potentially carrying any\r\nrelation-specific data). Dereferencing
    such relations means crafting and\r\nexecuting (potentially complicated) SQL `JOIN`
    queries.\r\n\r\n![relations](http://i.imgur.com/CO6gf.png)\r\n\r\n_An example
    set of relations (arrows) between typical objects in a system._\r\n\r\nModeling
    relations in document databases is quite different from modeling for\r\na RDMS.
    Some of the relations (like the above-mentioned post/comments example) \r\nare
    best modeled using embedded documents. Despite being very useful in certain scenarios
    (e.g., retrieving\r\na post with all of its comments), this approach might cause
    problems when new\r\nfeatures require cross-cutting through all of such embedded
    documents. For\r\nexample, retrieving all of the comments by a given person or
    getting the list of the\r\nmost recent comments means scanning through the whole
    `posts` collection.\r\n\r\nAlthough some document databases employ implicit, foreign-key-like
    references\r\n(e.g., MongoDBs DBRefs, which are two-key documents of the form
    `{ $ref:\r\n<collection>, $id: <object_id> }`), dereferencing relations is usually
    a bigger\r\nproblem (due to the lack of standard approaches like SQL `JOIN` queries)
    and is\r\noften done on the client side, even if its greatly simplified by tools
    like\r\n[MongoHydrator](https://github.com/gregspurrier/mongo_hydrator).\r\n\r\nKey-value
    stores are, by definition, the least relation-friendly backendsand\r\nusing them
    for modeling relations requires explicit foreign keys that need to\r\nbe managed
    on the client side. On the other end of the spectrum are graph databases:\r\nrelations
    (modeled as edges) can usually carry any data required, can as\r\neasily point
    in either or both directions, and are represented in the same way\r\nregardless
    of whether they model a one-to-one, one-to-many, or many-to-many\r\nrelation.
    Graph databases also allow for all kinds of data analysis/querying\r\nbased on
    the relations themselves, making things like graph traversal or proximity\r\nmetrics
    easier and faster than they would be with a relational database.\r\n\r\n### Modeling
    relations as proper objects\r\n\r\nNow that you know the different ways (and issues
    with) persisting objects and\r\nrelations between them, is there a way to model
    relations that could be deemed\r\npersistence independent, or at least not
    persistence driven? One such approach \r\nwould be to model relations as proper
    objects in the system, akin to\r\nhow theyre modeled in graph databases.\r\n\r\nIn
    this approach, relations would be objects that reference two other objects\r\nand
    carry any additional data particular to a given relation (such as\r\nparticipation
    role in a relation between a person and an event, start/end dates\r\nof the given
    relation, etc.). This approach is the most flexible in schema-less\r\ndatabasesdocument
    databases could have a separate collection of relations,\r\nand different relations
    could store different types of data. In relational\r\ndatabases, this design could
    be modeled by either separate tables (one per relation\r\ntype) or a common `relations`
    table storing the references to the related\r\nobjects and a relation type pointing
    to a table holding data for all relations\r\nof this particular type/schema.\r\n\r\nThe
    main drawback of this approach is dereferencinggetting other objects\r\nrelated
    to the object at hand would be a two-step process: getting all of\r\nthe objects
    relations (potentially only of a certain type) and then getting\r\nall of the
    other objects referenced by these relations. Note, however, that\r\nthis is
    exactly what we do every day with join tables for many-to-many\r\nrelations, so
    the drawback is mostly that this approach would apply to all of\r\nthe relations
    in the given system, not only many-to-many ones.\r\n\r\nThe main advantages of
    this approach are its simplicity (everything is an\r\nobject; relations just happen
    to carry certain properties, like the identifiers\r\nof the objects they reference)
    and its potential higher portability (in that it doesn't tie\r\nthe way relations
    are modeled to a given persistence approach). Having\r\nrelations as proper objects
    can also help in producing aggregated statistics\r\nabout the system (like what
    are the hubs of the systemthe most connected\r\nobjects, regardless of relation
    type).\r\n\r\nAdditionally, when all of the objects in the system have unique
    identifiers\r\n(_of course_ [PostgreSQL has a native type for\r\nUUIDs](http://www.postgresql.org/docs/9.1/static/datatype-uuid.html)),\r\nrelations
    no longer need to carry the information about the table/collection of\r\nthe referenced
    object; assuming the system has a way to retrieve an object\r\nsolely based on
    its UUID, relations becomein their simplest formjust\r\ntriples of 128-bit UUIDs
    (one identifying the relation and the other two identifying the\r\nreferenced
    objects) plus some information about the relation type.\r\n\r\n### Object databases\r\n\r\n>
    Now that people are considering NoSQL, will more people consider no-database?\r\n>\r\n>
    <cite>Martin Fowler</cite>\r\n\r\nA different approach to solving problems with
    persisting relations\r\nbetween objects is to persist the objects not in a way
    that requires explicit\r\nmapping, but by using an object database.\r\n\r\nIn
    the past, there were a few approaches to solving this problem in Ruby\r\nnotable
    contestants being [Madeleine](http://madeleine.rubyforge.org),\r\n[ODB](http://zeropluszero.com/software/odb/),
    and\r\n[HybridDB](https://github.com/pauliephonic/hybriddb); unfortunately, all
    of\r\nthese seem to be no longer maintained (although some birds at the wroc\\_love.rb\r\nconference
    earlier this year suggested that it might be revived if enough interest\r\nis
    expressed!). Currently the most promising solution for straight object\r\npersistence
    is [MagLev](http://maglev.github.com), a recently released Ruby\r\nimplementation
    built on top of the GemStone/S Virtual Machine known as _the_\r\nSmalltalk object
    persistence solution. Although it probably wont be\r\na widely adopted silver
    bullet for some time, I have high hopes for MagLev and\r\nthe changes that object
    persistence can bring to the way we think about giving our\r\nobjects immortality.\r\n\r\nUnfortunately,
    because the use of object databases is not widespread at all,\r\nthere is not
    much more to say about them except that they may prove to be an\r\ninteresting
    option in the future.\r\n\r\n### Not your usual persistence models\r\n\r\nI will
    wrap up this article with two examples of object persistence\r\nthat are not related
    to persisting relations but rather to hiding persistence\r\naltogether. ActiveRecord
    gives us a nice abstraction for wrting SQL, but\r\nthese two examples show how
    persistence can be abstracted even more.\r\n\r\nThe first example is [Candy](https://github.com/SFEley/candy).
    Although it is\r\ncurrently unmaintained and in need of a fix to get running with
    the current\r\nmongo gem, Candy is a nice and/or crazy example of how object persistence
    can be hidden\r\nfrom our eyes with a single `include Candy::Piece` line:\r\n\r\n```ruby\r\nrequire
    'candy'\r\n\r\nclass Conference\r\n  include Candy::Piece\r\nend\r\n\r\nrubyconf
    = Conference.new\r\n# connects to localhost:27017 and 'chastell' db if needed\r\n#
    and saves a new document to the 'Conference' collection\r\n\r\nrubyconf.location
    = 'New Orleans'   # method_missing resaves\r\n\r\nrubyconf.events = { parties:
    { thursday: '&block Party' } }\r\nrubyconf.events.parties.thursday    #=> '&block
    Party'\r\n```\r\n\r\nFor a similarly unobtrusive way to _query_ a collection,\r\n[Ambition](https://github.com/defunkt/ambition)
    provides a way \r\nto do Ruby-like queries against any supported persistence store.
    \r\nLike Candy, it is currently unmaintained but still worth checking out.\r\n\r\nTo
    see why Ambition is interesting, compare the following query against \r\nan ActiveRecord-supported
    store:\r\n\r\n```ruby\r\nrequire 'ambition/adapters/active_record'\r\n\r\nclass
    Person < ActiveRecord::Base\r\nend\r\n\r\nPerson.select do |p|\r\n  (p.country
    == 'USA' && p.age >= 21) ||\r\n  (p.country != 'USA' && p.age >= 18)\r\nend\r\n```\r\n\r\nwith
    an example query against an LDAP backend:\r\n\r\n```ruby\r\nrequire 'ambition/adapters/active_ldap'\r\n\r\nclass
    Person < ActiveLdap::Base\r\nend\r\n\r\nPerson.select do |p|\r\n  (p.country ==
    'USA' && p.age >= 21) ||\r\n  (p.country != 'USA' && p.age >= 18)\r\nend\r\n```\r\n\r\nAlthough
    the code difference lays solely in the `require` and inheritance\r\nclauses, the
    resulting backend query in the first place is the following SQL:\r\n\r\n```sql\r\nSELECT
    * FROM people\r\nWHERE (\r\n  (people.country =  'USA' AND people.age >= 21) OR\r\n
    \ (people.country <> 'USA' AND people.age >= 18)\r\n)\r\n```\r\n\r\nAnd the query
    generated by the latter is the equivalent LDAP selector:\r\n\r\n```\r\n(|\r\n
    \ (& (country=USA)    (age>=21))\r\n  (& (!(country=USA)) (age>=18))\r\n)\r\n```\r\n\r\nThese
    examples demonstrate how the benefits of the cross-platform nature of\r\nusing
    an ORM are preserved even though the syntax makes it appear as if\r\nyou are not
    working with a database at all. Although this style of interface\r\nnever quite
    caught on in the Ruby world, it is at least interesting to\r\nthink about.\r\n\r\n###
    Closing thoughts\r\n\r\nThe problem of persisting object relations is tightly
    related to the general problem of object\r\npersistence. Rails, with its `rails
    generate model`driven development,\r\nteaches us that our domain models should
    be tied one-to-one to their database\r\nrepresentations, but there are other (potentially
    better) ways to do persistence\r\nin the object-oriented world.\r\n\r\nIf this
    topic sounds intriguing, you might be\r\ninterested in another of my talks, which
    was given at wroc\\_love.rb this year (with a\r\nhighly revised version scheduled
    for the Scottish Ruby Conference in Edinburgh):\r\n_Decoupling Persistence (Like
    Theres Some Tomorrow)_\r\n([slides](http://decoupling-wrocloverb-2012.heroku.com),\r\n[video](https://www.youtube.com/watch?v=w7Eol9N3jGI)).\r\n"
- :slug: confident-ruby
  :title: Writing confident code
  :summary: Develop intention-revealing code that is confident about its responsibilities.
    (w. Avdi Grimm)
  :published: 2012-06-05 00:00:00.000000000 Z
  :issue_number: '4.7'
  :volume: 4
  :body: "*This article was contributed by [Avdi Grimm](http://avdi.org). Avdi has
    been wrangling Ruby code for over a\r\ndecade and shows no signs of slowing down.
    He is the author of\r\n[*Exceptional Ruby*](http://exceptionalruby.com) and\r\n[*Objects
    on Rails*](http://objectsonrails.com). His next book,\r\n[*Confident Ruby*](http://confidentruby.com),
    focuses on writing Ruby\r\ncode with a confident and straightforward style.*\r\n\r\n###
    Losing the plot\r\n\r\nHave you ever read a \"choose your own adventure\" book?
    Nearly every page ends with a question like this:\r\n\r\n> * If you fight the
    angry troll with your bare hands, turn to page 137.\r\n> * If you try to reason
    with the troll, turn to page 29.\r\n> * If you don your invisibility cloak, turn
    to page 6.\r\n\r\nYou'd pick one option, turn to the indicated page, and the story
    would\r\ncontinue.\r\n\r\nDid you ever try to read one of those books from front
    to back? It's a\r\nsurreal experience. The story jumps forward and back in\r\ntime.
    Characters appear out of nowhere. One page you're crushed by the\r\nfist of an
    angry troll, and on the next you're just entering the\r\ntroll's realm for the
    first time.\r\n\r\nWhat if _each individual page_ was this kind of mish-mash?
    What if\r\nevery page read like this:\r\n\r\n>   You exit the passageway into
    a large cavern. Unless you came from\r\n>   page 59, in which case you fall down
    the sinkhole into a large\r\n>   cavern. A huge troll, or possibly a badger (if
    you already visited\r\n>   Queen Pelican), blocks your path. Unless you threw
    a button down the\r\n>   wishing well on page 8, in which case there nothing blocking
    your\r\n>   way. The [troll or badger or nothing at all] does not look happy to\r\n>
    \  see you.\r\n> \r\n> * If you came here from chapter 7 (the Pool of Time), go
    back to the\r\n>   top of the page and read it again, only imagine you are watching
    the\r\n>   events happen to someone else.\r\n> \r\n> * If you already received
    the invisibility cloak from the aged\r\n>   lighthouse-keeper, and you want to
    use it now, go to page 67. Otherwise, forget you read anything about an invisibility
    cloak.\r\n> \r\n> * If you are facing a badger (see above), and you choose to
    run away,\r\n>   turn to page 93\r\n\r\nNot the most compelling narrative, is
    it? The story asks you to carry\r\nso much mental baggage for it that just getting
    through a page is\r\nexhausting.\r\n\r\n### Code as narrative\r\n\r\nWhat does
    this have to do with software? Well, code can tell a story\r\nas well. It might
    not be a tale of high adventure and intrigue. But\r\nit's a story nonetheless;
    one about a problem that needed to be\r\nsolved, and the path the developer(s)
    chose to accomplish that task.\r\n\r\nA single method is like a page in that story.
    And unfortunately, a lot\r\nof methods are just as convoluted, equivical, and
    confusing as that\r\nmade-up page above.\r\n\r\nIn the following sections, we'll
    take a look at some examples of code\r\nthat unnecessarily obscures the storyline
    of a method. We'll also\r\nexplore some techniques for minimizing distractions
    and writing\r\nmethods that straightforwardly convey their intent.\r\n\r\n###
    Secure the borders\r\n\r\nHere is some code that's having some trouble sticking
    to the plot:\r\n\r\n```ruby\r\nrequire 'date'\r\n\r\nclass Employee\r\n  attr_accessor
    :name\r\n  attr_accessor :hire_date\r\n\r\n  def initialize(name, hire_date)\r\n
    \   @name      = name\r\n    @hire_date = hire_date\r\n  end\r\n\r\n  def due_for_tie_pin?\r\n
    \   raise \"Missing hire date!\" unless hire_date\r\n    ((Date.today - hire_date)
    / 365).to_i >= 10\r\n  end\r\n\r\n  def covered_by_pension_plan?\r\n    # TODO
    Someone in HR should probably check this logic\r\n    ((hire_date && hire_date.year)
    || 2000) < 2000\r\n  end\r\n\r\n  def bio\r\n    if hire_date\r\n      \"#{name}
    has been a Yoyodyne employee since #{hire_date.year}\"\r\n    else\r\n      \"#{name}
    is a proud Yoyodyne employee\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWe can
    speculate about the history of this class. It looks like over\r\nthe course of
    development, three different developers discovered that\r\n`#hire_date` might
    sometimes be `nil`. They each chose to handle this\r\nfact in a slightly different
    way. The one who wrote\r\n`#due_for_tie_pin?` added a check that raises an exception
    if the hire\r\ndate is missing. The developer responsible for\r\n`#covered_by_pension_plan`
    substituted a (seemingly arbitrary) default\r\nvalue for `nil`. And the writer
    of `#bio` went with an `if` statement\r\nswitching on the presence of `#hire_date`.\r\n\r\nThis
    class has serious problems with second-guessing itself. And the\r\nroot of all
    this insecurity is the fact that the `#hire_date`\r\nattribute is unreliableeven
    though it's clearly important to the operation of the class!\r\n\r\n\r\nOne of
    the purposes of a constructor is to establish an object's\r\ninvariant: a set
    of properties which should always hold true for that\r\nobject. In this case,
    it really seems like one of those invariants should be: *employee hire date is
    a `Date`*.\r\n\r\nBut the constructor, whose job it is to stand guard against
    initial\r\nvalues which are not compatible with the class invariant, has fallen\r\nasleep
    on the job. As a result, every other method dealing with hire\r\ndates is burdened
    with the additional responsibility of checking\r\nwhether the value is present.\r\n\r\nThis
    is an example of a class which needs to set some\r\nboundaries. Since there is
    no obvious \"right\" way to handle a missing\r\nhire date, it probably needs to
    simply insist on having a valid hire\r\ndate, thereby forcing the cause of these
    spurious `nil` values to be\r\ndiscovered and sorted out. To do this, it should
    guard its own\r\nintegrity by checking the value wherever it is set, either in
    the\r\nconstructor or elsewhere:\r\n\r\n```ruby\r\nrequire 'date'\r\n\r\nclass
    Employee\r\n  attr_accessor :name\r\n  attr_reader :hire_date  \r\n\r\n  def initialize(name,
    hire_date)\r\n    @name          = name\r\n    self.hire_date = hire_date\r\n
    \ end\r\n\r\n  def hire_date=(new_hire_date)\r\n    raise TypeError, \"Invalid
    hire date\" unless new_hire_date.is_a?(Date)\r\n    @hire_date = new_hire_date\r\n
    \ end\r\n\r\n  def due_for_tie_pin?\r\n    ((Date.today - hire_date) / 365).to_i
    >= 10\r\n  end\r\n\r\n  def covered_by_pension_plan?\r\n    hire_date.year < 2000\r\n
    \ end\r\n\r\n  def bio\r\n    \"#{name} has been a Yoyodyne employee since #{hire_date.year}\"\r\n
    \ end\r\nend\r\n```\r\n\r\nIn this version, the `hire_date` attribute is protected
    by type check\r\nin the setter method. Since the constructor now delegates to
    this\r\nsetter method to initialize the attribute, it is no longer possible to\r\nconstruct
    new `Employee` objects without a valid hire date. Now that\r\nthe \"borders\"
    of the object are guarded, all the other methods can\r\nfocus on telling their
    own stories, without being distracted by\r\na potentially missing `hire_date`.\r\n\r\n###
    Be assertive\r\n\r\nIn the last section we saw how assertions in a class' constructor
    or\r\nsetter methods can help keep the other methods focused. But\r\nuncertainty
    and convoluted code can come from sources\r\nother than input parameters.\r\n\r\nLet's
    say you're working on some budget management software. The next\r\nuser story
    requires the application to pull in transaction data from a\r\nthird-party electronic
    banking API. According to the meager\r\ndocumentation you can find, you need to
    use the\r\n`Bank#read_transactions` method in order to load bank\r\ntransactions.
    The first thing you decide to do is to stash the loaded\r\ntransactions into a
    local data store.\r\n\r\n```ruby\r\nclass Account\r\n  def refresh_transactions\r\n
    \   transactions = bank.read_transactions(account_number)\r\n    # ... now what?\r\n
    \ end\r\nend\r\n```\r\n\r\nUnfortunately the documentation doesn't say what the\r\n`#read_transactions`
    method returns. An `Array` seems likely. But what\r\nif there are no transactions
    found? What if the account is not found?\r\nWill it raise an exception, or perhaps
    return `nil`? Given enough time\r\nyou might be able to work it out by reading
    the API library's source\r\ncode, but it's pretty convoluted and you might still
    miss some edge\r\ncases.\r\n\r\nYou decide to make an assumption but as insurance,
    you document your assumption with an assertion.\r\n\r\n```ruby\r\nclass Account\r\n
    \ def refresh_transactions\r\n    transactions = bank.read_transactions(account_number)\r\n
    \   transactions.is_a?(Array) or raise TypeError, \"transactions is not an Array\"\r\n
    \   transactions.each do |transaction|\r\n      # ...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou
    manually test the code against a test account and it doesn't blow\r\nup, so it
    seems your suspicion was correct. Next, you move on to\r\npulling amount information
    out of the individual transactions.\r\n\r\nYou ask your teammate, who has had
    some experience with this API, what\r\nformat transactions are in. She says she
    thinks they are hashes with\r\nstring keys. You decide to tentatively try looking
    at the \"amount\"\r\nkey.\r\n\r\n```ruby\r\ntransactions.each do |transaction|\r\n
    \ amount = transaction[\"amount\"]\r\nend\r\n```\r\n\r\nYou look at this for a
    few seconds, and realize that if there is no\r\n\"amount\" key, you'll just get
    a `nil` back. Then you'd have to check\r\nfor the presence of `nil` everywhere
    the amount is used. You'd prefer\r\nto document your assumption more explicitly.
    So instead, you make an\r\nassertion by using the `Hash#fetch` method:\r\n\r\n```ruby\r\ntransactions.each
    do |transaction|\r\n  amount = transaction.fetch(\"amount\")\r\nend\r\n```\r\n\r\n`Hash#fetch`
    will raise a `KeyError` if the given key is not found,\r\nsignaling that one of
    your assumptions about the `Bank API` was\r\nincorrect.\r\n\r\nYou make another
    trial run and you don't get any exceptions, so you\r\nproceed onward. Before you
    can store the value locally, you want to\r\nmake sure the transaction amount is
    in a format that your local\r\ntransaction store can understand. Nobody in the
    office seems to know\r\nwhat format the amounts come in as. You know that many
    financial\r\nsystem store dollar amounts as an integer number of cents, so you\r\ndecide
    to proceed with the assumption that it's the same with this\r\nsystem. In order
    to once again document your assumption, you make\r\nanother assertion:\r\n\r\n```ruby\r\ntransactions.each
    do |transaction|\r\n  amount = transaction[\"amount\"]\r\n  amount.is_a?(Integer)
    or raise TypeError, \"amount not an Integer\"\r\nend\r\n```\r\n\r\nYou put the
    code through it's paces and BOOM. You get an error.\r\n\r\n```\r\nTypeError:
    amount not an Integer\r\n```\r\n\r\nYou decide to drop into the debugger on the
    next round, and take a\r\nlook at the transaction values coming back from the
    API. You see this:\r\n\r\n```ruby\r\n[\r\n {\"amount\" => \"1.23\"},\r\n {\"amount\"
    => \"4.75\"},\r\n {\"amount\" => \"8.97\"}\r\n]\r\n```\r\n\r\nWell that's interesting.
    The amounts are reported as decimal strings.\r\n\r\nYou decide to convert them
    to integers, since that's what\r\nyour internal `Transaction` class uses.\r\n\r\n```ruby\r\ntransactions.each
    do |transaction|\r\n  amount = transaction.fetch(\"amount\")\r\n  amount_cents
    = (amount.to_f * 100).to_i\r\n  # ...\r\nend\r\n```\r\n\r\nOnce again, you find
    yourself questioning this code as soon as you\r\nwrite it. You remember something
    about `#to_f` being really forgiving\r\nin how it parses numbers. A little experimentation
    proves this to be\r\ntrue.\r\n\r\n```ruby\r\n\"1.23\".to_f                     #
    => 1.23\r\n\"$1.23\".to_f                    # => 0.0\r\n\"a hojillion\".to_f
    \             # => 0.0\r\n```\r\n\r\nOnly having a small sample of demonstration
    values to go on, you're\r\nnot confident that the amounts this API might return
    will always be in\r\na format that `#to_f` understands. What about negative numbers?
    Will\r\nthey be formatted as \"-4.56\"? Or as \"(4.56)\"? Having an unrecognized\r\namount
    format silently converted to zero could lead to nasty bugs down\r\nthe road.\r\n\r\nYet
    again, you want a way to state in no uncertain terms what kind of\r\nvalues the
    code is prepared to deal with. This time, you use\r\nKernel#Float to assert that
    the amount is in a format Ruby can parse\r\nunambiguously as a floating point
    number:\r\n\r\n```ruby\r\ntransactions.each do |transaction|\r\n  amount = transaction.fetch(\"amount\")\r\n
    \ amount_cents = (Float(amount) * 100).to_i\r\n  cache_transaction(:amount =>
    amount_cents)\r\nend\r\n```\r\n\r\n`Kernel#Float` is much stricter than `String#to_f`:\r\n\r\n```ruby\r\nFloat(\"$1.23\")\r\n#
    ~> -:1:in `Float': invalid value for Float(): \"$1.23\" (ArgumentError)\r\n# ~>
    \   from -:1:in `<main>'\r\n```\r\n\r\nThe final code is chock full of assertions:\r\n\r\n```ruby\r\nclass
    Account\r\n  def refresh_transactions\r\n    transactions = bank.read_transactions(account_number)\r\n
    \   transactions.is_a?(Array) or raise TypeError, \"transactions is not an Array\"\r\n
    \   transactions.each do |transaction|\r\n      amount = transaction.fetch(\"amount\")\r\n
    \     amount_cents = (Float(amount) * 100).to_i\r\n      cache_transaction(:amount
    => amount_cents)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis code clearly states
    what it expects. It communicates a great deal\r\nof information about your understanding
    of the external API at the\r\ntime you wrote it. It explicitly establishes the
    parameters within\r\nwhich it can operate confidently; as soon as any of its expectations\r\nare
    violated it fails quickly, with a meaningful exception message.\r\n\r\nUnfortunately,
    as a result it is really telling two stories: one about\r\nrefreshing transactions
    (remember, that's nominally what this method is\r\nabout) and one about the format
    of an external data source. This is\r\nquickly mended, however:\r\n\r\n```ruby\r\nclass
    Account\r\n  def refresh_transactions\r\n    fetch_transactions do |transaction_attributes|\r\n
    \     cache_transaction(transaction_attributes)\r\n    end\r\n  end\r\n\r\n  #
    Yields a hash of cleaned-up transaction attributes for each transaction\r\n  def
    fetch_transactions\r\n    transactions = bank.read_transactions(account_number)\r\n
    \   transactions.is_a?(Array) or raise TypeError, \"transactions is not an Array\"\r\n
    \   transactions.each do |transaction|\r\n      amount = transaction.fetch(\"amount\")\r\n
    \     amount_cents = (Float(amount) * 100).to_i\r\n      yield(:amount => amount_cents)\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nBy failing early rather than allowing misunderstood
    inputs to\r\ncontaminate the system, it reduces the need for type-checking and\r\ncoercion
    in other methods. And not only does this code document your\r\nassumptions now,
    it also sets up an early-warning system should the\r\nthird-party API ever change
    unexpectedly in the future.\r\n\r\n### Represent special cases with objects\r\n\r\nThe
    most common causes of code that tells a confusing story are\r\nspecial cases.
    Let's look at an example of a special case, in the\r\ncontext of our budgeting
    application.\r\n\r\nYou've implemented transaction import and it's working great.
    Except\r\nfor one little problem: users have been reporting bugs about the\r\nreported
    balances being off. And not just the balances; in fact, all\r\nof the reports
    seem to have incorrect numbers for some accounts.\r\n\r\nYou do some investigation
    into the system logs, and eventually\r\ndiscover the culprit. It turns out that
    some banks, when they receive\r\na authorization for a credit card charge, immediately
    report it as a\r\npending transaction in the transaction list. The data looks
    something\r\nlike this:\r\n\r\n```ruby\r\n{\"amount\" => \"55.08\", \"type\" =>
    \"pending\", \"id\" => \"98765\"}\r\n```\r\n\r\nThen, when the charge is completed
    or \"captured\", another transaction\r\nis recorded:\r\n\r\n```ruby\r\n{\"amount\"
    => \"55.08\", \"type\" => \"charge\", \"id\" => \"98765\"}\r\n```\r\n\r\n> **Aside:**
    if you've ever written code to deal with actual banking APIs,\r\n> you've probably
    figured out by now that I have not. I'm making this up for the\r\n> sake of example.
    I expect real banking APIs are just as idiosyncratic, though,\r\n> in their own
    ways.\r\n\r\nThe result of these \"double entries\" is that your calculations
    get\r\nthrown off. Your application has routines for summing transactions,\r\naveraging
    them, breaking them down by month and quarter, and many\r\nmore. And every one
    of these calculations uses the amount field to\r\narrive at its results.\r\n\r\nYou
    briefly consider simply throwing out pending transactions. But\r\nafter a quick
    consultation with your team you realize this would only\r\nintroduce more problems.
    There is sanity-checking code in place which\r\nchecks that the bank servers and
    the local cache have the same\r\ntransaction count and contain the same transaction
    IDs. And not only\r\nthat, you might actually want to use the pending transaction\r\ninformation
    for upcoming features.\r\n\r\nYour second option is to handle the special case
    *specially*,\r\neverywhere that the amount field is referenced. For example:\r\n\r\n```ruby\r\ndef
    account_balance\r\n  cached_transactions.reduce(starting_balance) do |balance,
    transaction|\r\n    if transaction.type == \"pending\"\r\n      balance\r\n    else\r\n
    \     balance + transaction.amount\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou'll
    have to carefully audit the code base, adding conditionals to\r\nevery use of
    amount. Not only that, you'll have to make sure anyone\r\nelse who works on this
    code understands the special case.\r\n\r\nThat doesn't seem like a very attractive
    option. Thankfully, there is\r\na third way. And the code above actually gives
    you the hint you needed\r\nto discover it.\r\n\r\nLet's look at that conditional
    again:\r\n\r\n```ruby\r\nif transaction.type == \"pending\"\r\n```\r\n\r\nThis
    code is branching on the type of a value. This is a huge clue. In\r\nan object-oriented
    language, anytime we branch on an object's type,\r\nwe're doing work that the
    language could be doing for us.\r\n\r\nYou realize that this special case calls
    for a special type of object\r\nto represent it.\r\n\r\nYou decide to try this
    approach out. You find the code where\r\ntransaction objects are being instantiated:\r\n\r\n```ruby\r\n#
    Note: we expect that transaction attributes have already been\r\n# converted to
    use Symbol keys at this point.\r\ndef cache_transaction(attributes)\r\n  cached_transactions
    << Transaction.new(attributes)\r\nend\r\n```\r\n\r\nYou change it to instantiate
    a different kind of object for pending\r\ntransactions. Because you want to quickly
    spike this approach, you use\r\nan `OpenStruct` to create a rough-and-ready ad-hoc
    object:\r\n\r\n```ruby\r\ndef cache_transaction(attributes)\r\n  transaction =
    \r\n    case attributes[:type]\r\n    when \"pending\"\r\n      pending_attributes
    = {\r\n        :amount         => 0,\r\n        :pending_amount => attributes[:amount]\r\n
    \     }\r\n      OpenStruct.new(attributes.merge(pending_attributes))\r\n    else\r\n
    \     Transaction.new(attributes)\r\n    end\r\n  cached_transactions << transaction\r\nend\r\n```\r\n\r\nThis
    switches on type as well, but it only does it once. After that,\r\nthe transaction
    can be used as-is in all of your existing algorithms.\r\n\r\nYou run some tests,
    and discover this fixes the problem! You consider\r\nsimply leaving the code as
    it is, since it's working now. But on\r\nreflection you decide that the concept
    of a pending transaction would\r\nbe best represented by a proper class. That
    way you have a place to\r\nput documentation about this special case, as well
    as any more special\r\nlogic you realize you need down the road.\r\n\r\n```ruby\r\n#
    A pending credit-card transaction\r\nclass PendingTransaction\r\n  attr_reader
    :id, :pending_amount\r\n\r\n  def initialize(attributes)\r\n    @id             =
    attributes.fetch(:id)\r\n    @pending_amount = attributes.fetch(:amount)\r\n  end\r\n\r\n
    \ def amount\r\n    # Pending transactions duplicate finished transactions, thus\r\n
    \   # throwing off calculations. For the purpose of calculations and\r\n    #
    reports, a pending transaction always has a zero amount. The\r\n    # real amount
    is available from #pending_amount.\r\n    0\r\n  end\r\nend\r\n```\r\n\r\nYou
    then rewrite `#cached_transactions` to use this new class.\r\n\r\n```ruby\r\ndef
    cache_transaction(attributes)\r\n  transaction = \r\n    case attributes[:type]\r\n
    \   when \"pending\"\r\n      PendingTransaction.new(attributes)\r\n    else\r\n
    \     Transaction.new(attributes)\r\n    end\r\n  cached_transactions << transaction\r\nend\r\n```\r\n\r\nThis
    code solves the immediate problem of a special type of\r\ntransaction, without
    duplicating logic for that special case all\r\nthroughout the codebase. But not
    only that, it is *exemplary*: it sets\r\na good example for code that follows.
    When, inevitably, another\r\nspecial case transaction type turns up, whoever is
    tasked with dealing\r\nwith it will see this class and be guided towards representing
    the new\r\ncase as a distinct type of object.\r\n\r\n### Conclusion\r\n\r\nRuby
    is a language which values expressiveness over just about\r\neverything else.
    It is optimized to help us programmers say exactly\r\nwhat we mean, without any
    extraneous fluff, to both the computer and\r\nto future readers of our code. This
    is what makes it so much fun to\r\ncode in.\r\n\r\nWhen we allow our methods to
    become cluttered up with ifs and maybes\r\nand provisos and digressions, we let
    go of that expressiveness. We\r\nstart to lose the clear, confident narrative
    voice. We force the\r\nfuture maintainers of the code to navigate through a twisty
    path full\r\nof logical forks in the road in order to understand the purpose of
    a\r\nmethod. Reading and updating the code stops being fun.\r\n\r\nMy challenge
    to you is this: when you are writing a new method, keep a\r\nclear idea in mind
    of the story you are trying to tell. When detours\r\nand diversions start to show
    up along the way, figure out what you\r\nneed to do to restore the narrative,
    and do it. You might get rid of\r\nrepetitive data integrity checks by introducing
    preconditions in the\r\ninitializer of a method. Maybe you can surround an external
    API in\r\nassertions that document your beliefs about it, rather than trying to\r\nhandle
    anything it throws at you. Or perhaps you can eliminate a\r\nfamily of often-repeated
    conditionals by representing a special case\r\nas a class in its own right.\r\n\r\nHowever
    you do it, keep your focus on telling a straightforward\r\ntale. Not only will
    the future readers of your code thank you for it,\r\nbut I think you'll find that
    it makes your code more robust and easier\r\nto maintain as well.\r\n"
- :slug: implementing-the-active-record-pattern-1
  :title: Implementing the Active Record pattern, Part 1
  :summary: Build a basic foundation to serve as the groundwork for implementing an
    ActiveRecord-style ORM.
  :published: 2012-06-12 00:00:00.000000000 Z
  :issue_number: '4.8'
  :volume: 4
  :body: "> (ORM) is one of the most complex things you could ever touch, and we choose
    it\r\n> over and over again without thinking at all because everybody is doing
    it. It\r\n>  is really complex! You waste an inordinate amount of your time on
    it, and\r\n>  you need to look at it. -- [Rich Hickey, RailsConf 2012 (video)](http://www.youtube.com/watch?v=rI8tNMsozo0#t=1289s)\r\n\r\nDepending
    on the kind of work you do, the claim that object-relational mapping\r\nis _\"one
    of the most complex things you could ever touch\"_ is just \r\nas likely to be
    shocking as it is to be blindingly obvious. Because \r\nActiveRecord (and other
    Ruby ORMs) provide highly abstracted ways of solving\r\ncommon problems, it is
    easy to ignore the underlying complexity involved in even\r\nthe most simple things
    that we use ORM for. But just as there is a huge\r\ndifference between driving
    a car and repairing one, the cost of \r\nunderstanding ORM is much higher than
    simply making use of it.\r\n\r\nIn this two-part article, I will walk you through
    a minimal \r\nimplementation of the [Active\r\nRecord](http://en.wikipedia.org/wiki/Active_record)
    pattern so that you can more \r\neasily understand what we take for granted when
    we use this flavor \r\nof ORM in our projects.\r\n\r\n### Is the Active Record
    pattern inherently complex?\r\n\r\nWhenever we talk about an Active Record in
    Ruby, it is extremely common for us\r\nto immediately tie our thoughts to the
    Rails implementation of this pattern,\r\neven though the concept itself was around
    before Rails was invented. If we \r\naccept the Rails-centric view of our world,
    the question of whether\r\nActiveRecord is a complex piece of software is trivial
    to answer; we only need\r\nto look at the `ActiveRecord::Base` object to see that
    it has all of the \r\nfollowing complecting characteristics:\r\n\r\n* Hundreds
    of instance methods\r\n* Hundreds of class methods\r\n* Over a dozen instance
    variables\r\n* Over a dozen class instance variables\r\n* Several class variables
    ([a construct that's inherently complex!](http://www.oreillynet.com/ruby/blog/2007/01/nubygems_dont_use_class_variab_1.html))\r\n*
    A 40 level deep lookup path for class methods\r\n* A 46 level deep lookup path
    for instance methods\r\n* Dozens of kinds of method_missing hacks\r\n* No encapsulation
    whatsoever between mixed in modules\r\n\r\nBut if you look back at how Martin
    Fowler defined the concept of an Active\r\nRecord in his 2003 book \"Patterns
    of Enterprise Application Architecture\", you\r\nwill find that the pattern does
    not necessarily require such a massively complex\r\nimplementation. In fact, Fowler's
    definition of an Active Record included any\r\nobject that could do most or all
    of the following things:\r\n\r\n* Construct an instance of the Active Record from
    a SQL result set row\r\n* Construct a new instance for later insertion into the
    table\r\n* Use static finder methods to wrap commonly used SQL queries and return\r\n
    \ Active Record objects\r\n* Update the database and insert data into the Active
    Record\r\n* Get and set fields\r\n* Implement some pieces of business logic\r\n\r\nClearly,
    the Rails-based ActiveRecord library does all of these things, but it\r\nalso
    does a lot more. As a result, it is easy to conflate the\r\ncoincidental complexity
    of this very popular implementation with the inherent \r\ncomplexity of its underlying
    pattern. This is a major source of\r\nconfounding in many discussions about software
    design for Rails developers, and\r\nis something I want to avoid in this article.\r\n\r\nWith
    that problem in mind, I built a minimal implementation of the Active Record pattern
    called\r\n[BrokenRecord](https://github.com/elm-city-craftworks/broken_record)
    which will\r\nhelp you understand the fundamental design challenges involved in
    implementing this\r\nparticular flavor of ORM. As long as you keep in mind that
    BrokenRecord exists\r\nprimarily to facilitate thought experiments and is not
    meant to be used in\r\nproduction code, it should provide an easy way for you
    to explore a number\r\nof questions about ORM in general, and the Active Record
    pattern in particular.\r\n\r\n### The ingredients for implementing an Active Record
    object\r\n\r\nNow that you know what an Active Record is in its most generic form,
    how would you\r\ngo about implementing it? To answer that question, it may help
    to reflect upon\r\nan example of how Active Record objects are actually used.
    The following code\r\nis a good place to start, because it illustrates some of
    the most basic \r\nfeatures you can expect from an Active Record object.\r\n\r\n```ruby\r\n##
    Create an article with a few positive comments.\r\n\r\narticle1 = Article.create(:title
    => \"A great article\",\r\n                          :body  => \"Short but sweet!\")\r\n\r\n\r\nComment.create(:body
    => \"Supportive comment!\", :article_id => article1.id)\r\nComment.create(:body
    => \"Friendly comment!\",   :article_id => article1.id)\r\n\r\n## Create an article
    with a few negative comments.\r\n\r\narticle2 = Article.create(:title => \"A not
    so great article\",\r\n                          :body  => \"Just as short\")\r\n\r\nComment.create(:body
    => \"Angry comment!\",      :article_id => article2.id)\r\nComment.create(:body
    => \"Frustrated comment!\", :article_id => article2.id)\r\nComment.create(:body
    => \"Irritated comment!\",  :article_id => article2.id)\r\n\r\n## Display all
    the articles and their comments \r\n\r\nArticle.all.each do |article|\r\n  puts
    %{\r\n    TITLE: #{article.title}\r\n    BODY: #{article.body}\r\n    COMMENTS:\\n#{article.comments.map
    { |e| \"    - #{e.body}\" }.join(\"\\n\")}\r\n  }\r\nend\r\n```\r\n\r\nWhile this
    example omits a bit of setup code, it is not hard to see that it\r\nproduces the
    following output:\r\n\r\n```\r\n    TITLE: A great article\r\n    BODY: Short
    but sweet!\r\n    COMMENTS:\r\n    - Supportive comment!\r\n    - Friendly comment!\r\n\r\n\r\n
    \   TITLE: A not so great article\r\n    BODY: Just as short\r\n    COMMENTS:\r\n
    \   - Angry comment!\r\n    - Frustrated comment!\r\n    - Irritated comment!
    \ \r\n```\r\n\r\nDespite its simple output, there is a lot going in this little
    \r\ncode sample. To gain a better sense of what is happening under\r\nthe hood,
    take a look at how the `Article` and `Comment` objects\r\nare defined:\r\n\r\n```ruby\r\nclass
    Article\r\n  include BrokenRecord::Mapping\r\n  \r\n  map_to_table :articles\r\n\r\n
    \ has_many :comments, :key   => :article_id,\r\n                      :class =>
    \"Comment\"\r\nend\r\n\r\nclass Comment\r\n  include BrokenRecord::Mapping\r\n\r\n
    \ map_to_table :comments\r\n\r\n  belongs_to :article, :key   => :article_id,\r\n
    \                      :class => \"Article\"\r\nend\r\n```\r\n\r\nBecause `BrokenRecord::Mapping`
    does not implement the naming \r\nshortcuts that `ActiveRecord::Base` uses, the
    connection between \r\nthese objects and the underlying database schema is much
    more \r\nexplicit. If you take a look at how the `articles` and `comments` \r\ntables
    are defined, it should be straightforward to understand how \r\nthis all comes
    together:\r\n\r\n```sql\r\n create table articles ( \r\n   id     INTEGER PRIMARY
    KEY,\r\n   title  TEXT,\r\n   body   TEXT,\r\n );\r\n\r\n create table comments
    (\r\n   id          INTEGER PRIMARY KEY,\r\n   body        TEXT,\r\n   article_id
    \ INTEGER,\r\n   FOREIGN KEY(article_id) REFERENCES articles(id)\r\n );\r\n```\r\n\r\nIf
    you haven't been paying close attention to what kinds of things you would\r\nneed
    to build in order to make this code work, go ahead and quickly re-read this\r\nsection
    with that in mind. Once you've done that, examine the following grocery \r\nlist
    of Active Record ingredients and see if they match your own:\r\n\r\n1. Storage
    and retrieval of record data in an SQL database. \r\n  (e.g. `Article.create`
    and `Article.all`)\r\n2. Dynamic generation of accessors for record data. (e.g.
    `article.body`)\r\n3. Dynamic generation of associations methods (e.g. `article.comments`),\r\n
    \ including the ability to dynamically look up the associated class.\r\n  (e.g.
    `:class => \"Comments\"`)\r\n4. The ability to wrap all these features up into
    a single module mix-in.\r\n\r\nThis list easily demonstrates that a fair amount
    of complicated code is needed \r\nto support the most basic uses of Active Record
    objects, even when the\r\npattern is stripped down to its bare essentials. But
    it is one thing\r\nto have a rough sense that a problem is complex, and a different
    thing\r\nentirely to familiarize yourself with its nuances. The former insight
    leads you to\r\nappreciate your magical tools; the latter helps you master them.\r\n\r\nTo
    help you dig deeper, I will guide you through the code that handles each\r\nof
    these responsibilities in `BrokenRecord`, explaining how it all works along\r\nthe
    way. We will start by exploring some low level constructs that help\r\nsimplify
    the implementation of Active Record objects, and then in [part 2](http://practicingruby.com/articles/63)
    \r\nwe will look at how the whole system comes together.\r\n\r\n### Abstracting
    away the database\r\n\r\nUsing the Active Record pattern introduces tight coupling
    between classes\r\ncontaining bits of domain logic and the underlying persistence
    layer. However,\r\nthis does not mean that an Active Record ought to directly
    tie itself to \r\na low-level database adapter. With that in mind, introducing
    a simple\r\nobject to handle basic table manipulations and queries is a good way\r\nto
    reduce the brittleness of this tightly coupled design.\r\n\r\nThe following example
    shows how `BrokenRecord::Table` can be used directly to\r\nsolve the same problem
    that was shown earlier. As you read through it, try to\r\nimagine how the `BrokenRecord::Mapping`
    module might be implemented using this\r\nobject as a foundation.\r\n\r\n```ruby\r\n##
    create a couple table objects\r\n\r\narticles = BrokenRecord::Table.new(:name
    => \"articles\",\r\n                                   :db   => BrokenRecord.database)\r\n\r\ncomments
    = BrokenRecord::Table.new(:name => \"comments\",\r\n                                   :db
    \  => BrokenRecord.database)\r\n\r\n## create an article with some positive comments\r\n\r\na1
    = articles.insert(:title => \"A great article\", \r\n                     :body
    \ => \"Short but sweet\")\r\n\r\ncomments.insert(:body => \"Supportive comment!\",
    :article_id => a1)\r\ncomments.insert(:body => \"Friendly comment!\",   :article_id
    => a1)\r\n\r\n## create an article with some negative comments\r\n\r\na2 = articles.insert(:title
    => \"A not so great article\", \r\n                     :body  => \"Just as short\")\r\n\r\ncomments.insert(:body
    => \"Angry comment!\",      :article_id => a2)\r\ncomments.insert(:body => \"Frustrated
    comment!\", :article_id => a2)\r\ncomments.insert(:body => \"Irritated comment!\",
    \ :article_id => a2)\r\n\r\n## Display the articles and their comments\r\n\r\narticles.all.each
    do |article|\r\n  responses = comments.where(:article_id => article[:id])\r\n\r\n
    \ puts %{\r\n    TITLE: #{article[:title]}\r\n    BODY: #{article[:body]}\r\n
    \   COMMENTS:\\n#{responses.map { |e| \"    - #{e[:body]}\" }.join(\"\\n\") }\r\n
    \ }\r\nend\r\n```\r\n\r\nDespite the superficial similarity between the features
    provided by\r\nthe `BrokenRecord::Mapping` mixin and the `BrokenRecord::Table`
    class,\r\nthere are several key differences that set them apart from one another:\r\n\r\n1)
    `Mapping` assumes that `BrokenRecord.database` holds a\r\nreference to an appropriate
    database adapter, but `Table` requires\r\nthe database adapter to be injected.
    This means that unlike `Mapping`, the\r\n`Table` class has no dependencies on
    global state. \r\n\r\n2) Most of the methods in `Mapping` return instances of
    whatever\r\nobject it gets mixed into, but `Table` always returns primitive\r\nvalues
    such as arrays, hashes, and integers. This means that\r\n`Mapping` needs to make
    assumptions about the interfaces of other\r\nobjects, and `Table` does not.\r\n\r\n3)
    `Mapping` implements a big chunk of its functionality via class methods, \r\nbut
    `Table` does not rely on any special\r\nclass-level behavior. This means that
    `Table` can be easily tested\r\nwithout generating anonymous classes or doing
    awkward cleanup tasks.\r\n\r\nThe `Mapping` mix-in is convenient to use because
    it can introduce \r\npersistence into any class, but it bakes in a few assumptions
    that you\r\ncan't easily change. By contrast, the `Table` object expects you to
    wire more\r\nthings up by hand, but is conceptually simple and very flexible.
    This is exactly\r\nthe kind of tension to expect between higher and lower levels
    of abstraction,\r\nand is not necessarily a sign of a design problem.\r\n\r\nIf
    these two components were merged into a single entity, the \r\nconflict between
    their design priorities would quickly lead \r\nto creating an object with a split-personality.
    Whenever that happens, \r\ncomplexity goes through the roof, and so does the cost\r\nof
    change. By allowing `Mapping` to delegate much of its functionality to \r\na `Table`
    object, it is possible to sidestep these concerns and gain \r\nthe best of both
    worlds.\r\n\r\n### Encapsulating record data\r\n\r\nOne of the defining characteristics
    of an Active Record is that ordinary\r\naccessors can be used to retrieve and
    manipulate its data. As a\r\nresult, basic operations on Active Record objects
    end up looking like \r\nplain old Ruby code, such as in the following example:\r\n\r\n```ruby\r\nArticle.all.each
    do |article|\r\n  puts %{\r\n    TITLE: #{article.title}\r\n    BODY: #{article.body}\r\n
    \   COMMENTS:\\n#{article.comments.map { |e| \"    - #{e.body}\" }.join(\"\\n\")}\r\n
    \ }\r\nend\r\n```\r\n\r\nThe interesting part about getters and setters for Active
    Record objects \r\nis that they need to be dynamically generated. To refresh your
    memory, take a\r\nsecond look at the class definition for `Article`, and note
    that it contains\r\nno explicit definitions for the `Article#title` and `Article#body`
    methods.\r\n\r\n```ruby\r\nclass Article\r\n  include BrokenRecord::Mapping\r\n
    \ \r\n  map_to_table :articles\r\n\r\n  has_many :comments, :key   => :article_id,\r\n
    \                     :class => \"Comment\"\r\nend\r\n```\r\n\r\nIn the above
    code, `map_to_table` ties the `Article` class to a database \r\ntable, and the
    columns in that table determine what accessors need to \r\nbe defined. Through
    a low-level call to `BrokenRecord::Table`, it \r\nis possible to get back an array
    of column names, as shown below:\r\n\r\n```ruby\r\n  table.columns.keys #=> [:id,
    :title, :body]\r\n```\r\n\r\nIf you assume that `Article` will not store field
    values directly, but instead\r\ndelegate to some sort of value object, Ruby's
    built in `Struct` object might\r\ncome to mind as a way to solve this problem.
    After all, it does make \r\ndynamically generating a value object with accessors
    quite easy:\r\n\r\n```ruby\r\n  article_container = Struct.new(:id, :title, :body)\r\n\r\n
    \ article = article_container.new\r\n  article.title = \"A fancy article\"\r\n
    \ article.body  = \"This is so full of class, it's silly\"\r\n\r\n  # ... \r\n```\r\n\r\nUsing
    a `Struct` for this purpose is a fairly standard idiom, and it is not\r\nnecessarily
    a bad idea. But despite how simple they appear to be on the surface,\r\nthe lesser
    known features of `Struct` objects make them very complex. In\r\naddition to accessors,
    using a `Struct` also gives you all of the \r\nfollowing functionality:\r\n\r\n```ruby\r\n
    \ # array-like indexing\r\n  article[1] #=> \"A fancy article\"\r\n\r\n  # hash-like
    indexing with both symbols and strings\r\n  article[:title] == article[1]       #=>
    true\r\n  article[:title] == article[\"title\"] #=> true \r\n\r\n  # Enumerability\r\n
    \ article.count       #=> 3\r\n  article.map(&:nil?) #=> [true, false, false]\r\n\r\n
    \ # Pair-wise iteration\r\n  article.each_pair { |k,v| p [k,v] }\r\n  \r\n  #
    Customized inspect output\r\n  p article #=> #<struct id=nil, title=\"A fancy
    article\", \r\n                # body=\"This is so full of class, it's silly\">\r\n```\r\n\r\nWhile
    this broad interface makes `Struct` very useful for certain data\r\nprocessing
    tasks, they are much more often used in scenarios in which a simple\r\nobject
    with dynamic accessors would be a much better fit. The\r\n`BrokenRecord::FieldSet`
    class implements such an object while \r\nmaintaining a minimal API: \r\n\r\n```ruby\r\nmodule
    BrokenRecord\r\n  class FieldSet\r\n    def initialize(params)\r\n      self.data
    = {}\r\n\r\n      attributes  = params.fetch(:attributes)\r\n      values      =
    deep_copy(params.fetch(:values, {}))\r\n\r\n      attributes.each { |name| data[name]
    = values[name] }\r\n\r\n      build_accessors(attributes)\r\n    end\r\n\r\n    def
    to_hash\r\n      deep_copy(data)\r\n    end\r\n\r\n    private\r\n\r\n    attr_accessor
    :data\r\n\r\n    def deep_copy(object)\r\n      Marshal.load(Marshal.dump(object))\r\n
    \   end\r\n\r\n    def build_accessors(attributes)\r\n      attributes.each do
    |name|\r\n        define_singleton_method(name) { data[name] }\r\n        define_singleton_method(\"#{name}=\")
    { |v| data[name] = v }\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n
    The most important thing to note about this code is that\r\n `BrokenRecord::FieldSet`
    makes it just as easy to create \r\n a dynamic value object as `Struct` does:\r\n\r\n```ruby\r\narticle
    = BrokenRecord::FieldSet.new(:attributes => [:id, :title, :body])\r\narticle.title
    = \"A fancy article\"\r\narticle.body  = \"This is so full of class, its silly\"\r\n\r\n#
    ...\r\n```\r\n\r\nThe similarity ends there, mostly because `BrokenRecord::FieldSet`
    does not \r\nimplement most of the features that `Struct` provides. Another important
    difference\r\nis that `BrokenRecord::FieldSet` does not rely on an anonymous intermediate
    class to\r\nimplement its functionality. This helps discourage the use of class
    inheritance\r\nfor code reuse, which in turn reduces overall system complexity.\r\n\r\nIn
    addition to these simplifications, `BrokenRecord::FieldSet` also attempts to \r\nadapt
    itself a bit better to its own problem domain. Because `FieldSet`\r\nobjects need
    to be used in conjunction with `Table` objects, they need to be \r\nmore hash-friendly
    than `Struct` objects are. In particular, it must easy \r\nto set  the values
    of the `FieldSet` object using a hash, and it must be easy to \r\nconvert a `FieldSet`
    back into a hash. The following example demonstrates \r\nthat both of those requirements
    are handled gracefully:\r\n\r\n```ruby\r\narticle_data = { :id    => 1,\r\n                 :title
    => \"A fancy article\",\r\n                 :body  => \"This is so full of class,
    it's silly\" }\r\n\r\narticle = BrokenRecord::FieldSet.new(:attributes => [:id,
    :title, :body],\r\n                                     :values       => article_data)\r\n\r\np
    article.title #=> \"A fancy title\"\r\n\r\np article.to_hash == article_data #=>
    true\r\n\r\narticle.title = \"A less fancy title\"\r\n\r\np article.to_hash ==
    article_data #=> false\r\np article.to_hash[:title]         #=> \"A less fancy
    title\"\r\n```\r\n\r\nWhile it may be a bit overkill to roll your own object for
    the sole purpose of\r\nremoving features from an existing well supported object,
    the fact that\r\n`BrokenRecord::FieldSet` also introduces a few new features of
    its own makes it more\r\nreasonable to implement things this way. More could definitely
    be said about the\r\ntrade-offs involved in making this kind of design decision,
    but they are very \r\ncontext dependent, and that makes them a bit tricky to generalize.\r\n\r\n###
    Reflections\r\n\r\nThe objects described in this article may seem a bit austere,\r\nbut
    they are easy to reason about once you gain some familiarity with them. In\r\nthe
    [second part of this article (Issue\r\n4.10)](http://practicingruby.com/articles/63),
    you will be able to see these\r\nobjects in the context which they are actually
    used, which will help you\r\nunderstand them further.\r\n\r\nThe main theory I
    am trying to test out here is that I believe simple low level \r\nconstructs tend
    to make it easier to build simple higher level constructs.\r\nHowever, there is
    a very real tension between conceptual simplicity and\r\npractical ease-of-use,
    and that can lead to some complicated design decisions.\r\n\r\nWhat do you think
    about these ideas? Are the techniques that I've shown so far more\r\nconfusing
    than they are enlightening? Do you have a better idea for how to\r\napproach this
    problem? No matter what is on your mind, if you have thoughts on\r\nthis topic,
    I want to hear from you!\r\n\r\n> **BONUS CONTENT:** If you're curious about what
    it looks like for me to put the \"finishing touches\" on a Practicing Ruby article,
    see [this youtube video](http://www.youtube.com/watch?v=bojXlV1mFNY). Be warned
    however, I am barely capable of using a computer, and so it's likely to be painful
    to watch me work."
- :slug: hidden-costs-of-inheritance
  :title: The hidden costs of inheritance
  :summary: Think through some problems with inheritance-based modeling and then try
    a few related exercises.
  :published: 2012-06-19 00:00:00.000000000 Z
  :issue_number: '4.9'
  :volume: 4
  :body: "As a Ruby programmer, you almost certainly make use of inheritance-based
    object\r\nmodeling on a daily basis. In fact, extending base classes and mixing\r\nmodules
    into your objects may be so common for you that you rarely \r\nneed to think about
    the mechanics involved in doing so. If you are like \r\nmost Ruby programmers,
    your readiness to apply this complex design paradigm \r\nthroughout your projects
    is both a blessing and a curse.\r\n\r\nOn the one hand, your ability to make good
    use of inheritance-based modeling\r\nwithout thinking about its complexity is
    a sign that it works well as an\r\nabstraction. But on the other hand, having
    this familiar tool constantly within\r\nreach makes it harder to recognize alternative
    approaches that may lead to\r\ngreater simplicity in certain contexts. Because
    no one tool is a golden hammer,\r\nit is a good idea to understand the limitations
    of your preferred modeling\r\ntechniques as well as their virtues.\r\n\r\nIn this
    article, I will guide you through three properties of\r\ninheritance-based modeling
    that can lead to design complications unless they are\r\ngiven careful consideration.
    These are meant to be starting points for\r\nconversation more-so than tutorials
    on what to do and what not to do, so please\r\nattempt some of the homework exercises
    I've included at the bottom of the\r\narticle!\r\n\r\n### PROBLEM 1: There is
    no encapsulation along ancestry chains\r\n\r\nInheritance-based modeling is most
    commonly used for behavior sharing, but \r\nwhat it actually provides is implementation
    sharing. Among other things,\r\nthis means that no matter how many ancestors an
    object has, all of its \r\nmethods and state end up getting defined in a single
    namespace. If you \r\naren't careful, this lack of encapsulation between objects
    in an \r\ninheritance relationship can easily bite you.\r\n\r\nTo test your understanding
    of this problem, see if you can spot the bug in the\r\nfollowing example: \r\n\r\n```ruby\r\nrequire
    \"prawn\"\r\n\r\nclass StyledDocument < Prawn::Document\r\n  def style(params)\r\n
    \   @font_name = params[:font]\r\n    @font_size = params[:size]\r\n  end\r\n\r\n
    \ def styled_text(content)\r\n    font(@font_name) do\r\n      text(content, :size
    => @font_size)\r\n    end\r\n  end\r\nend\r\n\r\nStyledDocument.generate(\"example.pdf\")
    do \r\n  text \"This is the default font size and face\"\r\n\r\n  style(:font
    => \"Courier\", :size => 20)\r\n\r\n  styled_text \"This line should be in size
    20 Courier\"\r\n\r\n  text \"This line should be in the default font size and
    face\"\r\nend\r\n```\r\n\r\nThis example runs without raising any sort of explicit
    error, but produces\r\nthe following incorrect output:\r\n\r\n![](http://i.imgur.com/xjOpU.png)\r\n\r\nThere
    aren't a whole lot of things that can go wrong in this example,\r\nand so you
    have probably figured out the source of the problem by now:\r\n`StyledDocument`
    and `Prawn::Document` each define `@font_size`, but \r\nthey each use it for a
    completely different purpose. As a result, calling \r\n`StyledDocument#style`
    triggers a side effect that leads to this\r\nsubtle defect.\r\n\r\nTo verify that
    a naming collision to blame for this problem, you can \r\ntry renaming the `@font_size`
    variable in `StyledDocument` to \r\nsomething else, such as `@styled_font_size`.
    Making that tiny \r\nchange will cause the example to produce the correct output,
    \r\nas shown below:\r\n\r\n![](http://i.imgur.com/1O23U.png)\r\n\r\nHowever, this
    is only a superficial fix, and does not address the root problem.\r\nThe real
    issue is that without true subobjects with isolated state, the chance\r\nof clashing
    with a variable used by an ancestor increases as your\r\nancestry chain grows.
    If you look at the mixins that `ActiveRecord::Base` \r\ndepends on, you'll find
    examples of a \r\n[scary lack of encapsulation](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/transactions.rb#L327-345)\r\nthat
    will make you wonder how things don't break more often.\r\n\r\nTo make matters
    worse, the lack of encapsulation between objects in an\r\ninheritance relationship
    also means that methods can clash in the same way that\r\nvariables can. A lack
    of true private methods in Ruby complicates the problem\r\neven further, because
    there simply isn't a way to write a method in a parent\r\nobject that a child
    object can't clash with or override. One of the homework\r\nquestions for this
    article addresses this issue, but is worth thinking \r\nabout for a moment before
    you read on.\r\n\r\n### PROBLEM 2: Interfaces tend to grow rapidly under inheritance\r\n\r\nI
    am going to attempt a proof without words for this particular problem, and\r\nleave
    it up to you to figure out *why* this can be a source of maintenance\r\nheadaches,
    but please share your thoughts in the comments:\r\n\r\n```ruby\r\n>> (ActiveRecord::Base.instance_methods
    | \r\n    ActiveRecord::Base.private_instance_methods)\r\n=> [:logger, :configurations,
    :default_timezone, :schema_format,\r\n:timestamped_migrations, :init_with, :initialize_dup,
    :encode_with, :==, :eql?,\r\n:hash, :freeze, :frozen?, :<=>, :readonly?, :readonly!,
    :inspect, :to_yaml,\r\n:yaml_initialize, :_attr_readonly, :_attr_readonly?, :primary_key_prefix_type,\r\n:table_name_prefix,
    :table_name_prefix?, :table_name_suffix,\r\n:table_name_suffix?, :pluralize_table_names,
    :pluralize_table_names?,\r\n:store_full_sti_class, :store_full_sti_class?, :store_full_sti_class=,\r\n:default_scopes,
    :default_scopes?, :_accessible_attributes,\r\n:_accessible_attributes?, :_accessible_attributes=,
    :_protected_attributes,\r\n:_protected_attributes?, :_protected_attributes=, :_active_authorizer,\r\n:_active_authorizer?,
    :_active_authorizer=, :_mass_assignment_sanitizer,\r\n:_mass_assignment_sanitizer?,
    :_mass_assignment_sanitizer=, :validation_context,\r\n:validation_context=, :_validate_callbacks,
    :_validate_callbacks?,\r\n:_validate_callbacks=, :_validators, :_validators?,
    :_validators=,\r\n:lock_optimistically, :attribute_method_matchers, :attribute_method_matchers?,\r\n:attribute_types_cached_by_default,
    :time_zone_aware_attributes,\r\n:skip_time_zone_conversion_for_attributes,\r\n:skip_time_zone_conversion_for_attributes?,
    :partial_updates, :partial_updates?,\r\n:partial_updates=, :serialized_attributes,
    :serialized_attributes?,\r\n:serialized_attributes=, :[], :[]=, :record_timestamps,
    :record_timestamps?,\r\n:record_timestamps=, :_validation_callbacks, :_validation_callbacks?,\r\n:_validation_callbacks=,
    :_initialize_callbacks, :_initialize_callbacks?,\r\n:_initialize_callbacks=, :_find_callbacks,
    :_find_callbacks?, :_find_callbacks=,\r\n:_touch_callbacks, :_touch_callbacks?,
    :_touch_callbacks=, :_save_callbacks,\r\n:_save_callbacks?, :_save_callbacks=,
    :_create_callbacks, :_create_callbacks?,\r\n:_create_callbacks=, :_update_callbacks,
    :_update_callbacks?,\r\n:_update_callbacks=, :_destroy_callbacks, :_destroy_callbacks?,\r\n:_destroy_callbacks=,
    :auto_explain_threshold_in_seconds,\r\n:auto_explain_threshold_in_seconds?, :nested_attributes_options,\r\n:nested_attributes_options?,
    :include_root_in_json, :include_root_in_json?,\r\n:include_root_in_json=, :reflections,
    :reflections?, :reflections=,\r\n:_commit_callbacks, :_commit_callbacks?, :_commit_callbacks=,\r\n:_rollback_callbacks,
    :_rollback_callbacks?, :_rollback_callbacks=,\r\n:connection_handler, :connection_handler?,
    :connection,\r\n:clear_aggregation_cache, :transaction, :destroy, :save, :save!,\r\n:rollback_active_record_state!,
    :committed!, :rolledback!, :add_to_transaction,\r\n:with_transaction_returning_status,
    :remember_transaction_record_state,\r\n:clear_transaction_record_state, :restore_transaction_record_state,\r\n:transaction_record_state,
    :transaction_include_action?, :serializable_hash,\r\n:to_xml, :from_xml, :as_json,
    :from_json, :read_attribute_for_serialization,\r\n:reload, :mark_for_destruction,
    :marked_for_destruction?,\r\n:changed_for_autosave?, :_destroy, :reinit_with,
    :clear_association_cache,\r\n:association_cache, :association, :run_validations!,
    :touch, :_attribute,\r\n:type_cast_attribute_for_write, :read_attribute_before_type_cast,
    :changed?,\r\n:changed, :changes, :previous_changes, :changed_attributes, :to_key,
    :id, :id=,\r\n:id?, :query_attribute, :attributes_before_type_cast, :raw_write_attribute,\r\n:read_attribute,
    :method_missing, :attribute_missing, :respond_to?,\r\n:has_attribute?, :attribute_names,
    :attributes, :attribute_for_inspect,\r\n:attribute_present?, :column_for_attribute,
    :clone_attributes,\r\n:clone_attribute_value, :arel_attributes_values, :attribute_method?,\r\n:respond_to_without_attributes?,
    :locking_enabled?, :lock!, :with_lock, :valid?,\r\n:perform_validations, :validates_acceptance_of,
    :validates_confirmation_of,\r\n:validates_exclusion_of, :validates_format_of,
    :validates_inclusion_of,\r\n:validates_length_of, :validates_size_of, :validates_numericality_of,\r\n:validates_presence_of,
    :errors, :invalid?, :read_attribute_for_validation,\r\n:validates_with, :run_callbacks,
    :to_model, :to_param, :to_partial_path,\r\n:attributes=, :assign_attributes, :mass_assignment_options,\r\n:mass_assignment_role,
    :sanitize_for_mass_assignment,\r\n:mass_assignment_authorizer, :cache_key, :quoted_id,\r\n:populate_with_current_scope_attributes,
    :new_record?, :destroyed?, :persisted?,\r\n:delete, :becomes, :update_attribute,
    :update_column, :update_attributes,\r\n:update_attributes!, :increment, :increment!,
    :decrement, :decrement!, :toggle,\r\n:toggle!, :psych_to_yaml, :to_yaml_properties,
    :in?, :blank?, :present?,\r\n:presence, :acts_like?, :try, :duplicable?, :to_json,
    :instance_values,\r\n:instance_variable_names, :require_or_load, :require_dependency,\r\n:require_association,
    :load_dependency, :load, :require, :unloadable, :nil?,\r\n:===, :=~, :!~, :class,
    :singleton_class, :clone, :dup, :initialize_clone,\r\n:taint, :tainted?, :untaint,
    :untrust, :untrusted?, :trust, :to_s, :methods,\r\n:singleton_methods, :protected_methods,
    :private_methods, :public_methods,\r\n:instance_variables, :instance_variable_get,
    :instance_variable_set,\r\n:instance_variable_defined?, :instance_of?, :kind_of?,
    :is_a?, :tap, :send,\r\n:public_send, :respond_to_missing?, :extend, :display,
    :method, :public_method,\r\n:define_singleton_method, :object_id, :to_enum, :enum_for,
    :psych_y,\r\n:class_eval, :silence_warnings, :enable_warnings, :with_warnings,\r\n:silence_stderr,
    :silence_stream, :suppress, :capture, :silence, :quietly,\r\n:equal?, :!, :!=,
    :instance_eval, :instance_exec, :__send__, :__id__,\r\n:initialize, :to_ary, :_run_validate_callbacks,
    :_run_validation_callbacks,\r\n:_run_initialize_callbacks, :_run_find_callbacks,
    :_run_touch_callbacks,\r\n:_run_save_callbacks, :_run_create_callbacks, :_run_update_callbacks,\r\n:_run_destroy_callbacks,
    :_run_commit_callbacks, :_run_rollback_callbacks,\r\n:serializable_add_includes,
    :associated_records_to_validate_or_save,\r\n:nested_records_changed_for_autosave?,
    :validate_single_association,\r\n:validate_collection_association, :association_valid?,\r\n:before_save_collection_association,
    :save_collection_association,\r\n:save_has_one_association, :save_belongs_to_association,\r\n:assign_nested_attributes_for_one_to_one_association,\r\n:assign_nested_attributes_for_collection_association,\r\n:assign_to_or_mark_for_destruction,
    :has_destroy_flag?, :reject_new_record?,\r\n:call_reject_if, :raise_nested_attributes_record_not_found,
    :unassignable_keys,\r\n:association_instance_get, :association_instance_set, :create_or_update,\r\n:create,
    :update, :notify_observers, :should_record_timestamps?,\r\n:timestamp_attributes_for_create_in_model,\r\n:timestamp_attributes_for_update_in_model,
    :all_timestamp_attributes_in_model,\r\n:timestamp_attributes_for_update, :timestamp_attributes_for_create,\r\n:all_timestamp_attributes,
    :current_time_from_proper_timezone,\r\n:clear_timestamp_attributes, :write_attribute,
    :field_changed?,\r\n:clone_with_time_zone_conversion_attribute?, :attribute_changed?,\r\n:attribute_change,
    :attribute_was, :attribute_will_change!, :reset_attribute!,\r\n:attribute?, :attribute_before_type_cast,
    :attribute=,\r\n:convert_number_column_value, :attribute, :match_attribute_method?,\r\n:missing_attribute,
    :increment_lock, :_merge_attributes, :halted_callback_hook,\r\n:assign_multiparameter_attributes,
    :instantiate_time_object,\r\n:execute_callstack_for_multiparameter_attributes,
    :read_value_from_parameter,\r\n:read_time_parameter_value, :read_date_parameter_value,\r\n:read_other_parameter_value,
    :extract_max_param_for_multiparameter_attributes,\r\n:extract_callstack_for_multiparameter_attributes,
    :type_cast_attribute_value,\r\n:find_parameter_position, :quote_value, :ensure_proper_type,\r\n:destroy_associations,
    :default_src_encoding, :irb_binding, :Digest,\r\n:initialize_copy, :remove_instance_variable,
    :sprintf, :format, :Integer,\r\n:Float, :String, :Array, :warn, :raise, :fail,
    :global_variables, :__method__,\r\n:__callee__, :eval, :local_variables, :iterator?,
    :block_given?, :catch, :throw,\r\n:loop, :caller, :trace_var, :untrace_var, :at_exit,
    :syscall, :open, :printf,\r\n:print, :putc, :puts, :gets, :readline, :select,
    :readlines, :`, :p, :test,\r\n:srand, :rand, :trap, :exec, :fork, :exit!, :system,
    :spawn, :sleep, :exit,\r\n:abort, :require_relative, :autoload, :autoload?, :proc,
    :lambda, :binding,\r\n:set_trace_func, :Rational, :Complex, :gem, :gem_original_require,
    :BigDecimal,\r\n:y, :Pathname, :j, :jj, :JSON, :singleton_method_added,\r\n:singleton_method_removed,
    :singleton_method_undefined]\r\n```\r\n\r\nThere is a specific issue I have with
    interface explosion, and it isn't so much\r\nto do with code organization as it
    is with state management. Can you \r\nguess what my concern is?\r\n\r\n### PROBLEM
    3: Balancing reuse and customization can be tricky\r\n\r\nSome ancestors provide
    methods that are designed to be replaced by \r\ntheir descendants. When executed
    well, this pattern provides a convenient\r\nbalance between code reuse and customization.
    However, because it is \r\nimpossible to account for all possible customizations
    that descendants \r\nof a base object will want to make, this approach has its\r\nlimitations.\r\n\r\nThis
    design problem is best explained by example, and you can find a great \r\none
    in Ruby itself. Start by considering the following trivial code, paying\r\nparticular
    attention to its output:\r\n\r\n```ruby\r\nclass Person\r\n  def initialize(name,
    email)\r\n    @name  = name\r\n    @email = email\r\n  end\r\nend\r\n\r\nperson
    = Person.new(\"Gregory Brown\", \"gregory@practicingruby.com\")\r\n\r\np person
    \   #=~\r\n#<Person:0x0000010108bbf8 @name=\"Gregory Brown\", \r\n#                         @email=\"gregory@practicingruby.com\">\r\n\r\nputs
    person #=~\r\n#<Person:0x0000010108bbf8>     \r\n```\r\n\r\nUnder the hood, `p`
    calls `person.inspect`, and `puts` calls\r\n`person.to_s`. What you see above
    is output from the default implementation \r\nof each of those methods. Arguably,
    `Object#inspect` \r\nprovides useful debugging output, but `Object#to_s` is\r\nmore
    of a template method that needs to be overridden in order to be useful. The\r\nfollowing
    code shows how easy to customize things by simply adding your own `to_s`\r\ndefinition:\r\n\r\n```ruby\r\nclass
    Person\r\n  def initialize(name, email)\r\n    @name  = name\r\n    @email = email\r\n
    \ end\r\n\r\n  def to_s\r\n    \"#{@name} <#{@email}>\"\r\n  end\r\nend\r\n\r\nperson
    = Person.new(\"Gregory Brown\", \"gregory@practicingruby.com\")\r\n\r\nputs person
    #=~ Gregory Brown <gregory@practicingruby.com>  \r\n```\r\n\r\nOn the surface,
    there is nothing wrong with this code: this is exactly what a\r\ntemplate-method
    based extension mechanism should look like. However, due to the\r\nweird way that
    `Object#inspect` works in Ruby 1.9, defining your own `to_s`\r\nimplementation
    has some unpleasant side effects that are likely to surprise you:\r\n\r\n```ruby\r\np
    person #=~ Gregory Brown <gregory@practicingruby.com>  \r\n```\r\n\r\nIf you look
    at the [definition of\r\nObject#inspect](https://github.com/ruby/ruby/blob/trunk/object.c#L486-511),\r\nyou'll
    find that this behavior is by design. In a nutshell, the method is set\r\nup to
    provide its default output if `to_s` has not been overridden, but simply\r\ndelegate
    to `to_s` if it has been. This is problematic, because `to_s` is meant\r\nto be
    used for humanized output such as what you saw in the previous\r\nexample, not
    debugging output.\r\n\r\nThe unfortunate consequence of this problem is that if
    you define `to_s` in your\r\nobjects, you must also define a meaningful `inspect`,
    and if you want to \r\nreproduce the same behavior as `Object#inspect`, you need
    to implement \r\nit yourself. While this is mostly a problem of brittle code and
    it is not\r\nspecifically related to inheritance, the problem is compounded by\r\ninheritance-based
    modeling. For example, suppose the `Person` class was defined\r\nas shown above,
    and you decided to subclass it:\r\n\r\n```ruby\r\nclass Employee < Person \r\n
    \ def initialize(name, email, role)\r\n    super(name, email)\r\n    @role = role\r\n
    \ end\r\nend\r\n```\r\n\r\nIf `Person` does define its own `inspect` method, `Employee`
    will inherit the\r\nsame problem. On the other hand, if `Person` does implement
    `inspect`, it needs\r\nto take care to implement it in a way that's suitably general
    to account for\r\nwhat its descendants might find useful. This invites the same
    design challenges\r\nthat caused this problem in the first place, which means
    that `Employee` may end\r\nup cleaning up after its parent object in a similar
    way. Unfortunately,\r\nbrittleness tends to cascade downwards throughout ancestry
    chains.\r\n\r\n### Homework exercises \r\n\r\nThis article is on the short-side,
    and it also leaves out a lot of the story\r\nfrom each of these points. I did
    this intentionally to encourage you to\r\nparticipate in an active discussion
    on this topic. To get the most out of this\r\narticle, please complete at least
    one of the following homework exercises:\r\n\r\n1) Show a realistic example of
    an accidental method naming collision, in a\r\nsimilar spirit to the state-based
    example shown in Problem #1. For bonus\r\npoints, choose an example that involves
    private methods.\r\n\r\n2) Post a comment in response to the \"interface explosion\"
    example shown \r\nin Problem #2. You can either try to guess what my main concern
    about \r\nit is, or share your own concerns. If instead you feel that there is
    \r\nnothing wrong with this kind of design, explain why you think that.\r\n\r\n3)
    Come up with another downside of inheritance-based modeling, and provide an\r\nexample
    of it. If you have trouble coming up with your own, you may want to look\r\ninto
    issues that can arise from overriding methods, or perhaps explore what\r\nhappens
    when you mix traditional inheritance-based modeling with\r\n`method_missing`.\r\n\r\n4)
    Share an example of a library or project which is difficult to work with\r\nbecause
    of the way it uses inheritance-based modeling, or describe problems you've run\r\ninto
    with your own projects due to inheritance.\r\n\r\n5) Share the conventions and
    guidelines you follow to avoid the problems\r\ndescribed in this article, as well
    as other problems you've encountered with\r\ninheritance-based modeling.\r\n\r\nLooking
    forward to seeing your responses! Don't worry about getting the *right*\r\nanswers,
    discussion threads here on Practicing Ruby are about learning, not\r\nnecessarily
    showing off what you already know."
- :slug: implementing-the-active-record-pattern-2
  :title: Implementing the Active Record pattern, Part 2
  :summary: Consider using "object-oriented mixins" to reduce inheritance-related
    problems in ActiveRecord.
  :published: 2012-07-03 00:00:00.000000000 Z
  :issue_number: '4.10'
  :volume: 4
  :body: "> This two part article explores the challenges involved in\r\n> building
    a minimal implementation of the Active Record pattern. \r\n> [Part 1 (Issue 4.8)](http://practicingruby.com/articles/60)
    provides\r\n> some basic background information about the problem and\r\n> walks
    through some of the low level structures that are\r\n> needed to build an ORM.
    Part 2 (this issue) builds on top of\r\n> those structures to construct a complete
    Active Record\r\n> object.\r\n\r\n### Building object-oriented mixins\r\n\r\nOne
    thing that makes the Active Record pattern challenging to implement is that\r\ninvolves
    shoehorning a bunch of persistence-related functionality into model\r\nobjects.
    In the case of Rails, models inherit from `ActiveRecord::Base` which\r\nhas dozens
    of modules mixed into it. This inheritance-based approach is the\r\ncommon way
    of doing complex behavior sharing in Ruby, but comes at a [high\r\nmaintainence
    cost](http://practicingruby.com/articles/62). This is one of the\r\nmain design
    challenges that\r\n[BrokenRecord](https://github.com/elm-city-craftworks/broken_record)
    attempts to solve.\r\n\r\nBecause this is a tricky problem, it helps to explore
    these ideas by\r\nsolving an easier problem first. For example, suppose that you
    have the following trivial\r\n`Stack` object and you want to extend it with some
    `Enumerable`-like\r\nfunctionality without mixing `Enumerable` directly into the
    `Stack` object:\r\n\r\n```ruby\r\nclass Stack\r\n  def initialize\r\n    @data
    = []\r\n  end\r\n\r\n  def push(obj)\r\n    data.push(obj)\r\n  end\r\n\r\n  def
    pop\r\n    data.pop\r\n  end\r\n\r\n  def size\r\n    data.size\r\n  end\r\n\r\n
    \ def each\r\n    data.reverse_each { |e| yield(e) }\r\n  end\r\n\r\n  private\r\n\r\n
    \ attr_reader :data\r\nend\r\n```\r\n\r\nYou could use an `Enumerator` for this
    purpose, as shown in the following\r\nexample:\r\n\r\n```ruby\r\nstack = Stack.new\r\n\r\nstack.push(10)\r\nstack.push(20)\r\nstack.push(30)\r\n\r\nenum
    \ = Enumerator.new { |y| stack.each { |e| y.yield(e) } }\r\np enum.map { |x| \"Has
    element: #{x}\" } #=~\r\n# [\"Has element: 30\", \"Has element: 20\", \"Has element:
    10\"]    \r\n```\r\n\r\nThis is a very clean design, but it makes it so that you
    have to interact with\r\nboth a `Stack` object and an `Enumerator`, which feels
    a bit tedious. With a\r\nlittle effort, the two could be unified under a single
    interface while keeping\r\ntheir variables and internal method calls separated:\r\n\r\n```ruby\r\nclass
    EnumerableStack\r\n  def initialize\r\n    @stack = Stack.new\r\n    @enum  =
    Enumerator.new { |y| @stack.each { |e| y.yield(e) } }       \r\n  end\r\n\r\n
    \ def respond_to_missing?(m, *a)\r\n    [@stack, @enum].find { |e| e.respond_to?(m)
    }\r\n  end\r\n\r\n  def method_missing(m, *a, &b)\r\n    obj = respond_to_missing?(m)\r\n\r\n
    \   return super unless obj\r\n    obj.send(m, *a, &b)\r\n  end\r\nend\r\n```\r\n\r\nFrom
    the external perspective, `EnumerableStack` still looks and \r\nfeels like an
    ordinary `Enumerable` object:\r\n\r\n```ruby\r\nstack = EnumerableStack.new\r\n\r\nstack.push(10)\r\nstack.push(20)\r\nstack.push(30)\r\n\r\np
    stack.map { |x| \"Has element: #{x}\" } #=~\r\n# [\"Has element: 30\", \"Has element:
    20\", \"Has element: 10\"]  \r\n```\r\n\r\nUnfortunately, it is painful to implement
    objects this way. If you\r\napplied this kind of technique throughout a codebase
    without introducing some\r\nsort of abstraction, you would end up having to write
    a ton of very boring\r\n`respond_to_missing?` and `method_missing` calls. It would
    be better to have\r\nan object that knows how to delegate methods automatically,
    such as \r\nthe `Composite` object in the following example:\r\n\r\n```ruby\r\nclass
    EnumerableStack\r\n  def initialize\r\n    stack = Stack.new\r\n    enum  = Enumerator.new
    { |y| stack.each { |e| y.yield(e) } }      \r\n    \r\n    @composite = Composite.new\r\n
    \   @composite << stack << enum\r\n  end\r\n\r\n  def respond_to_missing?(m, *a)\r\n
    \   @composite.receives?(m)\r\n  end\r\n\r\n  def method_missing(m, *a, &b)\r\n
    \   @composite.dispatch(m, *a, &b)\r\n  end\r\nend\r\n```\r\n\r\nThe neat thing
    about this approach is that the `EnumerableStack`\r\nobject now only needs to
    keep track of a single variable, even though it is\r\ndelegating to multiple objects.
    This makes it safe to extract some\r\nof the functionality into a mix-in without
    the code becoming too brittle:\r\n\r\n```ruby\r\nclass EnumerableStack\r\n  include
    Composable\r\n\r\n  def initialize\r\n    stack = Stack.new\r\n    enum  = Enumerator.new
    { |y| stack.each { |e| y.yield(e) } }      \r\n\r\n    # features is a simple
    attribute containing a Composite object\r\n    features << stack << enum\r\n  end\r\nend\r\n```\r\n\r\nThe
    end result looks pretty clean, but using the `Composable` \r\nmixin to solve this
    particular problem is massively overkill. \r\nMixing the `Enumerable` module directly
    into the `Stack` object\r\nis not that hard to do, and is unlikely to have any
    adverse\r\nconsequences. Still, seeing how `Composable` can be used to\r\nreplace
    one of the most common applications of mixins makes\r\nit much easier to understand
    how this technique can be \r\napplied in more complex scenarios. The good news
    is \r\nthat as long as you have a rough idea of how `Composable` \r\nworks in
    this context, you will have no trouble understanding\r\nhow it is used in BrokenRecord.\r\n\r\nTo
    test whether or not you understand the basic pattern, take a look at the\r\nfollowing
    code and see if you can figure out how it works. Don't worry about\r\nthe exact
    implementation details, just compare the following code to the other\r\nexamples
    in this section and think about what the purpose of this module is:\r\n\r\n```ruby\r\nmodule
    BrokenRecord\r\n  module Mapping\r\n    include Composable\r\n\r\n    def initialize(params)\r\n
    \     features << Record.new(params)\r\n    end\r\n\r\n    def self.included(base)\r\n
    \     base.extend(ClassMethods)\r\n    end\r\n\r\n    module ClassMethods\r\n
    \     include Composable\r\n\r\n      def map_to_table(table_name)\r\n        features
    << Relation.new(:name         => table_name,\r\n                                 :db
    \          => BrokenRecord.database,\r\n                                 :record_class
    => self)\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIf you guessed
    that mixing `BrokenRecord::Mapping` into a class will cause any\r\nunhandled messages
    to be delegated to `BrokenRecord::Relation` at the class \r\nlevel and to `BrokenRecord::Record`
    at the instance level, then you guessed\r\ncorrectly! If you're still stuck, it
    might help to recall how this mixin \r\nis used:\r\n\r\n```ruby\r\nclass Article\r\n
    \ include BrokenRecord::Mapping\r\n\r\n  map_to_table :articles\r\nend\r\n\r\narticle
    = Article.create(:title => \"Great article\", :body => \"Wonderful!\")\r\np article.title.upcase
    #=> \"GREAT ARTICLE\"\r\n```\r\n\r\nIf you consider that the definition of `BrokenRecord::Mapping`
    above is its\r\ncomplete implementation, it becomes clear that the methods being
    called in this\r\nexample need to come from somewhere. Now, it should be easier
    to see that\r\n`Relation` and `Record` are where those methods come from.\r\n\r\nYou
    really don't need to know the exact details of how \r\nthe `Composable` module
    works, because it is based entirely on the \r\nideas already discussed in this
    article. However, if `Composable` still feels a\r\nbit too magical, go ahead and
    [study its\r\nimplementation](https://github.com/elm-city-craftworks/broken_record/blob/master/lib/broken_record/composable.rb)\r\nbefore
    reading on. For bonus points, pull the code down and try to \r\nrecreate the `EnumerableStack`
    example on your own machine.\r\n\r\nOnce you feel that you have a good grasp on
    how `Composable` works, you can\r\ncontinue on to see how it can be used to implement
    an Active Record object.\r\n\r\n### Implementing basic CRUD operations\r\n\r\nThe
    complex relationships that Active Record objects depend upon make them a bit\r\nchallenging
    to understand and analyze. But like any complicated system,\r\nyou can gain some
    foundational knowledge by starting with a very simple example as an\r\nentry point
    and digging deeper from there.\r\n\r\nIn the case of BrokenRecord, a good place
    to start is with a somewhat trivial\r\nmodel definition:\r\n\r\n```ruby\r\nclass
    Article\r\n  include BrokenRecord::Mapping\r\n\r\n  map_to_table :articles\r\n\r\n
    \ def published?\r\n    status == \"published\"\r\n  end\r\nend\r\n```\r\n\r\nYou
    found out earlier when you looked at `BrokenRecord::Mapping` that it exists\r\nprimarily
    to extend classes with functionality provided by\r\n`BrokenRecord::Relation` at
    the class level, and `BrokenRecord::Record` at the\r\ninstance level. Because
    `BrokenRecord::Mapping` provides a fairly complicated \r\n`initialize` method,
    it is safe to assume that `Article` objects should be\r\ncreated by factory methods
    rather than instantiated directly. The following \r\ncode demonstrates how that
    works:\r\n\r\n\r\n```ruby\r\nArticle.create(:title  => \"A great article\",\r\n
    \              :body   => \"The rain in Spain...\",\r\n               :status
    => \"draft\")\r\n\r\nArticle.create(:title  => \"A mediocre article\",\r\n               :body
    \  => \"Falls mainly in the plains\",\r\n               :status => \"published\")\r\n\r\nArticle.create(:title
    \ => \"A bad article\",\r\n               :body   => \"Is really bad!\",\r\n               :status
    => \"published\")\r\n\r\nArticle.all.each do |article|\r\n  if article.published?\r\n
    \   puts \"PUBLISHED: #{article.title}\"\r\n  else\r\n    puts \"UPCOMING: #{article.title}\"\r\n
    \ end\r\nend\r\n```\r\n\r\nIf you ignore what is going on inside the `each` block
    for the moment, it is\r\neasy to spot two factory methods being used in the previous
    example:\r\n`Article.create` and `Article.all`. To track down where these methods
    are coming\r\nfrom, you need to take a look at `BrokenRecord::Relation`, because
    that is where\r\nclass-level method calls on `Article` are forwarded to if `Article`
    does not\r\nhandle them itself. But before you do that, keep in mind that this
    is how\r\nthat object gets created in the first place:\r\n\r\n```ruby\r\n  def
    map_to_table(table_name)\r\n    features << Relation.new(:name         => table_name,\r\n
    \                            :db           => BrokenRecord.database,\r\n                             :record_class
    => self)\r\n  end\r\n```\r\n\r\nIf you note that `map_to_table :articles` is called
    within the `Article`\r\nclass, you can visualize the call to `Relation.new` in
    the previous example as\r\nbeing essentially the same as what you see below:\r\n\r\n```ruby\r\nfeatures
    << Relation.new(:name          => :articles,\r\n                         :db            =>
    BrokenRecord.database,\r\n                         :record_class  => Article)\r\n```\r\n\r\nArmed
    with this knowledge, it should be easier to make sense of the\r\n`BrokenRecord::Relation`
    class, which is shown in its entirety below. Pay\r\nparticular attention to the
    `initialize` method, and just skim the rest of the\r\nmethod definitions; it isn't
    important to fully understand them until later.\r\n\r\n```ruby\r\nmodule BrokenRecord\r\n
    \ class Relation\r\n    include Composable\r\n\r\n    def initialize(params)\r\n
    \     self.table = Table.new(:name => params.fetch(:name),\r\n                             :db
    \  => params.fetch(:db))\r\n\r\n      self.record_class = params.fetch(:record_class)\r\n\r\n
    \     features << CRUD.new(self) << Associations.new(self)\r\n    end\r\n\r\n
    \   attr_reader :table\r\n\r\n    def attributes\r\n      table.columns.keys\r\n
    \   end\r\n\r\n    def new_record(values)\r\n      record_class.new(:relation
    => self,\r\n                       :values   => values,\r\n                       :key
    \     => values[table.primary_key])\r\n    end\r\n\r\n    def define_record_method(name,
    &block)\r\n      record_class.send(:define_method, name, &block)\r\n    end\r\n\r\n
    \   private\r\n\r\n    attr_reader :record_class\r\n    attr_writer :table, :record_class\r\n
    \ end\r\nend\r\n```\r\n\r\nThe main thing to notice about `BrokenRecord::Relation`
    is that its main purpose\r\nis to glue together a `BrokenRecord::Table` object
    with a user-defined record\r\nclass, such as the `Article` class we've been working
    with in this example. The\r\nrest of its functionality is provided by the `Relation::CRUD`
    and\r\n`Relation::Associations` objects via composition. Because `Article.all`
    and\r\n`Article.create` are both easily identifiable as CRUD operations, the `Relation::CRUD`
    \r\nobject is the next stop on your tour:\r\n\r\n```ruby\r\nmodule BrokenRecord\r\n
    \ class Relation\r\n    class CRUD\r\n      def initialize(relation)\r\n        self.relation
    = relation\r\n      end\r\n\r\n      def all\r\n        table.all.map { |values|
    relation.new_record(values) }\r\n      end\r\n\r\n      def create(values)\r\n
    \       id = table.insert(values)    \r\n      \r\n        find(id)\r\n      end\r\n\r\n
    \     def find(id)\r\n        values = table.where(table.primary_key => id).first\r\n\r\n
    \       return nil unless values\r\n\r\n        relation.new_record(values)\r\n
    \     end\r\n\r\n      # ... other irrelevant CRUD operations omitted\r\n      \r\n
    \     private\r\n\r\n      attr_accessor :relation\r\n\r\n      def table\r\n
    \       relation.table\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAt
    this point, you should have noticed that both `create()` and\r\n`all()` are defined
    by `Relation::CRUD`, and it is ultimately these \r\nmethods that get called whenever
    you call `Article.create` \r\nand `Article.all`. Whether you trace `Relation::CRUD#create`
    or `Relation::CRUD#all`, you'll find\r\nthat they both interact with the `Table`
    object provided by `Relation`, and that\r\nthey both call `Relation#new_record`,
    and they don't do much more than that. \r\nTo keep things simple, we'll follow
    the path that `Relation::CRUD#all` takes:\r\n\r\n```ruby\r\ndef all\r\n  table.all.map
    { |values| relation.new_record(values) }\r\nend\r\n```\r\n\r\nThis method calls
    `BrokenRecord::Table#all`, which as you saw in \r\n[Issue 4.8](http://practicingruby.com/articles/60)
    returns an\r\narray of hashes representing the results returned from the \r\ndatabase
    when a trivial `select * from articles` query is issued. \r\nFor this particular
    data set, the following results get \r\nreturned:\r\n\r\n```ruby\r\n[\r\n { :id
    \    => 1, \r\n   :title  => \"A great article\", \r\n   :body   => \"The rain
    in Spain...\", \r\n   :status => \"draft\" }, \r\n\r\n { :id     => 2, \r\n   :title
    \ => \"A mediocre article\", \r\n   :body   => \"Falls mainly in the plains\",
    \r\n   :status => \"published\"}, \r\n\r\n { :id     => 3, \r\n   :title  => \"A
    bad article\", \r\n   :body   => \"Is really bad!\", \r\n   :status => \"published\"
    }\r\n]\r\n```\r\n\r\nTaking a second look at the `Relation::CRUD#all` method,
    it is easy to\r\nsee that this is being transformed by a simple `map` call which
    passes each of\r\nthese hashes to `Relation#new_record`. I had asked you to skim
    over that\r\nmethod earlier, but now would be a good time to take a second look
    at its\r\ndefinition:\r\n\r\n```ruby\r\nmodule BrokenRecord\r\n  class Relation\r\n
    \   def new_record(values)\r\n      record_class.new(:relation => self,\r\n                       :values
    \  => values,\r\n                       :key      => values[table.primary_key])\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nIf you recall that in this context `record_class`
    is a reference to `Article`,\r\nit becomes easy to visualize this call as something
    similar to what is \r\nshown below:\r\n\r\n```ruby\r\nvalues = { :id     => 1,
    \r\n           :title  => \"A great article\", \r\n           :body   => \"The
    rain in Spain...\", \r\n           :status => \"draft\" }\r\n\r\nArticle.new(:relation
    => some_relation_obj,\r\n            :values   => values,\r\n            :key
    \     => 1)\r\n```\r\n\r\nAs you discovered before, `Article` does not provide
    its own `initialize`\r\nmethod, and instead inherits the definition provided by
    \r\n`BrokenRecord::Mapping#initialize`:\r\n\r\n```ruby\r\nmodule Mapping\r\n  include
    Composable\r\n\r\n  def initialize(params)\r\n    features << Record.new(params)\r\n
    \ end\r\nend\r\n```\r\n\r\nIf you put all the pieces together, you will find that
    calls to\r\n`Article.all` or `Article.create` return instances of `Article`, but\r\nthose
    instances are imbued with functionality provided by a `Record`\r\nobject, which
    in turn hold a reference to a `Relation` object \r\nthat ties everything back
    to the database. By now you're probably feeling like\r\nthe Active Record pattern
    is a bit of a \r\n[Rube Goldberg machine](http://www.youtube.com/watch?v=qybUFnY7Y8w),
    and that\r\nisn't far from the truth. Don't worry though, the next section should
    help \r\ntie everything together for you.\r\n\r\n### Implementing the Active Record
    object itself\r\n\r\nEarlier, I had asked you to ignore what was going on in the
    `each` block of the\r\noriginal example that kicked off this exploration, because
    I wanted to show you\r\nhow `Article` instances get created before discussing
    how they work. Now that you\r\nhave worked through that process, you can drop
    down to the instance level to\r\ncomplete the journey. Using the same code reading
    strategy as what you used\r\nbefore, you can start with the `Article#published?`
    and `Article#title` \r\ncalls in the following example and see where they take
    you:\r\n\r\n```ruby\r\nArticle.all.each do |article|\r\n  if article.published?\r\n
    \   puts \"PUBLISHED: #{article.title}\"\r\n  else\r\n    puts \"UPCOMING: #{article.title}\"\r\n
    \ end\r\nend\r\n```\r\n\r\nA second look at the `Article` class definition reveals
    that it implements\r\nthe `published?` method but does not implement the `title`
    method; the latter call gets \r\npassed along to `BrokenRecord::Record` automatically.
    Similarly, the internal call \r\nto `status` gets delegated as well:\r\n\r\n```ruby\r\nclass
    Article\r\n  include BrokenRecord::Mapping\r\n\r\n  map_to_table :articles\r\n\r\n
    \ def published?\r\n    status == \"published\"\r\n  end\r\nend\r\n```\r\n\r\nTo
    understand what happens next, take a look at how the `BrokenRecord::Record` class
    works:\r\n\r\n```ruby\r\nmodule BrokenRecord\r\n  class Record\r\n    include
    Composable\r\n\r\n    def initialize(params)\r\n      self.key      = params.fetch(:key,
    nil)\r\n      self.relation = params.fetch(:relation)\r\n\r\n      # NOTE: FieldSet
    (formally called Row) is a simple Struct-like object\r\n      features << FieldSet.new(:values
    \    => params.fetch(:values, {}),\r\n                               :attributes
    => relation.attributes)\r\n    end\r\n\r\n    # ... irrelevant functionality omitted
    ...\r\n\r\n    private\r\n\r\n    attr_accessor :relation, :key\r\n  end\r\nend\r\n```\r\n\r\nBy
    now you should be able to quickly identify `BrokenRecord::FieldSet` as the object
    that\r\nreceives any calls that `Record` does not answer itself. The good\r\nnews
    is that you already know how `FieldSet` works, because it was discussed in\r\ndetail
    in [Issue 4.8](http://practicingruby.com/articles/60). But if you need a\r\nrefresher,
    check out the following code:\r\n\r\n```ruby\r\nvalues = { :id     => 1, \r\n
    \          :title  => \"A great article\", \r\n           :body   => \"The rain
    in Spain...\", \r\n           :status => \"draft\" }\r\n\r\nfieldset = BrokenRecord::FieldSet.new(:values
    \    => values,\r\n                                      :attributes => values.keys)\r\n\r\np
    fieldset.title  #=> \"A great article\"\r\np fieldset.status #=> \"draft\"\r\n```\r\n\r\nIf
    you read back through the last few examples, you should be able to see how\r\nthe
    data provided by `Relation` gets shoehorned into one of these `FieldSet`\r\nobjects,
    and from there it becomes obvious how the `Article#title` and `Article#status`\r\nmessages
    are handled.\r\n\r\nIf `FieldSet` is doing all the heavy lifting, you may be wondering
    why the\r\n`Record` class needs to exist at all. Those details were omitted from
    the\r\noriginal example, so it is definitely a reasonable question to ask. To
    find your\r\nanswer, consider the following example of updating database records:\r\n\r\n```ruby\r\narticles
    = Article.where(:status => \"draft\")\r\n\r\narticles.each do |article|\r\n  article.status
    = \"published\"\r\n  article.save\r\nend\r\n```\r\n\r\nIn the example you worked
    through earlier, data was being read and not written,\r\nand so it was hard to
    see how `Record` offered anything more than a layer of\r\nindirection on top of
    `FieldSet`. However, the example shown above changes that\r\nperspective significantly
    by giving a clear reason for `Record` to hold a\r\nreference to a `Relation` object.
    While `Article#status=` is provided by\r\n`FieldSet`, the `Article#save` method
    is provided by `Record`, and is defined as\r\nfollows:\r\n\r\n```ruby\r\nmodule
    BrokenRecord\r\n  class Record\r\n    \r\n    # ... other details omitted ...\r\n\r\n
    \   def save\r\n      if key\r\n        relation.update(key, to_hash)\r\n      else\r\n
    \       relation.create(to_hash)\r\n      end\r\n    end \r\n  end\r\nend\r\n```\r\n\r\nFrom
    this method (and others like it), it becomes clear that `Record` is\r\nessentially
    a persistent `FieldSet` object, which forms the essence of what an\r\nActive Record
    object is in its most basic form.\r\n\r\n### EXERCISE: Implementing minimal association
    support \r\n\r\nThe process of working through the low level foundations built
    up in [Issue\r\n4.8](http://practicingruby.com/articles/60) combined with this
    article's \r\nextensive walkthrough of how BrokenRecord implements some basic
    CRUD \r\nfunctionality probably gave you enough learning moments to make you want
    to \r\nquit while you're ahead. That said, if you are looking to dig a little
    deeper, I'd recommend\r\ntrying to work your way through BrokenRecord's implementation
    of associations\r\nand see if you can make sense of it. The following example
    should serve as a\r\ngood starting point:\r\n\r\n```ruby\r\nclass Article\r\n
    \ include BrokenRecord::Mapping\r\n\r\n  map_to_table :articles\r\n\r\n  has_many
    :comments, :key   => :article_id, \r\n                      :class => \"Comment\"\r\n\r\n
    \ def published?\r\n    status == \"published\"\r\n  end\r\nend\r\n\r\nclass Comment\r\n
    \ include BrokenRecord::Mapping\r\n\r\n  map_to_table :comments\r\n\r\n  belongs_to
    :article, :key   => :article_id,\r\n                       :class => \"Article\"\r\nend\r\n\r\n\r\nArticle.create(:title
    \ => \"A great articles\",\r\n               :body   => \"The Rain in Spain\",\r\n
    \              :status => \"draft\")\r\n\r\n\r\nComment.create(:body => \"A first
    comment\",  :article_id => 1)\r\nComment.create(:body => \"A second comment\",
    :article_id => 1)\r\n\r\n\r\narticle = Article.find(1)\r\n\r\nputs \"#{article.title}
    -- #{article.comments.count} comments\"\r\nputs article.comments.map { |e| \"
    \ * #{e.body}\" }.join(\"\\n\")\r\n```\r\n\r\nBecause not all the features used
    by this example are covered in this article,\r\nyou will definitely need to directly
    reference the [full source of\r\nBrokenRecord](https://github.com/elm-city-craftworks/broken_record)
    to complete\r\nthis exercise. But don't worry, by now you should be familiar with
    most of its\r\ncode, and that will help you find your way around. If you attempt
    this \r\nexercise, please let me know your thoughts and questions about it!\r\n\r\n###
    Reflections\r\n\r\nObject-oriented mixins seems very promising to me, but also
    full of open \r\nquestions and potential pitfalls. While they seem to work well
    in this toy \r\nimplementation of Active Record, they may end up creating as many
    problems as\r\nthey solve. In particular, it remains to be seen how this kind
    of modeling would\r\nimpact performance, debugging, and introspection of Ruby
    objects. Still, the\r\npattern does a good enough job of handling a very complex
    architectural\r\npattern to hint that some further experimentation may be worthwhile.\r\n\r\nGoing
    back to the original question I had hoped to answer in the first part of\r\nthis
    article about whether or not the Active Record pattern is inherently complex,
    I\r\nsuppose we have found out that there isn't an easy answer to that question.
    My\r\nBrokenRecord implementation is conceptually simpler than the Rails-based\r\nActiveRecord,
    but only implements a tiny amount of functionality. I think that\r\nthe closest
    thing to a conclusion I can come to here is that the traditional\r\nmethods we
    use for object modeling in Ruby are certainly complex, and so any\r\nsystem which
    attempts to implement large-scale architectural patterns in Ruby\r\nwill inherit
    that complexity unless it deviates from convention.\r\n\r\nThat all having been
    said, reducing complexity is about  more than just\r\npreferring composition over
    inheritance and reducing the amount of magic in our\r\ncode. The much deeper questions
    that we can ask ourselves is whether these very\r\ncomplicated systems we build
    are really necessary, or if they are a\r\nconsequence of piling [abstractions
    on top of abstractions](http://timelessrepo.com/abstraction-creep) \r\nin order
    to fix some fundamental low-level problem.\r\n\r\nWhile this article was a fun
    little exploration into the depths of a\r\ncomplex modeling problem in Ruby, I
    think its real point is to get us to\r\nquestion our own tolerance for complexity
    at all levels of what we do. If you\r\nhave thoughts to share about that, I would
    love to hear them."
- :slug: responsibility-centric-vs-data-centric-design
  :title: Responsibility-centric vs. data-centric design
  :summary: Work through two approaches to object modeling and examine their tradeoffs.
    (w. Greg Moeck)
  :published: 2012-07-10 00:00:00.000000000 Z
  :issue_number: '4.11'
  :volume: 4
  :body: "_This article was contributed by Greg Moeck. Greg is a software \r\ncraftsman
    who has been working with Ruby since 2004. When this\r\narticle was published,
    he was working on mobile javascript development\r\nat Facebook._\r\n\r\nGiven
    that Ruby is an object oriented programming language, all Ruby\r\nprograms are
    going to be composed of many objects. However, techniques \r\nfor breaking the
    functionality of programs into objects can\r\nvary from programmer to programmer.
    In this article I'm going to walk\r\nthrough two common approaches to driving
    design at a high level:\r\n**data-centric design** and **responsibility-centric
    design**. I will\r\nbriefly sketch the key ideas of each of the design methodologies,\r\nillustrating
    how one might structure parts of a simple e-commerce\r\napplication using each
    of the methods. I'll then follow up with some \r\nadvice about where I've found
    the different approaches to be particularly\r\nhelpful or unhelpful.\r\n\r\n###
    Data-centric design\r\n\r\nIn a data-centric design, the system is generally separated
    into objects\r\nbased upon the data that they encapsulate. For example, in an\r\ne-commerce
    application you are likely to find objects that represent\r\nproducts, invoices,
    payments, and users. These objects provide \r\nmethods which operate on that data,
    either returning its values, \r\nor mutating its state. A `Product` object might
    provide a method to \r\ndetermine how many of a given product are currently in
    stock, or possibly\r\na method to add that product to the current shopping cart.\r\n\r\nNames
    for data-centric objects are often nouns, because\r\nthey frequently correspond
    to real-world objects. This real-worldliness \r\nis generally also true of the
    methods that these objects provide. \r\nThe methods either represent accessors
    to the object's data, \r\nrelationships between objects, or actions that could
    be taken on \r\nthe object. The following ActiveRecord object serves as a good
    example\r\nof this style of design:\r\n\r\n```ruby\r\nclass Product < ActiveRecord::Base\r\n
    \ #relationships between objects\r\n  has_many :categories\r\n\r\n  #accessing
    objects data\r\n  def on_sale?\r\n    not(sale_price.nil?)\r\n  end\r\n\r\n  #action
    to take on the product\r\n  def add_to_cart(cart)\r\n    self.remaining_items
    -= 1\r\n    save!\r\n    cart.items << self\r\n  end\r\nend\r\n```\r\n\r\nFollowing
    along these lines, inheritance is generally used as a principle\r\nof classification,
    establishing a subtype relationship\r\nbetween the parent and the child. If B
    inherits from A, that is a\r\nstatement that B is a type of A. This is generally
    described as an **is-a**\r\nrelationship. For example, the classes `LaborCharge`
    and `ProductCharge`\r\nmight both inherit from a `LineItem` base class which implements
    the\r\nfeatures they have in common. The key thing to note about these classes
    is that \r\nthey share at least some data attributes and the behavior around those\r\nattributes,
    even if some of that behavior might end up being overridden.\r\n\r\nHowever, not
    everything can have a counterpart in the real world. There\r\nstill needs to be
    some communication model that is created to describe\r\nthe global or system level
    view of the interactions between objects.\r\nThese **controllers** will fetch
    data from different parts of the system, \r\nand pipe it into actions in another
    part.\r\nSince these objects generally are very difficult to classify in a\r\nhierarchical
    way, it is a good idea to keep them as thin as\r\npossible, pushing as much logic
    into the actual domain model as you\r\npossibly can.\r\n\r\nFor those familiar
    with standard Rails architectures, you should see a\r\nlot of commonalities with
    the above description. Rails model objects are\r\ninherently structured this way
    because the ActiveRecord pattern tightly\r\ncouples your domain objects to the
    way in which their data is persisted.\r\nAnd so all ActiveRecord objects are about
    some \"encapsulated\" data, and\r\noperations that can be done on that data. Rails
    controllers provide the\r\nglobal knowledge of control, interacting with those
    models to then\r\naccomplish some tasks.\r\n\r\n### Responsibility-centric design\r\n\r\nIn
    a responsibility-centric design, systems are divided by the\r\ncollection of behaviors
    that they must implement. The goal of this division is\r\nto formulate the description
    of the behavior of the system in terms of\r\nmultiple interacting processes, with
    each process playing a\r\nseparate **role**. For example, in an e-commerce application
    with a\r\nresponsibility-centric design, you would be likely to find objects\r\nsuch
    as a payment processor, an inventory tracker, and a user\r\nauthenticator.\r\n\r\nThe
    relationships between objects become very similar to the\r\nclient/server model.
    A **client** object will make requests of the server\r\nto perform some service,
    and a **server** object will provide a public API\r\nfor the set of services that
    it can perform. This relationship is\r\ndescribed by a **contract** - that is
    a list of requests that can be made\r\nof the server by the client. Both objects
    must fulfill this contract,\r\nin that the client can only make the requests specified
    by the API, and\r\nthe server must respond by fulfilling those requests when told.\r\n\r\nAs
    an example, a responsibility-centric order processing service might look like\r\nwhat
    you see below:\r\n\r\n```ruby\r\nclass StandardOrderProcessor\r\n  def initialize(payment_processor,
    shipment_scheduler)\r\n    @payment_processor = payment_processor\r\n    @shipment_scheduler
    = shipment_scheduler\r\n  end\r\n\r\n  def process_order(order)\r\n    @payment_processor.debit_account(order.payment_method,
    order.amount)\r\n    @shipment_scheduler.schedule_delivery(order.delivery_address,\r\n
    \                                         order.items)\r\n  end\r\nend\r\n```\r\n\r\nThe
    goal of describing relationships between objects in this way is that\r\nit forces
    the API for the server object to describe *what* it does for\r\nthe client rather
    than *how* it accomplishes it. By its very nature \r\nthe implementation of the
    server must be encapsulated, and\r\nlocked away from the client. This means that
    the client object can only\r\nbe coupled to the public API of its server objects,
    which allows developer\r\nto freely change server internals as long as the client
    still has an\r\nobject to talk to that fulfills the contract. \r\n\r\nThe practical
    benefit of this kind of design is that it makes certain kinds of\r\nchanges very
    easy. For example, the following code could be used as a drop-in\r\nreplacement
    for the `StandardOrderProcessor`, because it implements the same\r\ncontract:\r\n\r\n```ruby\r\nclass
    OrderValidationProcessor\r\n  def initialize(order_processor, error_handler)\r\n
    \   @order_processor = order_processor\r\n    @error_handler = error_handler\r\n
    \ end\r\n\r\n  def process_order(order)\r\n    if is_valid_order(order)\r\n      @order_processor.process_order(order)\r\n
    \   else\r\n      @error_handler.invalid_order(order)\r\n    end\r\n  end\r\n\r\n
    \ private\r\n  def is_valid_order(order)\r\n    #does some checking for if the
    order is valid\r\n  end\r\nend\r\n```\r\n\r\nThe client does not know which sort
    of\r\norder processor it is talking to, it just knows how to request\r\nthat an
    order gets processed. Validations are skipped when the client is\r\nprovided with
    a `StandardOrderProcessor`, and they are run when it is \r\nprovided with a `OrderValidationProcessor`,
    but the client does not\r\nknow or care about these details. This allows for substantial
    changes\r\nin order processing behavior without requiring any modifications to
    \r\nthe client object.\r\n\r\nTo make them easier to work with, these kinds of
    service objects would \r\ngenerally be composed with a factory that might look
    something like\r\nwhat you see below:\r\n\r\n```ruby\r\nclass OrderProcessor\r\n
    \ # ...\r\n\r\n  def with_validation\r\n    OrderValidationProcessor.new(without_validation,\r\n
    \                                error_handler)\r\n  end\r\n\r\n  def without_validation\r\n
    \   StandardOrderProcessor.new(payment_processor, shipment_scheduler)\r\n  end\r\n\r\n
    \ # ...\r\nend\r\n```\r\n\r\n\r\nThe notion of client and server are related to
    what side of a contract \r\neach object is on, which means that individual objects
    frequently \r\nplay both roles. For example, a payment processor object may\r\nconsume
    the services of a credit card processor, while providing\r\nservices for an order
    processor. From the perspective of the credit card\r\nprocessor, the payment processor
    is a client, but just the opposite is\r\ntrue for the ordering system. A key feature
    of this kind of design\r\nis that objects are coupled to an interface rather than
    an \r\nimplementation, which makes the relationships between objects much\r\nmore
    dynamic than what you can expect from a data-centric design.\r\n\r\nAs you've
    probably already noticed, because these kinds of objects represent the\r\nbehavior
    of the system rather than the data, the objects are not\r\ngenerally named after
    real-world entities. The roles that an object\r\nplays often represent real-world
    processes, and the implementation of\r\nthese roles are often named after *how*
    they implement the desired role.\r\nFor example, within our system there might
    be two objects which\r\ncan play the role of a shipment scheduler: a `FedexDeliveryScheduler`
    and\r\n`UPSDeliveryScheduler`. Despite the specificity of their names, the client
    \r\nconsuming these objects would not know which of the two it was talking to
    as\r\nlong as they implemented a common interface for scheduling deliveries. A
    natural\r\nconsequence of role-based modeling is that method names become more
    important\r\nwhile class names become less important, and this example is no exception.\r\n\r\nAnother
    core concept of responsibility-centric designs is that data \r\ntends to flow
    through the system rather than being centrally managed within the \r\nsystem.
    As a result, data typically takes the form of immutable \r\nvalue objects. For
    example, in the above order processors, the processes\r\nwere being passed an
    order object, which contained the data for a given\r\norder. The objects within
    the system are not mutating or persisting this\r\ndata directly, but passing values
    around instead. With that in mind,\r\nan object responsible for tracking the current
    order might look like\r\nwhat you see below:\r\n\r\n```ruby\r\nclass CurrentOrderTracker\r\n
    \ def initialize\r\n    @order = Order.new\r\n  end\r\n\r\n  def item_selected(item)\r\n
    \   @order = order.add_item(item)\r\n  end\r\n\r\n  class Order\r\n    attr_accessor
    :items\r\n\r\n    def initialize(items)\r\n      @items = items || []\r\n    end\r\n\r\n
    \   def add_item(item)\r\n      Order.new(@items + item)\r\n    end\r\n  end\r\nend\r\n```\r\nBecause
    any reference to one of these values is guaranteed to be\r\nimmutable, any process
    can read from it at any time without worrying\r\nthat it might have been modified
    by another process. This is not to \r\nsay however that this data is never persisted.
    When it is\r\nnecessary to persist this data, an object playing the role of a\r\npersister
    must be created, and it must receive messages containing these\r\nvalues just
    like any other part of the system. In this way, the\r\npersistance logic generally
    lives on the boundaries of the system rather\r\nthan in the center. Such an object
    might look something like this:\r\n\r\n```ruby\r\nclass SQLOrderPersister\r\n
    \ #assuming that AROrder is an active record object\r\n  def persist_order(order)\r\n
    \   order = AROrder.find(order.id)\r\n    if order\r\n      order.update_attributes(order.attributes)\r\n
    \   else\r\n      AR.Order.new(order.attributes).save\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe
    last thing to note is that in this sort of system using inheritance\r\nas a form
    of classification doesn't really make much sense. Historically\r\ninheritance
    has taken the form of \"plays the same role as\" instead \r\nof **is-a**. Objects
    which play the same role have historically inherited\r\nfrom a common abstract
    base class which merely implements the role's\r\npublic API, and forces any class
    that inherits from it to do the same.\r\nThis relationship expresses that an object
    implements a certain contract, \r\nrather than categorically claiming  what the
    object is.\r\n\r\nIn Ruby, using inheritance for this sort of relationship isn't
    \r\nstrictly necessary. Due to duck typing, if something quacks \r\nlike a duck
    (that is if it implements the same API as a duck), it \r\nis a duck, and there
    is no need to have the objects inherit\r\nfrom a common base class. That being
    said, it can still be nice to\r\nexplicitly name these roles, and an abstract
    base class can often be\r\nused to do that.\r\n\r\n### Comparing and contrasting
    the two design styles\r\n\r\nAs with almost any engineering choice, it isn't possible
    to say that either \r\nof these two approaches is always superior or inferior.
    That said, \r\nwe can still walk through some strengths and weaknesses of each
    approach.\r\n\r\n**Strengths of data-centric design:**\r\n\r\n1) Because the code
    is broken into parts around real world entities,\r\n  these entities are easy
    to find and tweak. All the code relative to a\r\n  certain set of data lives together.\r\n\r\n2)
    Because it has a global flow control, and the fact that it is\r\n  it is centered
    around data (which people generally understand),\r\n  it is relatively easy for
    programmers experienced with traditional\r\n  procedural languages to adapt their
    previous experience into this\r\n  style.\r\n\r\n3) It is very easy to model things
    like create/read/update/destroy\r\n  because the data is found in a single model
    for all real world\r\n  objects.\r\n\r\n4) For systems with many data types and
    a small amount of behavior, this\r\n  approach evenly distributes the location
    of the code.\r\n\r\n**Weaknesses of data-centric design:**\r\n\r\n1) Because the
    structure of an object is a part of its definition,\r\n   encapsulation is generally
    harder to achieve.\r\n\r\n2) Because the system is split according to data, behavior
    is often hard\r\n  to track down. Similar operations often span across multiple
    data\r\n  types, and as such end spread out across the entirety of the system.\r\n\r\n3)
    The cohesion of behavior within an object is often low since every\r\n  object
    has to have all actions that could be taken upon it, and those\r\n  actions often
    have very little to do with one another.\r\n\r\n4) In practice it often leads
    to coupling to the structure of the object\r\n  as one needs to violate the Law
    of Demeter to traverse the\r\n  relationships of the objects. For example, think
    of often you in Rails\r\n  you see something like the following code:\r\n\r\n```ruby\r\n@post.comments.each
    do |comment|\r\n  if comment.author.something\r\n    ...\r\n  end\r\nend\r\n```\r\n\r\n**Strengths
    of responsibility-centric design:**\r\n\r\n1) Objects tend to be highly cohesive
    around their behavior, because\r\nroles are defined by behavior, not data.\r\n\r\n2)
    Coupling to an interface rather than an implementation makes\r\nit easier to change
    behavior via composition.\r\n\r\n3) As more behaviors are introduced into the
    system, the number of \r\nobjects increases rather than the lines of code within
    model objects.\r\n\r\n\r\n**Weaknesses of responsibility-centric design:**\r\n\r\n1)
    It is often difficult to drop into the code and make simple changes as\r\n  even
    the simplest change necessitates understanding the architecture\r\n  of at least
    the module. This means that the on-ramping time for the\r\n  team is generally
    fairly high.\r\n\r\n2) Since there is generally no global control, it is often
    difficult for\r\n  someone to grasp where things are happening. As Kent Beck,
    and Ward\r\n  Cunningham have said, \"The most difficult problem in teaching object-\r\n
    \ oriented programming is getting the learner to give up the global\r\n  knowledge
    of control that is possible  with  procedural  programs,\r\n  and rely on the
    local knowledge of objects to accomplish their\r\n  tasks.\"\r\n\r\n3) Data is
    not as readily available since the destructuring of the\r\n  application is around
    behavioral lines. The data can often be\r\n  scattered throughout the system.
    Which means changing the data\r\n  structure is more expensive than changing the
    behavior.\r\n\r\n### Choosing the right design\r\n\r\nRails has proven how the
    data centric approach can lead to quickly\r\nbuilding an application that can
    create, read, update and destroy data.\r\nAnd for applications whose domain complexity
    lies primarily in data types,\r\nand the actions that can be taken on those data
    types, the pattern works\r\nextremely well. Adding or updating data types is fast
    and easy since the\r\nsystem is cohesive around its data.\r\n\r\nHowever as some
    large legacy Rails codebases show, when the complexity\r\nof the domain lies primarily
    in the behaviors or rules of the domain\r\nthen organizing around data leads to
    a lot of jumbled code. The models\r\nend up needing to have many methods on them
    in order to process all of\r\nthe potential actions that can be taken on them,
    and many of these\r\nactions end up being similar across data types. As such the
    cohesion of\r\nthe system suffers, and extending or modifying the behavior becomes
    more and\r\nmore difficult over time.\r\n\r\nThe opposite of course is true as
    well in my experience. In a system\r\nwhose domain complexity lies primarily in
    its behavior, decomposing the\r\nsystem around those behaviors makes extending
    or modifying the behavior\r\nof the system over time to be much faster and easier.
    However the cost\r\nis that extending or modifying the data of the system can
    become more\r\nand more difficult over time.\r\n\r\nAs with most design methods,
    it comes down to an engineering decision,\r\nwhich often means you have to guess,
    and evolve over time. There is no\r\nmagic system that will be the right way to
    model things regardless of\r\nthe application. There might even be some subsets
    of an application\r\nthat might be better modeled in a data-centric way, whereas
    other\r\nsections of the system might be better modeled in a behavior-centric
    way.\r\nThe key thing I've found is to be sensitive to the \"thrash\" smell, where\r\nyou
    notice that things are becoming more and more difficult to extend or\r\nmodify,
    and be open to refactor the design based on the feedback you're\r\ngetting from
    the system.\r\n\r\n### Further references\r\n\r\n1) Growing Object Oriented Software
    Guided By Tests, Steve Freeman, Nat Pryce\r\n\r\n2) Object-oriented design: a
    responsibility-driven approach, R. Wirfs-Brock, B. Wilkerson, OOPSLA '89 Conference
    proceedings on Object-oriented programming systems, languages and applications\r\n\r\n3)
    The object-oriented brewery: a comparison of two object-oriented development methods,
    Robert C. Sharble, Samuel S. Cohen, ACM SIGSOFT Software Engineering Notes, Volume
    18 Issue 2, April 1993\r\n\r\n4) Mock Roles, Not Objects, Steve Freeman, Tim Mackinnon,
    Nat Pryce, Joe Walnes, OOPSLA '04 Companion to the 19th annual ACM SIGPLAN conference
    on Object-oriented programming systems, languages, and applications\r\n\r\n5)
    A Laboratory For Teaching Object-Oriented Thinking, Kent Beck, Ward Cunningham,
    OOPSLA '89 Conference proceedings on Object-oriented programming systems, languages
    and applications\r\n"
- :slug: tdd-lessons-learned
  :title: Lessons learned from my TDD self-study
  :summary: Revisit the reasons for Gregory's 90-day self-study on TDD, and see the
    results.
  :published: 2012-07-17 00:00:00.000000000 Z
  :issue_number: '4.12'
  :volume: 4
  :body: "Test-driven development (TDD) is a topic that never gets old among programmers,
    \r\neven though we can hardly agree on what its costs and benefits are. While
    \r\nthere are no shortage of neatly packaged expert viewpoints on this topic,\r\nvery
    few of them are backed up by solid evidence. Formal research\r\nindicates that
    TDD does tend to produce code with fewer defects, but no other\r\nsignificant
    effects have been found. What these results tell us is that the\r\nburden of proof
    is on us for everything else we believe about TDD, especially \r\nwhen it comes
    to perceived benefits that have nothing to do with \r\nregression testing.\r\n\r\nThinking
    about my own relationship to test-driven development, I came to\r\nrealize that
    my own assumptions about its costs and benefits were \r\nfuzzy at best. I had
    plenty of opinions on the topic, but found it hard to \r\nelaborate on them. As
    these opinions hardened into beliefs, it became \r\nmuch more challenging to meaningfully
    consider ideas about TDD which\r\ndiffered from my own. My own cynicism was preventing
    me from making \r\na reasoned argument for my way of doing things. \r\n\r\nKnowing
    that stubbornness is the enemy of progress, I decided to take \r\na fresh look
    at my use of TDD and how it effects my work. For a period\r\nof 90 days, I challenged
    myself to practice formal TDD as often as \r\npossible, and to learn as much about
    \r\nit as I could during that time. While the [original plans for my self\r\nstudy](http://practicingruby.com/articles/28)
    were much more\r\nrigorous than what I ended up doing, I did maintain a fairly\r\ndisciplined
    TDD workflow throughout the three month period, and that\r\ntaught me a few lessons
    worth sharing.\r\n\r\nTo make it easier for us to discuss what I've learned, I've
    decided to \r\nbreak the lessons out into individual mini-articles, each with
    their own comments\r\nthread. Please follow the links below to read them:\r\n\r\n*
    [LESSON 1: End-to-end testing is essential](http://practicingruby.com/articles/66)\r\n*
    [LESSON 2: Refactoring is not redesign](http://practicingruby.com/articles/67)\r\n*
    [LESSON 3: Mock objects deeply influence design](http://practicingruby.com/articles/68)\r\n*
    [LESSON 4: Spiking is not cowboy coding](http://practicingruby.com/articles/69)\r\n\r\nIf
    you feel there are other lessons that you have learned from your own work\r\nwith
    TDD, or you have general questions about how my self-study went, feel free\r\nto
    share them here.\r\n"
- :slug: end-to-end-testing-is-essential
  :title: End-to-end testing is essential
  :summary: Build acceptance tests that reflect application behavior, rather than
    implementation details.
  :published: 2012-07-18 00:00:00.000000000 Z
  :issue_number: 4.12.1
  :volume: 4
  :body: "> **NOTE:** This is one of [four lessons\r\n> learned](http://practicingruby.com/articles/65)
    from my 90 day [self-study on\r\n> test-driven development](http://practicingruby.com/articles/28).
    \r\n> If this topic interests you, be sure to check out the other lessons!\r\n\r\nPerhaps
    the most significant thing I have noticed about my own TDD habits \r\nis that
    I frequently defer end-to-end testing or skip it entirely, and that \r\nalways
    comes at a huge cost. Now that I have had a chance to watch \r\nmyself get caught
    in that trap several times, I have a better understanding\r\nof what triggers
    it.\r\n\r\nMost of the time when I work on application development, I start out
    by \r\nattempting to treat its delivery mechanism as an implementation detail.
    \r\nThinking this way makes me feel that testing code through the UI \r\nisn't
    especially important, provided that I test-drive my domain objects \r\nand keep
    their surface as narrow as possible. My first iteration on the\r\nBlind game provides
    a good example of how I tend to apply this strategy.\r\n\r\nMy first complete
    feature in the game was a simple proof of concept: \r\nI dropped the player into
    the center of a map, and then allowed them to\r\nmove around using the WASD keys
    on their keyboard. When the player \r\nreached the edge of the map, the game would
    play a beeping sound\r\nand then terminate itself. You can check out the [full
    source for \r\nthis feature](https://github.com/elm-city-craftworks/blind/compare/1f6a...4345)\r\nto
    see its implementation details, but the important thing to note\r\nis that its
    delivery mechanism was tiny and almost completely logic-free:\r\n\r\n```ruby\r\nRay.game
    \"Blind\" do\r\n  register { add_hook :quit, method(:exit!) }\r\n\r\n  scene :main
    do\r\n    self.frames_per_second = 10\r\n\r\n    @game = Blind::Game.new\r\n    @game.on_event(:out_of_bounds)
    do\r\n      beep = sound(\"#{File.dirname(__FILE__)}/../data/beep.wav\")\r\n      beep.play\r\n
    \     sleep beep.duration\r\n\r\n      exit!\r\n    end\r\n\r\n    always do\r\n
    \     puts @game.player_position\r\n\r\n      @game.move_player(0,-1) if holding?(:w)\r\n
    \     @game.move_player(0,1) if holding?(:s)\r\n      @game.move_player(-1,0)
    if holding?(:a)\r\n      @game.move_player(1,0) if holding?(:d)\r\n    end\r\n
    \ end\r\n\r\n  scenes << :main\r\nend\r\n```\r\n\r\nBased on this single code
    example, it is easy to make the case that end-to-end\r\ntesting can be deferred
    until later, or that perhaps it is not needed at all.\r\nThinking this way is
    very tempting, because it frees you from having to think\r\nabout how to dig down
    into the delivery mechanism and run your tests through it.\r\nAlready burdened
    by the idea of writing more tests than I usually do, I was\r\nquick to take that
    bargain and felt like it was a reasonable tradeoff at the\r\ntime.\r\n\r\nI couldn't
    have been more wrong. I encountered my first trivial UI bug \r\nwithin 24 hours
    of shipping the first feature. Several dozen patches \r\nlater when I had a playable
    game, I had already sunk several hours into \r\nfinding and fixing UI defects
    that I discovered through manual play testing.\r\nThe wheels finally came off
    the wagon when I realized that I could not\r\neven safely rename methods without
    playing through the entire game and\r\ntriggering each of its edge cases. The
    following example shows one\r\nof the many \"oops\" changesets that the projects
    accumulated in a very short\r\nperiod of time:\r\n\r\n```diff\r\nsounds[:siren].volume
    = \r\n-  ((world.distance(world.center_position) - min) / max.to_f) * 100\r\n+
    \ ((world.distance(world.center_point) - min) / max.to_f) * 100\r\n```\r\n\r\nBy
    the time I had finally felt the pain of not having any tests running from\r\nend-to-end,
    the delivery mechanism was no longer a trivial script that could\r\nbe scribbled
    on the back of a napkin. Over the period of a week or so, it had\r\ngrown into
    a [couple hundred lines of code](https://github.com/elm-city-craftworks/blind/tree/776f3462c2244634ccddc22a5473916d6439872c/lib/blind/ui)
    \r\nspread across several significant features. The surface of\r\nthe domain model
    also needed to expand to support these new\r\nfeatures, and so the critical path
    through the system became difficult to \r\nkeep in mind while working on the codebase.
    This made it much harder\r\nto introduce a change without accidentally breaking
    something. \r\n\r\nFed up with chasing down trivial bugs and spending so much
    time on manual\r\ntesting, I finally decided that I needed to implement a player
    simulator \r\nwhich would allow me write tests similar to the one shown below:\r\n\r\n```ruby\r\nit
    \"should result in a loss on entering deep space\" do\r\n  world  = Blind::Worlds.original(0)\r\n
    \ levels = [Blind::Level.new(world, \"test\")]\r\n\r\n  game  = Blind::UI::GamePresenter.new(levels)\r\n\r\n
    \ sim   = Blind::UI::Simulator.new(game)\r\n\r\n  sim.move(500, 500)\r\n  \r\n
    \ sim.status.must_equal \"You drifted off into deep space! YOU LOSE!\"\r\nend\r\n```\r\n\r\nAs
    predicted, the `Blind::UI::Simulator` object was [not especially easy to\r\nimplement](https://github.com/elm-city-craftworks/blind/blob/2fa2d75216077bdafa556be3c560b3f7c205e672/lib/blind/ui/simulator.rb).
    \r\nTo get it to work, I had to experiment with several undocumented features
    in the Ray\r\nframework and cobble them together through a messy trial and error
    process. This\r\nreminded me of previous projects I had worked on where I had
    to do the same\r\nthing to introduce end-to-end tests in Rails applications, and
    is quite possibly\r\none of my least favorite programming tasks; all this work
    just feels so\r\ntangential to the task at hand.\r\n\r\nStill, it is hard to argue
    with results. After introducing this little simulator\r\nobject, the number of
    trivial errors I introduced into the system rapidly\r\ndeclined, even though I
    was still actively changing things. Occasionally, I'd\r\nmake a change which broke
    the simulator in weird and confusing ways, but all the\r\ntime spent working on
    those issues was less than the total time I spent chasing\r\ndown dumb mistakes
    before making this change. \r\n\r\nAs I continued on with my study, I experienced
    similar situations with both a \r\nSinatra application and a command line application,
    and that is when I realized\r\nthat you simply can't get away from paying this
    tax one way or another. If\r\nnothing else, working on acceptance tests first
    helps balance out the illusion\r\nof progress in the early stages of a project,
    and makes it easier to sustain\r\nan even pace of development over time.\r\n\r\nAt
    the end of my study, I read the first few chapters of [Growing Object\r\nOriented
    Software, Guided by Tests](http://www.growing-object-oriented-software.com/),
    \r\nand it gave similar advice to what I had found out the hard way. The authors\r\npresented
    a somewhat more radical idea about how to build application runners, \r\nsuggesting
    that they should completely hide the implementation details of the \r\nunderlying
    application and its delivery mechanism. To try out these ideas, \r\nI built a
    small [tic-tac-toe game](https://github.com/elm-city-craftworks/ruby-examples/tree/master/tic_tac_toe)
    \r\nusing Ray, writing my first end-to-end test before writing any other code:
    \r\n\r\n```ruby\r\ndescribe \"A tic tac toe game\" do\r\n  it \"alternates between
    X and O\" do\r\n    run_game do |runner|\r\n      runner.message.must_equal(\"It's
    your turn, X\")\r\n      runner.move(5)\r\n      runner.message.must_equal(\"It's
    your turn, O\")\r\n      runner.move(3)\r\n      runner.message.must_equal(\"It's
    your turn, X\")\r\n    end\r\n  end\r\n\r\n  def run_game(&block)\r\n    GameRunner.run(&block)\r\n
    \ end\r\nend\r\n```\r\n\r\nBecause this test does all of its work through the\r\n[GameRunner\r\nobject](https://github.com/elm-city-craftworks/ruby-examples/blob/master/tic_tac_toe/test/helpers/game_runner.rb),\r\nit
    is both easier to read and more maintainable than the tests that I built for\r\nBlind.
    Furthermore, I feel like it is much easier write test-first code this\r\nway,
    as it doesn't require as many decisions to be made up front.\r\n\r\nI've been
    talking about a rather weird domain throughout this article (game\r\nprogramming
    in Ray), but I could easily imagine how I might apply what I've\r\nlearned to
    a traditional Rails application. For example, if I were to build a\r\nblog and
    wanted to write my first test for it, I might start with something like\r\nthis:\r\n\r\n```ruby\r\ndescribe
    \"A post\" do\r\n  let(:blogger) { SimulatedBlogger.new }\r\n\r\n  it \"can be
    created by a logged in blogger\" do\r\n    blogger.log_in(\"user\", \"password\")\r\n
    \   blogger.create_post(\"Hello World\")\r\n  end\r\n\r\n  it \"cannot be created
    by a blogger that has not logged in\" do\r\n    assert_raises(SimulatedBlogger::AccessDeniedError)
    do\r\n      blogger.create_post(\"Hello World\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nI
    would then move on to implement the `SimulatedBlogger` using something like\r\ncapybara
    or some other web automation tool. On the surface, this at least \r\nseems like
    a good idea; in practice it may be more trouble than it's worth for a number \r\nof
    reasons.\r\n\r\nSince I'm still relatively new to end-to-end testing in general,
    I am definitely\r\ncurious to hear what you think of these ideas. This article
    summarizes what\r\nI learned from my experiences during my study, but I am not
    yet confident in my \r\nown applications of these techniques. If you have an interesting
    story to share, \r\nplease do so!\r\n"
- :slug: refactoring-is-not-redesign
  :title: Refactoring is not redesign
  :summary: 'Discover how the differences between refactoring and redesign affect
    testing strategies. '
  :published: 2012-07-19 00:00:00.000000000 Z
  :issue_number: 4.12.2
  :volume: 4
  :body: "> **NOTE**: This is one of [four lessons learned](http://practicingruby.com/articles/65)
    \r\nfrom my [90 day self-study on test-driven development](http://practicingruby.com/articles/28).
    \r\nIf this topic interests you,  be sure to check out the other lessons! \r\n\r\nTo
    maintain a productive TDD workflow, you need understand the difference\r\nbetween
    **refactoring** and **redesign**. These two activities are distinct from one\r\nanother,
    but because they are often done in lockstep, it can be \r\nchallenging to mentally
    separate them. \r\n\r\nThe problem I noticed in my own work is that seemingly
    simple changes\r\noften spiral into much more complex modifications. Whenever
    that happens,\r\nit is easy to make bad decisions that can cause progress to grind
    to a halt. \r\nHaving a good way to distinguish between what can be accomplished\r\nvia
    simple refactorings and what requires careful design consideration \r\nseems to
    be the key to preventing this problem.\r\n\r\nMy hope is that by reading what
    I have learned from my own experiences,\r\nyou will be able to avoid some of these
    obstacles along your own path. \r\nThese lessons are not fun to learn the hard
    way!\r\n\r\n### What is refactoring?\r\n\r\nRefactoring in the traditional sense
    has to do with making [small and safe \r\ntransformations](http://refactoring.com/catalog/index.html)
    to a codebase \r\nwithout altering its external behavior. Because refactorings
    are designed to be atomic \r\nand almost trivial, you can apply them whenever
    you feel that they will make life\r\n easier for you down the road. For example,
    it is rarely a bad idea to clean up messy\r\n code by introducing a couple helper
    methods:\r\n \r\n```diff\r\n       def belongs_to(parent, params)\r\n-        mapper.record_class.send(:define_method,
    parent) do\r\n-          Object.const_get(params[:class]).find(send(params[:key]))\r\n+
    \       define_association(parent) do\r\n+          BrokenRecord.string_to_constant(params[:class])\r\n+
    \                     .find(send(params[:key]))\r\n         end\r\n       end\r\n
    \r\n       def has_many(children, params)\r\n         table_primary_key = mapper.primary_key\r\n
    \r\n-        mapper.record_class.send(:define_method, children) do\r\n-          Object.const_get(params[:class])\r\n-
    \               .where(params[:key] => send(table_primary_key))\r\n+        define_association(children)
    do\r\n+          BrokenRecord.string_to_constant(params[:class])\r\n+            .where(params[:key]
    => send(table_primary_key))\r\n         end\r\n       end\r\n ```\r\n \r\nOn the
    surface, this change is very superficial, as a proper refactoring ought\r\nto
    be. However, it has several immediate advantages worth pointing out:\r\n\r\n*
    The `define_association` helper makes the code reveal its \r\nintentions much
    more clearly by hiding some awkward metaprogramming.\r\n\r\n* The `BrokenRecord.string_to_constant`
    method makes it easy\r\nto extend this code so that it handles fully qualified
    constant names \r\n(i.e. `SomeProject::Person`), without the need to add a bunch
    of extra \r\nnoise in multiple places.\r\n\r\n* Both helper methods cut down on
    duplication, eliminating the connascence\r\nof algorithm that was present in the
    original code.\r\n\r\n* Both helper methods reduce the amount of implementation
    details that\r\nthe `belongs_to` and `has_many` methods need to be directly aware
    of,\r\nmaking them more adaptive to future changes.\r\n\r\nThe important thing
    to notice here is that while making this change opens\r\na lot of doors for us,
    and has some immediate tangible benefits, it does \r\nnot introduce any observable
    functional changes, both from the external\r\nperspective, and from the perspective
    of the object's collaborators.\r\n\r\n### What is redesign?\r\n\r\nWhile the concept
    of refactoring is easy to define and categorize, the\r\nprocess of redesigning
    code is not nearly as straightforward. Rather\r\nthan attempting to provide an
    awkard definition for it, I will\r\ndemonstrate what makes redesign different
    from refactoring by\r\nshowing you a real example from my study.\r\n\r\nWhen working
    on BrokenRecord (my toy implementation of \r\nthe Active Record pattern), I initially
    designed it so that a \r\nsingle object was responsible for running queries against\r\nthe
    database and mapping their results to user-defined \r\nmodels. This worked fine
    as a proof of concept, and the\r\n[code was pretty easy to follow](https://github.com/elm-city-craftworks/broken_record/blob/e5bd9fb676361b97c9c27d46efd812b826eecbf6/lib/broken_record/table.rb).\r\n\r\nHowever,
    designing things this way lead to very high\r\ncoupling between the query API
    and the underlying\r\ndatabase implementation, as you can see in the following\r\ncode:\r\n\r\n```ruby\r\nmodule
    BrokenRecord\r\n  class Table\r\n  \r\n   #...\r\n\r\n    def create(params)\r\n
    \     escapes = params.count.times.map { \"?\" }.join(\", \") \r\n      fields
    \ = params.keys.join(\", \")\r\n\r\n      BrokenRecord.database.execute(\r\n        \"insert
    into #{@table_name} (#{fields}) values (#{escapes})\",\r\n        params.values\r\n
    \     )\r\n    end\r\n\r\n    def find(id)\r\n      BrokenRecord.database\r\n
    \                 .execute(\"select * from #{@table_name} where id = ?\", [id])\r\n
    \                 .map { |r| @row_builder.build_row(self, r) }.first\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nEven though I had no intentions of making BrokenRecord
    into a \r\nlibrary that could be used for practical applications, this design
    was\r\nfundamentally inconsistent with what it means to be an \r\nobject-relational
    mapper. The lack of abstraction made any sort\r\nof query optimization impossible,
    and also prevented the \r\npossibility of introducing support for multiple database
    backends.\r\n\r\nIn addition to these concerns about future extensibility, the
    current\r\ndesign made it much harder to test this code, and much harder\r\nto
    do some common queries without directly hijacking the global \r\nreference to
    the underlying database adapter. All these things \r\ncombined meant that a redesign
    was clearly in order.\r\n\r\nTaking a first glance at the implementation of \r\n[BrokenRecord::Table](https://github.com/elm-city-craftworks/broken_record/blob/e5bd9fb676361b97c9c27d46efd812b826eecbf6/lib/broken_record/table.rb),\r\nit
    was tempting to think that all that was needed here was to [extract\r\na class](http://refactoring.com/catalog/extractClass.html)
    to encapsulate the \r\ndatabase interactions. But because this object had come
    into existence as\r\na result of a [broad-based integration test](https://github.com/elm-city-craftworks/broken_record/blob/e5bd9fb676361b97c9c27d46efd812b826eecbf6/test/integration.rb)\r\n
    rather than a series of focused unit tests, I was hesitant to perform an extraction
    \r\n without writing a few more tests first.\r\n \r\n Thinking about the problem
    a little more, I noticed that the changes I wanted\r\n were deeper than just putting
    together an internal object to hide\r\n some implementation details and reduce
    coupling. The fact that `Table` was\r\n the best name I could think of for my
    extracted object even though that was\r\n the name of the original class was a
    sign that I was in the process of \r\n changing some responsibilities in the system,
    not just grouping related\r\n bits of functionality together.\r\n \r\n### Taking
    a TDD-friendly approach to redesign\r\n\r\nThe mistake I've made in the past when
    it comes to redesigning internal\r\nobjects is that I tended to make my changes
    recursively, often without\r\nintroducing new tests as I went. So for example,
    I might take a helper\r\nobject that had gotten too complex and break it into
    two objects, testing\r\nboth objects only indirectly through some higher level
    test. That kind of\r\nchange would often reveal to me that I wanted to extract
    even more classes\r\nor methods, or possibly even change the protocols between
    the low-level \r\ncollaborators in the system. \r\n\r\nSooner or later, I would
    end up with a complicated web of internal objects \r\nthat were all being tested
    through a single use case at the high level, \r\nand so any defects I introduced
    became very hard to track down. Even though\r\nmy tests were protecting external
    defects from creeping into the system, \r\nI had negated the design and debugging
    benefits that come along with doing\r\nTDD more rigorously.\r\n\r\nAfter [discussing
    this bad habit of mine with Eric Hodel](https://github.com/mendicant/mendicantuniversity.org/wiki/TDD-study-session-%282012-May-03%29)\r\nduring
    one of Mendicant University's study sessions, I came to realize that \r\nthere
    are some simple ways to sidestep this problem. In particular, I realized \r\nthat
    I could redesign systems by introducing new components from the bottom \r\nup,
    cutting over to the new implementation only when it was ready to be integrated.\r\n\r\nWanting
    to try out these new ideas in BrokenRecord, I started out by renaming\r\nthe `BrokenRecord::Table`
    object to `BrokenRecord::RecordTable`. I put virtually\r\nno thought into the
    new name, because what I was really trying to do was free\r\nup the `BrokenRecord::Table`
    name so that I could completely change the\r\nresponsibilities associated with
    it. This allowed me to experience a similar\r\namount of freedom that simply deleting
    the original class would have given\r\nme, but without the cost of having to work
    through a bunch of orphaned\r\nreferences and broken tests in my system.\r\n\r\nI
    drove the new `BrokenRecord::Table` object test first, mostly mirroring the\r\nideas
    from the original object but sticking strictly to the interactions with\r\nthe
    database and representing records as simple Hash objects. I also\r\nadded a new
    feature which provided information about the columns\r\nin a given table. You
    can get a rough idea for how I sketched out that\r\nfeature by checking out the
    following test:\r\n\r\n```ruby\r\n  it \"must be able to retrieve column information\"
    do\r\n    columns = table.columns\r\n\r\n    columns.count.must_equal(3)\r\n\r\n
    \   columns[:id][:type].must_equal(\"integer\")\r\n    columns[:title][:type].must_equal(\"text\")\r\n
    \   columns[:body][:type].must_equal(\"text\")\r\n  end\r\n```\r\n\r\nThe original
    `BrokenRecord::Table` object was just a first iteration spike,\r\nand so it expected
    that all model objects explicitly defined what fields \r\nwere in the tables they
    mapped to. This helped keep the implementation\r\nsimple, which was essential
    when the class was taking on two \r\nresponsibilities at once. However, in the
    new `BrokenRecord::Table` \r\nobject, this kind of low level database interaction
    looked perfectly at\r\nhome, and paved the way for removing the tedious `BrokenRecord::RowMapper`\r\nobject
    in the newly designed system.\r\n\r\nThroughout the process of building better
    internals from the bottom\r\nup, I was able to make these kinds of revisions to
    several objects, and\r\nalso introduced a couple more internal objects to help
    out with various\r\nthings. Sooner or later, I reached the point where I was ready
    to create\r\nan object that could serve as a drop-in replacement for the original\r\n`BrokenRecord::Table`
    object (the one I renamed `RecordTable`). \r\nFeeling like I might actually keep
    this new object around for a while, \r\nI decided to name it `TableMapper`, which
    at least sounded slightly\r\nless horrible than `RecordTable`. Its methods ended
    up looking \r\nsomething this:\r\n\r\n \r\n ```ruby\r\nmodule BrokenRecord\r\n
    \ class TableMapper\r\n\r\n   # ...\r\n    \r\n    def create(params)\r\n      id
    = @table.insert(params)    \r\n    \r\n      find(id)\r\n    end\r\n\r\n    def
    find(id)\r\n      fields = @table.where(:id => id).first\r\n\r\n      return nil
    unless fields\r\n\r\n      @record_class.new(:table => @table,\r\n                        :fields
    => fields,\r\n                        :key    => id)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nFunctionality-wise,
    the newly created `BrokenRecord::TableMapper` was nearly a\r\ndrop in replacement
    for the original system, even though it had a much better\r\nunderlying design.
    Because it only needed to implement a handful of methods\r\nto maintain API compatibility,
    integrating it went very smoothly, and required\r\nalmost no changes to the original
    top-level tests. Once I cut things over\r\nand had all the tests passing, I was
    able to completely remove the\r\n`BrokenRecord::RecordTable` object without any
    issues.\r\n\r\n### Reflections\r\n\r\nIf I had not taken this more disciplined
    approach and instead followed my old\r\nways, I probably would have ended up in
    about the same place design-wise, but\r\nit would have come at a much higher cost.
    I would have had fewer tests,\r\nspent more time debugging trivial errors, and
    probably would have cut corners\r\nin places out of impatience or frustration.
    The overall codebase would have\r\nstill been quite brittle, and future changes
    would be harder to make rather\r\nthan easier. Taking that less disciplined approach
    might have allowed me\r\nto implement this particular set of changes a little
    faster, but my past \r\nexperiences have taught me that I always end up having
    to pay down\r\nmy techinical debt sooner or later.\r\n\r\nBy teaching myself to
    think of refactoring and redesign as distinct activities,\r\nI am much more likely
    to stop myself from going on long exploratory cleanup\r\nmissions with little
    guidance from my tests. This has already made a big\r\ndifference in my own work,
    so I'd definitely recommend giving it a try.\r\n\r\nIf you have questions, or
    a story of your own to share, please leave me a comment!\r\n\r\n\r\n"
- :slug: mock-objects-deeply-influence-design
  :title: Mock objects deeply influence design
  :summary: Learn the rules that you need to follow in order to use mock objects as
    an effective design tool.
  :published: 2012-07-24 00:00:00.000000000 Z
  :issue_number: 4.12.3
  :volume: 4
  :body: "> **NOTE:** This is one of [four lessons\r\n> learned](http://practicingruby.com/articles/65)
    from my 90 day [self-study on\r\n> test-driven development](http://practicingruby.com/articles/28).
    \r\n> If this topic interests you, be sure to check out the other lessons!\r\n\r\nBefore
    this study, I knew that I [rarely used mock objects](http://practicingruby.com/articles/49)
    \r\nin my tests, but I didn't clearly understand why that was the case. When asked
    to explain my \r\npreferences, I typically would offer some vague argument about
    keeping things\r\nsimple, and then go on to complain about test brittleness. Because
    I knew many\r\nother people who shared the same view, I assumed my line of reasoning
    was \r\nmostly coherent. This left me with no desire to dig any deeper than what
    my own \r\nexperiences had taught me.\r\n\r\nAfter years of somewhat blissful
    ignorance, I finally started to second guess\r\nmyself after watching Greg Moeck's
    excellent talk at RubyConf 2011, which was\r\naptly named [Why You Don't Get Mock
    Objects](http://www.confreaks.com/videos/659-rubyconf2011-why-you-don-t-get-mock-objects).
    \r\nThis talk pointed out that the reason why most Rubyists tend to dislike mock\r\nobjects
    is because they try to shoehorn them into existing workflows rather \r\nthan adopting
    the form of TDD that mocks are meant to promote. I remember being\r\neasily convinced
    by this talk when I first watched it, but because old habits\r\ndie hard, I never
    ended up changing my way of doing things.\r\n\r\nThroughout the entire 90 day
    period of my study, I found myself [using mock\r\nobjects only\r\nonce](https://github.com/elm-city-craftworks/broken_record/blob/5c9287e0c6d8211c4a91aee43b26181dfbcc1992/test/record_test.rb),
    \r\neven though I had thought about using them in many places. Towards the end,
    I realized that I\r\nstill didn't quite understand how mocks were meant to be
    used, and so I\r\ndecided to study them properly. This inevitably lead me to the
    excellent [Mock\r\nRoles, Not Objects](http://www.jmock.org/oopsla2004.pdf) paper,
    which was written in \r\n2004 by the developers who had pioneered the concept
    of mock-based testing. In\r\naddition to being a solid introduction to the topic
    in general, the paper lays\r\nout a number of practical guidelines for avoiding
    the common problems that can\r\narise from using mocks incorrectly. In particular,
    the authors proposed the\r\nfollowing rules:\r\n\r\n* Only mock types you own.\r\n*
    Don't use getters.\r\n* Be explicit about what should not happen.\r\n* Specify
    as little as possible in a test.\r\n* Don't use mocks to test boundary objects.\r\n*
    Don't add behavior to mocks.\r\n* Only mock your immediate neighbors.\r\n* Don't
    create too many mocks.\r\n* Inject all dependencies.\r\n\r\nBy programming in
    this style, the promise is that the benefits of mock objects\r\nwill be maximized
    and their drawbacks minimized. The interesting thing is that\r\nwhile several
    of these heuristics are meant to improve the testability of code,\r\nnearly as
    many have a direct influence on software design in general. Taken\r\ntogether,
    the following four points strongly favor [responsibility-centric\r\ndesign](http://practicingruby.com/articles/64):\r\n\r\n*
    Don't use getters.\r\n* Only mock your immediate neighbors.\r\n* Don't create
    too many mocks.\r\n* Inject all dependencies.\r\n\r\nThese guidelines will almost
    certainly lead to code that is more testable, \r\nand should also lead to code
    that is easier to change. If you think about\r\nthese heuristics a little bit,
    you'll find they conveniently map onto\r\nthe following software design principles:\r\n\r\n*
    [Tell, don't ask](http://robots.thoughtbot.com/post/27572137956/tell-dont-ask)\r\n*
    [The law of Demeter](http://en.wikipedia.org/wiki/Law_of_Demeter)\r\n* [Single
    responsibility](http://en.wikipedia.org/wiki/Single_responsibility_principle)\r\n*
    [Dependency inversion](http://en.wikipedia.org/wiki/Dependency_inversion_principle)\r\n\r\nTesting
    a codebase via mock objects is easy when these design principles are\r\nfollowed,
    and challenging when they are not. In that sense, mock objects can be\r\nused
    as a smoke test for the overall design of a project, which is useful in its\r\nown
    right. However, most mockists claim that the technique actually inspires \r\nbetter
    design, rather than simply helping you find areas in your code that\r\nsuffer
    from bad design. This is a much broader statement, and isn't nearly as\r\nobvious
    to those who have not had this experience themselves.\r\n\r\nBecause I used mock
    objects so infrequently during my study, I am unable to tell\r\nyou whether or
    not they can actually help improve software design. However, now\r\nthat I have
    a clearer sense of what my own workflow is like, I understand why I\r\nhave had
    so few opportunities to make good use of mock objects. It all boils\r\ndown to
    the fact that I don't practice disciplined outside-in design.\r\n\r\nThe way I
    tend to approach design is to choose a very small vertical slice of\r\nfunctionality
    and develop an imaginary example of how I expect that feature to\r\nwork. This
    technique is consistent with the outside-in way of doing things, \r\nbut my next
    steps bring me in a completely different direction. Rather than\r\nstarting with
    my interface and then using mock objects to allow me to discover\r\ncollaborators
    iteratively until I reach the lowest-level objects in my system, \r\nI build things
    bottom up instead.\r\n\r\nTaking a look back at the projects I worked on during
    this study, I was able to\r\nsee this trend in action. For example, in BrokenRecord,
    my first test\r\nwas for a struct-like object that would be used for storing field\r\ndata:\r\n\r\n```ruby\r\ndescribe
    BrokenRecord::Row do\r\n  it \"must create readers for all attributes\" do\r\n
    \   row = BrokenRecord::Row.new(:a => 1, :b => 2)\r\n\r\n    row.a.must_equal(1)\r\n
    \   row.b.must_equal(2)\r\n  end\r\nend\r\n```\r\n\r\nSimilarly, when I was working
    on the Blind game, my first test was for a `Map` object\r\nthat allowed you to
    place named objects at specific coordinates:\r\n\r\n```ruby\r\ndescribe Blind::Map
    do\r\n  it \"must be able to store elements at a position\" do\r\n    map = Blind::Map.new\r\n
    \   map.add_object(\"player\", 10, 25)\r\n\r\n    pos = map.locate(\"player\")\r\n
    \   [pos.x, pos.y].must_equal([10,25])\r\n  end\r\nend\r\n```\r\n\r\nEven though
    each of these objects were designed with a single external feature\r\nin mind,
    they are clearly boundary objects; concrete implementation code with \r\nno collaborators
    within the system. As I built on top of them, I found no\r\nneed for mocks, because
    using these objects directly was easy enough to do. The\r\nbenefit of building
    things this way is that you can think in terms of concrete\r\nobjects at all times,
    but that is also the drawback: you can't use mock objects\r\nto discover the protocols
    of your collaborators if those details have already\r\nbeen locked down. I don't
    know enough about mock-based TDD to know\r\nwhether this is a trade worth making,
    but this does explain to me why I've\r\nfailed to experience some of its benefits.\r\n\r\nAfter
    I realized that I haven't been working in a way that would support the\r\neffective
    use of mock objects, I took an interest in figuring out what kind of\r\nworkflow
    mockists tend to follow. Digging back to one of my [favorite articles on\r\nmock
    objects](http://martinfowler.com/articles/mocksArentStubs.html), I found that
    \r\nthis is what Martin Fowler had to say:\r\n\r\n> Mock objects came out of the
    XP community, and one of the principal features of XP is its emphasis on Test
    Driven Development - where a system design is evolved through iteration driven
    by writing tests.\r\n\r\n> Thus it's no surprise that the mockists particularly
    talk about the effect of mockist testing on a design. In particular they advocate
    a style called need-driven development. With this style you begin developing a
    story by writing your first test for the outside of your system, making some interface
    object your SUT. By thinking through the expectations upon the collaborators,
    you explore the interaction between the SUT and its neighbors - effectively designing
    the outbound interface of the SUT.\r\n\r\n> Once you have your first test running,
    the expectations on the mocks provide a specification for the next step and a
    starting point for the tests. You turn each expectation into a test on a collaborator
    and repeat the process working your way into the system one SUT at a time. This
    style is also referred to as outside-in, which is a very descriptive name for
    it. It works well with layered systems. You first start by programming the UI
    using mock layers underneath. Then you write tests for the lower layer, gradually
    stepping through the system one layer at a time. This is a very structured and
    controlled approach, one that many people believe is helpful to guide newcomers
    to OO and TDD.\r\n\r\nBased on what I learned about mock objects, this style of
    development does\r\nappear to be a natural way of developing responsibility-centric
    code that abides\r\nby all the guidelines laid out in the [Mock Roles, Not\r\nObjects](http://www.jmock.org/oopsla2004.pdf)
    paper. While it sounds intriguing\r\nto me and worth trying out, I doubt that
    I am smart enough to apply this\r\nstyle of development effectively. The reason
    I tend to use a divide-and-conquer, \r\nthink-in-concrete-objects strategy in
    my projects is that I don't have much\r\nfaith in my own abilities to understand
    the current and future relations \r\nbetween my objects. In other words, the disciplined
    outside-in approach seems \r\nto require more design confidence than what I typically
    am able to muster up. \r\n\r\nTo make matters worse, I have not yet come across
    an example that clearly shows how this\r\ntechnique can be applied throughout
    an entire project. I think that in addition\r\nto my own experimentation, I'll
    need to see something like that for these ideas\r\nto finally click. If you know
    of a source of good large-scale examples of these\r\ntechniques, please let me
    know!\r\n\r\nTo sum up the overall point of this lesson: mock objects facilitate\r\na
    particular design style, and if you're not using that approach in\r\nyour projects,
    you probably will not experience their benefits. I'd love to hear\r\nyour thoughts
    on that conclusion, whether or not you agree with it; I clearly\r\nhave a lot
    more to learn in this area.\r\n"
- :slug: spiking-is-not-cowboy-coding
  :title: Spiking is not cowboy coding
  :summary: Search for the boundary lines between organized chaos and wild, unstructured
    hacking.
  :published: 2012-07-26 00:00:00.000000000 Z
  :issue_number: 4.12.4
  :volume: 4
  :body: "> **NOTE:** This is one of [four lessons\r\n> learned](http://practicingruby.com/articles/65)
    from my 90 day [self-study on\r\n> test-driven development](http://practicingruby.com/articles/28).
    \r\n> If this topic interests you, be sure to check out the other lessons!\r\n\r\nWhen
    used in moderation, experimental spikes can be a very powerful tool for\r\nshining
    some light into the dark corners of your projects. However, there is\r\na natural
    tension between chaotic spiking and formal TDD practices \r\nthat needs to be
    balanced if you want to use the two techniques \r\nside by side. Equalizing these
    forces can be very challenging, and\r\nit is something that I have struggled with
    throughout my career.\r\n\r\nBecause I started programming as a self-taught hobbyist,
    I spent many years\r\nwriting code without a well defined process. As I started
    to work\r\non larger and more important projects, I learned how to program in
    a\r\nmore disciplined way. I developed an interest in object-oriented design \r\nand
    also picked up the basics of test-driven development. These methodologies\r\nhelped
    me work in a more controlled fashion when I needed to, but they did not do \r\nmuch
    to change my everyday coding habits. I still relied on lots of messy\r\nexperimentation;
    I just knew how to clean up my code so that I didn't\r\nend up shipping sloppy
    work in the end.\r\n\r\nWhile I have managed to be very productive over the years,
    my day to day \r\nefficiency has been very unpredictable because of the way that
    I do things. This\r\nis something I have been aware of for some time, and was
    one of the \r\nmain problems that I wanted to take a closer look at during \r\nthis
    study. With that in mind, I will now walk you through three \r\nexamples of where
    I broke away from TDD to try out some experiments and\r\nthen share my thoughts
    on what worked and what didn't work.\r\n\r\n### Exploring the unknown\r\n\r\nI
    knew when I started working on [Blind](https://github.com/elm-city-craftworks/blind)
    \r\nthat I would need to learn how to do two\r\nthings with the [Ray](http://mon-ouie.github.com/projects/ray.html)
    game engine\r\nthat I hadn't done before: work with positional \r\naudio, and
    write tests against the UI layer. I knew that these things were\r\nsupported by
    Ray because the documentation had examples for them, but I needed\r\nto convince
    myself that they would work in practice by building a small proof of\r\nconcept.\r\n\r\nRather
    than trying to build realistic examples that matched how I would end up\r\nusing
    these features, I instead focused on their most basic prerequisites. For\r\nexample,
    I knew that I'd never be able to have dynamically positioned sound \r\nemitters
    in a three-dimensional space if I couldn't play a simple beeping \r\nsound without
    any positioning at all. I also saw from the documentation that\r\nin order to
    write tests against Ray it was necessary to use its class-based API\r\nrather
    than using its fancy DSL. Combining those two ideas together lead me to\r\nbuild
    the following (almost trivial) spike solution:\r\n\r\n```ruby\r\nrequire \"ray\"\r\n\r\nclass
    MainScene < Ray::Scene\r\n  scene_name :main\r\n\r\n  def setup\r\n    @sound
    = sound(\"beep.wav\")\r\n  end\r\n\r\n  def register\r\n    always do\r\n      @sound.play\r\n
    \     sleep @sound.duration\r\n    end\r\n  end\r\n\r\n  def render(win)\r\n  end\r\nend\r\n\r\nclass
    Game < Ray::Game\r\n  def initialize\r\n    super \"Awesome Game\"\r\n\r\n    MainScene.bind(self)\r\n\r\n
    \   scenes << :main\r\n  end\r\nend\r\n\r\nGame.new.run\r\n```\r\n\r\nWhile this
    code was little more than the end result of mixing a\r\ncouple examples from Ray's
    documentation together, it helped me verify \r\nthat there weren't any problems
    playing sounds on my system, and that\r\nthe documentation I was reading was up
    to date.\r\n\r\nCoincidentally, this tiny script helped me notice that my wife's\r\nlaptop
    was missing the core audio dependencies that Ray needed; \r\nwhich is a perfect
    example of what this kind of spike is made to test. It also\r\ngave me an opportunity
    to answer some questions that the documentation\r\ndidn't make clear to me. For
    example, removing the `sleep` call made me realize\r\nthat playing a sound was
    a non-blocking operation, and deleting the `render`\r\nmethod made me realize
    that it only needed to be provided if it was doing\r\nsomething useful. In a fairly
    complex and immature project like Ray, this\r\nkind of trial-and-error based investigation
    is often a faster way to \r\nfind answers than digging through source code.\r\n\r\nI
    was actually very happy with the outcomes from this spike, and the effort I\r\nput
    into it was minimal compared to what I got out of it. While I can't say\r\nthe
    same for the other experiments I am about to show you, this little script\r\nserves
    as a nice example of spiking done right.\r\n\r\n### Trying out a new design\r\n\r\nMid-way
    through working on Blind, I decided to completely change the way I\r\nwas modeling
    things. All elements in the game were originally modeled as \r\nrectangles, but
    as I tweaked the game rules, I started to realize that all I\r\nreally cared about
    was point-to-point distance between the player and various\r\nlocations in the
    world. The hoops I was having to jump through to work with\r\nrectangular game
    elements eventually got annoying enough that I decided to try\r\nout my new ideas
    on an experimental branch.\r\n\r\nI started working on this redesign from the
    bottom up, test-driving a couple\r\nsupporting objects that I knew I'd need, including
    a very boring `Point` class.\r\nDespite the smooth start, it eventually became
    clear to me that this approach \r\nwould only take me so far: the original `Game`
    class was tightly \r\ncoupled to a particular representation of Blind's world.
    To make matters \r\nworse, the UI code I had written was a messy prototype \r\nthat
    I hadn't cleaned up or tested properly yet. These issues \r\nleft me stuck between
    a rock and a hard place.\r\n\r\nI had already sunk a lot of time into building
    the new object model, but didn't\r\nwant to keep investing in it without being
    reasonably sure that it was the right\r\nway to go. To build up my confidence,
    I decided to do a quick spike to transform\r\nthe old UI into something that could
    work on top of the new object model.\r\n\r\nWithin an hour or two, I had a working
    game running on top of the new codebase. \r\nI made several minor changes and
    added a couple new features\r\nto various objects in the process of doing so,
    without writing any tests for\r\nthem. I originally assumed that I didn't need
    to write tests because I expected\r\nto throw all this code away, but after wrapping
    up my experiment I decided that\r\nthe code was good enough to merge could be
    easily cleaned up later. This decision\r\neventually came back to haunt me.\r\n\r\nOver
    the next several days, I ran into small bugs in various edge case\r\nscenarios
    in the code that had been implemented during the spike. For example,\r\nthe randomized
    positioning of mines and exit locations had not been rewritten to\r\naccount for
    the fact that the game no longer defined regions as rectangles, and\r\nthat would
    occasionally cause them to spawn in the wrong regions. The following\r\npatch
    was required to fix that problem:\r\n\r\n```diff\r\n       @current_position =
    Blind::Point.new(0,0)\r\n \r\n       @mine_positions   = mine_count.times.map
    do\r\n-        Blind::Point.new(rand(MINE_FIELD_RANGE), rand(MINE_FIELD_RANGE))\r\n+
    \       random_minefield_position\r\n       end\r\n \r\n-      @exit_position
    = \r\n-        Blind::Point.new(rand(MINE_FIELD_RANGE), rand(MINE_FIELD_RANGE))\r\n+
    \     @exit_position = random_minefield_position\r\n     end\r\n \r\n     attr_reader
    :current_position, :mine_positions, :exit_position\r\n@@ -42,5 +41,15 @@ def current_region\r\n
    \        :outer_rim\r\n       end\r\n     end\r\n+\r\n+    private\r\n+    \r\n+
    \   def random_minefield_position\r\n+      begin \r\n+        point = Blind::Point.new(rand(MINE_FIELD_RANGE),
    rand(MINE_FIELD_RANGE))\r\n+      end until MINE_FIELD_RANGE.include?(@center.distance(point))\r\n+\r\n+
    \     point\r\n+    end\r\n   end\r\n end\r\n```\r\n\r\nSimilarly, whenever I
    wanted to refactor some code to introduce a change or\r\nextend functionality
    in some way, I needed to write tests to fill the coverage gaps \r\nthat were introduced
    during my experiment. This lead to a temporary but\r\nsharp rise in the cost of
    change, and that caused my morale to plummet.\r\n\r\nLooking back on what happened,
    I think the problem was not that I created an\r\nexperimental branch with some
    untested code on it, but that I decided to keep\r\nthat code rather than throwing
    it out and starting fresh. Wiring up my new data\r\nmodel to the UI and seeing
    a playable game come out of it was a huge confidence\r\nbooster, and it only cost
    me a couple hours to get to that point. But because I\r\ndecided to merge that
    code into master, I inherited several more hours of\r\nunpredictable maintenance
    work that might have been avoided if I had redone the\r\nwork in a more disciplined
    way.\r\n\r\n### Sketching out an idea\r\n\r\nAbout mid-way through my study, I
    had an idea for a project that I knew I\r\nwouldn't have time for right away:
    an abstract interface for describing vector\r\ndrawings. However, because I couldn't
    stop thinking about the problem, I decided\r\nI needed to make a simple prototype
    to satisfy my curiosity. An entire evening\r\nof hacking got me to the point where
    I was able to generate the following image\r\nin PDF format using [Prawn](https://github.com/prawnpdf/prawn):\r\n\r\n![](http://i.imgur.com/OW5gT.png)\r\n\r\nThe
    basic idea of my abstract interface was that rather than making direct calls\r\nto
    Prawn's APIs, you could instead describe your diagrams in a general way, such\r\nas
    in the following example:\r\n\r\n```ruby\r\ndrawing = Vellum::Drawing.new(300,400)\r\n\r\ndrawing.layer(:box)
    do |g|\r\n  g.rect(g.top_left, g.width, g.height)\r\nend\r\n\r\ndrawing.layer(:x)
    do |g|\r\n  g.line(g.top_left,  g.bottom_right)\r\n   .line(g.top_right, g.bottom_left)\r\nend\r\n\r\ndrawing.layer(:cross)
    do |g|\r\n  g.line([g.width / 2, 0], [g.width / 2, g.height])\r\n   .line([0,
    g.height / 2], [g.width, g.height/2])\r\nend\r\n\r\ndrawing.style(:x,     :stroke_color
    => \"ff0000\") \r\n\r\ndrawing.style(:box,   :line_width   => 2, \r\n                      :fill_color
    \  => \"ffffcc\")\r\n\r\ndrawing.style(:cross, :stroke_color => \"00ff00\")\r\n```\r\n\r\nA
    `Vellum::Renderer` object would then be used to turn this abstract\r\nrepresentation
    into output in a particular format, using some simple \r\ncallbacks. A Prawn-based
    implementation is shown below:\r\n\r\n```ruby\r\nrequire \"prawn\"\r\n\r\npdf
    \     = Prawn::Document.new\r\nrenderer = Vellum::Renderer.new\r\n\r\nrenderer.on(Object)
    do |shape, style|\r\n  pdf.stroke_color = style.fetch(:stroke_color, \"000000\")\r\n
    \ pdf.fill_color   = style.fetch(:fill_color, \"ffffff\")\r\n  pdf.line_width
    \  = style.fetch(:line_width, 1)\r\nend\r\n\r\nrenderer.on(Vellum::Line) do |shape,
    style|\r\n  pdf.stroke_line(shape.p1, shape.p2)\r\nend\r\n\r\nrenderer.on(Vellum::Rectangle)
    do |shape, style|\r\n  pdf.fill_and_stroke_rectangle(shape.point, shape.width,
    shape.height)\r\nend\r\n\r\nrenderer.render(drawing)\r\n\r\npdf.render_file(\"foo.pdf\")\r\n```\r\n\r\nLooking
    back on this code, I'm still excited by the basic idea, because it\r\nwould make
    it possible for backend-agnostic graphics code to be written, and\r\nwould allow
    for more than a few interesting manipulations of the abstract\r\nstructures prior
    to rendering. However, I can't help but think that for a\r\nthrowaway prototype,
    there is far too much detail here.\r\n\r\nIf you take a closer look at [how I
    actually implemented Vellum](https://gist.github.com/2732815), \r\nyou'll find
    that I shoved together \r\nseveral classes into a single file, which I stowed
    away on a gist. I never\r\nbothered to record the history of my experiment, which
    I assume was actually\r\nbuilt up incrementally rather than designed all at once.
    Without a single test\r\nto guide me, I would need to study the implementation
    code all over again if I\r\nwanted to begin to understand what I had actually
    learned from my experiment.\r\n\r\nWhile it is hard to say whether this little
    prototype was worth the effort or\r\nnot, it underscores a bad habit of mine that
    bites me from time to time: I can\r\neasily get excited about an idea and then
    dive into it with reckless abandon. In\r\nthis particular situation, I ended up
    with some working code at the end of\r\nmy wild hacking session, but there were
    several other ideas I worked on during\r\nmy study that I ended up getting nowhere
    with.\r\n\r\n### What makes spiking different from cowboy coding?\r\n\r\nThe main
    thing I learned from taking a look at how I work on experimental ideas\r\nis that
    there is a big difference between spiking and cowboy coding.\r\n\r\nWhen you are
    truly working on a spike, you have a specific question in mind that \r\nyou want
    to answer, you know roughly how much you're willing to invest in \r\nfinding out
    that answer, and you cut as many corners as possible to get that\r\nanswer as
    quickly as possible. The success of a spike is measured by what you\r\nlearn,
    not what code you produce. Once you feel that you understand what\r\nneeds to
    be done, you pull yourself out of spike mode and return to your \r\nmore disciplined
    way of doing things.\r\n\r\nCowboy coding, on the other hand, is primarily driven
    by gut feelings, past\r\nexperiences, and on-the-spot decision making. This kind
    of programming can be\r\nfun because it allows you to write code quickly without
    thinking deeply about\r\nits consequences, but in most circumstances, you end
    up needing to pay for your\r\nlack of discipline somewhere down the line.\r\n\r\nOf
    the three examples I discussed in this article, the first one looks and feels\r\nlike
    a true spike, and the third one is the result of straight-up guns-blazing\r\ncowboy
    coding. The second example lies somewhere between those two extremes, and\r\nperhaps
    represents a spike that turned into a cowboy coding session. I think\r\nscenarios
    like that are what we really need to look out for, because it is\r\nvery easy
    to drop our good practices but much harder to return to them.\r\n\r\nNow that
    I've laid this all out on the line for you, I'd love to hear some\r\nof your own
    stories! Please leave a comment if you have an interesting\r\nexperience to share,
    or if you have any questions for me.\r\n\r\n> **NOTE:** While doing some research
    for this article, I stumbled across a nice excerpt\r\nfrom \"The Art of Agile
    Development\" which describes [how to safely make use\r\nof spike solutions](http://jamesshore.com/Agile-Book/spike_solutions.html).
    It's\r\ndefinitely worth checking out if you're interested in studying this topic
    more.\r\n"
- :slug: intro-to-basic-statistical-methods
  :title: A practical application of basic statistical methods
  :summary: Crunch some numbers to see how Olympic medal wins relate to GDP and population.
    (w. Jia Wu)
  :published: 2012-08-07 00:00:00.000000000 Z
  :issue_number: '5.1'
  :volume: 5
  :body: "> This issue was a collaboration with my wife, Jia Wu. Jia is an associate\r\n>
    scientist at the Yale Child Study Center, where she spends a good portion of\r\n>
    her time analyzing brainwave data from various EEG experiments. Although\r\n>
    this article focuses on very basic concepts, her background in \r\n> statistical
    programming was very helpful whenever I got stuck on \r\n> something. That said,
    if you find any mistakes in this article, you\r\n> can blame me, not her.\r\n\r\nStatistics
    and programming go hand in hand, but the kinds of problems we tend to\r\nwork
    on in Ruby make it easy to overlook this point. If your work does not \r\ninvolve
    a lot of data analysis, you may not feel much pain even if you have a very \r\nlimited
    math background. However, as our world becomes increasingly data-driven, \r\na
    working knowledge of statistics can really come in handy.\r\n\r\nIn this article,
    I will walk you through a simple example of how you can use \r\ntwo very basic
    statistical methods (correlation + significance testing) to \r\nexplore your own
    questions about the patterns you notice in the world. \r\nAlthough we won't dig
    too deeply into underlying math involved in these\r\nconcepts, I will try to provide
    you with enough background information to \r\nstart trying out your own experiments
    even if you have never formally \r\nstudied statistics before.\r\n\r\nThe example
    that I'll share with you explores the connection between\r\nthe economic strength
    and population of nations and their performance in \r\nrecent Olympic games. In
    order to interpret the (rudimentary) analysis I did, \r\nyou'll need to understand
    what a correlation coefficient is, and what it means \r\nfor a result to be statistically
    significant. If you are familiar with those \r\nconcepts, feel free to skim or
    skip the next two sections. Otherwise, just read \r\non, and I'll do my best to
    fill you in on what you need to know.\r\n\r\n### Measuring the strength of relationships
    between datasets\r\n\r\nPut simply, correlation measures the dependency relationship
    between two\r\ndatasets. When two datasets are fully dependent on each other,
    there\r\nexists a pattern which can be used to predict the elements in either
    set\r\nbased on the elements in the other. When datasets are completely independent
    \r\nfrom one another, it is impossible to come up with a mapping between \r\nthem
    that describes their relationship any better than a completely \r\nrandomized
    mapping would. Virtually all real world datasets that are not \r\ngenerated from
    purely mathematical models fall somewhere between these \r\ntwo extremes, and
    that means that in practice correlation needs to be \r\ntreated as continuum rather
    than a boolean property. This relative dependency\r\nrelationship between datasets
    is typically represented by a correlation coefficient.\r\n\r\nCorrelation coefficients
    can be computed in a number of ways, but the most\r\ncommon and straightforward
    way of doing so is by establishing a trend line\r\nand then calculating how closely
    the data fits that line on average. \r\nThis measure is called the [Pearson correlation
    coefficient](http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient),
    \r\nand is denoted by the variable `r`.\r\n\r\nWhen two datasets are perfectly
    linearly correlated, the mapping\r\nbetween them is perfectly described by a straight
    line. However, when no \r\ncorrelation exists, there will be no meaningful linear
    pattern to the data at all. An\r\nexample of both extremes is shown below; the
    graph on the left describes perfect\r\ncorrelation, and the graph on the right
    describes (almost) no correlation:\r\n\r\n![](http://i.imgur.com/G1laY.png)\r\n\r\nNotice
    that in the graph on the left, each and every point is perfectly\r\npredicted
    by the line, but in the graph on the right, there is little to\r\nseparate the
    trend line shown from any other arbitrary line you could draw\r\nthrough the data.
    If we compute the correlation coefficient for these\r\ntwo examples, the left
    diagram has `r=1`, and the\r\nright diagram is very close to `r=0`.\r\n\r\nReal
    world data tends to be noisy, and so in practice you only find datasets\r\nwith
    correlation coefficients of 0.0 or 1.0 in deterministic mathematical\r\nmodels.
    With that in mind, the following example shows a messy but strongly \r\ncorrelated
    dataset, with a coefficient of `r=0.767`:\r\n\r\n![](http://i.imgur.com/TauIx.png)\r\n\r\nYou
    can see from this graph that while the trend line does not directly\r\npredict
    where the points will fall in the scatter plot, it reflects the\r\npattern exhibited
    by the data, and most of the\r\npoints within the image fall within a short distance
    of that line. Taken\r\ntogether with its relatively high correlation coefficient,
    this picture\r\nshows a fairly strong relationship between the two datasets.\r\n\r\nIf
    you are struggling with mapping the concept of correlation\r\ncoefficients to
    real world relations, it may help to consider the \r\nfollowing examples (from
    the book [Thinking, Fast and\r\nSlow](http://en.wikipedia.org/wiki/Thinking,_Fast_and_Slow)):\r\n\r\n*
    The correlation between the size of objects measured in English units\r\nor metric
    units is 1. \r\n\r\n* The correlation between SAT scores and college GPA is close
    to 0.60.\r\n\r\n* The correlation between income and education level in the United
    States is\r\nclose to 0.40.\r\n\r\n* The correlation between family income and
    the last four digits of their\r\nphone number is 0.\r\n\r\nWe'll talk more about
    what correlation does and does not measure in a little\r\nwhile, but for now we
    can move on to discuss what separates genuine \r\npatterns from coincidences.
    \r\n\r\n### Establishing a confidence factor for your results \r\n\r\nBecause
    correlation only establishes the relationships between samples in\r\nan individual
    experiment, it is important to sanity check your findings\r\nto see how likely
    it will be that they will hold in future trials. When \r\ncombined with other
    considerations, statistical significance testing \r\ncan be a useful way of verifying
    that what you have observed is more than \r\npure happenstance.\r\n\r\nMethods
    for testing statistical significance can vary depending on the\r\nrelationships
    you are trying to verify, but they ultimately boil down to being a\r\nway of computing
    the probability that you would have achieved the same results\r\nby chance. This
    is done by assuming a default position called a null\r\nhypothesis, and then examining
    the likelihood that the same results would be\r\nobserved if that effect held
    true.\r\n\r\nIn the context of correlation testing, the null hypothesis is that
    your two\r\ndatasets are completely independent from one another. Assuming independence\r\nallows
    you to compute the probability that the effect you observed in \r\nyour real data
    could be reproduced by chance. The result of this computation \r\nis called a
    p-value, and is denoted by the variable `p`.  \r\n\r\nWhether or not a p-value
    implies statistical significance depends on the context\r\nof what is being studied.
    For example, in behavioral sciences, a significance \r\ntest that yields a value
    of `p=0.05` is typically considered to be a solid \r\nresult. The data from behavioral
    experiments is extremely noisy and hard to\r\nisolate, and that makes it reasonable
    from a practical standpoint to accept a\r\n1 in 20 chance that the same correlation
    could have been observed in \r\ncompletely independent datasets. However, in more
    stable environments, a much\r\nhigher standard is imposed. For particle physics
    discoveries (such as that of\r\nthe [Higgs Boson](http://en.wikipedia.org/wiki/Higgs_boson)),
    a significance \r\nof 5-sigma is expected, which is approximately `p = 0.0000003`.
    These kinds of \r\ndiscoveries have less than 1 in 3.5 million chance of being
    reproduced by \r\nhappenstance, which is an extremely robust result.\r\n\r\nThe
    important thing to note about statistical significance is that it can\r\nneither
    imply the likelihood that an observed result was a fluke, nor can it be\r\nused
    to verify the validity of an observed pattern. While significance testing\r\nhas
    value as a loose metric for establishing confidence in the plausibility of a\r\nresult,
    it is [frequently misunderstood](http://en.wikipedia.org/wiki/P_value#Misunderstandings)
    \r\nto mean much more than that. This point is important to keep in mind as you\r\nconduct
    your own experiments or read about what others have studied,\r\nbecause cargo
    cult science is every bit as dangerous as cargo cult programming.\r\n\r\n### Exploring
    statistical concepts in practice\r\n\r\nNow that we've caught up with all the
    background knowledge, we can finally dig\r\ninto a practical example of how to
    make use of these ideas. I will start by \r\nshowing you the results of my experiment,
    and then discuss how I went about \r\nimplementing it. \r\n\r\n[The full report
    is a four page\r\nPDF](https://github.com/elm-city-craftworks/olympics/blob/master/olympic_report.pdf?raw=true),
    \r\ncovering the 1996, 2000, 2004, and 2008 Summer Olympic games. The following
    \r\nscreenshot shows the Beijing 2008 page, which includes \r\na pair of scatterplots
    and their associated `r` and `p` values. For this \r\ndataset, I analyzed 152
    teams, excluding all those that were missing either\r\nGDP or population information
    in my raw data:\r\n\r\n![](http://i.imgur.com/c25L6.png)\r\n\r\nWhat this report
    shows is that there is a strong correlation between a nation's\r\nGDP and its
    Olympic medal wins (`r ~= 0.832`), and a moderate correlation between \r\npopulation
    and medal wins (`r ~= 0.494`). While there is some variation in these \r\neffects
    over the years, the general conclusion remains the same for all four \r\nof the
    Olympic games I analyzed, as shown below:\r\n\r\n![](http://i.imgur.com/Rw1Y4.png)\r\n\r\nWhile
    it would be possible with some effort to do this kind of data analysis in\r\npure
    Ruby, I chose to make use of [RSRuby](https://github.com/alexgutteridge/rsruby)\r\nto
    interface with the R language instead. R is a fantastic language for \r\nstatistics
    applications, and so it makes sense to use it when you are doing \r\nthis kind
    of work.\r\n\r\nBecause my needs were extremely simple, I did not need to write
    much glue code\r\nto get what I needed from R. In fact, the complete implementation
    of my \r\n`Olympics::Analysis` singleton object ended up being just a couple paragraphs\r\nof
    code, as shown below:\r\n\r\n```ruby\r\nmodule Olympics\r\n  class << (Analysis
    = Object.new)\r\n    attr_accessor :r\r\n\r\n    def correlation(params)\r\n      r.assign(\"x\",
    x=params.fetch(:x))\r\n      r.assign(\"y\", y=params.fetch(:y))\r\n\r\n      data
    = r.eval_R %{ cor.test(x, y) }\r\n\r\n      { :n => x.size, :r => data[\"estimate\"][\"cor\"],
    :p => data[\"p.value\"] }\r\n    end\r\n\r\n    def plot(params)\r\n      [:file,
    :x, :y, :x_label, :y_label].each do |key|\r\n        r.assign(key.to_s, params.fetch(key))\r\n
    \     end\r\n\r\n      r.eval_R %{\r\n        jpeg(filename=file, width=400, height=400)\r\n
    \       plot(x=x, y=y, xlab=x_label, ylab=y_label)\r\n        abline(lm(y ~ x),
    col=\"red\")\r\n        dev.off()\r\n      }\r\n\r\n      nil\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIn
    the `Olympics::Analysis#correlation` method, I make a call to \r\nR's [cor.test](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.test.html)\r\nfunction
    via an RSRuby object, and it returns a nested \r\nhash containing way more information
    that what I could possibly \r\nneed for the purposes of this report. With that
    in mind, I grab\r\nthe two values I need from that structure and return a hash
    with\r\nthe values of the `n`, `r`, and `p` variables.\r\n\r\nIn the `Olympics::Analysis#plot`
    method, I call a few R functions to \r\ngenerate a scatter-plot with a line of
    best fit in JPEG format. The\r\nway that R handles graphing is a bit weird, but
    it \r\nis extremely powerful. The thing I found particularly interesting as \r\nsomeone
    new to R is that its [linear modeling functions](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html)
    \r\nuse a formulaic syntax to define custom models for plotting trend \r\nlines.
    For our purposes, the simple `y ~ x` relationship works \r\nfine, but complicated
    fit lines can also be described using this \r\nsyntax. As a special-purpose language,
    this is perhaps not surprising, \r\nbut I found it fascinating from a design perspective.\r\n\r\nThe
    rest of the code involved in generating these reports is just a hodgepodge\r\nof
    miscellaneous data munging, using the CSV standard library to read data in as\r\na
    table, and access it by column. For example, I'm able to get all of the\r\ncountry
    names by executing the following code:\r\n\r\n```ruby\r\n>> table = CSV.table(\"data/1996_combined.csv\",
    :headers => true)\r\n>> table[:noc]\r\n=> [\"Afghanistan\", \"Albania\", ...,
    \"Zambia\", \"Zimbabwe\"]\r\n```\r\n\r\nThe CSV standard library really makes
    this kind of work easy, and its `Table`\r\nobject even automatically converts
    numeric columns into their appropriate \r\nRuby objects by default:\r\n\r\n```ruby\r\n>>
    table[:all_medals].reduce(:+)\r\n=> 837\r\n```\r\n\r\nI won't go into much of
    the details about the reporting code used to \r\ngenerate the PDF, because it
    isn't especially related to the main topic of this \r\narticle. However, it is
    worth pointing out that in order to make the data\r\nI got back from `Olympic::Analysis.correlation`
    display friendly, I needed to \r\ndo some extra transformations on it:\r\n\r\n```ruby\r\nmodule
    Olympics\r\n  class Report\r\n    # ...\r\n\r\n    private\r\n\r\n    def correlation_summary(x,
    y)\r\n      stats = Analysis.correlation(:x => x, :y => y)\r\n      n = \"n =
    #{stats[:n]}\"\r\n      r = \"r ~= #{'%.3f' % stats[:r]}\"\r\n      \r\n      if
    stats[:p] < 0.001\r\n        p = 'p < 0.001'\r\n      else\r\n        p = \"p
    ~= #{'%.3f' % stats[:p]}\"\r\n      end\r\n\r\n      [n,r,p].join(\", \")\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nThe formatting of the `n` and `r` values
    are very straightforward, and so it\r\nshould be clear what is going on there.
    However, to display `p` in a way that\r\nis consistent with statistical reporting,
    I need to check to see if its value\r\nis lower than the threshold I've chosen,
    and display `p < 0.001` rather\r\nthan `p ~= 0.000`. This requires just a little
    bit of extra effort, but it makes\r\nthe report a whole lot nicer looking.\r\n\r\nI
    had originally planned to show all of these values out to float precision, but\r\nit
    turns out that R's `cor.test` function returns `p=0` for any value of `p`\r\nthat
    is smaller than hardware float epsilon. This is a bit of an awkward\r\nbehavior,
    and so I was happy to sidestep it by displaying an inequality \r\ninstead. For
    what it's worth, the inner math geek in me cringes at the \r\nidea of displaying
    arbitrarily small values in the neighborhood of zero \r\nas if they were actually
    zeroes.\r\n\r\nWhile it isn't especially important for understanding the main
    concepts in this\r\narticle, if you feel like you want to know how this report
    works, \r\nyou can start with the [olympic_report.rb](https://github.com/elm-city-craftworks/olympics/blob/master/olympic_report.rb)
    \r\nscript and then trace the path of execution from there through to the actual\r\nPDF
    generation. If you have questions about its implementation, feel free\r\nto leave
    me a comment.\r\n\r\nSo far, I have provided you with some very basic background
    information on a\r\ncouple of statistical methods, and demonstrated how to make
    use of them in\r\npractice. However, what I haven't spent much time talking about
    is all the\r\nthings that can go wrong when you do this kind of analysis. Let's
    take a bit\r\nof time now to discuss that before we wrap things up.\r\n\r\n###
    Maintaining a healthy level of skepticism\r\n\r\nIn the process of researching
    this article, I learned that even statisticians\r\ncan be a bit trollish from
    time to time. If you don't believe me, take a look at\r\n[Anscombe's Quartet](http://en.wikipedia.org/wiki/Anscombe%27s_quartet):\r\n\r\n![](http://i.imgur.com/0QV6V.png)\r\n\r\nAll
    four of these figures have an identical trend line, and an identical\r\ncorrelation
    (`r = 0.816`), as well as several other properties in common.\r\nHowever, visual
    inspection reveals that they are clearly displaying wildly\r\ndifferent patterns
    from one another. The point of this diagram is obvious: \r\nsimple statistics
    on their own are no substitute for actually\r\nlooking at what the data is telling
    you.\r\n\r\nWith this idea in mind, it is important to take a close look at the
    patterns you see\r\nin your data, and look for outliers and groups of points that
    may be skewing\r\nresults. If excluding those values keeps the effect that you
    observed intact,\r\nyou can feel a bit more confident in the strength of your
    evidence. However, if\r\nyour effect disappears, that means you may need to do
    some thinking about why\r\nthat is the case, and possibly come up with some new
    questions to ask.\r\n\r\nLooking back at my report, it is easy to spot a few things\r\nthat
    could influence its results:\r\n\r\n![](http://i.imgur.com/AJdUf.png)\r\n\r\nTo
    see how what effect these factors were having on my results, I re-ran the\r\ncorrelation
    and significance calculations on a number of variations of the\r\noriginal Beijing
    2008 dataset:\r\n\r\n![](http://i.imgur.com/lvVrX.png)\r\n\r\nAll of the variations
    left the strong correlation between GDP and medal wins\r\nintact, although some
    changes did make some major impacts on the `r` value. This\r\ntells me that at
    least for the issues we identified, the trend is fairly\r\nrobust.\r\n\r\nThe
    relationship between population and medal wins is less\r\nstable, and simply excluding
    the US and China data points pushes it to the point\r\nof not having much of a
    correlation at all. When removing all the major\r\nidentified influencing factors,
    the moderate correlation is preserved, \r\nbut we end up with `p=0.002`. While
    it seems reasonable to accept 1 in\r\n500 odds on a dataset that is bound to be
    influenced by any number of external\r\nfactors, this result does still stand
    out when you note that most of our other\r\np-values were infinitesimal.\r\n\r\nEven
    if we accept that this investigation seems to support the notion of a\r\nstrong
    link between GDP and Olympic medal wins, and a somewhat dubious but plausible\r\nrelationship
    between population and Olympic medal wins, we still need to think\r\nof all of
    the things that could of gone wrong before we even reached the point\r\nof conducting
    our analysis. Without knowing that our source data is reliable, we\r\ncan't trust
    the results of our analysis.\r\n\r\nThe data I used for this report is cobbled
    together from CSVs I found via\r\nweb search, scraped data from Wikipedia, and
    copy and pasted data from\r\nWikipedia. To assemble the combined CSV documents
    that these reports run\r\nagainst, I wrote a bunch of small throwaway scripts
    and wasn't particularly\r\ncareful about avoiding data loss or corruption in the
    process. So in the end,\r\nthere is a very real possibility that the effect I
    found means nothing at all.\r\n\r\nThe lesson to take away from this point about
    data integrity is that fitness for\r\npurpose should always be on your mind. If
    you are throwing together a couple\r\ngraphs to get a rough picture of a phenomenon
    to see if there is anything\r\ninteresting worth saying about it, then you probably
    don't need to worry about\r\nhunting down perfectly clean data and processing
    it flawlessly. However, if you\r\nare tasked with building a statistical report
    which is actually meant to\r\ninfluence people in some way, or to inform a decision
    making process, you need\r\nto double and triple check that you're not feeding
    garbage data into your\r\nanalysis process. In other words, statistics can only
    be as reliable as the\r\nraw facts you use to generate them.\r\n\r\nIf we suppose
    that the raw data for this report was accurate in the first place, \r\nwas not
    corrupted in the process of analyzing it, and that the results we \r\ngenerated
    are significant and trustworthy, we still must accept that \r\n[correlation does
    not imply\r\ncausation](http://en.wikipedia.org/wiki/Correlation_is_not_causation).\r\nNonetheless,
    knowing what patterns exist out there in the world can be very\r\nhelpful to us
    as we contemplate *why* things are the way they are, and that\r\nmakes these very
    simple statistical methods useful in their own right.\r\n\r\n### Reflections\r\n\r\nWhile
    I hope that this article has some direct practical value for you, now that\r\nI
    have written it I feel that it is just as useful as an exercise in developing\r\na
    more rigorous and skeptical way of thinking about the work that we do. \r\n\r\nOn
    the one hand, statistics offers us the promise that we can make sense of the myriad\r\ndata
    streams that make up our lives. On the other hand, statistical thinking\r\nrequires
    us to be precise, diligent, and realistic about what we can expect to \r\nunderstand
    about the world. These kinds of mental states overlap nicely with\r\nwhat helps
    us become better at programming, and I think that is what made\r\nwriting this
    article so interesting to me. I hope you enjoyed it too!\r\n"
- :slug: temporal-coupling-and-the-law-of-demeter
  :title: Temporal coupling and the Law of Demeter
  :summary: See how NASA JPL's take on the Law of Demeter simplifies building robust
    asynchronous code.
  :published: 2012-08-19 00:00:00.000000000 Z
  :issue_number: '5.2'
  :volume: 5
  :body: "The [Law of Demeter](http://www.ccs.neu.edu/home/lieber/LoD.html) is a well-known
    \r\nsoftware design principle for reducing coupling between collaborating objects.
    \r\nHowever, because the law exists in many forms, it often means different things
    \r\nto different people. As far as laws go, Demeter has been flexible in practice,
    \r\nwhich has lead to some interesting evolutions in its application over time.
    \r\nIn this article, I will discuss an interpretation of the law that is quite
    \r\nliterally out of this world.\r\n\r\n### An introduction to Smyth's Law of
    Demeter\r\n\r\n[David Smyth](http://mars.jpl.nasa.gov/zipcodemars/bio-contribution.cfm?bid=1018&cid=393&pid=377&country_id=0),
    \r\na scientist who worked on various Mars missions for NASA's Jet \r\nPropulsion
    Laboratory, came up with this seemingly innocuous definition\r\nof the Law of
    Demeter:\r\n\r\n> A method can act only upon the message arguments and the state
    of the receiving object.\r\n\r\nOn the surface, this formulation is essentially
    [the object form of the Law\r\nof Demeter](http://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/object-formulation.html)\r\nstated
    in much less formal terms. However, Smyth's law is different in the way in which\r\nhe
    interprets it: he assumes that the Law of Demeter implies that \r\nmethods should
    not have return values. This small twist causes \r\nthe law to have a much deeper
    effect than its originators had \r\nanticipated. \r\n\r\nBefore we discuss the
    implications of building systems entirely out of methods\r\nwithout return values,
    it is important to understand why Smyth assumed\r\nthat value-returning methods
    were forbidden in the first place. To explore\r\nthat point, consider the following
    trivial example:\r\n\r\n```ruby\r\nclass Person < ActiveRecord::Base\r\n  def
    self.in_postal_area(zipcode)\r\n    where(:zipcode => zipcode)  \r\n  end\r\nend\r\n```\r\n\r\nThe
    `Person.in_postal_area` method does not violate the \r\nLaw of Demeter itself,
    as it is nothing more than a simple delegation\r\nmechanism that passes the `zipcode`
    parameter to a \r\nlower-level function on the same object. But because it\r\nreturns
    a value, this function makes it easy for its callers\r\nto violate the Law of
    Demeter, as shown here:\r\n\r\n```ruby\r\nclass UnsolicitedMailer < ActionMailer::Base\r\n
    \ def spam_postal_area(zipcode)\r\n    people = Person.in_postal_area(zipcode)\r\n\r\n
    \   emails = people.map { |e| e.email }\r\n\r\n    mail(:to => emails, :subject
    => \"Offer for you!\")\r\n  end\r\nend\r\n```\r\n\r\nBecause the value returned
    by `Person.in_postal_area` is neither \r\na direct part of the `UnsolicitedMailer`
    object nor a parameter\r\nof the `spam_postal_area` method, sending messages\r\nto
    it results in a Demeter violation. Depending on the project's \r\nrequirements,
    breaking the law in this fashion could be \r\nreasonable, but it is a code smell
    to watch out for.\r\n\r\nIn the context of the typical Ruby project, methods that
    \r\nreturn values are common because the convenience of implementing\r\nthings
    this way often outweighs the cost of doing so. However,\r\nwhenever you take this
    approach, you make two fundamental \r\nassumptions that those who write code for
    Mars rovers \r\ncannot: that your value-returning methods will respond\r\nin a
    reasonable amount of time, and that they will not fail \r\nin all sorts of complicated
    ways.\r\n\r\nAlthough these basic assumptions often apply to the bulk of what
    we do,\r\neven those of us who aren't rocket scientists occasionally\r\nneed to
    work on projects for which temporal coupling is considered\r\nharmful and robust
    failure handling is essential. In such\r\nscenarios, it is worth considering what
    Smyth's interpretation\r\nof the Law of Demeter (LoD) has to offer.\r\n\r\n###
    The implications of Smyth's Law of Demeter\r\n\r\nSmyth's unique interpretation
    of how to apply LoD eventually \r\ncaught the eye of Karl Lieberherr, a member
    of the\r\nDemeter project who published some of the earliest papers\r\non the
    topic. Lieberherr took an interest in Smyth's approach \r\nbecause it was clearly
    different than what the Demeter \r\nresearchers had intendedyet potentially useful.
    \r\nA correspondence between the two led Smyth to share his \r\nthoughts about
    what his definition of LoD brings to \r\nthe table. His six key points from the
    [original discussion](http://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/Smyth/LoD-revisited2)
    \r\nare listed in an abridged form here:\r\n\r\n```\r\nThere are actually several
    wonderful properties that fall out \r\nfrom this definition of LoD:\r\n\r\n     A
    method can act only upon the message arguments and the\r\n     existing state
    of the receiving object.\r\n\r\n1. Method bodies tend to be very close to straight-line
    code. Very\r\n   simple logic, very low complexity.\r\n\r\n2. There must be no
    return values; if there are, the sender of the message\r\n   is not obeying the
    law.\r\n\r\n3. There cannot be tight synchronization, as the sender cannot tell
    whether\r\n   the message is acted on or not within any \"small\" period of time\r\n
    \  (perhaps the objects collaborate with a two-way protocol and the\r\n   sender
    can eventually detect a timeout).\r\n\r\n4. Because there are no return values,
    the objects need to be\r\n   \"responsible\" objects: they need to handle both
    nominal and\r\n   foreseeable off-nominal cases. This requirement has the wonderful
    effect of\r\n   localizing failure handling within the object that has the\r\n
    \  best visibility and understanding of whatever went wrong.\r\n   It also dramatically
    reduces the complexity of protocols and\r\n   clients.\r\n\r\n   ...\r\n\r\n5.
    The law requires an object to subscribe to information so that it has\r\n   what
    it needs whenever it gets a message. Thus lazy\r\n   evaluation can't be used.
    Although this requirement may seem like an \r\n   inefficiency, it becomes one
    in practice only if the objects don't have \r\n   concise responsibilities. In
    such a case, efficiency of communication\r\n   bandwidth isn't the real problem.\r\n\r\n
    \  ...\r\n\r\n6. Because tight synchronization is out of the picture, the responsible\r\n
    \  objects should be goal oriented. A goal is different from a method\r\n   in
    that a goal is pursued over some expanse of time and does not\r\n   seem instantaneous.
    By thinking of goals rather than discrete\r\n   actions, people can derive solutions
    that don't require tight\r\n   temporal coupling. This sounds like hand waving,
    and it isbut\r\n   seven years of doing it shows that it really does work.\r\n```\r\n\r\nThese
    are deep claims, but the remainder of the discussion between Smyth\r\nand Lieberherr
    did not elaborate much further on them. However, it is \r\nfascinating to imagine
    the kind of programming style that Smyth\r\nis advocating here: it boils down
    to a highly robust form of\r\n[responsibility-driven development](http://practicingruby.com/articles/64)
    with \r\nconcurrent (and potentially distributed) objects that communicate almost
    \r\nexclusively via callback mechanisms. If Smyth were not an established\r\nscientist
    working on some of the world's most challenging problems,\r\nit would almost seem
    as if he were playing object-oriented buzzword bingo.\r\n\r\nAlthough I don't
    know nearly enough about any of these ideas to speak \r\nauthoritatively on them,
    I think that they form a great starting point \r\nfor a very interesting conversation.
    However, if you're like me, you\r\nwould benefit from having these ideas brought
    back down to earth\r\na bit. With that in mind, I've put together a little example
    \r\nprogram that will hopefully help you do exactly that.\r\n\r\n### Smyth's Law
    of Demeter in practice\r\n\r\nSoftware design principles can be interesting to
    study in the abstract, but\r\nthere is no substitute for trying them out in concrete
    applications. If you \r\ncan find a project that is a natural fit for the technique
    you are \r\ntrying to investigate, even the most simple toy application will teach
    you\r\nmore than pure thought experiments ever could.\r\n\r\nSmyth's approach
    to the Law of Demeter originated from his work on software for\r\nMars rovers,
    an environment where tight temporal coupling and a lack of \r\nrobust interactions
    between distributed systems can cause serious problems.\r\nBecause it takes about
    14 minutes for light to travel between Earth and Mars, \r\neven the most trivial
    system interactions require careful design consideration. \r\nWith so much room
    for things to go wrong, a programming style that claims to \r\nmake it easier
    to manage these kinds of problems definitely sounds promising.\r\n\r\nOf course,
    you don't need to land robots on Mars to encounter these kind of\r\nchallenges.
    I can easily imagine things such as payment processing systems \r\nand remote
    system administration toolchains having a good\r\ndegree of overlap with the issues
    that Smyth's LoD is meant to\r\naddress. Still, those problems are not nearly
    as exciting as driving a\r\nremote control car around on a different planet. Knowing
    that, I decided\r\nto test Smyth's ideas by building a very unrealistic Mars rover
    \r\nsimulation. The video below shows me interacting with it over IRC:\r\n\r\n<div
    align=\"center\">\r\n<iframe width=\"800\" height=\"600\"\r\nsrc=\"//www.youtube.com/embed/Yqofx6MbYFU?vq=480&rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n</div>\r\n\r\nIn the video, the
    communications delay is set at only a couple of seconds, but it\r\ncan be set
    arbitrarily high, which makes it possible to simulate the full 14-\r\nminute-plus
    delay between Earth and Mars. No matter what the delay is set at, the\r\nrover
    queues up commands as they come in and sends its responses one \r\nat a time as
    its tasks are completed. The entire simulator is only a couple of\r\npages of
    code. It consists of the following objects and responsibilities:\r\n\r\n* [SpaceExplorer::Radio](https://github.com/elm-city-craftworks/space_explorer/blob/pr-5.2/lib/space_explorer/radio.rb)
    relays messages on a time delay.\r\n* [SpaceExplorer::MissionControl](https://github.com/elm-city-craftworks/space_explorer/blob/pr-5.2/lib/space_explorer/mission_control.rb)
    communicates with the rover.\r\n* [SpaceExplorer::Rover](https://github.com/elm-city-craftworks/space_explorer/blob/pr-5.2/lib/space_explorer/rover.rb)
    communicates with mission control and updates the map.\r\n* [SpaceExplorer::World](https://github.com/elm-city-craftworks/space_explorer/blob/pr-5.2/lib/space_explorer/world.rb)
    implements the simulated world map.\r\n\r\nAs I implemented this system, I took
    care to abide by Smyth's recommendation\r\nthat methods not return meaningful
    values. Although I wasn't so pedantic as\r\nto explicitly return `nil` from each
    function, I treated them as void functions\r\ninternally, so none of the simulator's
    features depend on the return value \r\nof the methods I implemented. To see the
    effect this approach had on\r\noverall system design, we can trace a command's
    execution from end to end while\r\npaying attention to what is going on under
    the hood.\r\n\r\nI'd like to walk you through how `SNAPSHOT` works, simply because
    it has the\r\nlargest number of moving parts to it. As you saw in the video, \r\n`SNAPSHOT`
    is used to get back a 5x5 ASCII \"picture\" of the area around the \r\nrover,
    which can be used to aid navigation. In the following example, \r\n`@` is the
    rover, `-` represents empty spaces, and `X` represents boulders:\r\n\r\n```\r\n20:35|
    \ seacreature| !SNAPSHOT\r\n20:35|  roboseacreature| X - - X -\r\n20:35|  roboseacreature|
    X X - X X\r\n20:35|  roboseacreature| - X @ X X\r\n20:35|  roboseacreature| -
    - X X -\r\n20:35|  roboseacreature| - - - - -\r\n```\r\n\r\nAs you may have already
    guessed, the user interface for this project is\r\nIRC-based, which is a convenient
    (if ugly) medium for experimenting with\r\nasynchronous communications. A bot
    that is responsible for running\r\nthe simulation monitors the channel for commands,
    which can be any\r\nmessage that starts with an exclamation point. When these
    messages are\r\ndetected, they are passed on a `MissionControl` object for processing.
    The\r\ncallback that monitors the channel and passes messages along to that \r\nobject
    is shown here:\r\n\r\n```ruby\r\nbot.on(:message, /\\A!(.*)/) do |m, command|\r\n
    \ mission_control.send_command(command)\r\nend\r\n```\r\n\r\nThe `MissionControl`
    object is nothing more than a bridge between the UI \r\nand a `Radio` object,
    so the `send_command` method passes the \r\ncommand along without modification:\r\n\r\n```ruby\r\nmodule
    SpaceExplorer\r\n  class MissionControl\r\n    def send_command(command)\r\n      @radio_link.transmit(command)\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nThe `Radio` instance that `@radio_link`
    points to holds a\r\nreference to a `Rover` object, which is where the `SNAPSHOT`
    command will be\r\nprocessed. Before it gets there, `Radio#transmit` enforces
    a\r\ntransmission delay through the use of a very coarse-grained timer mechanism:\r\n\r\n```ruby\r\nmodule
    SpaceExplorer\r\n  class Radio\r\n    def transmit(command)\r\n      raise \"Target
    not defined\" unless defined?(@target)\r\n\r\n      Thread.new do\r\n        start_time
    = Time.now\r\n\r\n        sleep 1 while Time.now - start_time < @delay\r\n\r\n
    \       @target.receive_command(command) \r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIt's
    important to point out here that `Radio#transmit` is designed to work with\r\nan
    arbitrary delay, so it isn't practical for it to block execution and\r\nreturn
    a value. Instead, it spins off a background thread that will eventually\r\ncall
    the `receive_command` callback method on its `@target` object, which in this case
    is a\r\n`Rover` instance.\r\n\r\nThe implementation of the `Rover` object is more
    interesting than the\r\nobjects we've looked at so far because it implements the\r\n[Actor
    model](http://en.wikipedia.org/wiki/Actor_model). \r\nWhenever `Rover#receive_command`
    is called, commands are not\r\nprocessed directly but are instead placed on a
    threadsafe queue that then gets\r\nacted upon in a first-come, first-serve basis.
    This approach allows the `Rover` to do \r\nits tasks sequentially while continuing
    to accept requests as they come in. To\r\nunderstand how that works, think about
    how `SNAPSHOT` gets handled by the \r\nfollowing code:\r\n\r\n```ruby\r\nrequire
    \"thread\"\r\n\r\nmodule SpaceExplorer\r\n  class Rover\r\n    def initialize(world,
    radio_link)\r\n      @world      = world\r\n      @radio_link = radio_link\r\n\r\n
    \     @queue = Queue.new\r\n\r\n      Thread.new { loop { process_command(@queue.pop)
    } }\r\n    end\r\n\r\n    def receive_command(command)\r\n      @queue.push(command)\r\n
    \   end\r\n\r\n    def process_command(command)\r\n      case command\r\n      when
    \"PING\"\r\n        @radio_link.transmit(\"PONG\")\r\n      when \"NORTH\", \"SOUTH\",
    \"EAST\", \"WEST\"      \r\n        @world.move(command)\r\n      when \"SNAPSHOT\"\r\n
    \       @world.snapshot { |text| @radio_link.transmit(\"\\n#{text}\") }\r\n      else\r\n
    \       # do nothing\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhen
    the `receive_command` callback is triggered by the `Radio` object,\r\nthe method
    pushes that command onto a queue, which should happen nearly\r\ninstantaneously
    in practice. At this point, the command has finished its\r\noutbound trip and
    is ready to be processed.\r\n\r\nAfter the `Rover` object handles any tasks that
    were already queued up,\r\n`SNAPSHOT` is passed to the `process_command` method,
    where the \r\nfollowing line gets executed:\r\n\r\n```ruby\r\n@world.snapshot
    { |text| @radio_link.transmit(\"\\n#{text}\") }\r\n```\r\n\r\nThis code looks
    a little weird because it isn't immediately obvious why a block\r\nis being used
    here. Instead, we might expect the following code under \r\nordinary circumstances:\r\n\r\n```ruby\r\n@radio_link.transmit(\"\\n#{@world.snapshot}\")
    \r\n```\r\n\r\nHowever, taking this approach would be a subtle violation of Smyth's
    LoD,\r\nbecause it would require `World#snapshot` to have a meaningful return
    value,\r\nintroducing additional coupling. In this case, the coupling is\r\ntemporal
    rather than structural, which makes it harder to spot.\r\n\r\nThe main difference
    between the two examples is that the latter has a strong\r\nconnascence of timing
    and the former does not. In the value-returning example,\r\nif `@world.snapshot`
    were not simply generating a trivial ASCII diagram but\r\nactually controlling
    hardware on a Mars rover to take an image, we might expect\r\nit to take some
    amount of time to respond. If it were a large enough amount of\r\ntime, it wouldn't
    be practical to block while waiting for a response, so the\r\ncall to `RadioLink#transmit`
    would need to be backgrounded. This would also be\r\ntrue for any caller that
    made use of `World#snapshot`.\r\n\r\nBy using a code block (which is really just
    a lightweight, anonymous callback\r\nmechanism), we can push the responsibility
    of whether to run the\r\ncomputations in a background thread into the `World`
    object, making that\r\ndecision completely invisible to its callers. As an added
    bonus, `World` can\r\nalso be more responsible about failure handling as well,
    because it decides \r\nif and when to execute the callback and how to handle unexpected
    situations.\r\n\r\nIn practical scenarios, the advantages and disadvantages of
    whether \r\nviolate Smyth's law would need to be weighed out, but in this case
    I've\r\nintentionally tried to apply it first and then attempt to justify it.
    For this\r\nparticular example, I can see the approach as being worthwhile even
    if it \r\nmakes for slightly more ugly code.\r\n\r\nOf course, no attempt at purity
    is ultimately successful, and if you take a look\r\nat `World#snapshot`, you will
    see that this is where I finally throw Smyth's LoD\r\nout the window for the sake
    of practicality. Feel free to focus on the structure\r\nof the code rather than
    the algorithm used to process the map, as that is what \r\nmatters most in this
    article:\r\n\r\n```ruby\r\nmodule SpaceExplorer\r\n  class World\r\n    DELTAS
    = (-2..2).to_a.product((-2..2).to_a)\r\n\r\n    # ...\r\n\r\n    def snapshot\r\n
    \     snapshot = DELTAS.map do |rowD, colD|\r\n        if colD == 0 && rowD ==
    0\r\n          \"@\"\r\n        else\r\n          @data[@row + rowD][@col + colD]\r\n
    \       end\r\n      end\r\n\r\n      text = snapshot.each_slice(5).map { |e|
    e.join(\" \") }.join(\"\\n\")\r\n\r\n      yield text\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAmong
    other things, we see here the familiar chain of `Enumerable` methods \r\nslammed
    together, all of which return values that are not immediate parts of\r\nthe `World`
    object:\r\n\r\n```ruby\r\ntext = snapshot.each_slice(5).map { |e| e.join(\" \")
    }.join(\"\\n\")\r\n```\r\n\r\nAlthough I could probably have written some cumbersome
    adapters to make this\r\ncode conform to Smyth's LoD, I think that would be a
    wasteful attempt to follow\r\nthe letter of the law rather than its spirit. This
    is especially true when you\r\nconsider that Smyth and many other early adopters
    of the classical Law of\r\nDemeter were working in languages that had a clear
    separation between objects\r\nand data structures, so they would not necessarily
    have considered core\r\nstructures to be \"objects\" in the proper sense. In Ruby,
    our core structures are\r\nfull-blown objects, but that does not mean they need
    to follow the same rules \r\nas our domain objects.\r\n\r\nI would love it if
    you'd share a comment with your own thoughts about \r\nthe philosophical divide
    between data structures and domain objects, and\r\nalso encourage you to read
    [this post from Bob Martin](https://sites.google.com/site/unclebobconsultingllc/active-record-vs-objects)
    \r\non the topic, but I won't dwell on the point for now. We still have\r\nwork
    to do!\r\n\r\nWith the output in hand, all that remains to be done is to ferry
    it back to the\r\nIRC channel that requested it. Looking back at the relevant
    portion of `Rover#process_command`, \r\nyou can see that the yielded text from
    `World#snapshot` is passed on to \r\nanother `Radio` object:\r\n\r\n```ruby\r\n@world.snapshot
    { |text| @radio_link.transmit(\"\\n#{text}\") }\r\n```\r\n\r\nThis `Radio` object
    holds a reference to the `MissionControl` object that sent\r\nthe original `SNAPSHOT`
    command, and the path back to it is identical to the\r\npath the command took
    to get to the `Rover` object, just in reverse. I won't\r\nexplain that process
    again in detail, as all that really matters is that\r\n`MissionControl#receive_command`
    eventually gets run. This method is just as\r\nboring as the `send_command` method
    we looked at earlier, serving as a direct\r\nbridge to the UI. I've used a Cinch-based
    IRC bot in this example, but anything\r\nwith a `msg()` method will do:\r\n\r\n```ruby\r\nmodule
    SpaceExplorer\r\n  class MissionControl\r\n    # ...\r\n\r\n    def receive_command(command)\r\n
    \     @narrator.msg(command)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAt this
    point, a message is sent to the IRC channel and the out-and-back trip is\r\ncompleted.
    Despite being a fairly complicated feature, Smyth's LoD was mostly\r\nfollowed
    throughout, and things got weird in only a few places. That said,\r\nif you have
    a devious mind, you are likely to have already realized that the\r\nrelative simplicity
    of this code is deceptive, because there are\r\nso many places things can go wrong.
    Let's talk a little more about \r\nthat now.\r\n\r\n### GROUP PROJECT: Exploring
    our options for failure handling\r\n\r\nSmyth's Law of Demeter promises three
    main consequences: less complex method\r\ndefinitions, a decrease in temporal
    coupling, and a robust way of handling\r\nfailures. Although the example I've
    been using provides some evidence for the\r\nfirst two claims, I intentionally
    avoided working on error handling to leave\r\nsomething for us to think through
    together.\r\n\r\nYour challenge, if you choose to accept it, is to think about
    what can go wrong\r\nin this simulation and to come up with ways to handle those
    problems without\r\nviolating Smyth's LoD. Off the top of my head, I can think
    of several trivial\r\nproblems that exist in this code, but I'm sure there are
    many other things that I\r\nhaven't considered.\r\n\r\nIf you want to start with
    some low-hanging fruit, think about what happens when\r\nan invalid command is
    sent, or what happens when the rover moves off the edge of\r\nthe fixed-size map
    it is currently using. If you want to get fancy, think about\r\nwhether the rover
    ought to have some safety mechanism that will prevent it from\r\ndriving into
    boulders, which it is currently perfectly happy to do. Or, if you\r\nwant to get
    creative, find your own way of breaking things, and feel free to ask\r\nme clarifying
    questions as you go.\r\n\r\nAny level of participation is welcome, ranging from
    asking a \"What if?\"\r\nquestion after reading through the code a bit to grand-scale
    patches that make\r\nour clunky little rover bulletproof. As I said at the beginning
    of this\r\narticle, my purpose in introducing Smyth's LoD to you was to start
    a\r\nconversation, and I think this is a fun way to do exactly that.\r\n\r\nThe
    [full source for the simulator](https://github.com/elm-city-craftworks/space_explorer)
    \r\nis ready for you to tinker with, so go forth and break stuff!\r\n\r\n### Reflections\r\n\r\nAlthough
    I am fairly happy with how the simulator experiment turned out, it is \r\nhard
    to draw very many conclusions from it. In very small greenfield \r\nprojects,
    it is hard  to see how any design principle will ultimately \r\ninfluence the
    full software development lifecycle. That having been said,\r\nit did serve as
    a great testbed for exploring these ideas and can be a \r\nstepping stone toward
    trying these techniques in more practical settings.\r\n\r\nI tend to think of
    software principles as being descriptive rather than\r\nprescriptive; they provide
    us with convenient labels for particular approaches\r\nto problems that already
    exist in the wild. If you've seen or worked on some\r\ncode that reminds you of
    the ideas that Smyth's Law of Demeter attempts to\r\ncapture, I'd love to hear
    about it.\r\n\r\nI'd also love to hear about whatever doubts have been nagging
    you as\r\nyou worked your way through this article. Every software design strategy
    has its\r\nstrengths and weaknesses, and sometimes we make the mistake of emphasizing
    the\r\ngood parts while downplaying the bad parts, especially when we study new
    things.\r\nWith that in mind, your curmudgeonly comments are most welcome, as
    they tend to \r\nbring some balance along with them.\r\n\r\n> **NOTE:** I owe
    a huge hat-tip to [David\r\n> Black](http://twitter.com/david_a_black), as he
    was the inspiration for\r\nthis article. He and I were collaborating on a more
    traditional\r\ntreatment of the Law of Demeter; we each found our own divergent
    ideas to\r\ninvestigate, but I definitely would not have written this article
    if he hadn't\r\nshared his thoughtful explorations with me."
- :slug: event-loops-demystified
  :title: Event loops demystified
  :summary: Build a Node.js/EventMachine-style event loop in roughly 150 lines of
    Ruby code. (w. Magnus Holm)
  :published: 2012-09-04 00:00:00.000000000 Z
  :issue_number: '5.3'
  :volume: 5
  :body: "*This issue of Practicing Ruby was contributed by Magnus Holm ([@judofyr][judofyr]),
    \r\na Ruby programmer  from Norway. Magnus works on various open source \r\nprojects
    (including the [Camping][camping] web framework),\r\nand writes articles over
    at [the timeless repository][timeless].*\r\n\r\nWorking with network I/O in Ruby
    is so easy: \r\n\r\n```ruby\r\nrequire 'socket'\r\n\r\n# Start a server on port
    9234\r\nserver = TCPServer.new('0.0.0.0', 9234)\r\n\r\n# Wait for incoming connections\r\nwhile
    io = server.accept\r\n  io << \"HTTP/1.1 200 OK\\r\\n\\r\\nHello world!\"\r\n
    \ io.close\r\nend\r\n\r\n# Visit http://localhost:9234/ in your browser.\r\n```\r\n\r\nBoom,
    a server is up and running! Working in Ruby has some disadvantages, though: we\r\ncan
    handle only one connection at a time. We can also have only one *server*\r\nrunning
    at a time. There's no understatement in saying that these constraints\r\ncan be
    quite limiting. \r\n\r\nThere are several ways to improve this situation, but
    lately we've seen an\r\ninflux of event-driven solutions. [Node.js][nodejs] is
    just an event-driven I/O-library\r\nbuilt on top of JavaScript. [EventMachine][em]
    has been a solid solution in the Ruby\r\nworld for several years. Python has [Twisted][twisted],
    and Perl has so many that they even\r\nhave [an abstraction around them][anyevent].\r\n\r\nAlthough
    these solutions might seem like silver bullets, there are subtle details that\r\nyou'll
    have to think about. You can accomplish a lot by following simple rules\r\n(\"don't
    block the thread\"), but I always prefer to know precisely what I'm\r\ndealing
    with. Besides, if doing regular I/O is so simple, why does\r\nevent-driven I/O
    have to be looked at as black magic?\r\n\r\nTo show that they are nothing to be
    afraid of, we are going to implement an \r\nI/O event loop in this article. Yep,
    that's right; we'll capture the core \r\npart of EventMachine/Node.js/Twisted
    in about 150 lines of Ruby. It won't \r\nbe performant, it won't be test-driven,
    and it won't be solid, but it will \r\nuse the same concepts as in all of these
    great projects. We will start \r\nby looking at a minimal chat server example
    and then discuss \r\nhow to build the infrastructure that supports it.\r\n\r\n##
    Obligatory chat server example\r\n\r\nBecause chat servers seem to be the event-driven
    equivalent of a\r\n\"hello world\" program, we will keep with that tradition here.
    The\r\nfollowing example shows a trivial `ChatServer` object that uses\r\nthe
    `IOLoop` that we'll discuss in this article:\r\n\r\n```ruby\r\nclass ChatServer\r\n
    \ def initialize\r\n    @clients = []\r\n    @client_id = 0\r\n  end\r\n\r\n  def
    <<(server)\r\n    server.on(:accept) do |stream|\r\n      add_client(stream)\r\n
    \   end\r\n  end\r\n\r\n  def add_client(stream)\r\n    id = (@client_id += 1)\r\n
    \   send(\"User ##{id} joined\\n\")\r\n\r\n    stream.on(:data) do |chunk|\r\n
    \     send(\"User ##{id} said: #{chunk}\")\r\n    end\r\n\r\n    stream.on(:close)
    do\r\n      @clients.delete(stream)\r\n      send(\"User ##{id} left\")\r\n    end\r\n\r\n
    \   @clients << stream\r\n  end\r\n\r\n  def send(msg)\r\n    @clients.each do
    |stream|\r\n      stream << msg\r\n    end\r\n  end\r\nend\r\n\r\n# usage\r\n\r\nio
    \    = IOLoop.new\r\nserver = ChatServer.new\r\n\r\nserver << io.listen('0.0.0.0',
    1234)\r\n\r\nio.start\r\n```\r\n\r\nTo play around with this server, run [this
    script][chatserver] and then open up\r\na couple of telnet sessions to it. You
    should be able to produce something like the\r\nfollowing with a bit of experimentation:\r\n\r\n```\r\n#
    from User #1's console:\r\n$ telnet 127.0.0.1 1234\r\n\r\nUser #2 joined\r\nUser
    #2 said: Hi\r\nHi\r\nUser #1 said: Hi\r\nUser #2 said: Bye\r\nUser #2 left\r\n\r\n#
    from User #2's console (quits after saying Bye)\r\n$ telnet 127.0.0.1 1234\r\n\r\nUser
    #1 said: Hi\r\nBye\r\nUser #2 said: Bye\r\n```\r\n\r\nIf you don't have the time
    to try out this code right now,\r\ndon't worry: as long as you understand the
    basic idea behind it, you'll be fine.\r\nThis chat server is here to serve as
    a practical example to help you \r\nunderstand [the code we'll be discussing][chatserver]
    throughout this article.\r\n\r\nNow that we have a place to start from, let's
    build our event system.\r\n\r\n## Event handling\r\n\r\nFirst of all we need,
    obviously, events! With no further ado:\r\n\r\n```ruby\r\nmodule EventEmitter\r\n
    \ def _callbacks\r\n    @_callbacks ||= Hash.new { |h, k| h[k] = [] }\r\n  end\r\n\r\n
    \ def on(type, &blk)\r\n    _callbacks[type] << blk\r\n    self\r\n  end\r\n\r\n
    \ def emit(type, *args)\r\n    _callbacks[type].each do |blk|\r\n      blk.call(*args)\r\n
    \   end\r\n  end\r\nend\r\n\r\nclass HTTPServer\r\n  include EventEmitter\r\nend\r\n\r\nserver
    = HTTPServer.new\r\nserver.on(:request) do |req, res|\r\n  res.respond(200, 'Content-Type'
    => 'text/html')\r\n  res << \"Hello world!\"\r\n  res.close\r\nend\r\n\r\n# When
    a new request comes in, the server will run:\r\n#   server.emit(:request, req,
    res)\r\n\r\n```\r\n\r\n`EventEmitter` is a module that we can include in classes
    that can send and\r\nreceive events. In one sense, this is the most important
    part of our event\r\nloop: it defines how we use and reason about events in the
    system. Modifying it\r\nlater will require changes all over the place. Although
    this particular\r\nimplementation is a bit more simple than what you'd expect
    from a real \r\nlibrary, it covers the fundamental ideas that are common to all\r\nevent-based
    systems.\r\n\r\n## The IO loop\r\n\r\nNext, we need something to fire up these
    events. As you will see in\r\nthe following code, the general flow of an event
    loop is simple:\r\ndetect new events, run their associated callbacks, and then
    repeat\r\nthe whole process again.\r\n\r\n```ruby\r\nclass IOLoop\r\n  # List
    of streams that this IO loop will handle.\r\n  attr_reader :streams\r\n\r\n  def
    initialize\r\n    @streams = []\r\n  end\r\n  \r\n  # Low-level API for adding
    a stream.\r\n  def <<(stream)\r\n    @streams << stream\r\n    stream.on(:close)
    do\r\n      @streams.delete(stream)\r\n    end\r\n  end\r\n\r\n  # Some useful
    helpers:\r\n  def io(io)\r\n    stream = Stream.new(io)\r\n    self << stream\r\n
    \   stream\r\n  end\r\n\r\n  def open(file, *args)\r\n    io File.open(file, *args)\r\n
    \ end\r\n\r\n  def connect(host, port)\r\n    io TCPSocket.new(host, port)\r\n
    \ end\r\n\r\n  def listen(host, port)\r\n    server = Server.new(TCPServer.new(host,
    port))\r\n    self << server\r\n    server.on(:accept) do |stream|\r\n      self
    << stream\r\n    end\r\n    server\r\n  end\r\n\r\n  # Start the loop by calling
    #tick over and over again.\r\n  def start\r\n    @running = true\r\n    tick while
    @running\r\n  end\r\n\r\n  # Stop/pause the event loop after the current tick.\r\n
    \ def stop\r\n    @running = false\r\n  end\r\n\r\n  def tick\r\n    @streams.each
    do |stream|\r\n      stream.handle_read  if stream.readable?\r\n      stream.handle_write
    if stream.writable?\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNotice here that
    `IOLoop#start` blocks everything until `IOLoop#stop` is called.\r\nEverything
    after `IOLoop#start` will happen in callbacks, which means that the\r\ncontrol
    flow can be surprising. For example, consider the following code:\r\n\r\n```ruby\r\nl
    = IOLoop.new\r\n\r\nruby = i.connect('ruby-lang.org', 80)  # 1\r\nruby << \"GET
    / HTTP/1.0\\r\\n\\r\\n\"       # 2\r\n\r\n# Print output\r\nruby.on(:data) do
    |chunk|\r\n  puts chunk   # 3\r\nend\r\n\r\n# Stop IO loop when we're done\r\nruby.on(:close)
    do\r\n  l.stop       # 4\r\nend\r\n\r\nl.start        # 5\r\n```\r\n\r\nYou might
    think that you're writing data in step 2, but the\r\n`<<` method actually just
    stores the data in a local buffer.\r\nIt's not until the event loop has started
    (in step 5) that the data\r\nactually gets sent. The `IOLoop#start` method triggers
    `#tick` to be run in a loop, which\r\ndelegates to `Stream#handle_read` and `Stream#handle_write`.
    These methods \r\nare responsible for doing any necessary I/O operations and then
    triggering\r\nevents such as `:data` and `:close`, which you can see being used
    in steps 3 and 4. We'll take a look at how `Stream` is implemented later, but
    for now \r\nthe main thing to take away from this example is that event-driven
    code \r\ncannot be read in top-down fashion as if it were procedural code.\r\n\r\nStudying
    the implementation of `IOLoop` should also reveal why it's \r\nso terrible to
    block inside a callback. For example, take a look at this \r\ncall graph:\r\n\r\n```\r\n#
    indentation means that a method/block is called\r\n# deindentation means that
    the method/block returned\r\n\r\ntick (10 streams are readable)\r\n  stream1.handle_read\r\n
    \   stream1.emit(:data)\r\n      your callback\r\n\r\n  stream2.handle_read\r\n
    \   stream2.emit(:data)\r\n      your callback\r\n        you have a \"sleep 5\"
    inside here\r\n\r\n  stream3.handle_read\r\n    stream3.emit(:data)\r\n      your
    callback\r\n  ...\r\n```\r\n\r\nBy blocking inside the second callback, the I/O
    loop has to wait 5 seconds \r\nbefore it's able to call the rest of the callbacks.
    This wait is\r\nobviously a bad thing, and it is important\r\nto avoid such a
    situation when possible. Of course, nonblocking\r\ncallbacks are not enoughthe
    event loop also needs to make use of nonblocking\r\nI/O. Let's go over that a
    bit more now.\r\n\r\n## IO events\r\n\r\nAt the most basic level, there are only
    two events for an `IO` object:\r\n\r\n1. Readable: The `IO` is readable; data
    is waiting for us. \r\n2. Writable: The `IO` is writable; we can write data.\r\n\r\nThese
    might sound a little confusing: how can a client know that the server\r\nwill
    send us data? It can't. Readable doesn't mean \"the server will send us\r\ndata\";
    it means \"the server has already sent us data.\" In that case, the data\r\nis
    handled by the kernel in your OS. Whenever you read from an `IO` object, you're\r\nactually
    just copying bytes from the kernel. If the receiver does not read \r\nfrom `IO`,
    the kernel's buffer will become full and the sender's `IO` will \r\nno longer
    be writable. The sender will then have to wait until the \r\nreceiver can catch
    up and free up the kernel's buffer. This situation is\r\nwhat makes nonblocking
    `IO` operations tricky to work with.\r\n\r\nBecause these low-level operations
    can be tedious to handle manually, the \r\ngoal of an I/O loop is to trigger some
    more usable events for application\r\nprogrammers:\r\n\r\n1. Data: A chunk of
    data was sent to us.\r\n2. Close: The IO was closed.\r\n3. Drain: We've sent all
    buffered outgoing data.\r\n4. Accept: A new connection was opened (only for servers).\r\n\r\nAll
    of this functionality can be built on top of Ruby's `IO` objects with\r\na bit
    of effort.\r\n\r\n## Working with the Ruby IO object\r\n\r\nThere are various
    ways to read from an `IO` object in Ruby:\r\n\r\n```ruby\r\ndata = io.read\r\ndata
    = io.read(12)\r\ndata = io.readpartial(12)\r\ndata = io.read_nonblock(12)\r\n```\r\n\r\n*
    `io.read` reads until the `IO` is closed (e.g., end of file, server closes the\r\nconnection,
    etc.) \r\n\r\n* `io.read(12)` reads until it has received exactly 12 bytes.\r\n\r\n*
    `io.readpartial(12)` waits until the `IO` becomes readable, then it reads *at\r\nmost*
    12 bytes. So if a server sends only 6 bytes, `readpartial` will return\r\nthose
    6 bytes. If you had used `read(12)`, it would wait until 6 more bytes were\r\nsent.\r\n\r\n*
    `io.read_nonblock(12)` will read at most 12 bytes if the IO is readable. It\r\nraises
    `IO::WaitReadable` if the `IO` is not readable.\r\n\r\nFor writing, there are
    two methods:\r\n\r\n```ruby\r\nlength = io.write(str)\r\nlength = io.write_nonblock(str)\r\n```\r\n\r\n*
    `io.write` writes the whole string to the `IO`, waiting until the `IO` becomes\r\nwritable
    if necessary. It returns the number of bytes written (which should\r\nalways be
    equal to the number of bytes in the original string).\r\n\r\n* `io.write_nonblock`
    writes as many bytes as possible until the `IO` becomes\r\nnonwritable, returning
    the number of bytes written. It raises `IO::WaitWritable`\r\nif the `IO` is not
    writable.\r\n\r\nThe challenge when both reading and writing in a nonblocking
    fashion is knowing \r\nwhen it is possible to do so and when it is necessary to
    wait.\r\n\r\n## Getting real with IO.select\r\n\r\nWe need some mechanism for
    knowing when we can read or write to our\r\nstreams, but I'm not going to implement
    `Stream#readable?` or `#writable?`. It's \r\na terrible solution to loop over
    every stream object in Ruby and check whether it's\r\nreadable/writable over and
    over again. This is really just not a job for Ruby;\r\nit's too far away from
    the kernel.\r\n\r\nLuckily, the kernel exposes ways to efficiently detect readable
    and writable\r\nI/O streams. The simplest cross-platform method is called select(2)
    \r\nand is available in Ruby as `IO.select`:\r\n\r\n```\r\nIO.select(read_array
    [, write_array [, error_array [, timeout]]])\r\n\r\nCalls select(2) system call.
    It monitors supplied arrays of IO objects and waits\r\nuntil one or more IO objects
    are ready for reading, ready for writing, or have\r\nerrors. It returns an array
    of those IO objects that need attention. It returns \r\nnil if the optional timeout
    (in seconds) was supplied and has elapsed.\r\n```\r\n\r\nWith this knowledge,
    we can write a much better `#tick` method:\r\n\r\n```ruby\r\nclass IOLoop\r\n
    \ def tick\r\n    r, w = IO.select(@streams, @streams)\r\n    r.each do |stream|\r\n
    \     stream.handle_read\r\n    end\r\n  \r\n    w.each do |stream|\r\n      stream.handle_write\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\n`IO.select` will block until some of our
    streams become readable or writable\r\nand then return those streams. From there,
    it is up to those streams to do \r\nthe actual data processing work.\r\n\r\n##
    Handling streaming input and output \r\n\r\nNow that we've used the `Stream` object
    in various examples, you may \r\nalready have an idea of what its responsibilities
    are. But let's first take a look at how it is implemented:\r\n\r\n```ruby\r\nclass
    Stream\r\n  # We want to bind/emit events.\r\n  include EventEmitter\r\n\r\n  def
    initialize(io)\r\n    @io = io\r\n    # Store outgoing data in this String.\r\n
    \   @writebuffer = \"\"\r\n  end\r\n\r\n  # This tells IO.select what IO to use.\r\n
    \ def to_io; @io end\r\n\r\n  def <<(chunk)\r\n    # Append to buffer; #handle_write
    is doing the actual writing.\r\n    @writebuffer << chunk\r\n  end\r\n  \r\n  def
    handle_read\r\n    chunk = @io.read_nonblock(4096)\r\n    emit(:data, chunk)\r\n
    \ rescue IO::WaitReadable\r\n    # Oops, turned out the IO wasn't actually readable.\r\n
    \ rescue EOFError, Errno::ECONNRESET\r\n    # IO was closed\r\n    emit(:close)\r\n
    \ end\r\n  \r\n  def handle_write\r\n    return if @writebuffer.empty?\r\n    length
    = @io.write_nonblock(@writebuffer)\r\n    # Remove the data that was successfully
    written.\r\n    @writebuffer.slice!(0, length)\r\n    # Emit \"drain\" event if
    there's nothing more to write.\r\n    emit(:drain) if @writebuffer.empty?\r\n
    \ rescue IO::WaitWritable\r\n  rescue EOFError, Errno::ECONNRESET\r\n    emit(:close)\r\n
    \ end\r\nend\r\n```\r\n\r\n`Stream` is nothing more than a wrapper around a Ruby
    `IO` object that\r\nabstracts away all the low-level details of reading and writing
    that were\r\ndiscussed throughout this article. The `Server` object we make use
    of \r\nin `IOLoop#listen` is implemented in a similar fashion but is focused\r\non
    accepting incoming connections instead:\r\n\r\n```ruby\r\nclass Server\r\n  include
    EventEmitter\r\n\r\n  def initialize(io)\r\n    @io = io\r\n  end\r\n\r\n  def
    to_io; @io end\r\n  \r\n  def handle_read\r\n    sock = @io.accept_nonblock\r\n
    \   emit(:accept, Stream.new(sock))\r\n  rescue IO::WaitReadable\r\n  end\r\n\r\n
    \ def handle_write\r\n    # do nothing\r\n  end\r\nend\r\n```\r\n\r\nNow that
    you've studied how these low-level objects work, you should\r\nbe able to revisit
    the full [source code for the Chat Server\r\nexample][chatserver] and understand
    exactly how it works. If you\r\ncan do that, you know how to build an evented
    I/O loop from scratch.\r\n\r\n### Conclusions\r\n\r\nAlthough the basic ideas
    behind event-driven I/O systems are easy to understand, \r\nthere are many low-level
    details that complicate things. This article discussed some of these ideas, but
    there are many others that would need\r\nto be considered if we were trying to
    build a real event library. Among\r\nother things, we would need to consider the
    following problems:\r\n\r\n* Because our event loop does not implement timers,
    it is difficult to do\r\na number of important things. Even something as simple
    as keeping a \r\nconnection open for a set period of time can be painful without
    built-in\r\nsupport for timers, so any serious event library must support them.
    It's\r\nworth pointing out that `IO#select` does accept a timeout parameter, and\r\nit
    would be possible to make use of it fairly easily within this codebase.\r\n\r\n*
    The event loop shown in this article is susceptible to [back pressure][bp],\r\nwhich
    occurs when data continues to be buffered infinitely even if it\r\nhas not been
    accepted for processing yet. Because our event loop \r\nprovides no mechanism
    for signaling that its buffers are full, incoming\r\ndata will accumulate and
    have a similar effect to a memory leak until\r\nthe connection is closed or the
    data is accepted.\r\n\r\n* The performance of select(2) is linear, which means
    that handling \r\n10,000 streams will take 10,000x as long as handling a single
    stream. \r\nAlternative solutions do exist at the kernel, but many are not \r\ncross-platform
    and are not exposed to Ruby by default. If you have \r\nhigh performance needs,
    you may want to look into the [nio4r][nio4r] \r\nproject, which attempts to solve
    this problem in a clean way by \r\nwrapping the libev library.\r\n\r\nThe challenges
    involved in getting the details right in event loops\r\nare the real reason why
    tools like EventMachine and Node.js exist. These systems\r\nallow application
    programmers to gain the benefits of event-driven I/O without\r\nhaving to worry
    about too many subtle details. Still, knowing how they work under the hood\r\nshould
    help you make better use of these tools, and should also take away some\r\nof
    the feeling that they are a kind of deep voodoo that you'll never\r\ncomprehend.
    Event-driven I/O is perfectly understandable; it is just a bit \r\nmessy.\r\n\r\n[chatserver]:
    https://gist.githubusercontent.com/practicingruby/3612925/raw/315e7bfc5de7a029606b3885d71953acb84f112e/ChatServer.rb
    \r\n[timeless]: http://timelessrepo.com\r\n[camping]: https://github.com/camping\r\n[judofyr]:
    http://twitter.com/judofyr\r\n[nodejs]: http://nodejs.org\r\n[em]: http://rubyeventmachine.com\r\n[twisted]:
    http://twistedmatrix.com\r\n[anyevent]: http://metacpan.org/module/AnyEvent\r\n[libev]:
    http://software.schmorp.de/pkg/libev.html\r\n[libuv]: https://github.com/joyent/libuv\r\n[nio4r]:
    https://github.com/tarcieri/nio4r\r\n[bp]: http://en.wikipedia.org/wiki/Back_pressure#Back_pressure_in_information_technology\r\n"
- :slug: building-the-rstatus-api
  :title: 'Building the rstat.us API: Choices and challenges'
  :summary: Consider the design tradeoffs between the JSON API and hypermedia API
    styles. (w. Carol Nichols)
  :published: 2012-09-18 00:00:00.000000000 Z
  :issue_number: '5.4'
  :volume: 5
  :body: "*This article was contributed by Carol Nichols\r\n([@carols10cents](http://twitter.com/carols10cents),\r\n[carols10cents@rstat.us](https://rstat.us/users/Carols10cents)),
    one\r\nof the active maintainers of [rstat.us](https://rstat.us). Carol is\r\nalso
    involved in the Pittsburgh Ruby community, and is a co-organizer of the\r\n[Steel
    City Ruby Conf](http://steelcityrubyconf.org/).*\r\n\r\n[Rstat.us](https://rstat.us)
    is a microblogging site that is similar to Twitter, but \r\nbased on the [OStatus](http://ostatus.org/about)
    open standard. It's designed to be federated so\r\nthat anyone can run an instance
    of rstat.us on their own domain while still being\r\nable to follow people on
    other domains. Although rstat.us is an active project \r\nwhich has a lot to offer
    its users, the lack of an API has limited its\r\nadoption. In particular, an API
    would facilitate the development of mobile\r\nclients, which are a key part of
    what makes microblogging convenient for many people.\r\n\r\nTwo different types
    of APIs have been considered for possible implementation\r\nin rstat.us: a hypermedia
    API using an open microblogging spec and a JSON API that is\r\ncompatible with
    Twitter's API. In this article, we'll compare these two API styles \r\nin the
    context of rstat.us, and discuss the decision that the project's\r\ndevelopers
    have made after weighing out the options.\r\n\r\n## Hypermedia API\r\n\r\nHypermedia
    APIs currently have a reputation for being complicated and hard to\r\nunderstand,
    but they're really nothing to be scared of. There are many, many\r\narticles about
    what hypermedia is or is not, but the general definition that\r\nmade hypermedia
    click for me is that a hypermedia API returns links in its\r\nresponses that the
    client then uses to make its next calls. This means that the\r\nserver does not
    have a set of URLs with parameters documented for you up front;\r\nit has documentation
    of the controls that you will see within the responses.\r\n\r\nThe specific hypermedia
    API type that we are considering for rstat.us is one\r\nthat complies with the
    [Application-Level Profile Semantics (ALPS) microblogging\r\nspec](http://amundsen.com/hypermedia/profiles/).
    This spec is an experiment\r\nstarted by Mike Amundsen to explore the advantages
    and disadvantages of multiple\r\nclient and server implementations agreeing only
    on what particular values for\r\nthe XHTML attributes `class`, `id`, `rel`, and
    `name` signify. The spec does not\r\ncontain any URLs, example queries, or example
    responses.\r\n\r\nHere is a subset of the ALPS spec attributes and definitions;
    these have to do\r\nwith the rendering of one status update and its metadata:\r\n\r\n-
    li.message - A representation of a single message\r\n- span.message-text - The
    text of a message posted by a user\r\n- span.user-text - The user nickname text\r\n-
    a with rel 'message' - A reference to a message representation\r\n\r\nThis is
    one way you could render an update that is compatible with these attributes:\r\n\r\n```html\r\n<li
    class=\"message\">\r\n  <span class=\"message-text\">\r\n    I had a fantastic
    sandwich at Primanti's for lunch.\r\n  </span>\r\n  <span class=\"user-text\">Carols10cents</span>\r\n
    \ <a rel=\"message\" href=\"http://rstat.us/12345\">(permalink)</a>\r\n</li>\r\n```\r\n\r\nAnd
    this is another way that is also compatible:\r\n\r\n```html\r\n<li class=\"message
    even\">\r\n  <p>\r\n    <a rel=\"permalink message\" href=\"http://rstat.us/update?id=12345\">\r\n
    \     <span class=\"user-text\">Carols10cents</span> said:\r\n    </a>\r\n    <span
    class=\"message-text\">\r\n      I had a fantastic sandwich at Primanti's for
    lunch.\r\n    </span>\r\n  </p>\r\n</li>\r\n```\r\n\r\nNotice some of the differences
    between the two:\r\n\r\n- All the elements being siblings vs some nested within
    each other\r\n- Only having the ALPS attribute values vs having other classes
    and rels as well\r\n- Only having the ALPS elements vs having the `<p>` element
    \r\nbetween the `<li>` and the rest of the children\r\n- Simple resource-based
    routing vs. passing the id as a parameter\r\n\r\nAll of these are perfectly fine!
    If a client only depends on the values of the\r\nattributes and not the exact
    structure that's returned, it will be flexible\r\nenough to handle both responses.
    For example, you can extract the username \r\nfrom either fragment using the following
    CSS selector:\r\n\r\n```ruby\r\nrequire 'nokogiri'\r\n\r\n# Create a Nokogiri
    HTML Document from the first example, the second example \r\n# could be substituted
    and the result would be the same\r\nhtml = <<HERE\r\n  <li class=\"message\">\r\n
    \   <span class=\"message-text\">\r\n      I had a fantastic sandwich at Primanti's
    for lunch.\r\n    </span>\r\n    <span class=\"user-text\">Carols10cents</span>\r\n
    \   <a rel=\"message\" href=\"http://rstat.us/12345\">(permalink)</a>\r\n  </li>\r\nHERE\r\n\r\ndoc
    = Nokogiri::HTML::Document.parse(html)\r\n\r\n# Using CSS selectors\r\nusername
    = doc.css(\"li.message span.user-text\").text \r\n```\r\n\r\nWith this kind of
    contract, we can change the representation\r\nof an update by the server from
    the first format to the second without breaking\r\nclient functionality. While
    we will discuss the tradeoffs involved in using\r\nhypermedia APIs in more detail
    later, it is worth noting\r\nthat structural flexibility is a big part of what
    makes them attractive\r\nfrom a design perspective.\r\n\r\n## JSON API\r\n\r\nJSON
    APIs are much more common than hypermedia APIs right now. This style of API\r\ntypically
    has a published list of URLs, one for each action a client may want to\r\ntake.
    Each URL also has a number of documented parameters through which a client can\r\nsend
    arguments, and the requests return data in a defined format. This style is \r\nsimilar
    to a Remote Procedure Call (RPC) --\r\nfunctions are called with arguments, and
    values are returned, but the work is\r\ndone on a remote machine. Because this
    style matches the way we code locally,\r\nit feels familiar, and that may explain
    why the technique is so popular.\r\n\r\n[Twitter's API](https://dev.twitter.com/docs/api)
    is currently implemented in\r\nthis RPC-like style. There is a lot of documentation
    about all the URLs\r\navailable, what parameters they take, and what the returned
    data or resulting\r\nstate will be. For example, here is how you would get the
    text of the 3 most\r\nrecent tweets made by user @climagic with Twitter's JSON
    API ([relevant\r\ndocumentation](https://dev.twitter.com/docs/api/1/get/statuses/home_timeline)):\r\n\r\n```ruby\r\nrequire
    'open-uri'\r\nrequire 'json'\r\n\r\n# Make a request to the home_timeline resource
    with the format json.\r\n# Pass the parameter screen_name with the value climagic
    and the \r\n# parameter count with the value 3.\r\n\r\nbase = \"http://api.twitter.com/1/statuses/user_timeline.json\"\r\nuri
    \ = URI(\"#{base}?screen_name=climagic&count=3\")\r\n\r\n# The response object
    is a list of tweets, which is documented at\r\n# https://dev.twitter.com/docs/platform-objects/tweets\r\n\r\nresponse
    = JSON.parse(open(uri).read)\r\n\r\ntweets = response.map { |t| t[\"text\"] }\r\n```\r\n\r\nRendering
    JSON from the server is usually fairly simple as well, and\r\nthe simplicity of
    providing and consuming JSON in many different languages\r\nis another one of
    the big reasons why JSON APIs are gaining in popularity. Twitter\r\nactually decided
    to [drop support for XML, RSS, and\r\nAtom](https://dev.twitter.com/docs/api/1.1/overview#JSON_support_only)
    in\r\nversion 1.1 of their API, leaving ONLY support for JSON. [According to\r\nProgrammable\r\nWeb](http://blog.programmableweb.com/2011/05/25/1-in-5-apis-say-bye-xml/)
    20%\r\nof new APIs released in 2011 offered only JSON support.\r\n\r\nThat said,
    popularity is neither the best nor the only metric for evaluating\r\ndesign strategies;
    costs and benefits of different approaches \r\ncan only be weighed out in the
    context of a real project. To illustrate that point, we can consider how \r\neach
    of these API styles would impact the development of rstat.us.\r\n\r\n### Comparing
    and contrasting the two styles\r\n\r\nThere are many clients that have been built
    against Twitter's current API. There\r\nare even some clients that allow you to
    change the root URL of all the requests\r\n(ex:\r\n[Twidere](https://play.google.com/store/apps/details?id=org.mariotaku.twidere))\r\nIf
    rstat.us implemented the same parameters and response data,\r\npeople could use
    those clients to interact with both Twitter and rstat.us. \r\nEven if rstat.us
    doesn't end up having this level of compatibility with\r\nTwitter's API, a close
    approximation to it would still feel a lot more \r\nfamiliar to client developers,
    which may encourage them to support rstat.us.\r\n\r\nBut is it really a good idea
    to be coupled to Twitter's API design? If Twitter changes a\r\nparameter name,
    or a URL, or the structure of the data returned, rstat.us will\r\nneed to implement
    those changes or risk breaking its Twitter-compatible clients.\r\nBecause one
    of the reasons rstat.us was developed was to reduce this kind of\r\ndependency
    of Twitter, this is a big price to pay, and hypermedia APIs can help\r\nguard
    against this kind of brittleness.\r\n\r\nIn addition to flexibility in representation
    on both the client and server side,\r\nanother advantage of a hypermedia API is
    that\r\nit uses XHTML as its media type, and we just so happen to already have
    an XHTML\r\nrepresentation of rstat.us' functionality: the web interface itself!
    If\r\nyou take a look at the source of [http://rstat.us](http://rstat.us), you
    can see\r\nthat the markup for an update contains the attribute values we've been
    talking\r\nabout. We haven't made rstat.us completely compliant with the ALPS
    spec yet, \r\nbut adding attributes to our existing output [has been fairly\r\nsimple](https://github.com/hotsh/rstat.us/commit/4e234556c73426dc16526883661b3feb1e2f7d9f).\r\nBy
    contrast, building out a Twitter-compatible JSON API would mean reimplementing
    an almost\r\nentirely separate interface to rstat.us that would need to maintain
    a mapping\r\nbetween its core functionality and the external behavior of Twitter's
    API.\r\n\r\nBut looking at the source of http://rstat.us again, you'll also see
    a lot of\r\nother information in the source of the page. Most of it isn't needed
    for the use\r\nof the API, so we're transferring a lot of unnecessary data back
    and forth. The\r\nJSON responses are very compact in comparison; over time and
    with scale, this\r\ncould make a difference in performance.\r\n\r\nI am also concerned
    that some operations that are straightforward with a\r\nTwitter-style JSON API
    (such as getting one user's updates given their username)\r\nseem complex when
    following the ALPS spec. With the JSON API, there is a\r\npredefined URL with
    the username as a parameter, and the response contains\r\nthe user's updates.
    With the ALPS spec, starting from the root URL (which is the\r\nonly predefined
    URL in an ideal hypermedia API), we would need to do a minimum\r\nof 4 HTTP requests.
    That would lead to some very tedious client code:\r\n\r\n```ruby\r\nrequire 'nokogiri'\r\nrequire
    'open-uri'\r\n\r\nUSERNAME = \"carols10cents\"\r\nBASE_URI = \"https://rstat.us/\"\r\n\r\ndef
    find_a_in(html, params = {})\r\n  raise \"no rel specified\" unless params[:rel]\r\n\r\n
    \ # This XPath is necessary because @rels could have more than one value.\r\n
    \ link = html.xpath(\r\n    \".//a[contains(concat(' ', normalize-space(@rel),
    ' '), ' #{params[:rel]} ')]\"\r\n  ).first\r\nend\r\n\r\ndef resolve_relative_uri(params
    = {})\r\n  raise \"no relative uri specified\" unless params[:relative]\r\n  raise
    \"no base uri specified\" unless params[:base]\r\n\r\n  (URI(params[:base]) +
    URI(params[:relative])).to_s\r\nend\r\n\r\ndef request_html(relative_uri)\r\n
    \ absolute_uri = resolve_relative_uri(\r\n    :relative => relative_uri,\r\n    :base
    \    => BASE_URI\r\n  )\r\n  Nokogiri::HTML::Document.parse(open(absolute_uri).read)\r\nend\r\n\r\n#
    Request the root URL\r\n# HTTP Request #1\r\nroot_response = request_html(BASE_URI)\r\n\r\n#
    Find the `a` with `rel=users-search` and follow its `href`\r\n# HTTP Request #2\r\nusers_search_path
    = find_a_in(root_response, :rel => \"users-search\")[\"href\"]\r\nusers_search_response
    = request_html(users_search_path)\r\n\r\n# Fill out the `form` that has `class=users-search`,\r\n#
    putting the username in the `input` with `name=search`\r\n\r\nsearch_path = users_search_response.css(\"form.users-search\").first[\"action\"]\r\nuser_lookup_query
    = \"#{search_path}?search=#{USERNAME}\"\r\n\r\n# HTTP Request #3\r\nuser_lookup_response
    = request_html(user_lookup_query)\r\n\r\n# Find the search result beneath `div#users
    ul.search li.user` that has\r\n# `span.user-text` equal to the username\r\nsearch_results
    = user_lookup_response.css(\"div#users ul.search li.user\")\r\n\r\nresult = search_results.detect
    { |sr|\r\n  sr.css(\"span.user-text\").text.match(/^#{USERNAME}$/i)\r\n}\r\n\r\n#
    Follow the `a` with `rel=user` within that search result\r\n# HTTP Request #4\r\nuser_path
    = find_a_in(result, :rel => \"user\")[\"href\"]\r\nuser_response = request_html(user_path)\r\n\r\n#
    Extract the user's updates using the update attributes.\r\nupdates = user_response.css(\"div#messages
    ul.messages-user li\")\r\nputs updates.map { |li| li.css(\"span.message-text\").text.strip
    }.join(\"\\n\")\r\n```\r\n\r\nThis workflow could be cached so that the next time
    we try to get a user's\r\nupdates, we wouldn't have to make so many requests.
    The first two\r\nrequests for the root page and the user search page are unlikely
    to change\r\noften, so when we get a new username we can start with the construction\r\nof
    the `user_lookup_query` with a cached `search_path` value. That way, we would\r\nonly
    need to make the last two requests to look up subsequent users.\r\nHowever, if
    the root page or the user search page do change, subsequent \r\nrequests could
    fail. In that case, we'd need error handling code that clears \r\nthe cache and
    and starts from the root page again. Unfortunately, doing \r\nso would make the
    client code even more complicated.\r\n\r\nWe could simplify things by extending
    the ALPS spec to include a URI\r\ntemplate on the root page with a `rel` attribute
    to indicate that it's a\r\ntransition to information about a user when the template
    is filled out with\r\nthe username. The ALPS spec path would still work, but the
    shortcut would\r\nallow clients to get at this data in fewer requests.\r\nHowever,
    since it wouldn't be an official part of the spec, we'd need to\r\ndocument it,
    and all clients that wanted to remain compatible with ALPS would\r\nstill need
    to implement the long way of doing things.\r\n\r\nAs you can see, there are significant
    tradeoffs between the two API styles,\r\nand so it isn't especially easy to decide
    what to do. But because rstat.us\r\nreally needs an API in order to be a serious
    alternative to Twitter, we must \r\nfigure out a way forward!\r\n\r\n### Making
    a decision\r\n\r\nAfter weighing all these considerations, we've decided to concentrate
    first on\r\nimplementing a Twitter-compatible JSON API, because it may allow our
    users\r\nto interact with rstat.us using the clients they are already familiar
    with. Even\r\nif those clients end up requiring some modifications, having an
    API that is easily \r\nunderstood by many developers will still be a big plus.
    For the long term, having a more flexible and\r\nscalable solution is important,
    but those problems won't need to be solved\r\nuntil there is more adoption. We
    may implement a hypermedia API (probably an\r\nextension of the ALPS spec) in
    the future, but for now we will take the\r\npragmatic route in the hopes that
    it will encourage others to use\r\nrstat.us and support its development.\r\n\r\n###
    References\r\n\r\n- [rstat.us](http://rstat.us) and its [code on github](https://github.com/hotsh/rstat.us)\r\n-
    [ALPS microblogging spec](http://amundsen.com/hypermedia/profiles/)\r\n- [Designing
    Hypermedia APIs](http://designinghypermediaapis.com) by Steve Klabnik\r\n- [A
    Shoes hypermedia client for ALPS microblogging](https://gist.github.com/2187514)\r\n-
    [Twitter API docs](https://dev.twitter.com/docs/api)\r\n- [REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)\r\n"
- :slug: process-spawning-patterns
  :title: Process spawning patterns
  :summary: Implement Ruby's system and backticks methods using the fork/exec pattern.
    (w. Jesse Storimer)
  :published: 2012-10-02 00:00:00.000000000 Z
  :issue_number: '5.5'
  :volume: 5
  :body: "*This article was contributed by [Jesse Storimer](http://jstorimer.com).
    He is\r\nthe author of [Working with Unix Processes](http://workingwithunixprocesses.com)\r\nand
    [Working with TCP Sockets](http://workingwithtcpsockets.com), a pair of\r\nebooks
    providing fundamental Unix knowledge to Ruby developers. When he's not at\r\nthe
    keyboard, he's often enjoying the great Canadian outdoors with his family.*\r\n\r\nLike
    many of you, I discovered Ruby via Rails and web development. That was my\r\n\"in.\"
    But before it was popular for writing web apps, Ruby was known for its\r\nobject-oriented
    fundamentals and for being a great scripting language. One of the reasons for\r\nthis
    latter benefit is that it's so easy to marry Ruby with command-line\r\nutilities.
    Here's an example:\r\n\r\n```ruby\r\ntask :console do\r\n  `irb -r my_app`\r\nend\r\n```\r\n\r\nThere's
    something simple and beautiful in the combination of Ruby and the\r\ncommand line
    here--the backticks are barely detectable. This code will technically \r\naccomplish
    what you think it will: it will drop you into an app-specific console  that is\r\nbasically
    an `irb` session with your app already required. But do you know what's \r\ngoing
    on inside that backtick method? \r\n\r\nRuby provides many ways of spawing processes.
    Why use backticks instead of\r\n`system`?\r\n\r\n```ruby\r\ntask :console do\r\n
    \ system('irb -r my_app')\r\nend\r\n```\r\n\r\nOr what about `exec`? Would that
    have been better?\r\n\r\n```ruby\r\ntask :console do\r\n  exec('irb', '-r', 'my_app')\r\nend\r\n```\r\n\r\nIn
    order to make this decision, you need to understand what these methods are\r\ndoing
    under the hood. The differences may be trivial for spawning a development\r\nconsole,
    but picking one of these methods over another in a production environment can\r\nhave
    major implications.\r\n\r\nIn this article, we're going to reimplement the key
    parts of these process-spawning\r\nprimitives to get a better understanding of
    how they work and where they're most\r\napplicable. Afterward, you'll have a greater
    understanding of how process\r\nspawning works regardless of programming language
    and you'll have a grip on\r\nwhich methods are most applicable in different situations.\r\n\r\n##
    Starting somewhere\r\n\r\nI have already hinted at a few different process-spawning
    methods--Ruby has\r\na ton of them. Off the top of my head, there's: `Kernel#system`,\r\n<code>Kernel#\\`</code>,
    `IO.popen`, `Process.spawn`, `open`, `shell`, `open3`,\r\n`pty`, and probably
    more. All of these ship with Ruby, some in the core and\r\nothers in the standard
    library.\r\n\r\nAll of these spawning methods boil down to the same pattern, but
    we're not going\r\nto implement them all. To save time, we'll stick with implementing
    `system` and\r\nthe backtick method. Either of these methods can be called\r\nwith
    a shell command as the argument. Both handle the command in slightly\r\ndifferent
    ways with slightly different outputs:\r\n\r\n``` \r\nsystem('ls -l') #=> true\r\nsystem('ls
    -l *.rb | ack Product') #=> true\r\nsystem('boohoo') #=> nil\r\n`git log -n1 --format=%h^`
    #=> 51e7a1c\r\n`hostname` #=> jessebook\r\n```\r\n\r\nLet's start building them.\r\n\r\n##
    Harnessing ourselves with tests\r\n\r\nBefore we dive into spawning process head
    first, let's rein ourselves in a\r\nbit. If we're going to reimplement what Ruby
    already provides, we're going to\r\nneed a way to test our implementation and
    make sure that it performs the same\r\nway that Ruby does. Enter [Rubyspec](http://rubyspec.org).\r\n\r\n>
    The RubySpec project aims to write a complete executable specification for the\r\n>
    Ruby programming language that is syntax-compatible with RSpec. RSpec is\r\n>
    essentially a DSL (domain-specific language) for describing the behavior of\r\n>
    code. This project contains specs that describe Ruby language syntax, core\r\n>
    library classes, and standard library classes.\r\n\r\nRubySpec provides a specification
    for the Ruby language itself, and we want to\r\nreimplement a part of the Ruby
    language; therefore, we can use RubySpec\r\nto test our implementation.\r\n\r\nTo
    use these specs to drive our implementation, we need to get two\r\nthings: RubySpec
    itself, and its testing library mspec. You can check\r\nout [this README](https://github.com/rubyspec/rubyspec/blob/master/README)
    \r\nfor installation instructions. To verify that things are working as \r\nexpected,
    try running the kernel tests from within the RubySpec project\r\ndirectory:\r\n\r\n```bash\r\n$
    mspec core/kernel\r\n```\r\n\r\nTo run our custom code against these tests, we
    can use\r\nthe familiar `-r` option with `mspec` to require a file that redefines\r\nthe
    methods we want to override. Let's do that, while at the same time \r\nrunning
    the `Kernel.system` specs:\r\n\r\n```bash\r\n$ touch practicing_spawning.rb\r\n$
    mspec -r ./practicing_spawning.rb core/kernel/system_spec.rb\r\n```\r\n\r\nShould
    be all green so far!\r\n\r\n## Breaking the test\r\n\r\nLet's begin our implementation
    by causing the tests to fail:\r\n\r\n```ruby\r\n# practicing_spawning.rb\r\nmodule
    Kernel\r\n  def system(*args)\r\n  end\r\n\r\n  private :system\r\nend\r\n```\r\n\r\nThe
    very first spec says that `system` should be private. I set that up right\r\naway
    because it's not the interesting part. If we run the `system` specs again,\r\nwe
    get our first of several failures:\r\n\r\n```console\r\n1)\r\nKernel#system executes
    the specified command in a subprocess FAILED\r\nExpected (STDOUT): \"a\\n\"\r\n
    \         but got: \"\"\r\n```\r\n\r\nThis failure directly relates to the following
    spec:\r\n\r\n```ruby\r\nit \"executes the specified command in a subprocess\"
    do\r\n  lambda { @object.system(\"echo a\") }.should output_to_fd(\"a\\n\")\r\nend\r\n```\r\n\r\nIf
    you've ever used the `system` method, this test should be easy to\r\nunderstand.
    It says that shelling out to `echo` should output the echoed string.\r\nIf you
    [dig into](https://github.com/rubyspec/mspec/blob/master/lib/mspec/matchers/output_to_fd.rb#L68-70)\r\n
    the `output_to_fd` method that's part of `mspec`, you'll see that it's\r\nexpecting
    this output on `STDOUT`.\r\n\r\n## fork and subprocesses\r\n\r\nThe failing spec
    title says that `system` spawns a subprocess. If you're\r\ncreating new processes
    on a Unix system, that means using `fork`:\r\n\r\n> ------------------------------------------------------------------------------\r\n>
    \  Kernel.fork  [{ block }]   -> fixnum or nil  \r\n>   Process.fork [{ block
    }]   -> fixnum or nil\r\n>    \r\n> ------------------------------------------------------------------------------\r\n>
    \r\n> Creates a subprocess. If a block is specified, that block is run in the\r\n>
    subprocess, and the subprocess terminates with a status of zero. Otherwise,\r\n>
    the fork call returns twice, once in the parent, returning the process ID of\r\n>
    the child, and once in the child, returning nil.\r\n\r\nThis bit of Ruby documentation
    gives you an idea of what `fork` does. It's\r\nconceptually similar to going on
    a hike and coming to a fork in the trail. The\r\ntrail represents the execution
    of a process over time. Whereas humans can only\r\npick one path, when a process
    is forked it literally continues down both\r\nbranches of the trail in parallel.
    What was one process becomes two independent \r\nprocesses. This behavior is specified
    by the fork(2) manpage:\r\n\r\n> Fork() causes creation of a new process.  The
    new process (child process) is\r\n> an exact copy of the calling process (parent
    process) [...]\r\n\r\nWhen you `fork`, you start with one process and end up with
    two processes that\r\nare *exactly the same*. In some cases, this means that everything
    is copied from\r\none process to the other. But if [copy-on-write\r\nsemantics](http://en.wikipedia.org/wiki/Copy-on-write)
    are implemented,\r\nthe two processes may physically share memory until one of
    them tries to\r\nmodify it; then each gets its own copy written out.\r\n\r\nAlthough
    understanding `fork` is certainly helpful, we still haven't quite figured\r\nout
    how to implement the `system` method. We know that we can take our Ruby \r\nprocess
    and create a copy of it with `fork`, but how do we then turn the \r\nnew child
    process into an `echo` process?\r\n\r\n## fork + exec\r\n\r\nThe `fork` + `exec`
    pattern for spawning processes is the blueprint upon which\r\nmost process spawning
    is built. We've already looked at `fork`, so what\r\nabout `exec`?\r\n\r\n`exec`
    transforms the current process into another process. Using\r\n`exec`, you can
    transform a Ruby process into an `ls` process, another Ruby\r\nprocess, or an
    `echo` process:\r\n\r\n```ruby\r\nputs 'hi from Ruby'\r\nexec('ls')\r\nputs 'bye
    from Ruby' # will never be reached\r\n```\r\n\r\nThis program will never get to
    the last line of Ruby code. Once it has performed\r\n`exec('ls')`, the Ruby program
    no longer exists. It has been transformed to `ls`.\r\nSo there's no possible way
    for it to get back to this Ruby program and finish\r\nexecution.\r\n\r\n## Finally,
    a passing test\r\n\r\nWith `fork` and `exec`, we now have the building blocks
    that we need to implement\r\nour own `system` method. Here's the most basic implementation:\r\n\r\n```ruby\r\n#
    practicing_spawning.rb\r\nmodule Kernel\r\n  def system(*args)\r\n\r\n    # Create
    a new subprocess that will just exec the requested program.\r\n    pid = fork
    { exec(*args) }\r\n\r\n    # Because fork() allows both processes to work in parallel,
    we must tell the\r\n    # parent process to wait for the child to exit. Otherwise,
    the parent would\r\n    # continue in parallel with the child and would be unable
    to process its\r\n    # return value.\r\n    _, status = Process.waitpid2(pid)\r\n
    \   status.success?\r\n  end\r\n\r\n  private :system\r\nend\r\n```\r\n\r\nIf
    we run this against the same spec as before, more tests pass, but\r\nnot all of
    them. Still, getting that initial spec to pass means that we're headed\r\nin the
    right direction.\r\n\r\nThere are three very simple Unix programming primitives
    in use here: `fork`,\r\n`exec`, and `wait`. We've already talked about `fork`
    and `exec`, the\r\ncornerstone of Unix process spawning. The third player here,
    `wait`, is often\r\nused in unison with these two. It tells the parent process
    to wait for the child\r\nprocess before continuing, rather than continuing execution
    in parallel. This is\r\na pretty common pattern when spawning shell commands,
    because you usually want to\r\nwait for the output of the command.\r\n\r\nIn this
    case, we collect the status of the child when it exits and return the\r\nresult
    of `success?`. This result is `true` for a successful exit status code (i.e.,
    0)\r\nand `false` for any other value.\r\n\r\n## Getting back to green\r\n\r\nNow
    we need to get the rest of the `system` specs passing. In\r\nthe remainder of
    the failures, we see the following output:\r\n\r\n```console\r\n1) \r\nKernel#system
    returns nil when command execution fails FAILED\r\nExpected false to be nil\r\n<snipped
    backtrace...>\r\n\r\n2)\r\nKernel#system does not write to stderr when command
    execution fails FAILED\r\nExpected (STDERR): \"\"\r\n         but got: \"/[...]/practicing_spawning.rb:8:in
    `exec': No such \r\n         file or directory - sad (Errno::ENOENT)\r\n<snipped
    backtrace...>\r\n```\r\n\r\nThese failures relate to the following specs:\r\n\r\n```ruby\r\nruby_version_is
    \"1.9\" do\r\n  it \"returns nil when command execution fails\" do\r\n    @object.system(\"sad\").should
    be_nil\r\n  end\r\nend\r\n\r\nit \"does not write to stderr when command execution
    fails\" do\r\n  lambda { @object.system(\"sad\") }.should output_to_fd(\"\", STDERR)\r\nend\r\n```\r\n\r\nBoth
    of these specs are testing the same situation: trying to `exec` a command\r\nthat
    doesn't exist. When this happens, it actually raises an exception in\r\nthe subprocess,
    as is evidenced by the previously listed failure #2, which prints an\r\nexception
    message along with a stacktrace on its `STDERR`, whereas the spec\r\nexpected
    that `STDERR` would be empty.\r\n\r\nSo when the subprocess raises an exception,
    we need to notify the parent process\r\nof what went wrong. Note that we can't
    use Ruby's regular exception handling in\r\nthis case because the exception is
    happening inside the subprocess. The\r\nsubprocess got a copy of everything that
    the parent had, including the Ruby\r\ninterpreter. So although all of the code
    is sourced from the same file, we can't\r\ndepend on regular Ruby features because
    the processes are actually running on\r\ntheir own separate copies of the Ruby
    interpreter!\r\n\r\nTo solve this problem, we need some form of interprocess communication
    (IPC).\r\nKeeping with the general theme of this article, we'll use a Unix pipe.\r\n\r\n##
    The pipe\r\n\r\nA call to `IO.pipe` in Ruby will return two `IO` objects, one
    readable and\r\none writable. Together, they form a one-way data 'pipe'. Data
    is written\r\nto one `IO` object and read from the other:\r\n\r\n```ruby\r\nrd,
    wr = IO.pipe\r\nwr.write \"ping\"\r\nwr.close\r\n\r\nrd.read #=> \"ping\"\r\n```\r\n\r\nA
    pipe can be used for IPC by taking advantage of `fork` semantics. If you\r\ncreate
    a pipe before forking, the child process inherits a copy of the pipe\r\nfrom its
    parent. As both have a copy, one process can write to the pipe while\r\nthe other
    reads from it, enabling IPC. Pipes are\r\nbacked by the kernel itself, so we can
    use them to communicate between our independent\r\nRuby processes.\r\n\r\n## Implementing
    system() with a pipe\r\n\r\nNow we can roll together all of these concepts and
    write our own implementation\r\nof `system` that passes all the specs:\r\n\r\n```ruby\r\n#
    practicing_spawning.rb\r\nmodule Kernel\r\n  def system(*args)\r\n\r\n    rd,
    wr = IO.pipe\r\n\r\n    # Create a new subprocess that will just exec the requested
    program.\r\n    pid = fork do\r\n      # The subprocess closes its copy of the
    reading end of the pipe\r\n      # because it only needs to write.\r\n      rd.close\r\n\r\n
    \     begin\r\n        exec(*args)\r\n      rescue SystemCallError\r\n\r\n        #
    In case of failure, write a byte to the pipe to signal that an exception\r\n        #
    occurred and exit with an unsuccessful code.\r\n        wr.write('.')\r\n        exit
    1\r\n      end\r\n    end\r\n\r\n    # The parent process closes its copy of the
    writing end of the pipe\r\n    # because it only needs to read.\r\n    wr.close\r\n\r\n
    \   # Tell the parent to wait.\r\n    _, status = Process.waitpid2(pid)\r\n\r\n
    \   # If the reading end of the pipe has no data, there was no exception\r\n    #
    and we fall back to the exit status code of the subprocess. Otherwise,\r\n    #
    we return nil to denote the error case.\r\n    if rd.eof?\r\n      status.success?\r\n
    \   else\r\n      nil\r\n    end\r\n  end\r\n\r\n  private :system\r\nend\r\n```\r\n\r\nAll
    green!\r\n\r\n## Implementing backticks\r\n\r\nNow that you've got the fundamentals
    under your belt, we can apply these concepts to the\r\nimplementation of other
    process-spawning methods. Let's do backticks:\r\n\r\n```ruby\r\n# practicing_spawning.rb\r\nmodule
    Kernel\r\n  def `(str)\r\n    rd, wr = IO.pipe\r\n\r\n    # Create a new subprocess
    that will exec just the requested program.\r\n    pid = fork do\r\n      # The
    subprocess closes its copy of the reading end of the pipe\r\n      # because it
    only needs to write.\r\n      rd.close\r\n\r\n      # Anything that the exec'ed
    process would have written to $stdout will\r\n      # be written to the pipe instead.\r\n
    \     $stdout.reopen(wr)\r\n\r\n      exec(str)\r\n    end\r\n\r\n    # The parent
    process closes its copy of the writing end of the pipe\r\n    # because it only
    needs to read.\r\n    wr.close\r\n\r\n    # The parent waits for the child to
    exit.\r\n    Process.waitpid(pid)\r\n\r\n    # The parent returns whatever it
    can read from the pipe.\r\n    rd.read\r\n  end\r\n\r\n  private :`\r\nend\r\n```\r\n\r\nNow
    we can run the backticks spec against our implementation and see that it's\r\nall
    green!\r\n\r\n```console\r\n$ mspec -r ./practicing_spawning.rb core/kernel/backtick_spec.rb\r\n```\r\n\r\nThe
    full source for our `practicing_spawning.rb` file is available [as a gist](https://gist.github.com/3730986).
    \r\n\r\n## Closing notes\r\n\r\nI find something special in spawning processes.
    You get to dig down\r\nbelow the top layer of your programming language to the
    lower layer where All\r\nThings Are One. When dealing with things such as `fork`,
    `exec`, and `wait`, your\r\noperating system treats all processes equally. Any
    Ruby process can transform\r\ninto a C program, or a Python process, or vice versa.
    Similarly, you can `wait`\r\non processes written in any language. At this layer
    of abstraction, there are only\r\nthe system and its primitives.\r\n\r\nWe spend
    a lot of our mental energy worrying about good principles such as\r\nabstraction,
    decoupling, efficiency. When digging down a layer and learning what\r\nyour operating
    system is capable of, you see an extremely robust and abstract\r\nsystem. It cares
    not how you implement your programs but offers the same\r\nfunctionality for any
    running program. Understanding your system at this level\r\nwill really show you
    what it's capable of and give you a good mental\r\nunderstanding of how your system
    sees the world. Once you really grasp the\r\n`fork` + `exec` concepts, you'll
    see that these are right at the core of a Unix system.\r\nEvery process is spawned
    this way. The simplest example is your shell, which uses\r\nthis very pattern
    to launch programs.\r\n\r\nI'll leave you with two more tips:\r\n\r\n1. Use `exec()`
    at the end of scripts to save a process. Remember the early example\r\nin which
    a rake task spawned an `irb` session? The obvious\r\nchoice in that case is to
    use `exec`.\r\n\r\n    Any other variant will require forking a new process that
    then execs and\r\n    has the parent wait for it. Using `exec` directly eliminates
    the need for an extra\r\n    process by transforming the `rake` process directly
    into an `irb` process.\r\n    This trick obviously won't work in situations where
    you need to shell out and then\r\n    work with the output, but keep it in mind
    if the last line of your script\r\n    just shells out.\r\n\r\n2. Pass an `Array`
    instead of a `String`. The backticks method always takes a\r\nstring, but the
    `system` method (and many other process spawning methods) will\r\ntake an array
    or a string. \r\n\r\n    When passed a string, `exec` may spawn a shell to interpret
    the\r\n    command, rather than executing it directly. This approach is handy
    for stuff like\r\n    `system('find . | ack foobar -l')` but is very dangerous
    when user input is\r\n    involved. An unescaped string makes shell injection
    possible. Shell\r\n    injection is like SQL injection, except that a compromised
    shell could provide an\r\n    attacker with root access to your entire system!
    Using an array will never\r\n    spawn a shell but will pass the elements directly
    as the `ARGV` of the exec'ed process. \r\n    Always do this.\r\n\r\nFinally,
    if you enjoyed these exercises, try to implement some of\r\nthe other process
    spawning primitives I mentioned. With RubySpec as your guide,\r\nyou can try reimplementing
    just about anything with confidence. Doing so will\r\nsurely give you a better
    understanding of how process spawning works in Ruby--or \r\nany Unix environment.\r\n\r\nPlease
    leave a comment and share your code if you implement some pure-Ruby versions \r\nof
    these spawning methods. I'd love to see them!\r\n"
- :slug: growing-a-stable-codebase
  :title: Guidelines for growing a stable codebase
  :summary: Discover the process we use for continuously improving practicingruby.com.
    (w. Jordan Byron)
  :published: 2012-10-16 00:00:00.000000000 Z
  :issue_number: '5.6'
  :volume: 5
  :body: "Software projects need to evolve over time, but they also need to avoid\r\ncollapsing
    under their own weight. This balancing\r\nact is something that most programmers
    understand, but it is often \r\nhard to communicate its importance to nontechnical
    stakeholders. \r\nBecause of this disconnect, many projects operate under the\r\nfalse
    assumption that they must stagnate in order to stabilize. \r\n\r\nThis fundamental
    misconception about how to maintain a stable codebase has some\r\ndisastrous effects:
    it causes risk-averse organizations to produce stale \r\nsoftware that quickly
    becomes irrelevant, while risk-seeking organizations ship \r\nbuggy code in order
    to rush features out the door faster than their \r\ncompetitors. In either case,
    the people who depend on the software produced by\r\nthese teams give up something
    they shouldn't have to.\r\n\r\nI have always been interested in this problem,
    because I feel it is at the \r\nroot of why so many software projects fail. However,
    my work on Practicing Ruby\r\nhas forced me to become much more personally invested
    in solving it. As someone\r\nattempting to maintain a very high-quality experience
    on a shoestring budget, I\r\nnow understand what it is like to look at this problem
    from a stakeholder's\r\npoint of view. In this article, I will share the lessons
    that Jordan Byron and \r\nI have learned from trying to keep Practicing Ruby's
    web application stable as\r\nit grows.\r\n\r\n### Lesson 1: Work incrementally\r\n\r\nInspired
    by [Lean Software Development][lean] practices, we now\r\nview all work-in-progress
    code as a form of waste. This way of looking at things \r\nhas caused us to eschew
    iteration planning in favor of shipping a single\r\nimprovement or fix at a time.
    This workflow may seem a bit unrealistic at \r\nfirst glance, but with some practice
    it gets easier to break very \r\ncomplicated features into tiny bite-sized chunks.
    We now work this way by\r\nhabit, but our comment system was the first thing we
    approached in \r\nthis fashion.\r\n\r\nWhen we first implemented comments, we
    had Markdown support, but not much else. \r\nLater, we layered in various improvements
    one by one, including syntax \r\nhighlighting, email notifications, Twitter-style
    mentions, and Emoji support. \r\nWith so little development time available each
    week, it would have taken \r\nmonths to ship our discussion system if we attempted
    to build it all at once.\r\nWith that in mind, our adoption of a Lean-inspired
    deployment strategy was not just a\r\nworkflow optimizationit was an absolute
    necessity. We also eventually came to \r\nrealize that this constraint was a source
    of strength rather than weakness for\r\nus. Here's why:\r\n\r\n> Developing features
    incrementally reduces the number of moving parts \r\nto integrate on each deploy.
    This reduction in turn limits the number of new\r\ndefects introduced during development.\r\n\r\n>
    When new bits of functionality do fail, finding the root cause of the problem
    is usually easy, and even when it isn't, rolling the system\r\nback to a working
    state is much less traumatic. Together, these approaches result in\r\na greatly
    reduced day-to-day maintenance cost, which means that more time can\r\nbe spent
    on value-producing work.\r\n\r\nAs you read through the rest of the guidelines
    in this article, you'll find that\r\nalthough they are useful on their own, they
    are made much more effective by this\r\nshift in the way we ship things.\r\n\r\n###
    Lesson 2: Review everything\r\n\r\nIt is no secret that code reviews are useful
    for driving up quality and\r\nreducing the number of defects that are introduced
    into production in the first\r\nplace. However, figuring out how to conduct a
    good review is something that\r\ntakes a bit of fine-tuning to get right. Here
    is the set of steps we eventually\r\nsettled on:\r\n\r\n1. The reviewer attempts
    to actually use the new feature while its developer \r\nanswers any questions
    that come up along the way. Whenever an unanticipated\r\nedge case or inconsistency
    is found, we immediately file a ticket for it. We\r\nrepeat this process until
    all open questions or unexpected issues have been \r\ndocumented.\r\n\r\n    Unless
    the feature's developer has specific technical questions for the\r\n    reviewer,
    we don't bother with in-depth reviews of implementation details until\r\n    all
    functional issues have been addressed. This prevents us from spending time\r\n
    \   on bikeshed arguments about refactorings or hypothetical sources of\r\n    failure
    at the code level. Doing things this way also reminds us that the\r\n    external
    quality of our system is our highest priority and that although clean\r\n    code
    makes building a better product easier, it is a means, not an end in itself.\r\n\r\n2.
    Once a feature seems to work as expected by both the developer and\r\nthe reviewer,
    we next turn our attention to the tests. It is the\r\nreviewer's responsibility
    to make sure that the tests cover the issues brought\r\nup during the review and
    to verify that they exercise the \r\nfeature well enough to prevent it from silently
    breaking. Sometimes the reviewers will ask the developer\r\nof the feature to
    write the tests; other times it is easier for the reviewers to\r\nwrite the tests
    themselves rather than trying to explain what is needed. \r\n\r\n    In either
    case, the end result of this round of changes is that the feature's\r\n    requirements
    become clearer as the tests are updated to cover more subtle\r\n    details. Because
    many of these tests can be written at the UI level, it is\r\n    common to have
    not yet discussed implementation details at this stage of a\r\n    review.\r\n\r\n3.
    By now, the feature is tested well enough, and its functionality has been \r\nexercised
    more than a few times. That means that a spot check of its source code \r\nis
    in order. The goal is not to make the code perfect, \r\nbut to identify both low-cost
    improvements that can be done right away \r\nand any serious warning signs of
    potential problems that may make the \r\ncode hard to maintain or prone to error.
    Everything else is \r\nsomething that can be dealt with laterif and when a feature
    needs to be \r\nimproved or modified.\r\n\r\nEven though these items are listed
    in order, it's better to think of them as layers\r\nrather than procedural steps.
    You need to start at the outermost layer, then\r\ndig down as needed to fully
    answer each question that comes up during a review.\r\nThis may sound like a very
    rigorous procedure, but it isn't as daunting as it\r\nseems. You can get an idea
    of what this process looks like in practice by reading through \r\nthe conversation
    on [this pull request][pr-76]. Here's why we invest the extra\r\neffort:\r\n\r\n>
    Reviewing functionality first, tests second, and\r\n> implementation last helps
    ensure that the right kinds of\r\n> conversations happen at the right time. If
    a feature isn't implemented\r\n> correctly or is poorly usable, it doesn't matter
    how well written its tests\r\n> are. Likewise, if test coverage is inadequate,
    it isn't wise to recommend \r\n> major refactorings to production code. This simple
    prioritization keeps\r\n> the focus on improving the *application* rather than
    the *implementation*.\r\n\r\nEven with a very good review process, bad things
    still happen. That's\r\nwhy the remaining four lessons focus on what to do when
    things go wrong, but keep\r\nin mind that actively reviewed projects help prevent
    unexpected failures from\r\nhappening in the first place.\r\n\r\n### Lesson 3:
    Stay alert\r\n\r\nWhen something breaks, we want to know about it as soon as possible.\r\nWe
    rely on many different ways of detecting problems, and we automate as much as\r\nwe
    can.\r\n\r\nOur first line of defense is our continuous integration (CI) system.
    \r\nWe use [Travis CI][travis], but for our purposes pretty much any CI tool would\r\nwork.
    Travis does a great job of catching environmental issues for us: things\r\nsuch
    as unexpected changes in dependencies, application configuration problems,\r\nplatform-specific
    failures, and other subtle things that would be hard to \r\nnotice in development.
    More important, it helps protect us from ourselves: even if we \r\nforget to run
    the entire test suite before pushing a set of changes, \r\nTravis never forgets,
    and will complain loudly if we've broken the \r\nbuild. Most of the mistakes that
    CI can detect are quite \r\ntrivial, but catching them before they make it to
    production helps us \r\nkeep our service stable.\r\n\r\nFor the bugs that Travis
    can't catch (i.e., most of them), we rely on\r\nthe [Exception Notifier][exception-notification]
    plugin for Rails. Most\r\nnotification systems would probably do the trick for
    us, but we like that Exception\r\nNotifier is email-based; it fits into our existing
    workflow nicely. The default\r\ntemplate for error reports works great for us
    because it provides everything\r\nyou tend to get from debugging output during
    development: session data,\r\nenvironment information, the complete request, and
    a stack trace. If we start to\r\nnotice exception reports rolling in soon after
    we've pushed a change to the system, this\r\ninformation is usually all we need
    in order to find out what caused the problem.\r\n\r\nWhenever we're working on
    features that are part of the critical path of our\r\napplication, we tend to
    use the UNIX `tail -f` command to watch our production \r\nlogs in real time.
    We also occasionally write ad hoc reports that give us \r\ninsight into how our
    system is working. For example, we built the following \r\nreport to track account
    statuses when we rolled out a partial replacement \r\nfor our registration system.
    We wanted to make sure it was possible for folks to\r\nsuccessfully make it to
    the \"payment pending\" status, and the report showed\r\nus that it was:\r\n\r\n![Account
    status report](http://i.imgur.com/NOI0A.png)\r\n\r\nOur proactive approach to
    error detection means that we can rely less on\r\nbug reports from our subscribers
    and more on automated reports and alerts. This approach\r\nworks fairly well most
    of the time, and we even occasionally send messages\r\nto people who were affected
    by bugs with either an apology and a note that we\r\nfixed the problem, or a link
    to a ticket where they can track our progress on\r\nresolving the issue. We do
    display our email address on all of our error pages,\r\nbut we place a high priority
    on making sure that subscribers need to use\r\nit only to provide extra context
    for us, rather than to notify us that a\r\nproblem exists.\r\n\r\nBefore we move
    on to the next lesson, here are a few things to remember about\r\nthis topic:\r\n\r\n>
    The main reason to automate error detection as much as possible is that the\r\npeople
    who use your application should not be treated like unpaid QA testers.\r\nThe
    need for an active conversation with your users every time something goes\r\nwrong
    is a sign that you have poor visibility into your application's failures,\r\nand
    it will pay off to fix this problem. However, every automated error\r\ndetection
    system requires some fine-tuning to get it right, and you may need\r\nto make
    pragmatic compromises from time to time.\r\n\r\n> Automated error detection is
    almost always a good thing: the main question is how extensive\r\n> you want it
    to be. For small projects, something as simple as maintaining a\r\n> detailed
    log file is enough; for larger projects, much more sophisticated\r\n> systems
    are needed. The key is to choose a strategy that works for your\r\n> particular
    context, rather than trying to find a one-size-fits-all\r\n> solution.\r\n\r\nIf
    automated error detection interests you, please post a\r\ncomment about your experiences
    after you finish reading this article. It\r\nis a very complex topic, and I feel
    like I've only scratched the surface\r\nof it in my own work, so I'd love to hear
    some stories from our readers.\r\n\r\n### Lesson 4: Roll back ruthlessly\r\n\r\nWorking
    on one incremental improvement at a time makes it easy \r\nto revert newly released
    functionality immediately if we find \r\nout that it is defective. At first, we
    got into the habit of \r\nrolling things back to a stable state because we didn't\r\nknow
    when we'd get around to fixing the bugs we encountered. Later, we discovered that
    this approach allows us to take\r\nour time and get things right rather than shipping
    quick\r\nfixes that felt like rushed hacks.\r\n\r\nIn order to make rollbacks
    painless, good revision control processes\r\nare essential. We started out by
    practicing [GitHub Flow][gh-flow]\r\nin its original form, which consisted of
    the following steps:\r\n\r\n1. Anything in the master branch is deployable.\r\n\r\n2.
    To work on something new, create a descriptively named branch off of the master.\r\n\r\n3.
    Commit to that local branch and regularly push your work to the server.\r\n\r\n4.
    When you need feedback or help, or you want to merge, open a pull request.\r\n\r\n5.
    After someone else has reviewed the feature, you can merge it into the master.\r\n\r\n6.
    Once it is merged and pushed to the master, you can and should deploy\r\nimmediately.\r\n\r\nSomewhere
    down the line, we made a small tweak to the formula by deploying\r\ndirectly from
    our feature branches before merging them into the master branch. This\r\napproach
    allows every improvement we ship to get some live testing time in\r\nproduction
    before it gets merged, greatly increasing the stability\r\nof our mainline code.
    Whenever trouble strikes, we redeploy from our master branch, \r\nwhich executes
    a rollback without explicitly reverting any\r\ncommits. As it turns out, this
    approach is very similar to [GitHub's more recent\r\ndeployment practices][gh-deploy-aug-2012],
    minus their fancy robotic\r\nhelpers.\r\n\r\nAlthough this process significantly
    reduces the amount of defects on our master branch,\r\nwe do occasionally come
    across failures that are in old code rather than in our\r\nlatest work. When that
    happens, we tend to fix the issues directly on the master, \r\nverify that they
    work as expected in production, and then attempt to merge those changes into any
    active\r\nfeature branches. Most of the time, these merges can be cleanly applied,
    so\r\nit doesn't interrupt our work on new improvements all that much. But when
    things\r\nget messy, it is a reminder for us to take a step back and look at the
    big\r\npicture:\r\n\r\n> In a healthy system, rollbacks should be easy, particularly
    when feature\r\nbranches are used. When this process does not go smoothly, it
    is usually a \r\nsign of a deeper problem:\r\n\r\n> 1) If lots of bugs need to
    be fixed on the master branch,\r\nit is a sign that features may have been merged
    prematurely, or that\r\nthe application's integration points have become too brittle
    and need some \r\nrefactoring.\r\n\r\n> 2) If a new feature repeatedly fails in
    production despite attempts to fix\r\nit, it may be a sign that the feature isn't
    very well thought out and that\r\na redesign is in order.\r\n\r\n> Although neither
    of these situations are pleasant to deal with, addressing them\r\nright away helps
    prevent them from spiraling out of control. This approach makes sure\r\nthat small
    flaws do not evolve into big ones and minimizes the project's\r\npain points over
    the long haul.\r\n\r\nDespite these benefits, this practice does feel a bit ruthless
    at times, \r\nand it definitely takes some getting used to. However, by treating
    rollbacks \r\nas a perfectly acceptable response to a newly discovered defect
    rather \r\nthan an embarrassing failure, a totally different set of priorities
    are \r\nestablished that help keep things in a constant state of health. \r\n\r\n###
    Lesson 5: Minimize effort\r\n\r\nEvery time we find a defect in one of our features,
    we ask ourselves whether\r\nthat feature is important enough to us to be worth
    fixing at all. Properly\r\nfixing even the simplest bugs takes time away from
    our work on other\r\nimprovements, so we are tempted to cut our losses by removing\r\ndefective
    code rather than attempting to fix it. Whether we can get away with\r\nthat ultimately
    depends on the situation.\r\n\r\n---\r\n\r\n**Critical defects:** Sometimes bugs
    are severe enough that they need to be dealt with right away,\r\nand in those
    cases we [stop the line][autonomation] to give the issue the\r\nattention it deserves.
    The best example of this practice that we've encountered in recent\r\ntimes was
    when we neglected to update our omniauth dependency before GitHub shut\r\ndown
    an old version of their API, which disabled logins temporarily for all\r\nPracticing
    Ruby subscribers. We had an emergency fix out within hours, but it\r\npredictably
    broke some stuff. Over the next couple days, we added fixes for\r\nthe edge cases
    we hadn't considered until the system stabilized again. Because\r\nthis wasn't
    the kind of defect we could easily work around or roll back from, we\r\nwere working
    under pressure, and attempting to work on other things during that\r\ntime would
    have just made matters worse.\r\n\r\n**Trivial defects:** At the other extreme,
    some bugs are so easy to fix that it makes\r\nsense to take care of them as soon
    as you notice them. A few weeks before this\r\narticle was published, I noticed
    that our broadcast email system was treating our\r\nplain-text messages as if
    they were HTML that needed to be escaped, which caused\r\nsome text to be mangled.
    If you don't count the accompanying test, fixing this\r\nproblem was [a one-line
    change][htmlescape] to our production code. Tiny bugs \r\nlike this should be
    fixed right away to prevent them from accumulating \r\nover time.\r\n\r\n**Moderate
    defects:** Most of the bugs we discover fall somewhere \r\nbetween these two extremes,
    and figuring out how to deal with them is not nearly so\r\nstraightforward. We've
    gradually learned that it is\r\nbetter to assume that a feature can be either
    cut or simplified and then try to\r\nprove ourselves wrong rather than thinking
    that it absolutely must be fixed.\r\n\r\nOne area where we failed to keep things
    simple at first was in our work on\r\naccount cancellation. Because we were in
    the middle of a transition to a \r\nnew payment provider, this feature ended up
    being more complicated to\r\nimplement than we expected. After several hours of
    discussion and\r\ndevelopment, we ended up with something that almost worked but
    still had\r\nmany kinks to be ironed out. Almost immediately after we deployed
    the feature\r\nto production, we noticed that it wasn't working as expected and\r\nimmediately
    rolled it back.\r\n\r\nWe thought for some time about what would be needed in
    order to fix the\r\nremaining issues and eventually came to realize that we had
    overlooked an\r\nobvious shortcut: instead of fully automating cancellations,
    we could make it so\r\nthe unsubscribe button sent us an email with all the details
    necessary to close\r\naccounts upon request. This process takes only a few seconds
    to do manually and\r\nhappens only a few times a week. Most important, the semi-automatic\r\napproach
    was easy to understand with few potential points of failure and could\r\nbe designed,
    implemented, and tested in less time than it took for us to think\r\nthrough the
    issues of the more complicated system. In other words, it required\r\nless effort
    to ship this simple system than it would have taken to fix the\r\ncomplicated
    one, so we scrapped the old code.\r\n\r\n---\r\n\r\nEvery situation is different,
    but hopefully these examples have driven home the\r\npoint that dealing with bugs
    requires effort that might or might not be better spent\r\nelsewhere. In summary:\r\n\r\n>
    Critical flaws and trivial errors both deserve immediate attention: the former\r\n>
    because of their impact on people, the latter due to the fact that they get\r\n>
    harder to fix as they accumulate. Unfortunately, most bugs are in-between these
    two extremes and must be evaluated on a case-by-case basis.\r\n\r\n> You can't
    just decide whether a bug is worth fixing based on the utility of the\r\n> individual
    feature it affects: you need to think about whether your time would be\r\n> better
    spent working on other things. It is worth resolving defects only\r\n> if the
    answer to that question is \"No!\". Even if it is emotionally challenging\r\n>
    to do so, sometimes it makes sense to kill off a single buggy feature if doing\r\n>
    so improves the overall quality of your system.\r\n\r\nOf course, if you do decide
    to fix a bug, you need to do what you can to prevent\r\nthat time investment from
    going to waste. Regression testing can help with that,\r\nand that's why we've
    included it as the sixth and final lesson in this article.\r\n\r\n### Lesson 6:
    Prevent regressions \r\n\r\nOne clear pattern that time has taught us is that
    all bugs that are not covered by\r\na test eventually come back. To prevent this
    from happening, we\r\ntry to write UI-level acceptance tests to replicate defects
    as the first step \r\nin our bug-fixing process rather than the last.\r\n\r\nAdopting
    this practice was very tedious at first. Even though [Capybara][capybara]\r\nmade
    it easy to simulate browser-based interactions with our application, \r\ndropping
    down to that level of abstraction every time we found a new\r\ndefect both slowed
    us down and frustrated us. We eventually realized that we\r\nneeded to reduce
    the friction of writing our tests if we wanted this good habit\r\nto stick. To
    do so, we started to experiment with some ideas I hinted at\r\nback in [Issue
    4.12.1][pr-4.12.1]: application-specific helper objects for \r\nend-to-end testing.
    We eventually ended up with tests that look something like\r\nthe following example:\r\n\r\n```ruby\r\nclass
    ProfileTest < ActionDispatch::IntegrationTest\r\n  test \"contact email is validated\"
    do\r\n    simulate_user do\r\n      register(Support::SimulatedUser.default)\r\n
    \     edit_profile(:email => \"jordan byron at gmail dot com\")\r\n    end\r\n\r\n
    \   assert_content \"Contact email is invalid\"\r\n  end\r\n\r\n  # ...\r\nend\r\n```\r\n\r\nIf
    you strip away the syntactic sugar that the `simulate_user` method provides,\r\nyou'll
    find that this is what is really going on under the hood:\r\n\r\n```ruby\r\ntest
    \"contact email is validated\" do\r\n  user = Support::SimulatedUser.new(self)\r\n\r\n
    \ user.register(Support::SimulatedUser.default)\r\n  user.edit_profile(:email
    => \"jordan byron at gmail dot com\")\r\n\r\n  assert_content \"Contact email
    is invalid\"\r\nend\r\n```\r\n\r\nEven without reading the [implementation of
    Support::SimulatedUser][simulated-user],\r\nyou have probably already guessed
    that it is a simple wrapper around Capybara's\r\nfunctionality that provides application-specific
    helpers. This object provides\r\nus with two main benefits: reduced duplication
    in our tests, and a vocabulary\r\nthat matches our application's domain rather
    than its delivery mechanism. The\r\nlatter feature is what reduces the pain of
    assembling tests to go along \r\nwith our bug reports.\r\n\r\nLet's take a moment
    to consider the broader context of how this email\r\nvalidation test came into
    existence in the first place. Like many changes we\r\nmake to Practicing Ruby,
    this particular one was triggered by an exception\r\nreport that revealed to us
    that we had not been sanity-checking email \r\naddresses before updating them.
    This problem was causing a 500 error to be \r\nraised rather than failing gracefully
    with a useful failure message, which pretty\r\nmuch guaranteed a miserable experience
    for anyone who encountered it. The steps\r\nto reproduce this issue from scratch
    are roughly as follows:\r\n\r\n1. The user registers for Practicing Ruby.\r\n2.
    The user attempts to edit his or her profile with a badly formatted email address.\r\n3.
    The user *should* see a message saying that the email is invalid but\r\ninstead
    encounters a 500 error and a generic \"We're sorry, something went wrong\"\r\nmessage.\r\n\r\nIf
    you compare these steps to the ones that are covered by the test, you'll see\r\nthat
    they are almost identical to one another. Although the verbal description is\r\nsomething
    that may be easier to read for nonprogrammers, the tests communicate\r\nthe same
    idea at nearly the same level of abstraction and clarity to anyone who\r\nknows
    how to write Ruby code. Because of this, it isn't as easy for us to\r\ncome up
    with a valid excuse for not writing a test or putting it off until\r\nlater.\r\n\r\nOf
    course, old habits die hard, and occasionally we still cut corners when\r\ntrying
    to fix bugs. Every time we encounter an interaction that our\r\n`SimulatedUser`
    has not yet been programmed to handle, we experience the same\r\nfriction that
    makes it frustrating to write acceptance tests in the first place.\r\nWhen that
    happens, it's tempting to put things off or to cobble together a test\r\nin haste
    that verifies the behavior, but in a sloppy way that doesn't make\r\nfuture tests
    easier to write. The lesson here is simple: even the most\r\ndisciplined processes
    can easily break down when life gets too busy or too\r\nstressful.\r\n\r\nTo mitigate
    these issues, we rely once again on the same practice that allows \r\nus to let
    fewer bugs slip into production in the first place: active peer\r\nreview. Whenever
    one of us fixes a bug, the other person reviews it for quality and\r\ncompleteness.
    This process puts a bit of peer pressure on both of us to not be sloppy\r\nabout
    our bug fixes and also helps us catch issues that would otherwise hide\r\naway
    in our individual blind spots. \r\n\r\nIn summary, this approach towards regression
    testing has taught us the following\r\nlesson:\r\n\r\n> Any time not spent hunting
    down old bugs or trying to pin down new ones is \r\ntime that can be spent on
    value-producing work. Automated testing can really\r\nhelp in this context, but
    only if the friction of writing new high-level tests\r\nis minimized.\r\n\r\n>
    Even with convenient application-level test helpers, it can still be tedious\r\nto
    test behaviors that haven't been considered before, which makes it tempting\r\nto
    cut corners or to leave out testing entirely in the hopes that someone else \r\nwill
    get to it later. To keep us from doing this, bug fixes should be reviewed for
    \r\nquality just as improvements are, and their tests should be augmented as\r\nneeded
    whenever they seem to come up short.\r\n\r\nIt does require a little bit of will
    power, but this habit can work\r\nwonders over time. The trick is to make practicing
    it as easy as \r\npossible so that it doesn't bog you down.\r\n\r\n### Reflections\r\n\r\nDo
    we follow all of these practices completely and consistently without fail? Of\r\ncourse
    not! But we do try to follow them most of the time, and we have\r\nfound that
    they work best when done together. That's not to say\r\nthat removing or changing
    any one ingredient would spoil the soup, only that\r\nit's hard for us to guess
    what their effects would be like in isolation.\r\n\r\nIt's important to point
    out that we adopted these ideas organically rather\r\nthan carefully designing
    a process for ourselves to rigidly follow. This article\r\nis more of a description
    of how we viewed things at the time it was\r\npublished than a prescription for
    how people ought to approach all\r\nprojects all the time. We've found that it's
    best to maintain a consistent\r\nbroad-based goal (ours is to make the best possible
    user experience with the\r\nleast effort) and to continuously tweak your processes
    as needed to meet that\r\ngoal. Working habits need to be treated with a bit of
    fluidity because brittle\r\nprocesses can kill a project even faster than brittle
    code can.\r\n\r\nIn the end, much of this is very subjective and context dependent.
    I've shared\r\nwhat works for us in the hopes that it'll be helpful to you, but
    I want to\r\nhear about your own experiences as well. Because our process is\r\nnothing
    more than an amalgamation of good ideas that other people have come up\r\nwith,
    I'd love to hear what you think might be worth adding to the mix.\r\n\r\n> **UPDATE**:
    Although this article recommends using `tail -f` to watch logs in real\r\n> time,
    it may be [better to use less +F][less], because it makes scrollbacks\r\n> easier
    and can resume real-time monitoring at any time. Thanks to @sduckett for the suggestion.\r\n\r\n[mendicant]:
    http://mendicantuniversity.org\r\n[travis]: http://about.travis-ci.org/docs/user/getting-started/\r\n[lean]:
    http://en.wikipedia.org/wiki/Lean_software_development \r\n[exception-notification]:
    https://github.com/smartinez87/exception_notification\r\n[gh-flow]: http://scottchacon.com/2011/08/31/github-flow.html\r\n[capybara]:
    https://github.com/jnicklas/capybara\r\n[pr-4.12.1]: http://practicingruby.com/articles/66\r\n[simulated-user]:
    https://github.com/elm-city-craftworks/practicing-ruby-web/blob/f00f89b0a547829aea4ced523a3d23a136f1a6a7/test/support/simulated_user.rb\r\n[autonomation]:
    http://en.wikipedia.org/wiki/Autonomation\r\n[htmlescape]: https://github.com/elm-city-craftworks/practicing-ruby-web/commit/223ca92a0b769713ce3c2137de76a8f34f06647e\r\n[gh-deploy-aug-2012]:
    https://github.com/blog/1241-deploying-at-github\r\n[pr-76]: https://github.com/elm-city-craftworks/practicing-ruby-web/pull/76\r\n[less]:
    http://blog.libinpan.com/2009/07/less-is-better-than-tail/\r\n"
- :slug: relationships-between-objects
  :title: Understanding the relationships between objects
  :summary: Learn how to model dependencies, notifications, adjustments, and internal
    object relationships.
  :published: 2012-10-28 00:00:00.000000000 Z
  :issue_number: '5.7'
  :volume: 5
  :body: "> **CREDIT:** Although this article is my own work, it is based on ideas
    I got from\r\n> a very different but interesting [early draft][dna-draft] from
    Practicing Ruby reader\r\n> [Mike Subelsky][subelsky]. I owe him a huge hat tip
    for suggesting that we cover\r\n> this topic and for helping me get started with
    it.\r\n\r\nThe challenge of sensibly connecting a set of objects together to perform
    a\r\ncomplex task is one that confounds programmers of all skill levels. In fact,
    \r\nit is hard to reason about the relationships between objects without getting
    \r\ntrapped by analysis paralysis. With that in mind, it is no surprise that so\r\nmany
    of us struggle with this particular aspect of object-oriented programming. \r\n\r\nBut
    like so many other problems we encounter in our work, this one can\r\nbe simplified
    greatly by introducing a common vocabulary and some rough\r\nheuristics that make
    thinking and communicating about our code easier.\r\nFor reasoning about this
    particular design challenge, the \r\n\"Object Peer Stereotypes\" described in
    [Growing Object-Oriented Software, Guided\r\nby Tests][GOOS] give us some very
    useful conceptual tools \r\nto work with.\r\n\r\nIn this article, we will explore
    the three stereotypical relationships \r\nbetween an object and its peers that
    were described in GOOS: \r\ndependencies, notifications, and adjustments. Taken
    together, these \r\nrough categorizations do a good job of identifying the kinds
    of\r\nconnections that exist between objects, which makes it easier\r\nto develop
    a more nuanced view of how they communicate with each other.\r\n\r\nThe specific
    examples in this article are based on code from \r\n[Newman][newman] (my experimental
    email-based microframework), but the\r\ngeneral concepts that we'll discuss are
    relevant to all object-oriented \r\nsoftware. If you keep your own projects in
    the back of your mind as you\r\nread on, you'll easily find similarities between
    Newman's design \r\nchallenges and your own.\r\n\r\n## Dependencies\r\n\r\n> Services
    that the object requires from its peers so it can perform its\r\n> responsibilities.
    The object cannot function without these services. It should\r\n> not be possible
    to create the object without them. (GOOS, pg. 52)\r\n\r\nWhether they are internal
    or external, dependency relationships need to be\r\ncarefully managed in order
    to prevent brittleness. \r\nAlistair Cockburn's [ports and adapters][ports-and-adapters]
    pattern provides\r\none way of dealing with this problem: define abstract *ports*
    in the \r\napplication's domain language that covers slices of functionality,
    and then build \r\nimplementation-specific *adapters* with compatible interfaces.
    This approach allows dependencies \r\nto be reasoned about at a higher level of
    abstraction and makes it so that systems \r\ncan be easily changed.\r\n\r\nWe
    applied this pattern (albeit without recognizing it by name) when thinking\r\nthrough
    how Newman should handle its email dependency. We knew from the outset\r\nthat
    we'd need to support some sort of test mailer and that it should be a\r\ndrop-in
    replacement for its real mailer. We also anticipated that down the line\r\nwe
    might want to support delivery mechanisms other than the `mail` gem and\r\nfigured
    that some sort of adapter-based approach would be a good fit.\r\n\r\nConstructing
    a port involves thinking through the various ways a \r\nsubsystem will be used
    within your application and then \r\nmapping a protocol to those use cases. In
    Newman, we expected that\r\nour email dependency would need to support the following
    requirements:\r\n\r\n1) Read configuration data from a `Newman::Settings` object
    if necessary.\r\n\r\n```ruby\r\nmailer = AnyMailAdapter.new(settings)\r\n```\r\n\r\n2)
    Retrieve all messages from an inbox, deleting them from the server in the\r\nprocess.\r\n\r\n```ruby\r\nmailer.messages.each
    do |message|\r\n  do_something_exciting(message) \r\nend\r\n```\r\n\r\n3) Construct
    a complete message and deliver it immediately.\r\n\r\n```ruby\r\nmailer.deliver_message(:to
    \     => \"test@test.com\",\r\n                       :from    => \"gregory@practicingruby.com\",\r\n
    \                      :subject => \"A special offer for you!!!\",\r\n                       :body
    \   => \"Send me your credit card number, plz!\")\r\n```\r\n\r\n4) Construct a
    message incrementally and then deliver it later, if at all. \r\n\r\n```ruby\r\nmessage
    = mailer.new_message(:to   => \"test@test.com\",\r\n                             :from
    => \"gregory@practicingruby.com\")\r\n\r\nif bank_account.balance < 1_000_000_000\r\n
    \ message.subject = \"Can I interest you in some prescription painkillers?\"\r\n
    \ message.body    = \"Best prices anywhere on the internets!!!\"\r\n  messsage.deliver\r\nend\r\n```\r\n\r\nAlthough
    you can make an educated guess about how to implement adapters\r\nfor this port
    based on the previous examples, there are many\r\nunanswered questions lurking
    just beneath the surface. This is where\r\nthe difference between *interfaces*
    and *protocols* becomes important:\r\n\r\n> An interface defines whether two things
    can fit together, a protocol \r\ndefines whether two things can *work together*
    (GOOS, pg. 58)\r\n\r\nIf you revisit the code examples shown above, you'll notice
    that the interface\r\nrequirements for a Newman-compatible mail adapter are roughly
    as follows:\r\n\r\n* The constructor accepts one argument (the settings object).\r\n*
    The `messages` method returns an collection that responds to `each` and yields\r\nan
    object for each message in the inbox.\r\n* The `deliver_message` accepts one argument
    (a parameters hash).\r\n* The `new_message` method accepts a parameters hash and
    returns\r\nan object representing the message. At a minimum, the object allows
    certain fields\r\nto be set (i.e., `subject` and `body`) and responds to a `deliver`
    method.\r\n\r\nBuilding an object that satisfies these requirements is trivial,
    but there is\r\nno guarantee that doing so will result in an adapter that conforms
    to the\r\n*protocol* that Newman expects. Unfortunately, protocols are much harder\r\nto
    reason about and define than interfaces are.\r\n\r\nLike many Ruby libraries,
    Newman relies on loose [duck typing][duck typing] \r\nrather than a formal behavioral
    contract to determine whether one adapter can \r\nserve as a drop-in replacement
    for another. The `Newman::Mailer` object is used\r\nby default, so it defines
    the canonical implementation that \r\nother adapters are expected to mimic at
    the functional level -- even if they \r\nhandle things very differently under
    the hood. This implicit contract makes \r\nit possible for `Newman::TestMailer`
    to stand in for \r\na `Newman::Mailer` object, even though it stores all incoming
    and \r\noutgoing messages in memory rather than relying on SMTP and IMAP. Because\r\nthe
    two objects respond to the same messages in similar ways, the systems\r\nthat
    depend on them are unaware of their differences in implementation -- they\r\nare
    just two different adapters that both fit in the same port.\r\n\r\nIf you read
    through the source of the [Newman::Mailer][newman-mailer] \r\nand [Newman::TestMailer][newman-testmailer]
    objects, you will find that\r\nseveral compromises have been made for the sake
    of convenience:\r\n\r\n1. Arguments for the `new_message` and `deliver_message`
    methods on both \r\nadapters are directly delegated to the `Mail::Message` constructor,
    and the\r\nreturn value of `messages` on both adapters is a collection \r\nof
    `Mail::Message` objects. This design implicitly ties the interface of those \r\nmethods
    to the mail gem; it's what GOOS calls a *hidden dependency*.\r\n\r\n2. The `Newman::TestMailer`
    object is a singleton object, but it\r\nimplements a fake constructor in order
    to maintain interface compatibility \r\nwith `Newman::Mailer`. This is an example
    of how constraints \r\nfrom dependencies can spill over into client code.\r\n\r\n3.
    Configuration data is completely ignored by `Newman::TestMailer`. Because\r\nall
    of its operations are done in memory, it has no need for SMTP and IMAP\r\nsettings,
    but it needs to accept the settings object anyway for the \r\nsake of maintaining
    interface compatibility.\r\n\r\nAll of these warts stem from protocol issues.
    The first issue is due to\r\nunderspecification: Newman has a clear protocol for
    creating, retrieving, and\r\nsending messages, but it does not clearly define
    what it expects the messages\r\nthemselves to look like. The coupling between
    the interface of `Newman::Mailer`\r\nand that of `Mail::Message` makes it so that
    other adapters must also inherit\r\nthis hidden dependency. Because `Newman::TestMailer`
    also explicitly depends \r\nupon `Mail::Message`, this constraint does not complicate
    its implementation,\r\nbut it certainly does make it harder to build adapters
    that aren't dependent \r\non the mail gem.\r\n\r\nOn the flip side, the second
    and third issues are a result of \r\noverspecification. We didn't want to make
    `Newman::TestMailer` a singleton, \r\nbut because the underlying `Mail::TestMailer`
    is implemented that way,\r\nwe didn't have much of a choice. Our decision to implement
    a fake constructor\r\nin order to maintain compatibility with `Newman::Mailer`
    is something I was\r\nnever happy with, but I also couldn't think of a better\r\nalternative.
    I am somewhat less concerned about `Mailer::TestMailer` having to\r\naccept a
    settings object that it doesn't actually use, but it does feel like one\r\nextra
    hoop to jump through simply for the sake of consistency.\r\n\r\nDespite these
    rough edges, Newman's way of handling its email dependency is a\r\ngood example
    of the [ports and adapters][ports-and-adapters] pattern in the \r\nwild. If anything,
    it serves as a reminder that the hard part of writing loosely\r\ncoupled code
    is not in the creation of duck-typed adapters, but in clearly\r\ndefining the
    protocol for our ports. This concept takes us beyond the idea of \"coding to\r\nan
    interface rather than an implementation\" and is worth ruminating\r\nover.\r\n\r\n##
    Notifications\r\n\r\n> Peers that need to be kept up to date with the objects
    activity. The object\r\n> will notify interested peers whenever it changes state
    or performs a\r\n> significant action. Notifications are fire and forget; the
    object neither\r\n> knows nor cares which peers are listening. (GOOS, pg. 52)\r\n\r\nBecause
    Ruby is a message-oriented programming language, it is easy to model\r\nmany kinds
    of object relationships as notifications. Doing so greatly reduces\r\nthe coupling
    between objects and helps establish a straight-line flow from a \r\nsystem's inputs
    to its outputs.\r\n\r\nNotification-based modeling is especially useful when designing
    framework code,\r\nbecause it is important for frameworks to know as little as
    possible about the\r\napplications that are built on top of them. The general
    design of\r\nthe extremely popular [rack web server interface][rack] leverages
    these ideas to\r\ngreat effect; it assumes that its applications implement a meaningful\r\n`call`
    method, but otherwise remains blissfully ignorant of their behaviors.\r\n\r\nWe
    have designed Newman using a similar\r\nstrategy, and the general idea can be
    understood by tracing the execution of\r\nthe `Newman::Server#tick` method:\r\n\r\n```ruby\r\nmodule
    Newman\r\n  class Server\r\n    # NOTE: the mailer, apps, logger, and settings
    dependencies\r\n    # are initialized when a Server instance is instantiated\r\n\r\n
    \   def tick\r\n      mailer.messages.each do |request|\r\n        response =
    mailer.new_message(:to   => request.from,\r\n                                      :from
    => settings.service.default_sender)\r\n\r\n        process_request(request, response)
    && response.deliver\r\n      end\r\n\r\n      # ... error handling code omitted\r\n
    \   end\r\n\r\n\r\n    def process_request(request, response)\r\n      apps.each
    do |app|\r\n        app.call(:request  => request,\r\n                 :response
    => response,\r\n                 :settings => settings,\r\n                 :logger
    \  => logger)\r\n      end\r\n\r\n      return true\r\n\r\n      # ... error handling
    code omitted\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nDid you figure out how it
    works? Let's walk through the process step by step to\r\nconfirm:\r\n\r\n1. The
    `tick` method walks over each incoming message currently queued by the\r\n`mailer`
    object (i.e., the `request`).\r\n\r\n2. A `response` message is constructed and
    addressed to the sender of\r\nthe `request`.\r\n\r\n3. The `process_request` method
    is called, which iterates over a\r\ncollection, executing the `call` method on
    each element and passing along\r\nseveral dependencies that can be used to finish
    building a meaningful\r\n`response` message.\r\n\r\n4. Once `process_request`
    completes successfully, the response is delivered.\r\n\r\nBecause `Newman::Server`
    has a notification-based relationship with its\r\n`apps` collection, it does not
    know or care about the structure of those\r\nobjects. In fact, the contract is
    so simple that a trivial `Proc` object \r\ncan serve as a fully functioning Newman
    application:\r\n\r\n```ruby\r\nGreeter = ->(params) { |params| params[:response].subject
    = \"Hello World!\" }\r\n\r\nserver.apps = [Greeter]\r\nserver.tick\r\n```\r\n\r\nIf
    we wanted to make things a bit more interesting, we could add request\r\nand response
    logging into the mix, using Newman's built-in features:\r\n\r\n```ruby\r\nGreeter
    = ->(params) { |params| params[:response].subject = \"Hello World!\" }\r\n\r\nserver.apps
    = [Newman::RequestLogger, Greeter, Newman::ResponseLogger]\r\nserver.tick\r\n```\r\n\r\nThese
    objects make use of a mixin that simplifies email logging, but as you can\r\nsee
    from the following code, they have no knowledge of the `Newman::Server`\r\nobject
    and rely entirely on the parameters being passed into their `#call`\r\nmethod:\r\n\r\n```ruby\r\nmodule
    Newman\r\n  class << (RequestLogger = Object.new)\r\n    include EmailLogger\r\n\r\n
    \   def call(params)\r\n      log_email(params[:logger], \"REQUEST\", params[:request])
    \r\n    end\r\n  end\r\n\r\n  class << (ResponseLogger = Object.new)\r\n    include
    EmailLogger\r\n\r\n    def call(params)\r\n      log_email(params[:logger], \"RESPONSE\",
    params[:response])\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nTaken together, these
    four objects combined form a cohesive workflow:\r\n\r\n1. The server receives
    incoming emails and passes them on to its `apps` for\r\nprocessing, along with
    a placeholder `response` object.\r\n\r\n2. The request logger inspects the incoming
    email and records debugging \r\ninformation.\r\n\r\n3. The greeter sets the subject
    of the outgoing response to \"Hello World\".\r\n\r\n4. The response logger inspects
    the outgoing email and records debugging\r\ninformation.\r\n\r\n5. The server
    sends the response email.\r\n\r\nThe remarkable thing is not this semimundane
    process, but that the\r\nobjects involved know virtually nothing about their collaborators
    and are unaware of their position in the sequence of events. Context-independence\r\n(*GOOS,
    pg. 54*) is a powerful thing, because it allows each object to be reasoned\r\nabout,
    tested, and developed in isolation.\r\n\r\nThe implications of notification-based
    modeling extend far beyond\r\ncontext independence, but it wouldn't be easy to
    summarize them in \r\na few short sentences. Fortunately, this topic has been
    covered \r\nextensively in other Practicing Ruby articles, particularly in \r\n[Issue
    4.11][pr-4.11] and [Issue 5.2][pr-5.2]. Be sure to\r\nread those articles if you
    haven't already; they are among the finest in our\r\ncollection.\r\n\r\n## Adjustments\r\n\r\n>
    Peers that adjust the objects behavior to the wider needs of the system. This\r\nincludes
    policy objects that make decisions on the objects behalf . . . and\r\ncomponent
    parts of the object if its a composite. (GOOS, pg. 52)\r\n\r\nAdjustment relationships
    are hard to summarize, because they can exist in so \r\nmany forms. But regardless
    of the form they take on, adjustments tend to be\r\nused to bridge the gap between
    different levels of abstraction. Some are used\r\nto raise the level of abstraction
    by wrapping a specific object in a more\r\ngeneric interface, and others are designed
    to do the opposite. \r\n\r\nFor an example of climbing down the ladder of abstraction,
    consider \r\n`Newman::EmailLogger`. It is implemented as a module in Newman for
    convenience,\r\nbut it could easily be reimagined as a stateless peer object of
    `RequestLogger`\r\nand `ResponseLogger`. Such a redesign would yield something
    similar to the\r\nfollowing code:\r\n\r\n```ruby\r\nmodule Newman\r\n  class <<
    (EmailLogger = Object.new)\r\n    def log_email(logger, prefix, email)\r\n      logger.debug(prefix)
    { \"\\n#{email}\" }\r\n      logger.info(prefix) { email_summary(email) }\r\n
    \   end\r\n\r\n    private\r\n\r\n    def email_summary(email)\r\n      { :from
    \    => email.from,\r\n        :to       => email.to,\r\n        :bcc      =>
    email.bcc,\r\n        :subject  => email.subject,\r\n        :reply_to => email.reply_to
    }\r\n    end    \r\n  end\r\n\r\n  RequestLogger = ->(params) {  \r\n    EmailLogger.log_email(params[:logger],
    \"REQUEST\", params[:request])\r\n  }\r\n\r\n  ResponseLogger = ->(params) {\r\n
    \   EmailLogger.log_email(params[:logger], \"RESPONSE\", params[:response])\r\n
    \ }\r\nend\r\n```\r\n\r\nThough this is a subtle change, it lifts up and centralizes
    the concept of\r\n\"email logging\" into a single object, rather than mixing helper
    methods into\r\nvarious objects that need that functionality. This adjustment
    helps define the borders\r\nbetween distinct concepts within the code and establishes
    `EmailLogger` as an\r\nadjustment to the much more general `Logger` object it
    depends upon.\r\n\r\nThe philosophical distinction between these two objects is
    what matters here. \r\nA `Logger` has very abstract responsibilities: it must
    record arbitrary strings \r\nat various levels of severity and then format and
    output them to various \r\nstreams. `EmailLogger`, on the other hand, is extremely
    concrete in its\r\nresponsibilities: it uses a `Logger` to report debugging information
    about\r\nan email message. The details of how the actual logging happens are hidden
    from\r\n`EmailLogger`'s clients, making it easier to treat as a black box.\r\n\r\nSimple
    designs can also emerge from climbing the ladder of abstraction, \r\nthat is,
    moving from a very specific context to a much more general one. For\r\nexample,
    it might not be a bad idea to introduce an object into Newman \r\nthat encapsulates
    the concept of an email message but leaves the exact\r\ndelivery mechanism up
    to the individual adapters:\r\n\r\n```ruby\r\n# this code would be in an adapter
    or application code\r\nmessage = Newman::Message.new { |params| Mail::Message.new(params).deliver
    }\r\n\r\n# elsewhere, no knowledge of the dependency on the mail gem would be
    necessary:\r\nmessage.to      = \"test@test.com\"\r\nmessage.from    = \"gregory@practicingruby.com\"\r\nmessage.subject
    = \"You have won twenty bazillion dollars!\"\r\nmessage.body    = \"Please send
    us a hair sample to confirm your ID\"\r\n\r\nmessage.deliver\r\n```\r\n\r\nThis
    kind of object is trivial to implement because it is nothing more\r\nthan a value
    object with a simple callback mechanism bolted on top of it:\r\n\r\n```ruby\r\nmodule
    Newman \r\n  class Message\r\n    def initialize(&delivery_callback)\r\n      self.delivery_callback
    = delivery_callback\r\n    end\r\n\r\n    attr_accessor :to, :from, :subject,
    :body\r\n\r\n    def deliver\r\n      raise NotImplementedError unless delivery_callback\r\n\r\n
    \     delivery_callback.(:to      => to,      :from => from, \r\n                         :subject
    => subject, :body => body)\r\n    end\r\n\r\n    private\r\n\r\n    attr_accessor
    :delivery_callback\r\n  end\r\nend\r\n```\r\n\r\nDespite its simplicity, this
    object provides a useful benefit: it explicitly\r\nseparates the protocol of message
    delivery from its implementation. If all\r\nmail adapters for Newman were expected
    to return only `Newman::Message` objects, \r\nthen any message-processing code
    within Newman (either in the server or in\r\napplication code) would have a well-defined
    interface to work against. Although\r\nthis requirement would make adapters slightly
    more cumbersome to write, it would\r\ncompletely eliminate the hidden dependency
    issue discussed earlier.\r\n\r\nRegardless of which direction they are pointed
    in, adjustment relationships are\r\nvery closely related to the concept of object
    composition in general. With that\r\nin mind, the authors of GOOS have a useful
    rule to consider when designing \r\ncomposite objects:\r\n\r\n> The API of a composite
    object should not be more complicated than that of any\r\n> of its components.
    (GOOS, pg. 54)\r\n\r\nNotice that in both the `Newman::EmailLogger` example and
    the `Newman::Message`\r\nobject, the result of composition is that a more complex
    system is being wrapped\r\nby something with fewer methods and concepts to worry
    about. When applied\r\nrepeatedly, this kind of design causes software to become
    more simple as it\r\ngrows.\r\n\r\n## Reflections\r\n\r\nThe benefit I have gained
    from being able to explicitly label various \r\nobject relationships as dependencies,
    notifications, and adjustments is that\r\nit forces me to think about my code
    in a more fine-grained way. Each\r\nkind of object relationship comes with benefits
    and costs that are easier to\r\nreason about when you recognize them for what
    they are.\r\n\r\nAs with most ideas from [Growing Object-Oriented Software, Guided
    by Tests][GOOS],\r\nI have not yet had a chance to apply this particular set of
    heuristics\r\nfrequently enough to know the full extent of their usefulness. However,
    it never\r\nhurts to have specific words to describe ideas that previously were
    hard for me\r\nto express without relying heavily on intuition.\r\n\r\nI would
    love to hear from you if you can think of ways to connect these ideas\r\nback
    to your own projects or to the open source projects you've worked with. If\r\nyou
    have an interesting story to share, please leave a comment!\r\n\r\n[GOOS]: http://www.growing-object-oriented-software.com/\r\n[rack]:
    http://rack.github.com/\r\n[pr-4.11]: https://practicingruby.com/articles/64\r\n[pr-5.2]:
    https://practicingruby.com/articles/71\r\n[ports-and-adapters]: http://alistair.cockburn.us/Hexagonal+architecture\r\n[newman-mailer]:
    http://elm-city-craftworks.github.com/newman/lib/newman/mailer.html\r\n[newman-testmailer]:
    http://elm-city-craftworks.github.com/newman/lib/newman/test_mailer.html\r\n[duck
    typing]: http://en.wikipedia.org/wiki/Duck_typing\r\n[newman]: https://github.com/elm-city-craftworks/newman\r\n[subelsky]:
    http://www.subelsky.com/\r\n[dna-draft]: http://www.subelsky.com/2012/11/ruby-dependencies-notifications-and.html\r\n"
- :slug: expanding-your-code-reading-horizons
  :title: Expanding your code reading horizons
  :summary: See how much even a few dozen lines of code can tell you about a programming
    language.
  :published: 2012-11-13 00:00:00.000000000 Z
  :issue_number: '5.8'
  :volume: 5
  :body: "An interesting thing about learning new programming languages is that it
    takes\r\nmuch less time to learn how to read programs than it does to write them.
    While\r\nbuilding non-trivial software in a language you are not familiar with
    can take weeks\r\nor months of dedicated practice, the same software could be
    read and understood\r\nin a fraction of that time. \r\n\r\nBecause programming
    languages are much more similar to the formal language of \r\nmathematics than
    they are to natural languages, people from diverse backgrounds \r\ncan communicate
    complex ideas with a surprising lack of friction. Unfortunately,\r\nwe often forget
    this point because we are overwhelmed by the memories of how\r\nhard it is to
    *write* elegant code in a new language. This tendency puts us at a\r\ntremendous
    disadvantage, because it causes us to artifically limit our access to\r\nvaluable
    learning resources.\r\n\r\nIn this article, I will walk you through an example
    of how I was plagued by this\r\nvery fear, how I overcame it, and how that lead
    me to learn a lot \r\nabout [Clojure][clojure] in a very short period of time.
    My hope is that by following \r\nin my footsteps, you'll be able to learn the
    technique I used and possibly apply\r\nit to your own studies.\r\n\r\n## How I
    finally learned about Ant Colony Optimization\r\n\r\nFor a few weeks before this
    article was published, I was busy\r\nresearching  [swarm intelligence][swarm].
    I have always been fascinated by \r\nhow nature-inspired algorithms can be used
    to solve surprisingly complex \r\ncomputing problems, and I decided that I wanted
    to try implementing some \r\nof them myself. I started off by implementing the
    [Boids algorithm][boids], \r\nand was surprised at how quickly I was able to get
    something vaguely \r\nresembling a flock of birds to appear on my screen. Motivated
    by that small\r\nwin, I decided to try my hand at simulating an [Ant Colony][aco].\r\n\r\nOn
    the surface, ant behavior is deceptively simple, even intuitive. At least,\r\nthat
    is what the description provided by Wikipedia would have you believe:\r\n\r\n1.
    An ant (called \"blitz\") runs more or less at random around the colony;\r\n2.
    If it discovers a food source, it returns more or less directly to the nest, leaving
    in its path a trail of pheromone;\r\n3. These pheromones are attractive; nearby
    ants will be inclined to follow, more or less directly, the track;\r\n4. Returning
    to the colony, these ants will strengthen the route;\r\n5. If there are two routes
    to reach the same food source then, in a given amount of time, the shorter one
    will be traveled by more ants than the long route;\r\n6. The short route will
    be increasingly enhanced, and therefore become more attractive;\r\n7. The long
    route will eventually disappear because pheromones are volatile;\r\n8. Eventually,
    all the ants have determined and therefore \"chosen\" the shortest route.\r\n\r\nUnfortunately,
    it is hard to find resources that precisely describe the rules\r\nthat govern
    each of these behaviors, and those that do exist are highly abstract\r\nand mathematical.
    While I'm not one to shy away from theoretical papers, I\r\nusually like to approach
    them once I understand a concept fairly well in\r\npractice. For this particular
    problem, I was unable to find the materials \r\nthat would get to that point,
    and it felt like I was hitting a brick wall.\r\n\r\nAlthough I found tons of examples
    of applying a generalized form of ant colony \r\noptimization to the traveling
    salesman problem, I wanted to start with a more \r\ndirect simulation of the natural
    behavior. After digging around for a bit, I\r\nfound [Rich Hickey's ant simulator][sim],
    which is implemented \r\nin [Clojure][clojure]. Check out the video below to see
    what it looks like in action:\r\n\r\n<div align=\"center\">\r\n<iframe width=\"720\"
    height=\"480\"\r\nsrc=\"//www.youtube.com/embed/shm7QcJMvig?rel=0\" frameborder=\"0\"
    allowfullscreen></iframe>\r\n</div>\r\n\r\nI knew right away that this was exactly
    the kind of simulation I wanted to\r\nbuild, but it honestly didn't even cross
    my mind to attempt to read the Clojure\r\ncode and port it to Ruby. One quick
    glance at its [source code][sim] reminded me\r\njust how much I wanted to learn
    a Lisp dialect some day, but it definitely\r\nwasn't going to be today! I didn't
    have time to go dust off the books on my\r\nshelf that I never read, or to watch
    the [2.5 hour long video][hickey] of the\r\ntalk that this code came from. \r\n\r\nSo
    instead of doing all that, I set off to build my own implementation from\r\nscratch
    by cobbling together the bits of information I had collected\r\ninto something
    that sort of worked. Using the general description of ant\r\nbehavior as my guide,
    I left it up to my imagination to fill in the details, and\r\nwithin an hour or
    so I had built something that had ants moving around the\r\nscreen. Unfortunately,
    my little family of ants seemed to have come from a\r\nfailed evolutionary branch,
    because they didn't do what they were supposed to\r\ndo! They'd wander around
    randomly, get stuck, choose the wrong food sources, and\r\ngenerally misbehave
    in all sorts of painful ways. Thinking that I needed a\r\nbreak, I stepped away
    from the project for a day so that I could come back to it\r\nwith a fresh perspective.\r\n\r\nThe
    next day, I did end up getting something vaguely resembling an ant colony to\r\nappear
    on my screen. The behavior was not perfect, but it illustrated the main \r\nidea
    of the algorithm:\r\n\r\n<div align=\"center\">\r\n<iframe width=\"720\" height=\"480\"\r\nsrc=\"//www.youtube.com/embed/p_XmuRHs57g?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n</div>\r\n\r\nIt was fairly easy
    to get to this point, but then it became extremely hard to \r\nimprove upon the
    simulator. Ant colony optimization has a lot of variables to it\r\n(i.e. things
    like the size of the world, number of ants, number of food sources,\r\npheremone
    decay rate, amount of pheremone dropped per iteration, etc). Changing\r\nany one
    of these things can influence the effectiveness of the others. When you\r\ncombine
    this variability with an implementation where the actual behaviors were \r\nhalf-baked
    and possibly buggy, you end up with a big mess that is hard to debug,\r\nand even
    harder to understand. Knowing that my code was in really bad shape,\r\nI was ready
    to give up.\r\n\r\nAlthough it took a lot of rumination to get me there, the lightbulb
    eventually\r\nturned on: maybe reading the Clojure implementation wasn't such
    a bad idea after\r\nall! I had initially thought that learning the algorithm would
    be much easier\r\nthan learning the semantics and syntax of a new language, but
    two days of hard\r\nwork and mediocre results lead me to re-evaluate that assumption.
    At the very\r\nleast, I could spend an afternoon with the Clojure code. Even if
    the ants still frightened\r\nand confused me in the end, I'd at least learn how
    to read some code from a language \r\nthat I had always wanted to study anyway.
    \r\n\r\nI think you can guess what happened next: within a couple of hours, I
    not only\r\nfully understood Rich Hickey's implementation, but I had also learned
    dozens\r\nupon dozens of Clojure features, including a few that have no direct
    analogue in\r\nRuby. While it may have been a result of frustration \r\ndriven
    development, I was genuinely surprised at what a great way this was to\r\nlearn
    a new language while also studying a programming problem that I was\r\ninterested
    in.\r\n\r\nThroughout the rest of this article, I will attempt to demonstrate
    that given\r\nthe right example, even a few dozen lines of code can teach you
    a tremendous\r\namount of useful things about a language that you've never worked
    with before.\r\nIf you are new to Clojure programming, you'll be able to follow
    along\r\nand experience the same benefits that I did; if you already know the\r\nlanguage,
    you can use this as an exercise in developing a beginner's mindset. In\r\neither
    case, I think you'll be surprised at how much we can extract\r\nfrom such a small
    chunk of code.\r\n\r\nTo keep things simple, we won't bother to read the complex
    bits of code that \r\nimplements ant behavior. Instead, we'll start from the bottom
    up and\r\ntake a look at how this simulation models its world and the ants within
    it.\r\nAlthough this won't help us understand how things get set into action,
    it will\r\ngive us plenty of opportunities to learn some interesting Clojure\r\nfeatures.\r\n\r\n##
    Modeling the world\r\n\r\nThe following code is responsible for creating a blank
    slate world with 80x80\r\ndimensions:\r\n\r\n```clojure\r\n(defstruct cell :food
    :pher) ;may also have :ant and :home\r\n\r\n;dimensions of square world\r\n(def
    dim 80)\r\n\r\n;world is a 2d vector of refs to cells\r\n(def world \r\n   (apply
    vector \r\n     (map (fn [_] \r\n            (apply vector (map (fn [_] (ref (struct
    cell 0 0))) \r\n                               (range dim)))) \r\n          (range
    dim))))\r\n\r\n(defn place [[x y]]\r\n  (-> world (nth x) (nth y)))\r\n```\r\n\r\nEven
    if this is the first time you've ever seen a Clojure program, you could take an\r\neducated
    guess at what is going on in at least a few of these lines of code:\r\n\r\n```clojure\r\n(defstruct
    cell :food :pher)      ; this defines a Struct-like thing\r\n\r\n(def dim 80)
    \                     ; this defines a named value, setting dim=80\r\n\r\n(defn
    place [[x y]]\r\n  (-> world (nth x) (nth y)))     ; this looks like an accessor
    into a\r\n                                  ; two-dimensional grid\r\n```\r\n\r\nThe
    code in the `world` definition is much more complicated, but it \r\nhas a helpful
    comment that describes what it is: a 2D vector of \r\nrefs to cells. This hint
    gives us some useful keywords to search for \r\nin [Clojure's API docs][clojure-doc].
    With a bit of effort, it is possible\r\nto use this code sample and Clojure's
    documentation to learn all the \r\nfollowing things about the language:\r\n\r\n1.
    The [Map][Map] collection is Clojure's equivalent to Ruby's `Hash` object.\r\n1.
    The [StructMap][StructMap] collection is a `Map` with some predefined keys\r\nthat
    cannot be removed. They can be defined using `defstruct`, and are instantiated\r\nvia
    `struct`.\r\n1. The `(def ...)` construct is a [special form][def] that defines
    global variables \r\nwithin a namespace, but it is considered bad style to treat
    these variables as\r\nif they were mutable.\r\n1. The `(defn ...)` construct is
    a macro which among other things provides\r\nsyntactic sugar for defining functions
    with named parameters.\r\n1. The [Vector][Vector] collection has core functionality
    which is similar to\r\nRuby's `Array` object. Vectors can be instantiated using
    the `vector` function or\r\nvia the `[]` literal syntax,  and their elements are
    accessed using \r\nthe `nth` function.\r\n1. All collections in Clojure implement
    a [Sequence][Sequence]\r\ninterface that is similar to Ruby's `Enumerable` module.
    It provides various\r\nfunctions that Ruby programmers are already familiar with,
    such as `map`, `reduce`, \r\n`sort` But because most of these functions return
    lazy sequences, they\r\nbehave slightly differently than their Ruby counterparts.\r\n1.
    The [Ref][Ref] construct is a transactional reference, which is one of\r\nClojure's
    concurrency primitives. In a nutshell, wrapping state in a `Ref`\r\nmakes it so
    that state can only be modified from within a transaction, ensuring\r\nthread
    safety.\r\n1. Among other things, the `range` function provides behavior similar
    to the enumerator \r\nform of Ruby's `Integer#times` method. \r\n1. The `apply`
    function provides functionality similar to Ruby's splat operator\r\n(`*`), passing
    the elements of a sequence as arguments to a function.\r\n1. The [-> macro][->]
    provides syntactic sugar for function composition, which\r\ncan make chaining
    function calls easier.\r\n\r\nBased on this laundry list of concepts to learn,
    it is easy to see from this\r\nexample alone that much like Ruby, Clojure is a
    very rich language that is\r\ncapable of concisely expressing very complex ideas.
    With that in mind, it is\r\nhelpful to use Clojure's REPL to experiment while
    learning, much as we'd do\r\nwith `irb` in Ruby. Once again using the code sample
    as a guide, an \r\nexploration such as the one that follows can go a long way
    towards \r\nverifying our understanding of what we learned from the documentation:\r\n\r\n```clojure\r\nuser=>
    (defstruct cell :food :pher)\r\n; #'user/cell\r\nuser=> (struct cell 1 4)\r\n;
    {:food 1, :pher 4}\r\nuser=> [ [ :a :b :c ] [ :d :e :f ] ]\r\n; [[:a :b :c] [:d
    :e :f]]\r\nuser=> (def data [[:a :b :c] [:d :e :f]])\r\n; #'user/data\r\nuser=>
    (nth (nth data 1) 2)\r\n; :f\r\nuser=> (nth (nth data 2) 1)\r\n; IndexOutOfBoundsException
    \  clojure.lang.PersistentVector.arrayFor \r\n; (PersistentVector.java:106)\r\nuser=>
    (nth (nth data 0) 1)\r\n; :b\r\nuser=> (-> data (nth 1) (nth 2))\r\n; :f\r\nuser=>
    (map (fn [x] (* x 2)) [1 2 3])\r\n; (2 4 6)\r\nuser=> (vector (map (fn [x] (*
    x 2)) [1 2 3]))\r\n; [(2 4 6)]\r\nuser=> (apply vector (map (fn [x] (* x 2)) [1
    2 3]))\r\n; [2 4 6]\r\nuser=> (range 5)\r\n; (0 1 2 3 4)\r\nuser=> (apply vector
    (map (fn [x] (struct cell 0 0)) (range 5)))\r\n; [{:food 0, :pher 0} {:food 0,
    :pher 0} {:food 0, :pher 0} \r\n; {:food 0, :pher 0} {:food 0, :pher 0}]\r\n```\r\n\r\nKnowing
    what we now know, it is possible to imagine a loose translation of the\r\noriginal
    Clojure code sample into Ruby, if we account for a few cavaets:\r\n\r\n1. Most
    `Enumerable` methods return `Array` objects, which are not lazily\r\nevaluated.
    Some support for lazy sequences exist in Ruby 2.0, but we'll\r\nnot bother with
    that in our translation because it'd only create more\r\nwork for us.\r\n\r\n2.
    We don't have a direct analogy to Clojure's `Ref` construct, but we can\r\npretend
    that we do for the purposes of this example.\r\n\r\n3. We don't have anything
    baked into the language which implements a `Hash` with\r\nsome required keys and
    some optional ones. But such behavior could be\r\nemulated by building a custom
    `Cell` object. \r\n\r\n4. We don't have destructuring in the parameter lists for
    our\r\nfunctions, so we need to handle destructuring manually within the bodies\r\nof
    our methods rather than their signatures.\r\n\r\nKeeping these points in mind,
    here's a semi-literal translation of Clojure code\r\nto Ruby:\r\n\r\n```ruby\r\nDIM
    \   = 80                                          \r\nWORLD  = DIM.times.map do
    \                                # 1\r\n           DIM.times.map { Ref.new(Cell.new(0,
    0)) }      # 2,3\r\n         end\r\n\r\ndef place(pos)       \r\n  x, y = pos
    \                                             # 4\r\n  WORLD[x][y]\r\nend\r\n```\r\n\r\nWhile
    the two languages cannot be categorically compared by such a coarse\r\nexercise
    in syntactic gymnastics, it does help the similarities and \r\ndifferences between
    the languages stand out a bit more. This allows us to reuse\r\nthe knowledge we
    already have, and also exposes the gaps in our \r\nunderstanding that need to
    be filled in.\r\n\r\n> **SIDE QUEST:** The remaining two sections in this article
    will repeat this\r\nsame basic process on two more small chunks of code from the
    ant simulator. If you have some\r\nfree time and an interest in learning Clojure,
    you may want to start\r\nwith the initial code samples in each section and try
    to figure them out on\r\nyour own, and *then* come back to read my notes. If you
    decide to\r\ntry this out, please share a comment with what you've learned.\r\n\r\nNow
    that we've tackled one concrete feature from this program, it will be much\r\neasier
    to understand the rest. There's a lot left to learn, so let's keep\r\nmoving!\r\n\r\n##
    Modeling an ant\r\n\r\nThe following code is responsible for initializing an ant
    at a \r\ngiven location within the world:\r\n\r\n```clojure\r\n(defstruct ant
    :dir) ;may also have :food\r\n\r\n(defn create-ant \r\n  \"create an ant at the
    location, returning an ant agent on the location\"\r\n  [loc dir]\r\n    (dosync\r\n
    \     (let [p (place loc)\r\n            a (struct ant dir)]\r\n        (alter
    p assoc :ant a)\r\n        (agent loc))))\r\n```\r\n\r\nBecause we already have
    a rudimentary understanding of how `StructMap` works,\r\nand how to define functions,
    we can skip over some of the boilerplate\r\nand get right to the good stuff:\r\n\r\n```clojure\r\n(dosync
    \                              ; 1\r\n  (let [p (place loc)                 ;
    2\r\n        a (struct ant dir)]\r\n    (alter p assoc :ant a)            ; 3\r\n
    \   (agent loc)))                     ; 4\r\n```\r\n\r\nDigging back into Clojure's
    API docs, we can learn four new things \r\nfrom this code sample:\r\n\r\n1. The
    [dosync][dosync] macro starts a transaction,\r\nwhich among other things, makes
    it possible to modify `Ref`\r\nstructures in a thread-safe way.\r\n\r\n1. The
    [let][let] macro allows you to make use of named values within\r\na lexical scope.
    This construct appears to be roughly similar to the \r\nconcept of block-local
    variables in Ruby.\r\n\r\n1. The [alter][alter] function is used for modifying
    the contents of a `Ref`\r\nstructure, and can only be called within a transaction.\r\n\r\n1.
    The [Agent][Agent] construct is another one of Clojure's concurrency\r\nprimitives.
    This structure provides an interesting state-centric alternative\r\nto the actor
    model of concurrency: rather than encapsulating behavior that acts\r\nupon external
    state, agents encapsulate state which is *acted upon* by external\r\nbehaviors.\r\n\r\nOf
    course, in order to verify that we understand what the documentation is\r\ntelling
    us, nothing beats a bit of casual experimentation in the REPL:\r\n\r\n```clojure\r\nuser=>
    (let [x 10 y 20] (+ x y))\r\n; 30\r\nuser=> (let [x 10] (let [y 20] (+ x y)))\r\n;
    30\r\nuser=> (let [x 10] (let [y 20]) y)\r\n; CompilerException java.lang.RuntimeException:
    Unable to resolve \r\n; symbol: y in this context, compiling:(NO_SOURCE_PATH:3)
    \r\nuser=> (def foo (ref { :x 1 :y 1}) )\r\n; #'user/foo\r\nuser=> foo\r\n; #<Ref@6762ba99:
    {:y 1, :x 1}>\r\nuser=> (assoc foo :z 2)\r\n; ClassCastException clojure.lang.Ref
    cannot be cast to clojure.lang.Associative  \r\n; clojure.lang.RT.assoc (RT.java:691)\r\nuser=>
    (assoc @foo :z 2)\r\n; {:z 2, :y 1, :x 1}\r\nuser=> @foo\r\n; {:y 1, :x 1}\r\nuser=>
    (alter foo assoc :z 2)\r\n; IllegalStateException No transaction running  \r\n;
    clojure.lang.LockingTransaction.getEx (LockingTransaction.java:208)\r\nuser=>
    (dosync (alter foo assoc :z 2))\r\n; {:z 2, :y 1, :x 1}\r\nuser=> (def bar (agent
    [1 2 3]))\r\n; #'user/bar\r\nuser=> bar\r\n; #<Agent@3445378f: [1 2 3]>\r\nuser=>
    @bar\r\n; [1 2 3]\r\nuser=> (send bar reverse)\r\n; #<Agent@3445378f: [1 2 3]>\r\nuser=>
    bar\r\n; #<Agent@3445378f: (3 2 1)>\r\nuser=> @bar\r\n; (3 2 1)\r\nuser=> (reverse
    @bar)\r\n; (1 2 3)\r\nuser=> @bar\r\n; (3 2 1)\r\n```\r\n\r\nThe ant creation
    code sample consists mostly of features that don't exist in\r\nRuby, so a direct
    translation isn't possible. However, it doesn't hurt to\r\nimagine what the syntax
    for these features might look like in Ruby if we did\r\nhave Clojure's concurrency
    primitives:\r\n\r\n```ruby\r\n  def create_ant(loc, dir)\r\n    Ref.transaction
    do \r\n      p = place(loc)\r\n      a = Ant.new(dir)\r\n    \r\n      p.ant =
    a\r\n\r\n      Agent.new(loc)\r\n    end\r\n  end\r\n```\r\n\r\nAssuming that
    Clojure's semantics were maintained, either all mutations that\r\nhappen within
    the `Ref.transaction` block would be applied, or none of them\r\nwould be. Furthermore,
    thread-safety would be handled for us ensuring state\r\nconsistency for the duration
    of the block. Language-level transactions seem like\r\nseriously powerful stuff,
    and it will be interesting to see if Ruby ends up\r\nadopting them in the future.\r\n\r\n##
    Populating the world\r\n\r\nThe following code populates the initial state of
    the world with ants and food:\r\n\r\n```clojure\r\n;number of ants = nants-sqrt^2\r\n(def
    nants-sqrt 7)\r\n;number of places with food\r\n(def food-places 35)\r\n;range
    of amount of food at a place\r\n(def food-range 100)\r\n\r\n(def home-off (/ dim
    4))\r\n(def home-range (range home-off (+ nants-sqrt home-off)))\r\n\r\n(defn
    setup \r\n  \"places initial food and ants, returns seq of ant agents\"\r\n  []\r\n
    \ (dosync\r\n    (dotimes [i food-places]\r\n      (let [p (place [(rand-int dim)
    (rand-int dim)])]\r\n        (alter p assoc :food (rand-int food-range))))\r\n
    \   (doall\r\n     (for [x home-range y home-range]\r\n       (do\r\n         (alter
    (place [x y]) \r\n                assoc :home true)\r\n         (create-ant [x
    y] (rand-int 8)))))))\r\n```\r\n\r\nAs in the ant initialization code, this snippet
    includes a mixture of new\r\nconcepts and old ones. If we focus on the body of
    the `setup` definition, there\r\nare five new things for us to learn:\r\n\r\n```clojure\r\n(dosync\r\n
    \   (dotimes [i food-places]                             ;1\r\n      (let [p (place
    [(rand-int dim) (rand-int dim)])]   ;2\r\n        (alter p assoc :food (rand-int
    food-range))))\r\n    (doall                                               ;3\r\n
    \    (for [x home-range y home-range]                    ;4\r\n       (do                                               ;5\r\n
    \        (alter (place [x y]) \r\n                assoc :home true)\r\n         (create-ant
    [x y] (rand-int 8))))))\r\n```\r\n\r\n1. The [dotimes][dotimes] macro is a simple
    iterator that is comparable to the\r\nblock form of `Integer#times` in Ruby. \r\n\r\n1.
    The [rand-int][rand-int] function returns a random integer between 0 and\r\na
    given number, which is similar to calling Ruby's `Kernel#rand` with an \r\ninteger
    argument.\r\n\r\n1. The [doall][doall] macro is used to force a lazy sequence
    to be fully\r\nevaluated.\r\n\r\n1. The [for][for] macro implements list comprehensions,
    which are a very\r\npowerful form of iterator that does not have a direct analogue
    in Ruby.\r\n\r\n1. The [do][do] special form executes a series of expressions
    in sequence and\r\nreturns the result of the last expression. This is roughly
    equivalent to Ruby's\r\n`do...end` block syntax.\r\n\r\nOne last trip back to
    the REPL is needed to confirm that once again, the\r\ndocumentation is not lying,
    and we have not misunderstood its explanations:\r\n\r\n```clojure\r\nuser=> (dotimes
    [i 5] (println i))\r\n; 0\r\n; 1\r\n; 2\r\n; 3\r\n; 4\r\n; nil\r\nuser=> (rand-int
    10)\r\n; 3\r\nuser=> (rand-int 10)\r\n; 6\r\nuser=> (rand-int 10)\r\n; 6\r\nuser=>
    (rand-int 10)\r\n; 2\r\nuser=> (for [x (range 5) y (range 5)] [x y])\r\n; ([0
    0] [0 1] [0 2] [0 3] [0 4] [1 0] [1 1] [1 2] [1 3] [1 4] \r\n; [2 0] [2 1] [2
    2] [2 3] [2 4] [3 0] [3 1] [3 2] [3 3] [3 4] \r\n; [4 0] [4 1] [4 2] [4 3] [4
    4])\r\nuser=> (for [x (range 5) y (range 5)] (+ x y))\r\n; (0 1 2 3 4 1 2 3 4
    5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8)\r\nuser=> (do (print \"hello world\\n\") (+ 1
    1))\r\n; hello world\r\n; 2\r\nuser=> (realized? (for [x (range 5) y (range 5)]
    [x y])) \r\n; false\r\nuser=> (realized? (doall (for [x (range 5) y (range 5)]
    [x y])))\r\n; true\r\n```\r\n\r\nBecause many of the Clojure features used for
    populating the simulation's \r\nworld either already exist in Ruby or are irrelevant
    due to implementation\r\ndifferences, this code sample translates fairly well.
    Apart from the fact\r\nthat the `Ref` construct in this example is imaginary,
    the only \r\nnoticeable thing that is lost in translation is the conciseness\r\nof
    Clojure's list comprehensions. But in this particular use case,\r\n`Array#product`
    gets us part of the way there:\r\n\r\n```ruby\r\nNANTS_SQRT  = 7\r\nFOOD_PLACES
    = 35\r\nFOOD_RANGE  = 100\r\n\r\nHOME_OFF   = DIM / 4\r\nHOME_RANGE = (HOME_OFF..NANTS_SQRT
    + HOME_OFF)\r\n\r\ndef setup\r\n  Ref.transaction do\r\n    FOOD_PLACES.times
    do\r\n      p      = place([rand(DIM), rand(DIM])\r\n      p.food = rand(FOOD_RANGE)\r\n
    \   end\r\n\r\n    HOME_RANGE.to_a.product(HOME_RANGE.to_a).map do |x,y|\r\n      place([x,y]).home
    = true\r\n    \r\n      create_ant([c, y], rand(8))\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAt
    this point, you should now completely understand the structure of the initial\r\nstate
    of the world in [Rich Hickey's ant simulator][sim], and if you're new to\r\nClojure,
    you probably know a lot more about the language than you did when you\r\nstarted
    reading. If you have enjoyed the journey so far, definitely consider\r\nreading
    the entire program; this article only covers tip of the iceberg! \r\n\r\n## Reflections\r\n\r\n[XKCD]
    sums up how I feel about this exercise much better than I could on my own:\r\n\r\n[![](http://imgs.xkcd.com/comics/lisp_cycles.png)](http://xkcd.com/297/)\r\n\r\nThat
    said, I'm sure that more than a few people would be happy to tell you that \r\nmany
    of the pragmatic compromises that Clojure has made are blasphemic in some\r\nway.
    Truth be told, I don't know nearly enough about functional languages to\r\nweigh
    in on any of those claims.\r\n\r\nThe real takeaway for me was that by stepping
    outside of my comfort zone for\r\neven a few hours, I was able to look back at
    Ruby with a fresh perspective. I\r\nwas also able to gain an understanding of
    a programming problem that I couldn't\r\nfind a good Ruby example for. Both of
    these things were a huge win for me. I\r\nhope that you will find a way to try
    this exercise out on one of your own \r\nproblems, and I look forward to hearing
    what you think of it.\r\n\r\nLearning to read code in a language you are not familiar
    with takes practice,\r\nbut it is easier than it seems. If you step outside the\r\nbubble
    from time to time, only good things will come of it.\r\n\r\n> **NOTE**: You may
    want to try out [4Clojure][4Clojure] if you want to hone\r\n> your Clojure skills
    at a more gradual pace than what we attempted in this\r\n> article. It's a quiz
    site similar to [RubyKoans].\r\n \r\n[swarm]:       http://en.wikipedia.org/wiki/Swarm_intelligence\r\n[boids]:
    \      http://en.wikipedia.org/wiki/Boids\r\n[aco]:         http://en.wikipedia.org/wiki/Ant_colony_optimization\r\n[sim]:
    \        https://gist.github.com/1093917\r\n[clojure]:     http://clojure.org/\r\n[clojure-doc]:
    http://clojure.org/documentation\r\n[hickey]:      http://blip.tv/clojure/clojure-concurrency-819147\r\n[xkcd]:
    \       http://xkcd.com\r\n[4Clojure]:    http://www.4clojure.com\r\n[RubyKoans]:
    \  http://rubykoans.com\r\n\r\n[def]:     http://clojure.org/special_forms#Special%20Forms--%28def%20symbol%20init?%29\r\n[Map]:
    http://clojure.org/data_structures#Data%20Structures-Maps%20%28IPersistentMap%29\r\n[StructMap]:
    http://clojure.org/data_structures#Data%20Structures-StructMaps\r\n[Vector]: http://clojure.org/data_structures#Data%20Structures-Vectors%20%28IPersistentVector%29\r\n[Sequence]:
    http://clojure.org/sequences\r\n[Ref]: http://clojure.org/refs\r\n[->]: http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/\r\n[dosync]:
    http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/dosync\r\n[let]:
    http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/let\r\n[alter]:
    http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/alter\r\n[agent]:
    http://clojure.org/agents\r\n[dotimes]: http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/dotimes\r\n[for]:
    http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for\r\n[doall]:
    http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/doall\r\n[rand-int]:
    http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/rand-int\r\n[do]:
    http://clojure.org/special_forms#Special%20Forms--%28do%20exprs*%29\r\n"
- :slug: ant-colony-simulation
  :title: Simulating the emergent behavior of ant colonies
  :summary: Explore how simple rules for individuals can yield complex group behavior
    by simulating an ant colony.
  :published: 2012-11-27 00:00:00.000000000 Z
  :issue_number: '5.9'
  :volume: 5
  :body: "*This article is based on a [heavily modified Ruby port][rubyantsim] \r\nof
    Rich Hickey's [Clojure ant simulator][hickey]. Although I didn't directly collaborate
    with Rich on this issue of \r\nPracticing Ruby, I learned a lot from his code
    and it provided\r\nme with a great foundation to start from.*\r\n\r\nWatch as
    a small ant colony identifies and completely consumes its four nearest\r\nfood
    sources:\r\n\r\n<div align=\"center\">\r\n<iframe width=\"720\" height=\"480\"\r\nsrc=\"//www.youtube.com/embed/f2IX1Y5o6pc?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n</div>\r\n\r\nWhile this search
    effort may seem highly organized, it is the\r\nresult of very simple decisions
    made by individual ants. On each\r\ntick of the simulation, each ant decides its
    next action based only on its\r\ncurrent location and the three adjacent locations
    ahead of it. But \r\nbecause ants can indirectly communicate via their environment,
    complex \r\nbehavior arises in the aggregate.\r\n\r\nEmergence and self-organization
    are popular concepts in programming, but far too many\r\ndevelopers start and
    end their explorations into these ideas with [Conway's Game of Life][conway].
    \r\nIn this article, I will help you see these fascinating properties in a new\r\nlight
    by demonstrating the role they play in [ant colony optimization (ACO)][aco] algorithms.\r\n\r\n>
    **NOTE:** There are many ways to simulate ant behavior, some of which can be quite
    useful\r\nfor a wide range of search applications. For this article, I have built\r\na
    fairly nave simulation that is meant to loosely mimic the kind of ant\r\nbehavior
    you can observe in the natural world. This article *may* be useful as a \r\nbrief
    introduction to ACO, but be sure to dig deeper if you are interested in\r\npractical
    applications. My goal is to provide a great example of emergent \r\nbehavior,
    NOT a great reference for nature-inspired search algorithms.\r\n\r\n## Modeling
    the state of an ant colony\r\n\r\nThis simulated world consists of many cells:
    some are food sources, \r\nsome are part of the colony's nest, and the rest are
    an\r\nopen field that needs to be traversed. Each cell can contain a single \r\nant
    facing in one of the eight directions you'd find on a compass. \r\nAs the ants
    move around the world, they mark the cells they visit with\r\na trail of pheromones
    that helps them find their way between their \r\nnest and nearby food sources.
    Pheromones accumulate as more ants \r\ntravel across a given trail, but they also
    gradually evaporate. \r\nThe combination of these two properties of pheromones
    helps \r\nants find efficient paths to nearby food sources.\r\n\r\nSubtle changes
    to any of these rules can yield very different outcomes, \r\nand finding an optimal
    result will necessarily involve some\r\nexperimentation. Knowing that, it makes
    sense for the simulator to \r\nhave a data model that is divorced from its domain
    logic. Many\r\nbehavioral changes can be made without altering the\r\nunderlying
    data model, and that allows the `Ant`, `Cell`, and `World` constructs to\r\nbe
    defined as simple value objects as shown below:\r\n\r\n```ruby\r\nmodule AntSim
    \r\n  class Ant\r\n    def initialize(direction, location)\r\n      self.direction
    = direction\r\n      self.location  = location\r\n    end\r\n\r\n    attr_accessor
    :food, :direction, :location\r\n  end\r\n\r\n  class Cell\r\n    def initialize(food,
    home_pheremone, food_pheremone)\r\n      self.food           = food \r\n      self.home_pheremone
    = home_pheremone\r\n      self.food_pheremone = food_pheremone\r\n    end\r\n\r\n
    \   attr_accessor :food, :home_pheremone, :food_pheremone, :ant, :home\r\n  end\r\n\r\n
    \ class World\r\n    def initialize(world_size)\r\n      self.size = world_size\r\n
    \     self.data = size.times.map { size.times.map { Cell.new(0,0,0) } }\r\n    end\r\n\r\n
    \   def [](location)\r\n      x,y = location\r\n\r\n      data[x][y]\r\n    end\r\n\r\n
    \   def sample\r\n      data[rand(size)][rand(size)]\r\n    end\r\n\r\n    def
    each\r\n      data.each_with_index do |col,x| \r\n        col.each_with_index
    do |cell, y| \r\n          yield [cell, [x, y]]\r\n        end\r\n      end\r\n
    \   end\r\n\r\n    private\r\n\r\n    attr_accessor :data, :size\r\n  end\r\nend\r\n```\r\n\r\nThese
    classes are somewhat peculiar in that they are very state-centric and \r\ndo not
    encapsulate any interesting domain logic. Although it won't win us\r\nobject-oriented
    style points, designing things this way decouples the state of \r\nthe simulated
    world from both the events that happen within it and the \r\noptimization algorithms
    that run against it. These objects\r\nrepresent only the nouns of our system,
    leaving it up to their collaborators \r\nto supply the verbs.\r\n\r\n## Moving
    around the world\r\n\r\nThe ants in this system are surprisingly limited in their
    behavior. On each \r\nand every iteration, their entire decision making process
    can result \r\nin exactly one of the following outcomes:\r\n\r\n![Ant movement
    rules](http://i.imgur.com/VsBkn.png)\r\n\r\nMost of these actions are extremely
    localized. Turning does not affect any\r\ncells, while moving only affects the
    cell the ant currently occupies\r\nand the one immediately in front of it. However,
    taking or dropping food\r\ntriggers a pheromone update, affecting every cell the
    ant has \r\nvisited since the last time it updated its trails. This can have far-reaching\r\neffects
    on the behavior of the rest of the colony, even though each individual\r\nant
    can only sense the pheromone levels of its own cell and the three cells\r\ndirectly
    in front of it. While natural ants must drop pheromone\r\ncontinuously as they
    walk, artificial ants can improve upon nature by\r\nupdating entire paths instantaneously.\r\n\r\nAn
    object that implements these behaviors needs to know about the structure of\r\nthe
    `Ant`, `Cell`, and `World` objects, but it still does not\r\nneed to know much
    about the core domain logic of the simulator. What we want is\r\nan `Actor` that
    understands its world and how to play specific roles within it, \r\nbut does not
    attempt to define the broader story arc:\r\n\r\n```ruby\r\nrequire \"set\"\r\n\r\nmodule
    AntSim\r\n  class Actor\r\n    DIR_DELTA   = [[0, -1], [ 1, -1], [ 1, 0], [ 1,
    \ 1],\r\n                   [0,  1], [-1,  1], [-1, 0], [-1, -1]]\r\n\r\n    def
    initialize(world, ant)\r\n      self.world   = world\r\n      self.ant     = ant\r\n\r\n
    \     self.history = Set.new\r\n    end\r\n\r\n    attr_reader :ant\r\n\r\n    def
    turn(amt)\r\n      ant.direction = (ant.direction + amt) % 8\r\n\r\n      self\r\n
    \   end\r\n\r\n    def move\r\n      history << here\r\n\r\n      new_location
    = neighbor(ant.direction)\r\n\r\n      ahead.ant = ant\r\n      here.ant  = nil\r\n\r\n
    \     ant.location = new_location\r\n\r\n      self\r\n    end\r\n\r\n    def
    drop_food\r\n      here.food += 1\r\n      ant.food   = false\r\n\r\n      self\r\n
    \   end\r\n\r\n    def take_food\r\n      here.food -= 1\r\n      ant.food   =
    true\r\n\r\n      self\r\n    end\r\n\r\n    def mark_food_trail\r\n      history.each
    do |old_cell|\r\n        old_cell.food_pheremone += 1 unless old_cell.food > 0
    \r\n      end\r\n\r\n      history.clear\r\n\r\n      self\r\n    end\r\n\r\n
    \   def mark_home_trail\r\n      history.each do |old_cell|\r\n        old_cell.home_pheremone
    += 1 unless old_cell.home\r\n      end\r\n\r\n      history.clear\r\n\r\n      self\r\n
    \   end\r\n\r\n    def foraging?\r\n      !ant.food\r\n    end\r\n\r\n    def
    here\r\n      world[ant.location]\r\n    end\r\n\r\n    def ahead\r\n      world[neighbor(ant.direction)]\r\n
    \   end\r\n\r\n    def ahead_left\r\n      world[neighbor(ant.direction - 1)]\r\n
    \   end\r\n\r\n    def ahead_right\r\n      world[neighbor(ant.direction + 1)]\r\n
    \   end\r\n    \r\n    def nearby_places\r\n      [ahead, ahead_left, ahead_right]\r\n
    \   end\r\n\r\n    private\r\n\r\n    def neighbor(direction)\r\n      x,y = ant.location\r\n\r\n
    \     dx, dy = DIR_DELTA[direction % 8]\r\n\r\n      [(x + dx) % world.size, (y
    + dy) % world.size]\r\n    end\r\n\r\n    attr_accessor :world, :history\r\n    attr_writer
    \  :ant\r\n  end\r\nend\r\n```\r\n\r\nOf course, now that we have crossed the
    line from pure data models to an object\r\nwhich actually does something, it is
    impossible to implement meaningful behavior\r\nwithout making certain assumptions
    that will affect the capabilities of the \r\nrest of the system. The `Actor` class
    draws two significant lines in the sand that\r\nare easy to overlook on a quick
    glance:\r\n\r\n1. Storing history data in a `Set` rather than an `Array` makes
    it so\r\nthat when this object updates pheromone trails, it only takes into account\r\nwhat
    cells were visited, not how many times they were visited or in what order\r\nthey
    were traversed.\r\n\r\n2. The modular arithmetic performed in the `neighbor` function
    treats the world\r\nas if it were a [torus][torus], instead of a plane. This means
    that the\r\nleftmost column and the rightmost column of the map are adjacent to
    one \r\nanother, as are the top and bottom rows. This allows ants to easily wrap
    around\r\nthe edges of the map, but also establishes connections between cells
    that you\r\nmay not intuitively think of as being close to one another. Without
    a\r\nthree-dimensional visualization, it is hard to show that the top right corner
    of\r\nthe map and the bottom left corner are actually adjacent to one another.\r\n\r\nOf
    course, the purpose of the `Actor` class is to hide these details from\r\nthe
    rest of the system. As long as its collaborators can operate within these \r\nconstraints,
    the `Actor` object can be treated as a magic black box that knows\r\nhow to make
    ants move around the world and do interesting things. To see why\r\nthat is useful,
    check out the `Simulator#iterate` function which drives the\r\nsimulator's main
    event loop:\r\n\r\n```ruby\r\nmodule AntSim\r\n  class Simulator\r\n    # ...
    other functions ...\r\n\r\n    def iterate\r\n      actors.each do |actor|\r\n
    \       optimizer = Optimizer.new(actor.here, actor.nearby_places)\r\n        \r\n
    \       if actor.foraging?\r\n          action = optimizer.seek_food\r\n        else\r\n
    \         action = optimizer.seek_home\r\n        end\r\n\r\n        case action\r\n
    \       when :drop_food\r\n          actor.drop_food.mark_food_trail.turn(4)\r\n
    \       when :take_food\r\n          actor.take_food.mark_home_trail.turn(4)\r\n
    \       when :move_forward\r\n          actor.move\r\n        when :turn_left\r\n
    \         actor.turn(-1)\r\n        when :turn_right\r\n          actor.turn(1)\r\n
    \       else\r\n          raise NotImplementedError, action.inspect\r\n        end\r\n
    \     end\r\n\r\n      sleep ANT_SLEEP\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nHere
    we can see that the `Simulator` acts as a bridge that translates\r\nthe `Optimizer`
    object's very abstract suggestions into concrete\r\nactions for the `Actor` to
    carry out. The design of the `Actor` object gives the\r\n`Simulator` just enough
    control to make some small adjustments to the process,\r\nbut not so much that
    it needs to be bogged down with the details.\r\n\r\n## Finding food and bringing
    it home\r\n\r\nNow that we know the state of the world and how it can be manipulated,
    it is\r\ntime to discuss how to produce the kind of behavior that you saw in the\r\nvideo
    at the beginning of this article. Perhaps unsurprisingly, the life of the\r\neveryday
    worker ant is actually fairly mundane.\r\n\r\nEvery ant in this simulation is
    always either searching for food to bring back\r\nto the nest, or trying to return
    home with the food it found. As soon \r\nan ant accomplishes one of these tasks,
    it immediately transitions to the other,\r\nnot bothering to take even a moment
    to bask in fruits of its labor. The\r\nfollowing outline describes what the ants
    in this simulation are \"thinking\" \r\nat any given point in time, assuming that
    they haven't managed to \r\nbecome self-aware...\r\n\r\n**When searching for food:**\r\n\r\n1.
    If the current cell has food in it and it is NOT part of the nest, \r\npick up
    some food.\r\n\r\n2. Otherwise, check the cell directly in front of me. If it
    has food in it, is\r\nnot part of the nest, and it is not occupied by another
    ant, move there.\r\n\r\n3. If not, rank the three adjacent cells in front of me
    based\r\non the amount of food they contain, and how intense their `food_pheremone`\r\nlevels
    are. I will *usually* choose to move or turn towards the cell with\r\nhighest
    ranking, but I will randomly deviate from this pattern on occasion\r\nso that
    I can explore some uncharted territory.\r\n\r\n**When searching for the nest:**\r\n\r\n1.
    If the current cell is part of the nest, drop the food I am carrying.\r\n\r\n2.
    Otherwise, check the cell directly in front of me. If it is part of the nest,\r\nand
    it is not occupied by another ant, move there.\r\n\r\n3. If not, rank the three
    adjacent cells in front of me based\r\non whether or not they are part of the
    nest, and how intense their `home_pheremone`\r\nlevels are. I will *usually* choose
    to move or turn towards the cell with\r\nhighest ranking, but I will randomly
    deviate from this pattern on occasion\r\nso that I can explore some uncharted
    territory.\r\n\r\nTranslating these ideas into code is very straightforward, especially\r\nif
    you treat the underlying mathematical formulas as a black box:\r\n\r\n```ruby\r\nmodule
    AntSim\r\n  class Optimizer\r\n    # ...\r\n\r\n    def seek_food\r\n      if
    here.food > 0 && (! here.home)\r\n        :take_food\r\n      elsif ahead.food
    > 0 && (! ahead.home ) && (! ahead.ant )\r\n        :move_forward\r\n      else\r\n
    \       food_ranking = rank_by { |cell| cell.food }\r\n        pher_ranking =
    rank_by { |cell| cell.food_pheremone }\r\n\r\n        ranks = combined_ranks(food_ranking,
    pher_ranking)\r\n        follow_trail(ranks)\r\n      end\r\n    end\r\n\r\n    def
    seek_home\r\n      if here.home\r\n        :drop_food\r\n      elsif ahead.home
    && (! ahead.ant)\r\n        :move_forward\r\n      else\r\n        home_ranking
    = rank_by { |cell| cell.home ? 1 : 0 }\r\n        pher_ranking = rank_by { |cell|
    cell.home_pheremone }\r\n\r\n        ranks = combined_ranks(home_ranking, pher_ranking)\r\n
    \       follow_trail(ranks)\r\n      end\r\n    end\r\n\r\n    def follow_trail(ranks)\r\n
    \     choice = wrand([ ahead.ant ? 0 : ranks[ahead],\r\n                       ranks[ahead_left],\r\n
    \                      ranks[ahead_right]])\r\n\r\n      [:move_forward, :turn_left,
    :turn_right][choice]\r\n    end\r\n    \r\n\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nIf
    you understand the general idea behind this algorithm, don't worry about the\r\nexact
    computations that the `Optimizer` uses unless you are\r\nplanning on researching
    Ant Colony Optimization in much greater detail. While I\r\nunderstand what my
    own code is doing, I'll admit that I mostly \r\ncargo-cult copied the probabilistic
    methods \r\nfrom [Rich Hickey's simulator][hickey] while sprinkling in a few minor
    tweaks \r\nhere and there. That said, if you want to see exactly how I hacked
    things\r\ntogether, feel free to check out \r\nthe [full Optimizer class definition][optimizer].\r\n\r\nWhat
    I personally find much more interesting than the nuts and bolt of\r\n*how* this
    algorithm works is to think about *why* it works.\r\n\r\n## How the hive mind
    emerges\r\n\r\nAs we discussed in the previous section, ants are attracted to
    pheromone, and\r\nthat makes them more likely to follow the trails left behind
    by other ants than\r\nthey are to venture out on their own. However, when ants
    first start exploring\r\na new space, there are no trails to follow and so they
    are forced to wander\r\naround randomly until a food source is found.\r\n\r\nGenerally
    speaking, ants that take a shorter path from the nest to a food\r\nsource will
    arrive there sooner than ants that take a longer path. If they\r\nfollow their
    own pheromone trail back to the nest, they will also return home\r\nsooner than
    those who are traversing longer paths. By the time ants who have\r\ntaken a longer
    path return home, the ants on the shortest paths have already\r\nwent back out
    in search of additional food, which increases the pheromone levels\r\non their
    trails.\r\n\r\nThis process on its own would bias the ant colony to prefer shorter
    paths over\r\nlonger ones, but the optimization would be somewhat sluggish and
    might tend to\r\nproduce solutions that work well locally but aren't nearly as
    attractive\r\nglobally. To get better results, the system needs a bit of entropy
    thrown into\r\nthe mix.\r\n\r\nBecause the behavior of ants has a certain amount
    of randomness to it,\r\nthe occasional deviation from established paths are fairly
    common. Even if the\r\nfluctuations are small, each tiny shortcut that allows
    an ant to get between two\r\npoints along a path in a shorter amount of time ultimately
    contributes to\r\nfinding an optimal solution. This means that even an ant who
    goes wildly off\r\ncourse and starves to death nowhere near the nest can make
    a meaningful\r\ncontribution to the colony if even some tiny segment of its path
    serves to\r\nshorten an existing well-worn trail.\r\n\r\nWhen you add in the fact
    that pheromones are volatile and tend to evaporate over\r\ntime, an upper limit
    emerges for how much a bad path or a local optimization can\r\ninfluence the colony's
    decision making. Evaporation is also a key part of what\r\nallows the ants to
    change course when a food source is exhausted, or an obstacle\r\nstands in the
    way of an established path.\r\n\r\nPheromone decay is something that can be modeled
    in many ways, but the easiest\r\nway of simulating it is to gradually reduce the
    pheromone at every cell in the \r\nworld on a regular interval. For an example
    of this approach, check out\r\n`Simulator#evaporate`:\r\n\r\n```ruby\r\nmodule
    AntSim\r\n  class Simulator\r\n    def evaporate\r\n      world.each do |cell,
    (x,y)| \r\n        cell.home_pheremone *= EVAP_RATE \r\n        cell.food_pheremone
    *= EVAP_RATE\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nSo if you take
    the basic positive feedback loop caused by pheromone attraction\r\nand mix in
    a bit of probabilistic exploration and the gradual evaporation of trails, you
    end\r\nup with a fairly robust optimization process. It truly is remarkable that
    \r\nthese basic factors can combine to create a very\r\neffective search heuristic,
    especially when you consider the fact that what\r\nwe've discussed here is only
    a crude approximation of the tip of the iceberg\r\nwhen it comes to [Ant Colony
    Optimization][aco].\r\n\r\n## Reflections\r\n\r\nEmergent behaviors in computing
    problems have always fascinated me, even though I\r\nhave not spent nearly enough
    time studying them to understand them well. I feel\r\nsimilarly about a lot of
    other things in life, ranging from the board game Go,\r\nto the spread of memes
    throughout communities both online and offline.\r\n\r\nThere is something deep
    and almost spiritual in the realization that the\r\nextremely complex behaviors
    can emerge from very simple systems with very few\r\nrules, and a complete lack
    of central organization. It forces us to call into\r\nquestion everything we experience
    and to wonder whether there is some elegant\r\nexplanation for it all!\r\n\r\n[conway]:
    http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\r\n[aco]: http://en.wikipedia.org/wiki/Ant_colony_optimization\r\n[torus]:
    http://en.wikipedia.org/wiki/Torus\r\n[hickey]: https://gist.github.com/1093917\r\n[rubyantsim]:
    https://github.com/elm-city-craftworks/practicing-ruby-examples/tree/master/v5/009\r\n[optimizer]:
    https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v5/009/lib/ant_sim/optimizer.rb\r\n"
- :slug: adventure-in-prototypes
  :title: An adventure in prototypes
  :summary: Build a text adventure game and a prototype-based object model, at the
    same time! (w. Avdi Grimm)
  :published: 2012-12-11 00:00:00.000000000 Z
  :issue_number: '5.10'
  :volume: 5
  :body: "*This article was written by Avdi Grimm. Avdi is a [Ruby Rogue][rogue],
    a\r\nconsulting pair programmer, and the head chef at [RubyTapas][tapas]. He writes\r\nabout
    software development at [Virtuous Code.][virtuous]*\r\n\r\nWhen you think of the
    term *object-oriented programming*, one of the\r\nfirst associated words that
    springs to mind is probably *classes*. For\r\nmost of its history, the OOP paradigm
    has been almost inextricably\r\nlinked with the idea of classes. Classes serve
    as *object factories*:\r\nthey hold the blueprint for new objects, and can be
    called upon to\r\nmanufacture as many as needed. Each object, or *instance*, has
    its\r\nstate, but each derives its behavior from the class. Classes, in turn,\r\nshare
    behavior through inheritance. In most OO programs, the class\r\nstructure is the
    primary organizing principle.\r\n\r\nEven though classes have gone hand-in-hand
    with OOP for decades, they\r\naren't the only way to build families of objects
    with shared behavior.\r\nThe most common alternative to *class-based* programming
    is\r\n*prototype-based* programming. Languages that use prototypes rather than\r\nclasses
    include [Self][self], [Io][io], and (most well known of all) JavaScript.\r\n\r\nRuby
    comes from the class-based school of OO language design. But it's\r\nflexible
    enough that with a little cleverness, we can experiment with\r\nprototype-style
    coding. In this article that's just what we'll do.\r\n\r\n[self]: http://en.wikipedia.org/wiki/Self_(programming_language\r\n[io]:
    http://en.wikipedia.org/wiki/Io_(programming_language)\r\n[rogue]: http://rubyrogues.com/\r\n[tapas]:
    http://devblog.avdi.org/rubytapas/\r\n[virtuous]: http://devblog.avdi.org/\r\n\r\n##
    Getting started\r\n\r\nSo how do we write OO programs without classes? Let's explore
    this\r\nquestion in Ruby. We'll use the example of a text-adventure game in the\r\nstyle
    of \"[Colossal Cave\r\nAdventure](http://en.wikipedia.org/wiki/Colossal_Cave_Adventure)\".
    This\r\nis one of my favorite programming examples for object-oriented systems,\r\nsince
    it involves modeling a virtual world of interacting objects,\r\nincluding characters,
    items, and interconnected rooms.\r\n\r\nWe open up an interactive Ruby session,
    and start typing. We begin with\r\nan `adventurer` object. This object will serve
    as our avatar in the\r\ngame's world, translating our commands into interactions
    between\r\nobjects:\r\n\r\n```ruby\r\nadventurer = Object.new\r\n```\r\n\r\nThe
    first ability we give to our adventurer is the ability to look at\r\nits surroundings.
    The `look` command will cause the adventurer to output\r\na description of its
    current location:\r\n\r\n```ruby\r\nclass << adventurer\r\n  attr_accessor :location\r\n\r\n
    \ def look\r\n    puts location.description\r\n  end\r\nend\r\n```\r\n\r\nThen
    we add a starting location, called `end_of_road`, and put the\r\nadventurer in
    that location:\r\n\r\n```ruby\r\nend_of_road = Object.new\r\ndef end_of_road.description\r\n
    \ <<END\r\nYou are standing at the end of a road before a small brick building.\r\nAround
    you is a forest.  A small stream flows out of the building and\r\ndown a gully.\r\nEND\r\nend\r\n\r\nadventurer.location
    = end_of_road\r\n```\r\n\r\nNow we can tell our adventurer to take a look around:\r\n\r\n```console\r\n>
    adventurer.look\r\n\r\nYou are standing at the end of a road before a small brick
    building.\r\nAround you is a forest.  A small stream flows out of the building
    and\r\ndown a gully.\r\n```\r\n\r\n## Adding some conveniences\r\n\r\nSo far we've
    created an adventurer and a starting room without any kind\r\nof `Adventurer`
    or `Room` classes. This adventure is getting off to a\r\ngood start! Although,
    if we're going to be creating a lot of these\r\nobjects we'd like for the process
    to be a little less verbose. We decide\r\nto take a step back and build some syntax
    sugar before moving onward.\r\n\r\nWe start with an `ObjectBuilder` helper class.
    Yes, this is a class, when\r\nwe are supposed to be using only prototypes. However,
    Ruby doesn't offer\r\na lot of support for prototype-based programming out of
    the box. So we\r\nhave to build our tools with the class-oriented materials at
    hand. This\r\nis intended to be behind-the-scenes support code. In other words,
    pay no\r\nattention to the man behind the green curtain!\r\n\r\n```ruby\r\nclass
    ObjectBuilder\r\n  def initialize(object)\r\n    @object = object\r\n  end\r\n\r\n
    \ def respond_to_missing?(missing_method, include_private=false)\r\n    missing_method
    =~ /=\\z/\r\n  end\r\n\r\n  def method_missing(missing_method, *args, &block)\r\n
    \   if respond_to_missing?(missing_method)\r\n      method_name = missing_method.to_s.sub(/=\\z/,
    '')\r\n      value       = args.first\r\n      ivar_name   = \"@#{method_name}\"\r\n
    \    if value.is_a?(Proc)\r\n        define_code_method(method_name, ivar_name,
    value)\r\n      else\r\n        define_value_method(method_name, ivar_name, value)\r\n
    \     end\r\n    else\r\n      super\r\n    end\r\n  end\r\n\r\n  def define_value_method(method_name,
    ivar_name, value)\r\n    @object.instance_variable_set(ivar_name, value)\r\n    @object.define_singleton_method(method_name)
    do\r\n      instance_variable_get(ivar_name)\r\n    end\r\n  end\r\n\r\n  def
    define_code_method(method_name, ivar_name, implementation)\r\n    @object.instance_variable_set(ivar_name,
    implementation)\r\n    @object.define_singleton_method(method_name) do |*args|\r\n
    \     instance_exec(*args, &instance_variable_get(ivar_name))\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThere's
    a lot going on in this class. Going over it line-by-line might\r\nbe interesting
    in its own right, but it wouldn't advance our\r\nunderstanding of prototype-based
    programming all that much. Suffice to\r\nsay for now that this class can help
    us add new attributes and methods\r\nto a singleton object using a concise assignment-style
    syntax. This will\r\nmake more sense when we start to make use of it.\r\n\r\nWe
    add another bit of syntax sugar: a global method named `Object` (not\r\nto be
    confused with the class of the same name):\r\n\r\n```ruby\r\ndef Object(&definition)\r\n
    \ obj = Object.new\r\n  obj.singleton_class.instance_exec(ObjectBuilder.new(obj),
    &definition)\r\n  obj\r\nend\r\n```\r\n\r\nThis method takes a block, instantiates
    a new object, and evaluates the\r\nblock in the context of the object's singleton
    class, passing an\r\n`ObjectBuilder` as a block argument. Then it returns the
    new object.\r\n\r\nNow we recreate our adventurer using this new helper:\r\n\r\n```ruby\r\nadventurer
    = Object { |o|\r\n  o.location = end_of_road\r\n\r\n  attr_writer :location\r\n\r\n
    \ o.look = ->(*args) {\r\n    puts location.description\r\n  }\r\n}\r\n```\r\n\r\nThe
    combination of the `Object` factory method and the `ObjectBuilder`\r\ngives us
    a convenient, powerful notation for creating new ad-hoc\r\nobjects. We can create
    attribute reader methods and assign the value of\r\nthe attribute all at once:\r\n\r\n```ruby\r\no.location
    = end_of_road\r\n```\r\n\r\nWe can use standard Ruby class-level code:\r\n\r\n```ruby\r\nattr_writer
    :location\r\n```\r\n\r\nAnd finally we can define new methods by assigning a lambda
    to an \r\nattribute:\r\n\r\n```ruby\r\no.look = ->(*args) { puts location.description
    }\r\n```\r\n\r\nWe've deliberately avoided defining methods using `def` or\r\n`define_method`.
    We'll get into the reasons for that later on.\r\n\r\nBefore we move on, let's
    take a moment to make sure our shiny new adventurer still works the\r\nsame as
    before:\r\n\r\n```console\r\n> adventurer.look\r\n\r\nYou are standing at the
    end of a road before a small brick building.\r\nAround you is a forest.  A small
    stream flows out of the building and\r\ndown a gully.\r\n```\r\n\r\n## Moving
    around\r\n\r\nIt's time to let our adventurer object stretch its legs a bit.\r\nWe
    want to give it the ability to move from location to location. First,\r\nwe make
    a small modification to our `Object()` method:\r\n\r\n```ruby\r\ndef Object(object=nil,
    &definition)\r\n  obj = object || Object.new\r\n  obj.singleton_class.instance_exec(ObjectBuilder.new(obj),
    &definition)\r\n  obj\r\nend\r\n```\r\n\r\nNow along with creating new objects,
    `Object()` can also augment an\r\nexisting object which is passed in as an argument.\r\n\r\nWe
    pass the `adventurer` to `Object()`, and add a new `#go` method. This\r\nmethod
    will take a direction (like `:east`), and attempt to move to the\r\nnew location
    using the `exits` association on its current location:\r\n\r\n```ruby\r\nObject(adventurer)
    { |o|\r\n  o.go = ->(direction){\r\n    if(destination = location.exits[direction])\r\n
    \     self.location = destination\r\n      puts location.description\r\n    else\r\n
    \     puts \"You can't go that way\"\r\n    end\r\n  }\r\n}\r\n```\r\n\r\nWe add
    a destination room to the system:\r\n\r\n```ruby\r\nwellhouse = Object { |o|\r\n
    \ o.description = <<END\r\nYou are inside a small building, a wellhouse for a
    large spring.\r\nEND\r\n}\r\n```\r\n\r\nThen we add an `exits` Hash to `end_of_road`,
    with an entry saying that\r\nthe `wellhouse` is to the `:north` of it:\r\n\r\n```ruby\r\nObject(end_of_road)
    { |o| o.exits = {north: wellhouse} }\r\n```\r\n\r\nWith that done, we are now
    ready to set off on our journey!\r\n\r\n```console\r\n> adventurer.go(:north)\r\n\r\nYou
    are inside a small building, a wellhouse for a large spring.\r\n```\r\n\r\n##
    Cloning prototypes\r\n\r\nWe try to go north again, expecting to see the admonition
    \"You can't go\r\nthat way\" as we bump into the wall:\r\n\r\n```console\r\n>
    adventurer.go(:north)\r\n```\r\n\r\nInstead, we get an exception:\r\n\r\n```console\r\n-:82:in
    `block (2 levels) in <main>': undefined method `exits' for \r\n#<Object:0x0000000434d768>
    (NoMethodError)\r\n        from -:56:in `instance_exec'\r\n        from -:56:in
    `block (2 levels) in define_code_method'\r\n        from -:100:in `<main>'\r\n```\r\n\r\nThis
    is because we never got around to adding an `exits` Hash to\r\n`wellhouse`. We
    could go ahead and do that now. But as we think about\r\nit, we realize that now
    that our adventurer is capable of travel, it\r\nwould make sense if all rooms
    started out with an empty `exits` Hash,\r\ninstead of us having to add it manually
    every time.\r\n\r\nToward that end, we create a *prototypical room*:\r\n\r\n```ruby\r\nroom
    = Object { |o| o.exits = {} }\r\n```\r\n\r\nWe then experiment with creating a
    new `wellhouse`, this one based on\r\nthe `room` prototype. We do this by simply
    cloning the `room` object. We\r\nuse `#clone` rather than `#dup` because `#clone`
    copies singleton class\r\nmethods:\r\n\r\n```ruby\r\nnew_wellhouse = room.clone\r\n\r\nnew_wellhouse.exits[:south]
    = end_of_road\r\n```\r\n\r\nWe quickly uncover a problem with this naive cloning
    technique. Because\r\nRuby's `#clone` (as well as `#dup`) are *shallow copies*,
    `room` and\r\n`new_wellhouse` now share the same `exits`:\r\n\r\n```ruby\r\nrequire
    'pp'\r\n\r\nputs \"new_wellhouse exits:\"\r\npp new_wellhouse.exits\r\nputs \"room
    exits:\"\r\npp room.exits\r\n```\r\n\r\n```console\r\nnew_wellhouse exits:\r\n{:south=>\r\n
    \ #<Object:0x0000000482c8d8\r\n   @exits=\r\n    {:north=>\r\n      #<Object:0x0000000482bcd0\r\n
    \      @description=\r\n        \"You are inside a small building, a wellhouse
    for a large spring.\\n\">}>}\r\nroom exits:\r\n{:south=>\r\n  #<Object:0x0000000482c8d8\r\n
    \  @exits=\r\n    {:north=>\r\n      #<Object:0x0000000482bcd0\r\n       @description=\r\n
    \       \"You are inside a small building, a wellhouse for a large spring.\\n\">}>}\r\n```\r\n\r\nTo
    fix this, we could possibly customize the way Ruby does cloning by overriding\r\nthe
    [Object#initialize_clone](http://jonathanleighton.com/articles/2011/initialize_clone-initialize_dup-and-initialize_copy-in-ruby/)\r\nmethod,
    but that would be an invasive change with broad reaching effects.\r\nBecause extending
    core objects is a bit safer than modifying them, we opt to\r\ndefine our own `Object#copy`
    method which does a one-level-deep copying of\r\ninstance variables:\r\n\r\n```ruby\r\nclass
    Object\r\n  def copy\r\n    prototype = clone\r\n\r\n    instance_variables.each
    do |ivar_name|\r\n      prototype.instance_variable_set(\r\n        ivar_name,\r\n
    \       instance_variable_get(ivar_name).clone)\r\n    end\r\n\r\n    prototype\r\n
    \ end\r\nend\r\n```\r\n\r\nThen we recreate `room` and `new_wellhouse`, and confirm
    that they no\r\nlonger share exits:\r\n\r\n```ruby\r\nroom = Object { |o| o.exits
    = {} }\r\n\r\n# Use the newly defined Object#copy here instead of Object#clone\r\nnew_wellhouse
    = room.copy\r\n\r\nnew_wellhouse.exits[:south] = end_of_road\r\n\r\nputs \"new_wellhouse
    exits:\"\r\npp new_wellhouse.exits\r\nputs \"room exits:\"\r\npp room.exits\r\n```\r\n\r\n```console\r\nnew_wellhouse
    exits:\r\n{:south=>\r\n  #<Object:0x00000002ea85d8\r\n   @exits=\r\n    {:north=>\r\n
    \     #<Object:0x00000002ea79d0\r\n       @description=\r\n        \"You are inside
    a small building, a wellhouse for a large spring.\\n\">}>}\r\nroom exits:\r\n{}\r\n```\r\n\r\nCloning
    a prototypical object in order to create new\r\nobjects is the most basic form
    of prototype-based programming. In fact,\r\nthe \"Kevo\" research language (I'd
    link to it, but all the information\r\nabout it seems to have fallen off the Internet)
    used copying as the sole\r\nway to share behavior between objects.\r\n\r\n## Building
    dynamic prototypes\r\n\r\nThere are drawbacks to copying, however. It's a very
    static way to share\r\nbehavior between objects. Clones of `room` only share the
    behavior which\r\nwas defined at the time of the copy. If we were to modify `room`,
    we'd\r\nhave to recreate the `new_wellhouse` object once again in order to take\r\nadvantage
    of any new methods added to it.\r\n\r\nCloning also implies single inheritance.
    An object can only be a clone\r\nof one \"parent\" object.\r\n\r\nFinally, we
    also can't add any new behavior to our existing `wellhouse`\r\nobject this way.
    We'd have to throw away our program's state and rebuild\r\nit, this time cloning
    our `end_of_road` and `wellhouse` objects from\r\n`room`.\r\n\r\nIn Ruby, we're
    used to being able to make changes to a live session and\r\nsee how they play
    out. Thus far, we've done this all in a live\r\ninterpreter session. It seems
    a shame to have to lose our state and\r\nstart again. So we decide to find out
    if we can come up with a more\r\ndynamic form of prototypical inheritance than
    plain copying.\r\n\r\nWe start by adding a helper method called `#implementation_of`
    to\r\nObject. Given a method name that the object supports, it will return a\r\n`Proc`
    object containing the code of that method. We make it aware of\r\nthe style of
    method definition used in `ObjectBuilder`, where the\r\nimplementation `Procs`
    of new methods were stored in instance variables\r\nnamed for the methods:\r\n\r\n```ruby\r\nclass
    Object\r\n  def implementation_of(method_name)\r\n    if respond_to?(method_name)\r\n
    \     implementation = instance_variable_get(\"@#{method_name}\")\r\n      if
    implementation.is_a?(Proc)\r\n        implementation\r\n      elsif instance_variable_defined?(\"@#{method_name}\")\r\n
    \       # Assume the method is a reader\r\n        ->{ instance_variable_get(\"@#{method_name}\")
    }\r\n      else\r\n        method(method_name).to_proc\r\n      end\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nWe then define a new kind of `Module`, called `Prototype`:\r\n\r\n```ruby\r\nclass
    Prototype < Module\r\n  def initialize(target)\r\n    @target = target\r\n    super()
    do\r\n      define_method(:respond_to_missing?) do |missing_method, include_private|\r\n
    \       target.respond_to?(missing_method)\r\n      end\r\n\r\n      define_method(:method_missing)
    do |missing_method, *args, &block|\r\n        if target.respond_to?(missing_method)\r\n
    \         implementation = target.implementation_of(missing_method)\r\n          instance_exec(*args,
    &implementation)\r\n        else\r\n          super(missing_method, *args, &block)\r\n
    \       end\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nA `Prototype`
    is instantiated with a prototypical object. When a\r\n`Prototype` instance is
    added to an object using `#extend`, it makes the\r\nmethods of the prototype available
    to the extended object. It does this\r\nby implementing `#method_missing?` (and
    the associated\r\n`#respond_to_missing?`). When a message is sent to the extended
    object\r\nthat matches a method on the prototype object, the `Prototype` grabs
    the\r\nimplementation `Proc` from the prototype. Then it uses `#instance_exec`\r\nto
    evaluate the `prototype`'s method in the context of the extended\r\nobject. In
    effect, the extended object \"borrows\" a method from the\r\nprototype object
    for just long enough to execute it.\r\n\r\nNote that this is different from delegation.
    In delegation, one object\r\nhands off a message to be handled by another object.
    If object `a`\r\ndelegates a `#foo` message to object `b`, using, for instance,
    Ruby's\r\n`forwardable` library, `self` in that method will be object `b`. This
    is\r\neasily demonstrated:\r\n\r\n```ruby\r\nrequire 'forwardable'\r\n\r\nclass
    A\r\n  extend Forwardable\r\n  attr_accessor :b\r\n  def_delegator :b, :foo\r\nend\r\n\r\nclass
    B\r\n  def foo\r\n    puts \"executing #foo in #{self}\"\r\n  end\r\nend\r\n\r\na
    = A.new\r\na.b = B.new\r\na.foo\r\n# >> executing #foo in #<B:0x00000003295e20>\r\n```\r\n\r\nBut
    delegation is not what we want. We want to execute the methods from\r\nprototypes
    as if they had been defined on the inheriting object. We want\r\nthis because
    we want them to work with the instance variables of the\r\ninheriting object.
    If we send `wellhouse.exits`, we want the reader\r\nmethod to show us the content
    of `wellhouse`'s `@exits` instance\r\nvariable, not `room`'s instance variable.\r\n\r\nRemember
    how, in `ObjectBuilder`, we stored the implementations of\r\nmethods as `Procs`
    in instance variables rather than defining them\r\ndirectly as methods? This need
    to call prototype methods on the\r\ninheriting object is the reason for that.
    In Ruby, it is not possible to\r\nexecute a method from class A on an instance
    of unrelated class B. Since\r\nin this program we are using the singleton classes
    of objects to define\r\nall of their methods, Ruby considers all of our objects
    as belonging to\r\ndifferent classes for the purposes of method binding. We can
    see this if\r\nwe try to rebind a method from `room` onto `wellhouse` and then
    call it:\r\n\r\n```ruby\r\nroom.method(:exits).unbind.bind(wellhouse)\r\n```\r\n\r\n```console\r\n-:115:in
    `bind': singleton method called for a different object (TypeError)\r\n        from
    -:115:in `<main>'\r\n```\r\n\r\nBy storing the implementation of methods as raw
    `Procs`, without any\r\nassociation to a specific class, we are able to take the
    implementations\r\nand `instance_exec` them in other contexts.\r\n\r\nThe last
    change we make to support dynamic prototype inheritance is to\r\nadd a new `#prototype`
    method to our `ObjectBuilder`:\r\n\r\n```ruby\r\nclass ObjectBuilder\r\n  def
    prototype(proto)\r\n    # Leave method implementations on the proto object\r\n
    \   ivars = proto.instance_variables.reject{ |ivar_name|\r\n      proto.respond_to?(ivar_name.to_s[1..-1])
    &&\r\n      proto.instance_variable_get(ivar_name).is_a?(Proc)\r\n    }\r\n    ivars.each
    do |ivar_name|\r\n      unless @object.instance_variable_defined?(ivar_name)\r\n
    \       @object.instance_variable_set(\r\n          ivar_name,\r\n          proto.instance_variable_get(ivar_name).dup)\r\n
    \     end\r\n    end\r\n    @object.extend(Prototype.new(proto))\r\n  end\r\nend\r\n```\r\n\r\nThis
    method does two things:\r\n\r\n1.  It copies instance variables from a prototype
    object to the object\r\n    being built.\r\n2.  It extends the object being built
    with a `Prototype` module\r\n    referencing the prototype object.\r\n\r\nWe can
    now use all of this new machinery to dynamically add `room` as a\r\nprototype
    of `wellhouse`. We are then able to set the south exit to\r\npoint back to `end_of_road`,
    using the `exits` association that\r\n`wellhouse` now inherits from `room`:\r\n\r\n```ruby\r\nObject(wellhouse)
    { |o| o.prototype room }\r\n\r\nwellhouse.exits[:south] = end_of_road\r\n\r\nadventurer.location
    = wellhouse\r\n```\r\n\r\nThen we can move around again to make sure things are
    working as expected:\r\n\r\n```ruby\r\nputs \"* trying to go north from wellhouse\"\r\nadventurer.go(:north)\r\n\r\nputs
    \"* going back south\"\r\nadventurer.go(:south)\r\n```\r\n\r\n```console\r\n*
    trying to go north from wellhouse\r\nYou can't go that way\r\n* going back south\r\nYou
    are standing at the end of a road before a small brick building.\r\nAround you
    is a forest.  A small stream flows out of the building and\r\ndown a gully.\r\n```\r\n\r\n##
    Carrying items around\r\n\r\nWe now have some powerful tools at our disposal for
    composing objects\r\nfrom prototypes. We quickly proceed to implement the ability
    to pick up\r\nand drop items to our game. We start by creating a prototypical\r\n\"container\"
    object, which has an array of items and the ability to\r\ntransfer an item from
    itself to another container:\r\n\r\n```ruby\r\ncontainer = Object { |o|\r\n  o.items
    = []\r\n  o.transfer_item = ->(item, recipient) {\r\n    recipient.items << items.delete(item)\r\n
    \ }\r\n}  \r\n```\r\n\r\nWe then make the `adventurer` a container, and add some
    commands for\r\ntaking items, dropping items, and listing the adventurer's current\r\ninventory:\r\n\r\n```ruby\r\nObject(adventurer)
    {|o|\r\n  o.prototype container\r\n\r\n  o.look = -> {\r\n    puts location.description\r\n
    \   location.items.each do |item|\r\n      puts \"There is #{item} here.\"\r\n
    \   end\r\n  }\r\n\r\n  o.take = ->(item_name) {\r\n    item = location.items.detect{|item|
    item.include?(item_name) }\r\n    if item\r\n      location.transfer_item(item,
    self)\r\n      puts \"You take #{item}.\"\r\n    else\r\n      puts \"You see
    no #{item_name} here\"\r\n    end\r\n  }\r\n\r\n  o.drop = ->(item_name) {\r\n
    \   item = items.detect{|item| item.include?(item_name) }\r\n    if item\r\n      transfer_item(item,
    location)\r\n      puts \"You drop #{item}.\"\r\n    else\r\n      puts \"You
    are not carrying #{item_name}\"\r\n    end\r\n  }\r\n\r\n  o.inventory = -> {\r\n
    \   items.each do |item|\r\n      puts \"You have #{item}\"\r\n    end\r\n  }\r\n}\r\n```\r\n\r\nFor
    convenience, we've implemented `#take` and `#drop` so that they can\r\naccept
    any substring of the intended object's name.\r\n\r\nNext we make `wellhouse` a
    container, and add a list of starting items\r\nto it:\r\n\r\n```ruby\r\nObject(wellhouse)
    { |o|\r\n  o.prototype container\r\n  o.items = [\r\n    \"a shiny brass lamp\",\r\n
    \   \"some food\",\r\n    \"a bottle of water\"\r\n  ]\r\n  o.exits = {south:
    end_of_road}\r\n}\r\n```\r\n\r\nAs you may recall, `wellhouse` already has a prototype:
    `room`. But this\r\nis not a problem. One of the advantages of our dynamic prototyping\r\nsystem
    is that objects may have any number of prototypes. Since\r\nprototyping is implemented
    using specialized modules, when an object is\r\nsent a message that it can't handle
    itself, Ruby will keep searching up an\r\nobject's ancestor chain, from one `Prototype`
    to the next, looking for a\r\nmatching method. (This also puts us one-up on JavaScript's\r\nsingle-inheritance
    prototype system!)\r\n\r\nFinally, we make `end_of_road` a container:\r\n\r\n```ruby\r\nObject(end_of_road)
    { |o| o.prototype(container) }\r\n```\r\n\r\nWe then proceed to tell our adventurer
    to pick up a bottle of water from\r\nthe wellhouse, and put it down at the end
    of the road:\r\n\r\n```console\r\n> adventurer.go(:north)\r\nYou are inside a
    small building, a wellhouse for a large spring.\r\n> adventurer.take(\"water\")\r\nYou
    take a bottle of water.\r\n> adventurer.inventory\r\nYou have a bottle of water\r\n>
    adventurer.look\r\nYou are inside a small building, a wellhouse for a large spring.\r\nThere
    is a shiny brass lamp here.\r\nThere is some food here.\r\n> adventurer.go(:south)\r\nYou
    are standing at the end of a road before a small brick building.\r\nAround you
    is a forest.  A small stream flows out of the building and\r\ndown a gully.\r\n>
    adventurer.drop(\"water\")\r\nYou drop a bottle of water.\r\n> adventurer.look\r\nYou
    are standing at the end of a road before a small brick building.\r\nAround you
    is a forest.  A small stream flows out of the building and\r\ndown a gully.\r\nThere
    is a bottle of water here.\r\n```\r\n\r\nAnd with that, we now have a small but
    functional system which allows us to move\r\naround the game world and interact
    with it.\r\n\r\n## Reflections\r\n\r\nWe've written the beginnings of a text adventure
    game in a\r\nprototype-based style. Now, let's take a step back and talk about
    what\r\nthe point of this exercise was.\r\n\r\nThere is a strong argument to be
    made that prototype-based inheritance\r\nmore closely maps to how humans normally
    think through problems than\r\ndoes class-based inheritance. Quoting the paper
    \"[Classes vs.\r\nPrototypes: Some Philosophical and Historical\r\nObservations](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.4713)\":\r\n\r\n>
    A typical argument in favor of prototypes is that people seem to be a\r\n> lot
    better at dealing with specific examples first, then generalizing\r\n> from them,
    than they are at absorbing general abstract principles\r\n> first and later applying
    them in particular cases, ... the ability to\r\n> modify and evolve objects at
    the level of individual objects reduces\r\n> the need for a priori classification
    and encourages a more iterative\r\n> programming and design style.\r\n\r\nAs we
    built up our adventure game, we immediately added concrete objects\r\nto the system
    as soon as we thought them up. We added an `adventurer`,\r\nand then an `end_of_road`
    for the adventurer to start out in. Then\r\nlater, as we added more objects, we
    generalized out commonalities into\r\nobjects like `room` and `container`. Our
    program design emerged\r\ncompletely organically, and our abstractions emerged
    as soon as we\r\nneeded them, but no sooner. This kind of emergent, organic design\r\nprocess
    is one of the ideals of agile software development, and\r\nprototype-based systems
    seem to encourage it.\r\n\r\nOf course, the way we jammed prototypes into a class-based
    language here\r\nis a horrendous hack: please don't use it in a production system!\r\nBut
    the experience of writing code in a prototyped style can teach\r\nus a lot. We
    can use what we've learned to influence our daily\r\ncoding. We might prototype
    (heh) a system's design by writing one-off\r\nobjects at first, adding methods
    to their singleton classes. Then, as\r\npatterns of interaction emerge, we might
    capture the design using\r\nclasses. Prototypes can also teach us to do more with
    delegation and\r\ncomposition, building families of collaborating objects rather
    than\r\nhierarchies of related behavior.\r\n\r\nNow that we've reached the end
    of our journey, I hope you've found \r\nthis trip through prototype-land illuminating
    and thought-provoking. \r\nI'm still a relative newb to this way of thinking,
    so if you\r\nhave anything to add i.e. other benefits of using prototypes; subtle
    gotchas;\r\nexperiences from prototype-based languages, or alternative implementations
    of\r\nany of the code above, please don't hesitate to pipe up in the comments.
    Also,\r\nif you want clarifications about any of the gnarly metaprogramming I
    used to\r\nbash Ruby into a semblance of a prototype-based language, feel free
    to ask --\r\nbut I can't guarantee that the answers will make any more sense than
    the\r\ncode :-)\r\n\r\n> **NOTE:** If you had fun reading this article, you may
    also enjoy reading Advi's \r\n> blog post on the [Prototype Pattern](http://devblog.avdi.org/?p=5560),
    a design pattern that takes \r\n> ideas from prototype-based programming and applies
    them to class-based\r\n> modeling. That post started as a section of this article
    that gained a life\r\n> of its own.\r\n"
- :slug: parsing-json-the-hard-way
  :title: Parsing JSON the hard way
  :summary: Learn about low-level parser and compiler tools by implementing a JSON
    parser. (w. Aaron Patterson)
  :published: 2013-01-01 00:00:00.000000000 Z
  :issue_number: '6.1'
  :volume: 6
  :body: "*This article was written by Aaron Patterson, a Ruby\r\ndeveloper living
    in Seattle, WA.  He's been having fun writing Ruby for the past\r\n7 years, and
    hopes to share his love of Ruby with you.*\r\n\r\nHey everybody!  I hope you're
    having a great day today!  The sun has peeked out\r\nof the clouds for a bit today,
    so I'm doing great!\r\n\r\nIn this article, we're going to be looking at some
    compiler tools for use with Ruby.  In\r\norder to explore these tools, we'll write
    a JSON parser.  I know you're saying,\r\n\"but Aaron, *why* write a JSON parser?
    \ Don't we have like 1,234,567 of them?\".\r\nYes!  We do have precisely 1,234,567
    JSON parsers available in Ruby!  We're\r\ngoing to parse JSON because the grammar
    is simple enough that we can finish the\r\nparser in one sitting, and because
    the grammar is complex enough that we can\r\nexercise some of Ruby's compiler
    tools.\r\n\r\nAs you read on, keep in mind that this isn't an article about parsing
    JSON, \r\nits an article about using parser and compiler tools in Ruby.\r\n\r\n##
    The Tools We'll Be Using\r\n\r\nI'm going to be testing this with Ruby 2.1.0,
    but it should work under any\r\nflavor of Ruby you wish to try.  Mainly, we will
    be using a tool called `Racc`,\r\nand a tool called `StringScanner`.\r\n\r\n**Racc**\r\n\r\nWe'll
    be using Racc to generate our parser.  Racc is an LALR parser generator\r\nsimilar
    to YACC.  YACC stands for \"Yet Another Compiler Compiler\", but this is\r\nthe
    Ruby version, hence \"Racc\".  Racc converts a grammar file (the \".y\" file)\r\nto
    a Ruby file that contains state transitions.  These state transitions are\r\ninterpreted
    by the Racc state machine (or runtime).  The Racc runtime ships\r\nwith Ruby,
    but the tool that converts the \".y\" files to state tables does not.\r\nIn order
    to install the converter, do `gem install racc`.\r\n\r\nWe will write \".y\" files,
    but users cannot run the \".y\" files.  First we convert\r\nthem to runnable Ruby
    code, and ship the runnable Ruby code in our gem.  In\r\npractical terms, this
    means that *only we install the Racc gem*, other users\r\ndo not need it.\r\n\r\nDon't
    worry if this doesn't make sense right now.  It will become more clear\r\nwhen
    we get our hands dirty and start playing with code.\r\n\r\n**StringScanner**\r\n\r\nJust
    like the name implies, [StringScanner](http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html)\r\nis
    a class that helps us scan strings.  It keeps track of where we are\r\nin the
    string, and lets us advance forward via regular expressions or by\r\ncharacter.\r\n\r\nLet's
    try it out!  First we'll create a `StringScanner` object, then we'll scan\r\nsome
    letters from it:\r\n\r\n```ruby\r\nrequire 'strscan'\r\n\r\nss = StringScanner.new
    'aabbbbb' #=> #<StringScanner 0/7 @ \"aabbb...\">\r\nss.scan /a/ #=> \"a\"\r\nss.scan
    /a/ #=> \"a\"\r\nss.scan /a/ #=> nil\r\nss #=> #<StringScanner 2/7 \"aa\" @ \"bbbbb\">\r\n```\r\n\r\nNotice
    that the third call to\r\n[StringScanner#scan](http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html#method-i-scan)\r\nresulted
    in a `nil`, since the regular expression did not match from the current\r\nposition.
    \ Also note that when you inspect the `StringScanner` instance, you can\r\nsee
    the position of the scanner (in this case `2/7`).\r\n\r\nWe can also move through
    the scanner character by character using\r\n[StringScanner#getch](http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html#method-i-getch):\r\n\r\n```ruby\r\nss
    #=> #<StringScanner 2/7 \"aa\" @ \"bbbbb\">\r\nss.getch #=> \"b\"\r\n\r\nss #=>
    #<StringScanner 3/7 \"aab\" @ \"bbbb\">\r\n```\r\n\r\nThe `getch` method returns
    the next character, and advances the pointer by one.\r\n\r\nNow that we've covered
    the basics for scanning strings, let's take a \r\nlook at using Racc.\r\n\r\n##
    Racc Basics\r\n\r\nAs I said earlier, Racc is an LALR parser generator.  You can
    think of it as a\r\nsystem that lets you write limited regular expressions that
    can execute\r\narbitrary code at different points as they're being evaluated.\r\n\r\nLet's
    look at an example.  Suppose we have a pattern we want to match:\r\n`(a|c)*abb`.
    \ That is, we want to match any number of 'a' or 'c' followed by\r\n'abb'.  To
    translate this to a Racc grammar, we try to break up this regular\r\nexpression
    to smaller parts, and assemble them as the whole.  Each part is\r\ncalled a \"production\".
    \ Let's try breaking up this regular expression so that we\r\ncan see what the
    productions look like, and the format of a Racc grammar file.\r\n\r\nFirst we
    create our grammar file.  At the top of the file, we declare the Ruby\r\nclass
    to be produced, followed by the `rule` keyword to indicate that we're\r\ngoing
    to declare the productions, followed by the `end` keyword to indicate the\r\nend
    of the productions:\r\n\r\n```\r\nclass Parser\r\nrule\r\nend\r\n```\r\n\r\nNext
    lets add the production for \"a|c\".  We'll call this production `a_or_c`:\r\n\r\n\r\n```\r\nclass
    Parser\r\nrule\r\n  a_or_c : 'a' | 'c' ;\r\nend\r\n```\r\n\r\nNow we have a rule
    named `a_or_c`, and it matches the characters 'a' or 'c'.  In\r\norder to match
    one or more `a_or_c` productions, we'll add a recursive\r\nproduction called `a_or_cs`:\r\n\r\n```\r\nclass
    Parser\r\nrule\r\n  a_or_cs\r\n    : a_or_cs a_or_c\r\n    | a_or_c\r\n    ;\r\n
    \ a_or_c : 'a' | 'c' ;\r\nend\r\n```\r\n\r\nThe `a_or_cs` production recurses
    on itself, equivalent to the regular\r\nexpression `(a|c)+`.  Next, a production
    for 'abb':\r\n\r\n```\r\nclass Parser\r\nrule\r\n  a_or_cs\r\n    : a_or_cs a_or_c\r\n
    \   | a_or_c\r\n    ;\r\n  a_or_c : 'a' | 'c' ;\r\n  abb    : 'a' 'b' 'b' \r\nend\r\n```\r\n\r\nFinally,
    the `string` production ties everything together:\r\n\r\n\r\n```\r\nclass Parser\r\nrule\r\n
    \ string\r\n    : a_or_cs abb\r\n    | abb\r\n    ;\r\n  a_or_cs\r\n    : a_or_cs
    a_or_c\r\n    | a_or_c\r\n    ;\r\n  a_or_c : 'a' | 'c' ;\r\n  abb    : 'a' 'b'
    'b';\r\nend\r\n```\r\n\r\nThis final production matches one or more 'a' or 'c'
    characters followed by\r\n'abb', or just the string 'abb' on its own.  This is
    equivalent to our original\r\nregular expression of `(a|c)*abb`.\r\n\r\n**But
    Aaron, this is so long!**\r\n\r\nI know, it's much longer than the regular expression
    version.  However, we can\r\nadd arbitrary Ruby code to be executed at any point
    in the matching process.\r\nFor example, every time we find just the string \"abb\",
    we can execute some\r\narbitrary code:\r\n\r\n```\r\nclass Parser\r\nrule\r\n
    \ string\r\n    | a_or_cs abb\r\n    | abb         \r\n    ;\r\n  a_or_cs\r\n
    \   : a_or_cs a_or_c\r\n    | a_or_c\r\n    ;\r\n  a_or_c : 'a' | 'c' ;\r\n  abb
    \   : 'a' 'b' 'b' { puts \"I found abb!\" };\r\nend\r\n```\r\n\r\nThe Ruby code
    we want to execute should be wrapped in curly braces and placed\r\nafter the rule
    where we want the trigger to fire.\r\n\r\nTo use this parser, we also need a tokenizer
    that can break the input\r\ndata into tokens, along with some other boilerplate
    code. If you are curious\r\nabout how that works, you can check out [this standalone\r\nexample](https://gist.githubusercontent.com/sandal/9532497/raw/8e3bb03fc24c8f6604f96516bf242e7e13d0f4eb/parser_example.y).\r\n\r\nNow
    that we've covered the basics, we can use knowledge we have so far to build \r\nan
    event based JSON parser and tokenizer.\r\n\r\n## Building our JSON Parser\r\n\r\nOur
    JSON parser is going to consist of three different objects, a parser, a\r\ntokenizer,
    and document handler.The parser will be written with a Racc grammar, \r\nand will
    ask the tokenizer for input from the input stream.  Whenever the parser \r\ncan
    identify a part of the JSON stream, it will send an event to the document \r\nhandler.
    \ The document handler is responsible for collecting the JSON \r\ninformation
    and translating it to a Ruby data structure. When we read in \r\na JSON document,
    the following method calls are made:\r\n\r\n![method calls](//i.imgur.com/HZ0Sa.png)\r\n\r\nIt's
    time to get started building this system. We'll focus on building the \r\ntokenizer
    first, then work on the grammar for the parser, and finally implement \r\nthe
    document handler.\r\n\r\n## Building the tokenizer\r\n\r\nOur tokenizer is going
    to be constructed with an IO object.  We'll read the\r\nJSON data from the IO
    object.  Every time `next_token` is called, the tokenizer\r\nwill read a token
    from the input and return it. Our tokenizer will return the \r\nfollowing tokens,
    which we derived from the [JSON spec](http://www.json.org/):\r\n\r\n* Strings\r\n*
    Numbers\r\n* True\r\n* False\r\n* Null\r\n\r\nComplex types like arrays and objects
    will be determined by the parser.\r\n\r\n**`next_token` return values:**\r\n\r\nWhen
    the parser calls `next_token` on the tokenizer, it expects a two element\r\narray
    or a `nil` to be returned.  The first element of the array must contain\r\nthe
    name of the token, and the second element can be anything (but most people\r\njust
    add the matched text).  When a `nil` is returned, that indicates there are\r\nno
    more tokens left in the tokenizer.\r\n\r\n**`Tokenizer` class definition:**\r\n\r\nLet's
    look at the source for the Tokenizer class and walk through it:\r\n\r\n```ruby\r\nmodule
    RJSON\r\n  class Tokenizer\r\n    STRING = /\"(?:[^\"\\\\]|\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4}))*\"/\r\n
    \   NUMBER = /-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/\r\n    TRUE   =
    /true/\r\n    FALSE  = /false/\r\n    NULL   = /null/\r\n\r\n    def initialize
    io\r\n      @ss = StringScanner.new io.read\r\n    end\r\n\r\n    def next_token\r\n
    \     return if @ss.eos?\r\n\r\n      case\r\n      when text = @ss.scan(STRING)
    then [:STRING, text]\r\n      when text = @ss.scan(NUMBER) then [:NUMBER, text]\r\n
    \     when text = @ss.scan(TRUE)   then [:TRUE, text]\r\n      when text = @ss.scan(FALSE)
    \ then [:FALSE, text]\r\n      when text = @ss.scan(NULL)   then [:NULL, text]\r\n
    \     else\r\n        x = @ss.getch\r\n        [x, x]\r\n      end\r\n    end\r\n
    \ end\r\nend\r\n```\r\n\r\nFirst we declare some regular expressions that we'll
    use along with the string\r\nscanner.  These regular expressions were derived
    from the definitions on\r\n[json.org](http://www.json.org).  We instantiate a
    string scanner object in the\r\nconstructor.  String scanner requires a string
    on construction, so we read the\r\nIO object.  However, we could build an alternative
    tokenizer that reads from the\r\nIO as needed.\r\n\r\nThe real work is done in
    the `next_token` method.  The `next_token` method\r\nreturns nil if there is nothing
    left to read from the string scanner, then it\r\ntries each regular expression
    until it finds a match.  If it finds a match, it\r\nreturns the name of the token
    (for example `:STRING`) along with the text that\r\nit matched.  If none of the
    regular expressions match, then we read one\r\ncharacter off the scanner, and
    return that character as both the name of the\r\ntoken, and the value.\r\n\r\nLet's
    try feeding the tokenizer a JSON string and see what tokens come out:\r\n\r\n```ruby\r\ntok
    = RJSON::Tokenizer.new StringIO.new '{\"foo\":null}'\r\n#=> #<RJSON::Tokenizer:0x007fa8529fbeb8
    @ss=#<StringScanner 0/12 @ \"{\\\"foo...\">>\r\n\r\ntok.next_token #=> [\"{\",
    \"{\"]\r\ntok.next_token #=> [:STRING, \"\\\"foo\\\"\"]\r\ntok.next_token #=>
    [\":\", \":\"]\r\ntok.next_token #=> [:NULL, \"null\"]\r\ntok.next_token #=> [\"}\",
    \"}\"]\r\ntok.next_token #=> nil\r\n```\r\n\r\nIn this example, we wrap the JSON
    string with a `StringIO` object in order to\r\nmake the string quack like an IO.
    \ Next, we try reading tokens from the\r\ntokenizer.  Each token the Tokenizer
    understands has the name as the first value of\r\nthe array, where the unknown
    tokens have the single character value.  For\r\nexample, string tokens look like
    this: `[:STRING, \"foo\"]`, and unknown tokens\r\nlook like this: `['(', '(']`.
    \  Finally, `nil` is returned when the input has\r\nbeen exhausted.\r\n\r\nThis
    is it for our tokenizer.  The tokenizer is initialized with an `IO` object, \r\nand
    has only one method: `next_token`.  Now we can focus on the parser side.\r\n\r\n##
    Building the parser\r\n\r\nWe have our tokenizer in place, so now it's time to
    assemble the parser.  First\r\nwe need to do a little house keeping.  We're going
    to generate a Ruby file from\r\nour `.y` file.  The Ruby file needs to be regenerated
    every time the `.y` file\r\nchanges.  A Rake task sounds like the perfect solution.\r\n\r\n**Defining
    a compile task:**\r\n\r\nThe first thing we'll add to the Rakefile is a rule that
    says *\"translate .y files to\r\n.rb files using the following command\"*:\r\n\r\n```ruby\r\nrule
    '.rb' => '.y' do |t|\r\n  sh \"racc -l -o #{t.name} #{t.source}\"\r\nend\r\n```\r\n\r\nThen
    we'll add a \"compile\" task that depends on the generated `parser.rb` file:\r\n\r\n```ruby\r\ntask
    :compile => 'lib/rjson/parser.rb'\r\n```\r\n\r\nWe keep our grammar file as `lib/rjson/parser.y`,
    and when we run `rake\r\ncompile`, rake will automatically translate the `.y`
    file to a `.rb` file using\r\nRacc.\r\n\r\nFinally we make the test task depend
    on the compile task so that when we run\r\n`rake test`, the compiled file is automatically
    generated:\r\n\r\n```ruby\r\ntask :test => :compile\r\n```\r\n\r\nNow we can compile
    and test the `.y` file.\r\n\r\n**Translating the JSON.org spec:**\r\n\r\nWe're
    going to translate the diagrams from [json.org](http://www.json.org/) to a\r\nRacc
    grammar.  A JSON document should be an object or an array at the root, so\r\nwe'll
    make a production called `document` and it should be an `object` or an\r\n`array`:\r\n\r\n```\r\nrule\r\n
    \ document\r\n    : object\r\n    | array\r\n    ;\r\n```\r\n\r\nNext we need
    to define `array`.  The `array` production can either be empty, or\r\ncontain
    1 or more values:\r\n\r\n```\r\n  array\r\n    : '[' ']'\r\n    | '[' values ']'\r\n
    \   ;\r\n```\r\n\r\nThe `values` production can be recursively defined as one
    value, or many values\r\nseparated by a comma:\r\n\r\n```\r\n  values\r\n    :
    values ',' value\r\n    | value\r\n    ;\r\n```\r\n\r\nThe JSON spec defines a
    `value` as a string, number, object, array, true, false,\r\nor null.  We'll define
    it the same way, but for the immediate values such as\r\nNUMBER, TRUE, and FALSE,
    we'll use the token names we defined in the tokenizer:\r\n\r\n```\r\n  value\r\n
    \   : string\r\n    | NUMBER\r\n    | object\r\n    | array\r\n    | TRUE\r\n
    \   | FALSE\r\n    | NULL\r\n    ;\r\n```\r\n\r\nNow we need to define the `object`
    production.  Objects can be empty, or\r\nhave many pairs:\r\n\r\n```\r\n  object\r\n
    \   : '{' '}'\r\n    | '{' pairs '}'\r\n    ;\r\n```\r\n\r\nWe can have one or
    more pairs, and they must be separated with a comma.  We can\r\ndefine this recursively
    like we did with the array values:\r\n\r\n```\r\n  pairs\r\n    : pairs ',' pair\r\n
    \   | pair\r\n    ;\r\n```\r\n\r\nFinally, a pair is a string and value separated
    by a colon:\r\n\r\n```\r\n  pair\r\n    : string ':' value\r\n    ;\r\n```\r\n\r\nNow
    we let Racc know about our special tokens by declaring them at the top, and\r\nwe
    have our full parser:\r\n\r\n```\r\nclass RJSON::Parser\r\ntoken STRING NUMBER
    TRUE FALSE NULL\r\nrule\r\n  document\r\n    : object\r\n    | array\r\n    ;\r\n
    \ object\r\n    : '{' '}'\r\n    | '{' pairs '}'\r\n    ;\r\n  pairs\r\n    :
    pairs ',' pair\r\n    | pair\r\n    ;\r\n  pair : string ':' value ;\r\n  array\r\n
    \   : '[' ']'\r\n    | '[' values ']'\r\n    ;\r\n  values\r\n    : values ','
    value\r\n    | value\r\n    ;\r\n  value\r\n    : string\r\n    | NUMBER\r\n    |
    object\r\n    | array\r\n    | TRUE\r\n    | FALSE\r\n    | NULL\r\n    ;\r\n
    \ string : STRING ;\r\nend\r\n```\r\n\r\n## Building the handler\r\n\r\nOur parser
    will send events to a document handler.  The document handler will\r\nassemble
    the beautiful JSON bits in to lovely Ruby object!  Granularity of the\r\nevents
    is really up to you, but I'm going to go with 5 events:\r\n\r\n* `start_object`
    - called when an object is started\r\n* `end_object`   - called when an object
    ends\r\n* `start_array`  - called when an array is started\r\n* `end_array`    -
    called when an array ends\r\n* `scalar`       - called with terminal values like
    strings, true, false, etc\r\n\r\nWith these 5 events, we can assemble a Ruby object
    that represents the JSON\r\nobject we are parsing.\r\n\r\n**Keeping track of events**\r\n\r\nThe
    handler we build will simply keep track of events sent to us by the parser.\r\nThis
    creates tree-like data structure that we'll use to convert JSON to Ruby.\r\n\r\n```ruby\r\nmodule
    RJSON\r\n  class Handler\r\n    def initialize\r\n      @stack = [[:root]]\r\n
    \   end\r\n\r\n    def start_object\r\n      push [:hash]\r\n    end\r\n\r\n    def
    start_array\r\n      push [:array]\r\n    end\r\n\r\n    def end_array\r\n      @stack.pop\r\n
    \   end\r\n    alias :end_object :end_array\r\n\r\n    def scalar(s)\r\n      @stack.last
    << [:scalar, s]\r\n    end\r\n\r\n    private\r\n\r\n    def push(o)\r\n      @stack.last
    << o\r\n      @stack << o\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhen the parser
    encounters the start of an object, the handler pushes a list on\r\nthe stack with
    the \"hash\" symbol to indicate the start of a hash.  Events that\r\nare children
    will be added to the parent, then when the object end is\r\nencountered the parent
    is popped off the stack.\r\n\r\nThis may be a little hard to understand, so let's
    look at some examples.  If we\r\nparse this JSON: `{\"foo\":{\"bar\":null}}`,
    then the `@stack` variable will look\r\nlike this:\r\n\r\n```ruby\r\n[[:root,\r\n
    \ [:hash,\r\n    [:scalar, \"foo\"],\r\n    [:hash,\r\n      [:scalar, \"bar\"],\r\n
    \     [:scalar, nil]]]]]\r\n```\r\n\r\nIf we parse a JSON array, like this JSON:
    `[\"foo\",null,true]`, the `@stack`\r\nvariable will look like this:\r\n\r\n```ruby\r\n[[:root,\r\n
    \ [:array,\r\n    [:scalar, \"foo\"],\r\n    [:scalar, nil],\r\n    [:scalar,
    true]]]]\r\n```\r\n\r\n**Converting to Ruby:**\r\n\r\nNow that we have an intermediate
    representation of the JSON, let's convert it to\r\na Ruby data structure.  To
    convert to a Ruby data structure, we can just write a\r\nrecursive function to
    process the tree:\r\n\r\n```ruby\r\ndef result\r\n  root = @stack.first.last\r\n
    \ process root.first, root.drop(1)\r\nend\r\n\r\nprivate\r\ndef process type,
    rest\r\n  case type\r\n  when :array\r\n    rest.map { |x| process(x.first, x.drop(1))
    }\r\n  when :hash\r\n    Hash[rest.map { |x|\r\n      process(x.first, x.drop(1))\r\n
    \   }.each_slice(2).to_a]\r\n  when :scalar\r\n    rest.first\r\n  end\r\nend\r\n```\r\n\r\nThe
    `result` method removes the `root` node and sends the rest to the `process`\r\nmethod.
    \ When the `process` method encounters a `hash` symbol it builds a hash\r\nusing
    the children by recursively calling `process`.  Similarly, when an\r\n`array`
    symbol is found, an array is constructed recursively with the children.\r\nScalar
    values are simply returned (which prevents an infinite loop).  Now if we\r\ncall
    `result` on our handler, we can get the Ruby object back.\r\n\r\nLet's see it
    in action:\r\n\r\n```ruby\r\nrequire 'rjson'\r\n\r\ninput   = StringIO.new '{\"foo\":\"bar\"}'\r\ntok
    \    = RJSON::Tokenizer.new input\r\nparser  = RJSON::Parser.new tok\r\nhandler
    = parser.parse\r\nhandler.result # => {\"foo\"=>\"bar\"}\r\n```\r\n\r\n**Cleaning
    up the RJSON API:**\r\n\r\nWe have a fully function JSON parser.  Unfortunately,
    the API is not very\r\nfriendly.  Let's take the previous example, and package
    it up in a method:\r\n\r\n```ruby\r\nmodule RJSON\r\n  def self.load(json)\r\n
    \   input   = StringIO.new json\r\n    tok     = RJSON::Tokenizer.new input\r\n
    \   parser  = RJSON::Parser.new tok\r\n    handler = parser.parse\r\n    handler.result\r\n
    \ end\r\nend\r\n```\r\n\r\nSince we built our JSON parser to deal with IO from
    the start, we can add\r\nanother method for people who would like to pass a socket
    or file handle:\r\n\r\n```ruby\r\nmodule RJSON\r\n  def self.load_io(input)\r\n
    \   tok     = RJSON::Tokenizer.new input\r\n    parser  = RJSON::Parser.new tok\r\n
    \   handler = parser.parse\r\n    handler.result\r\n  end\r\n\r\n  def self.load(json)\r\n
    \   load_io StringIO.new json\r\n  end\r\nend\r\n```\r\n\r\nNow the interface
    is a bit more friendly:\r\n\r\n```ruby\r\nrequire 'rjson'\r\nrequire 'open-uri'\r\n\r\nRJSON.load
    '{\"foo\":\"bar\"}' # => {\"foo\"=>\"bar\"}\r\nRJSON.load_io open('http://example.org/some_endpoint.json')\r\n```\r\n\r\n##
    Reflections \r\n\r\nSo we've finished our JSON parser.  Along the way we've studied
    compiler\r\ntechnology including the basics of parsers, tokenizers, and even interpreters\r\n(yes,
    we actually interpreted our JSON!).  You should be proud of yourself!\r\n\r\nThe
    JSON parser we've built is versatile. We can:\r\n\r\n* Use it in an event driven
    manner by implementing a Handler object\r\n* Use a simpler API and just feed strings\r\n*
    Stream in JSON via IO objects\r\n\r\nI hope this article has given you the confidence
    to start playing with parser\r\nand compiler technology in Ruby. Please leave
    a comment if you have any\r\nquestions for me.\r\n\r\n## Post Script\r\n\r\nI
    want to follow up with a few bits of minutiae that I omitted to maintain\r\nclarity
    in the article:\r\n\r\n* [Here](https://github.com/tenderlove/rjson/blob/master/lib/rjson/parser.y)
    is\r\nthe final grammar file for our JSON parser.  Notice \r\nthe [---- inner
    section in the .y file](https://github.com/tenderlove/rjson/blob/master/lib/rjson/parser.y#L53).\r\nAnything
    in that section is included *inside* the generated parser class.  This\r\nis how
    we get the handler object to be passed to the parser.\r\n\r\n* Our parser actually
    [does the\r\ntranslation](https://github.com/tenderlove/rjson/blob/master/lib/rjson/parser.y#L42-50)\r\nof
    JSON terminal nodes to Ruby.  So we're actually doing the translation of JSON\r\nto
    Ruby in two places: the parser *and* the document handler.  The document\r\nhandler
    deals with structure where the parser deals with immediate values (like\r\ntrue,
    false, etc).  An argument could be made that none or all of this\r\ntranslation
    *should* be done in the parser.\r\n\r\n* Finally, I mentioned that [the\r\ntokenizer](https://github.com/tenderlove/rjson/blob/master/lib/rjson/tokenizer.rb)\r\nbuffers.
    \ I implemented a simple non-buffering tokenizer that you can read\r\n[here](https://github.com/tenderlove/rjson/blob/master/lib/rjson/stream_tokenizer.rb).\r\nIt's
    pretty messy, but I think could be cleaned up by using a state machine.\r\n\r\nThat's
    all. Thanks for reading! <3 <3 <3\r\n\r\n> NOTE: If you'd like to learn more about
    this topic, consider doing the Practicing Ruby self-guided course on [Streams,
    Files, and Sockets](https://practicingruby.com/articles/study-guide-1?u=dc2ab0f9bb).
    You've already completed one of its reading exercises by working through this
    article!\r\n"
- :slug: self-guided-code-tour
  :title: A self-guided tour of an interesting codebase
  :summary: Practice your code reading skills by walking through a small GUI client
    to the GNU Go game engine.
  :published: 2013-01-15 00:00:00.000000000 Z
  :issue_number: '6.2'
  :volume: 6
  :body: "> **NOTE:** This issue of Practicing Ruby is one of several content experiments
    that was published in Volume 6. It intentionally breaks away from the traditional
    article format that we have developed over the years in the hopes of finding new
    and interesting ways for you to level up your programming skills.\r\n\r\nWhen
    I prepare examples for Practicing Ruby articles, I work hard to find a linear
    path through a codebase so that I can tell a single coherent story. By doing this,
    I'm trying to help you navigate through complex problem spaces without getting
    lost along the way. This approach has its strong points, but it comes at the cost
    of discouraging ad-hoc exploration in a subtle way: if I give you a single path
    to follow through a codebase, you are less likely to veer off trail and discover
    something that I neglected to mention. This is a shame, because Practicing Ruby
    code examples are usually much deeper than the stories I tell about them.\r\n\r\nIn
    this experiment, we will discover what happens when I drop you directly into a
    codebase to explore on your own. In particular, you'll be working through understanding
    the implementation of [Weiqi](https://github.com/elm-city-craftworks/weiqi), the
    Go-playing desktop application shown in the following video:\r\n\r\n\r\n<div align=\"center\">\r\n<iframe
    width=\"720\" height=\"480\"\r\nsrc=\"//www.youtube.com/embed/5RZVfK1GdA8?rel=0\"
    frameborder=\"0\" allowfullscreen></iframe>\r\n</div>\r\n\r\n\r\nRather than attempting
    to rush off to a particular destination that I have planned for you in advance,
    I'd like you to try forging your own path and see where it takes you. Start with
    the project's [README](https://github.com/elm-city-craftworks/weiqi/blob/master/README.md)
    and then follow your interests from there.\r\n\r\nOnce you've had a chance to
    take a look around, consider either coming back here to discuss the things you
    found interesting, or continuing the conversation over on Github via tickets and
    pull requests. The code has its good and bad parts (as you'll soon find out),
    so there is definitely plenty to discuss.\r\n\r\nAnd most importantly, please
    let me know whether this particular experiment seemed to work for you or not.
    You're welcome to leave a comment below, or if you'd be more comfortable giving
    feedback in private, you can email me at: **gregory@practicingruby.com**."
- :slug: gentle-intro-to-actor-based-concurrency
  :title: A gentle introduction to actor-based concurrency
  :summary: Solve "Dining Philosophers" using mutex locks, then do it again using
    actors. (w. Alberto F. Capel)
  :published: 2013-01-25 00:00:00.000000000 Z
  :issue_number: '6.3'
  :volume: 6
  :body: "> This issue was a collaboration with [Alberto Fernndez Capel][afcapel],
    a Ruby developer\r\nfrom Spain. Although it has been through many revisions since\r\nwe
    started, Alberto's ideas, code, and explanations provided\r\nan excellent starting
    point that lead us to publish this article.\r\n\r\nConventional wisdom says that
    concurrent programming is hard, especially in \r\nRuby. This basic assumption
    is what lead many Rubyists to take an interest\r\nin languages like Erlang and
    Scala -- their baked in support for \r\nthe [actor model][actors] is meant to
    make concurrent systems \r\nmuch easier for everyday programmers to implement
    and understand.\r\n\r\nBut do you really need to look outside of Ruby to find
    concurrency primitives\r\nthat can make your work easier? The answer to that question
    probably \r\ndepends on the levels of concurrency and availability that you require,
    but\r\nthings have definitely been shaping up in recent years. In particular,
    \r\nthe [Celluloid][celluloid] framework has brought us a convenient and clean
    way to implement\r\nactor-based concurrent systems in Ruby.\r\n\r\nIn order to
    appreciate what Celluloid can do for you, you first need to\r\nunderstand what
    the actor model is, and what benefits it offers over the\r\ntraditional approach
    of directly using threads and locks for concurrent \r\nprogramming. In this article,
    we'll try to shed some light on those points by\r\nsolving a classic concurrency
    puzzle in three ways: Using Ruby's built-in\r\nprimitives (threads and mutex locks),
    using the Celluloid framework, and using a\r\nminimal implementation of the actor
    model that we'll build from scratch.\r\n\r\nBy the end of this article, you certainly
    won't be a concurrency expert\r\nif you aren't already, but you'll have a nice
    head start on some\r\nbasic concepts that will help you decide how to tackle concurrent
    programming\r\nwithin your own projects. Let's begin!\r\n\r\n## The Dining Philosophers
    Problem\r\n\r\nThe [Dining Philosophers][philosophers] problem was formulated
    by Edsger Djisktra in 1965 to\r\nillustrate the kind of issues we can find when
    multiple processes compete to\r\ngain access to exclusive resources.\r\n\r\nIn
    this problem, five philosophers meet to have dinner. They sit at a round\r\ntable
    and each one has a bowl of rice in front of them. There are also five\r\nchopsticks,
    one between each philosopher. The philosophers spent their time\r\nthinking about
    _The Meaning of Life_. Whenever they get\r\nhungry, they try to eat. But a philosopher
    needs a chopstick in each\r\nhand in order to grab the rice. If any other\r\nphilosopher
    has already taken one of those chopsticks, the hungry\r\nphilosopher will wait
    until that chopstick is available.\r\n\r\nThis problem is interesting because
    if it is not properly solved it can easily\r\nlead to deadlock issues. We'll take
    a look at those issues soon, but first let's\r\nconvert this problem domain into
    a few basic Ruby objects.\r\n\r\n### Modeling the table and its chopsticks\r\n\r\nAll
    three of the solutions we'll discuss in this article rely on a `Chopstick`\r\nclass
    and a `Table` class. The definitions of both classes are shown below:\r\n\r\n```ruby\r\nclass
    Chopstick\r\n  def initialize\r\n    @mutex = Mutex.new\r\n  end\r\n\r\n  def
    take\r\n    @mutex.lock\r\n  end\r\n\r\n  def drop\r\n    @mutex.unlock\r\n\r\n
    \ rescue ThreadError\r\n    puts \"Trying to drop a chopstick not acquired\"\r\n
    \ end\r\n\r\n  def in_use?\r\n    @mutex.locked?\r\n  end\r\nend\r\n\r\nclass
    Table\r\n  def initialize(num_seats)\r\n    @chopsticks  = num_seats.times.map
    { Chopstick.new }\r\n  end\r\n\r\n  def left_chopstick_at(position)\r\n    index
    = (position - 1) % @chopsticks.size\r\n    @chopsticks[index]\r\n  end\r\n\r\n
    \ def right_chopstick_at(position)\r\n    index = position % @chopsticks.size\r\n
    \   @chopsticks[index]\r\n  end\r\n\r\n  def chopsticks_in_use\r\n    @chopsticks.select
    { |f| f.in_use? }.size\r\n  end\r\nend\r\n```\r\n\r\nThe `Chopstick` class is
    just a thin wrapper around a regular Ruby mutex \r\nthat will ensure that two
    philosophers can not grab the same chopstick \r\nat the same time. The `Table`
    class deals with the geometry of the problem; \r\nit knows where each seat is
    at the table, which chopstick is to the left \r\nor to the right of that seat,
    and how many chopsticks are currently in use.\r\n\r\nNow that you've seen the
    basic domain objects that model this problem, we'll\r\nlook at different ways
    of implementing the behavior of the philosophers. \r\nWe'll start with what *doesn't*
    work.\r\n\r\n## A solution that leads to deadlocks\r\n\r\nThe `Philosopher` class
    shown below would seem to be the most straightforward\r\nsolution to this problem,
    but has a fatal flaw that prevents it from being\r\nthread safe. Can you spot
    it?\r\n\r\n```ruby\r\nclass Philosopher\r\n  def initialize(name)\r\n    @name
    = name\r\n  end\r\n\r\n  def dine(table, position)\r\n    @left_chopstick  = table.left_chopstick_at(position)\r\n
    \   @right_chopstick = table.right_chopstick_at(position)\r\n\r\n    loop do\r\n
    \     think\r\n      eat\r\n    end\r\n  end\r\n\r\n  def think\r\n    puts \"#{@name}
    is thinking\"\r\n  end\r\n\r\n  def eat\r\n    take_chopsticks\r\n\r\n    puts
    \"#{@name} is eating.\"\r\n\r\n    drop_chopsticks\r\n  end\r\n\r\n  def take_chopsticks\r\n
    \   @left_chopstick.take\r\n    @right_chopstick.take\r\n  end\r\n\r\n  def drop_chopsticks\r\n
    \   @left_chopstick.drop\r\n    @right_chopstick.drop\r\n  end\r\nend\r\n```\r\n\r\nIf
    you're still scratching your head, consider what happens when each\r\nphilosopher
    object is given its own thread, and all the philosophers attempt to\r\neat at
    the same time. \r\n\r\nIn this naive implementation, it is\r\npossible to reach
    a state in which every philosopher picks up their left-hand\r\nchopstick, leaving
    no chopsticks on the table. In that scenario, every\r\nphilosopher would simply
    wait forever for their right-hand chopstick to \r\nbecome available -- resulting
    in a deadlock. You can reproduce the problem\r\nby running the following code:\r\n\r\n```ruby\r\nnames
    = %w{Heraclitus Aristotle Epictetus Schopenhauer Popper}\r\n\r\nphilosophers =
    names.map { |name| Philosopher.new(name) }\r\ntable        = Table.new(philosophers.size)\r\n\r\nthreads
    = philosophers.map.with_index do |philosopher, i|\r\n  Thread.new { philosopher.dine(table,
    i) }\r\nend\r\n\r\nthreads.each(&:join)\r\nsleep\r\n```\r\n\r\nRuby is smart enough
    to inform you of what went wrong, so you should end up\r\nseeing a backtrace that
    looks something like this:\r\n\r\n```console\r\nAristotle is thinking\r\nPopper
    is eating.\r\nPopper is thinking\r\nEpictetus is eating.\r\nEpictetus is thinking\r\nHeraclitus
    is eating.\r\nHeraclitus is thinking\r\nSchopenhauer is eating.\r\nSchopenhauer
    is thinking\r\n\r\ndining_philosophers_uncoordinated.rb:79:in `join': deadlock
    detected (fatal)\r\n  from dining_philosophers_uncoordinated.rb:79:in `each'\r\n
    \ from dining_philosophers_uncoordinated.rb:79:in `<main>\r\n```\r\n\r\nIn many
    situations, the most simple solution tends to be the best one, but this\r\nis
    obviously not one of those cases. Since we've learned the hard way that the\r\nphilosophers
    cannot be safely left to their own devices, we'll need to do more\r\nto make sure
    their behaviors remain coordinated.\r\n\r\n### A coordinated mutex-based solution\r\n\r\nOne
    easy solution to this issue is introduce a `Waiter` object into the mix. In this\r\nmodel,
    the philosopher must ask the waiter before eating. If the number of chopsticks\r\nin
    use is four or more, the waiter will make the philosopher wait until someone\r\nfinishes
    eating. This will ensure that at least one philosopher will be able to eat \r\nat
    any time, avoiding the deadlock condition.\r\n\r\nThere's still a catch, though.
    From the moment the waiter checks the number of chopstick\r\nin use until the
    next philosopher starts to eat we have a critical region in our\r\nprogram: If
    we let two concurrent threads execute that code at the same time there\r\nis still
    a chance of a deadlock. For example, suppose the waiter checks the number of\r\nchopsticks
    used and see it is 3. At that moment, the scheduler yields control to\r\nanother
    philosopher who is just picking the chopstick. When the execution flow\r\ncomes
    back to the original thread, it will allow the original philosopher to\r\neat,
    even if there may be more than four chopsticks already in use.\r\n\r\nTo avoid
    this situation we need to protect the critical region with a mutex, as\r\nshown
    below:\r\n\r\n\r\n```ruby\r\nclass Waiter\r\n  def initialize(capacity)\r\n    @capacity
    = capacity\r\n    @mutex    = Mutex.new\r\n  end\r\n\r\n  def serve(table, philosopher)\r\n
    \   @mutex.synchronize do\r\n      sleep(rand) while table.chopsticks_in_use >=
    @capacity \r\n      philosopher.take_chopsticks\r\n    end\r\n\r\n    philosopher.eat\r\n
    \ end\r\nend\r\n```\r\n\r\nIntroducing the `Waiter` object requires us to make
    some minor changes to our\r\n`Philosopher` object, but they are fairly straightforward:
    \r\n\r\n```ruby\r\nclass Philosopher\r\n\r\n  # ... all omitted code same as before\r\n\r\n
    \ def dine(table, position, waiter)\r\n    @left_chopstick  = table.left_chopstick_at(position)\r\n
    \   @right_chopstick = table.right_chopstick_at(position)\r\n\r\n    loop do\r\n
    \     think\r\n\r\n      # instead of calling eat() directly, make a request to
    the waiter \r\n      waiter.serve(table, self)\r\n    end\r\n  end\r\n\r\n  def
    eat\r\n    # removed take_chopsticks call, as that's now handled by the waiter\r\n\r\n
    \   puts \"#{@name} is eating.\"\r\n\r\n    drop_chopsticks\r\n  end\r\nend\r\n```\r\n\r\nThe
    runner code also needs minor tweaks, but is mostly similar to what\r\nyou saw
    earlier:\r\n\r\n```ruby\r\nnames = %w{Heraclitus Aristotle Epictetus Schopenhauer
    Popper}\r\n\r\nphilosophers = names.map { |name| Philosopher.new(name) }\r\n\r\ntable
    \ = Table.new(philosophers.size)\r\nwaiter = Waiter.new(philosophers.size - 1)\r\n\r\nthreads
    = philosophers.map.with_index do |philosopher, i|\r\n  Thread.new { philosopher.dine(table,
    i, waiter) }\r\nend\r\n\r\nthreads.each(&:join)\r\nsleep\r\n```\r\n\r\nThis approach
    is reasonable and solves the deadlock issue, but using mutexes \r\nto synchronize
    code requires some low level thinking. Even in this simple \r\nproblem, there
    were several gotchas to consider. As programs get more\r\ncomplicated, it becomes
    really difficult to keep track of critical regions \r\nwhile ensuring that the
    code behaves properly when accessing them.\r\n\r\nThe actor model is meant to
    provide a more systematic and natural way of \r\nsharing data between threads.
    We'll now take a look at an actor-based \r\nsolution to this problem so that we
    can see how it compares to this \r\nmutex-based approach.\r\n\r\n## An actor-based
    solution using Celluloid\r\n\r\nWe'll now rework our `Philosopher` and `Waiter`
    classes to make use of \r\nCelluloid. Much of the code will remain the same, but
    some important\r\ndetails will change. The full class definitions are shown below
    to preserve\r\ncontext, but the changed portions are marked with comments.\r\n\r\nWe'll
    spend the rest of the article explaining the inner workings \r\nof this code,
    so don't worry about understanding every last detail. Instead,\r\njust try to
    get a basic idea of what's going on here:\r\n\r\n```ruby\r\nclass Philosopher\r\n
    \ include Celluloid\r\n\r\n  def initialize(name)\r\n    @name = name\r\n  end\r\n\r\n
    \ # Switching to the actor model requires us get rid of our\r\n  # more procedural
    event loop in favor of a message-oriented\r\n  # approach using recursion. The
    call to think() eventually\r\n  # leads to a call to eat(), which in turn calls
    back to think(),\r\n  # completing the loop.\r\n\r\n  def dine(table, position,
    waiter)\r\n    @waiter = waiter\r\n\r\n    @left_chopstick  = table.left_chopstick_at(position)\r\n
    \   @right_chopstick = table.right_chopstick_at(position)\r\n\r\n    think\r\n
    \ end\r\n\r\n  def think\r\n    puts \"#{@name} is thinking.\"\r\n    sleep(rand)\r\n\r\n
    \   # Asynchronously notifies the waiter object that\r\n    # the philosophor
    is ready to eat\r\n\r\n    @waiter.async.request_to_eat(Actor.current)\r\n  end\r\n\r\n
    \ def eat\r\n    take_chopsticks\r\n\r\n    puts \"#{@name} is eating.\"\r\n    sleep(rand)\r\n\r\n
    \   drop_chopsticks\r\n\r\n    # Asynchronously notifies the waiter\r\n    # that
    the philosopher has finished eating\r\n\r\n    @waiter.async.done_eating(Actor.current)\r\n\r\n
    \   think\r\n  end\r\n\r\n  def take_chopsticks\r\n    @left_chopstick.take\r\n
    \   @right_chopstick.take\r\n  end\r\n\r\n  def drop_chopsticks\r\n    @left_chopstick.drop\r\n
    \   @right_chopstick.drop\r\n  end\r\n\r\n  # This code is necessary in order
    for Celluloid to shut down cleanly\r\n  def finalize\r\n    drop_chopsticks\r\n
    \ end\r\nend\r\n\r\n\r\nclass Waiter\r\n  include Celluloid\r\n\r\n  def initialize\r\n
    \   @eating   = []\r\n  end\r\n\r\n  # because synchronized data access is ensured\r\n
    \ # by the actor model, this code is much more\r\n  # simple than its mutex-based
    counterpart. However,\r\n  # this approach requires two methods\r\n  # (one to
    start and one to stop the eating process),\r\n  # where the previous approach
    used a single serve() method.\r\n\r\n  def request_to_eat(philosopher)\r\n    return
    if @eating.include?(philosopher)\r\n\r\n    @eating << philosopher\r\n    philosopher.async.eat\r\n
    \ end\r\n\r\n  def done_eating(philosopher)\r\n    @eating.delete(philosopher)\r\n
    \ end\r\nend\r\n```\r\n\r\nThe runner code is similar to before, with only some
    very minor changes:\r\n\r\n```ruby\r\nnames = %w{Heraclitus Aristotle Epictetus
    Schopenhauer Popper}\r\n\r\nphilosophers = names.map { |name| Philosopher.new(name)
    }\r\n\r\nwaiter = Waiter.new # no longer needs a \"capacity\" argument\r\ntable
    = Table.new(philosophers.size)\r\n\r\nphilosophers.each_with_index do |philosopher,
    i| \r\n  # No longer manually create a thread, rely on async() to do that for
    us.\r\n  philosopher.async.dine(table, i, waiter) \r\nend\r\n\r\nsleep\r\n```\r\n\r\nThe
    runtime behavior of this solution is similar to that of our mutex-based\r\nsolution.
    However, the following differences in implementation are worth noting:\r\n\r\n*
    Each class that mixes in `Celluloid` becomes an actor with its own thread of execution.\r\n\r\n*
    The Celluloid library intercepts any method call run through the `async` proxy\r\nobject
    and stores it in the actor's mailbox. The actor's thread will sequentially \r\nexecute
    those stored methods, one after another.\r\n\r\n* This behavior makes it so that
    we don't need to manage threads and mutex\r\nsynchronization explicitly. The Celluloid
    library handles that under \r\nthe hood in an object-oriented manner.\r\n\r\n*
    If we encapsulate all data inside actor objects, only the actor's\r\nthread will
    be able to access and modify its own data. That prevents the\r\npossibility of
    two threads writing to a critical region at the same time,\r\nwhich eliminates
    the risk of deadlocks and data corruption.\r\n\r\nThese features are very useful
    for simplifying the way we think about\r\nconcurrent programming, but you're probably
    wondering how much magic is involved\r\nin implementing them. Let's build our
    own minimal drop-in replacement for\r\nCelluloid to find out!\r\n\r\n## Rolling
    our own actor model\r\n\r\nCelluloid provides much more functionality than what
    we can discuss\r\nin this article, but building a barebones implementation of
    the actor\r\nmodel is within our reach. In fact, the following 80 lines of code
    are\r\nenough to serve as a replacement for our use of Celluloid in the \r\nprevious
    example:\r\n\r\n```ruby\r\nrequire 'thread'\r\n\r\nmodule Actor  # To use this,
    you'd include Actor instead of Celluloid\r\n  module ClassMethods\r\n    def new(*args,
    &block)\r\n      Proxy.new(super)\r\n    end\r\n  end\r\n\r\n  class << self\r\n
    \   def included(klass)\r\n      klass.extend(ClassMethods)\r\n    end\r\n\r\n
    \   def current\r\n      Thread.current[:actor]\r\n    end\r\n  end\r\n\r\n  class
    Proxy\r\n    def initialize(target)\r\n      @target  = target\r\n      @mailbox
    = Queue.new\r\n      @mutex   = Mutex.new\r\n      @running = true\r\n\r\n      @async_proxy
    = AsyncProxy.new(self)\r\n\r\n      @thread = Thread.new do\r\n        Thread.current[:actor]
    = self\r\n        process_inbox\r\n      end\r\n    end\r\n\r\n    def async\r\n
    \     @async_proxy\r\n    end\r\n      \r\n    def send_later(meth, *args)\r\n
    \     @mailbox << [meth, args]\r\n    end\r\n\r\n    def terminate\r\n      @running
    = false\r\n    end\r\n\r\n    def method_missing(meth, *args)\r\n      process_message(meth,
    *args)\r\n    end\r\n\r\n    private\r\n\r\n    def process_inbox\r\n      while
    @running\r\n        meth, args = @mailbox.pop\r\n        process_message(meth,
    *args)\r\n      end\r\n\r\n    rescue Exception => ex\r\n      puts \"Error while
    running actor: #{ex}\"\r\n    end\r\n\r\n    def process_message(meth, *args)\r\n
    \     @mutex.synchronize do\r\n        @target.public_send(meth, *args)\r\n      end\r\n
    \   end\r\n  end\r\n\r\n  class AsyncProxy\r\n    def initialize(actor)\r\n      @actor
    = actor\r\n    end\r\n\r\n    def method_missing(meth, *args)\r\n      @actor.send_later(meth,
    *args)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis code mostly builds upon concepts
    that have already been covered in this \r\narticle, so it shouldn't be too hard
    to follow with a bit of effort. That\r\nsaid, combining meta-programming techniques
    and concurrency can\r\nlead to code that makes your eyes glaze over, so we should
    also make\r\nan attempt to discuss how this module works at the high level. Let's
    do that\r\nnow!\r\n\r\nAny class that includes the `Actor` module will be converted
    into an actor and will be \r\nable to receive asynchronous calls. We accomplish
    this by overriding the constructor\r\nof the target class so that we can return
    a proxy object every time an object of \r\nthat class is instantiated. We also
    store the proxy object in a\r\nthread level variable. This is necessary because
    when sending messages between actors, \r\nif we refer to self in method calls
    we will exposed the inner target object, \r\ninstead of the proxy. This same [gotcha
    is also present in Celluloid](https://github.com/celluloid/celluloid/wiki/Gotchas).\r\n\r\nUsing
    this mixin, whenever we attempt to create an instance of a `Philosopher`\r\nobject,
    we will actually receive an instance of `Actor::Proxy`. The `Philosopher` \r\nclass
    is left mostly untouched, and so the actor-like behavior is handled\r\nentirely
    by the proxy object. Upon instantiation, that proxy creates\r\na mailbox to store
    the incoming asynchronous messages and a thread to process those \r\nmessages.
    The inbox is a thread-safe queue that ensures that incoming message\r\nare processed
    sequentially even if they arrive at the same time. Whenever the inbox\r\nis empty,
    the actor's thread will be blocked until a new message needs to\r\nbe processed.\r\n\r\nThis
    is roughly how things work in Celluloid as well, although its\r\nimplementation
    is much more complex due to the many additional features it\r\noffers. Still,
    if you understand this code, you're well on your way to having a\r\nworking knowledge
    of what the actor model is all about.\r\n\r\n### Actors are helpful, but are not
    a golden hammer\r\n\r\nEven this minimal implementation of the actor model gets
    the low-level\r\nconcurrency primitives out of our ordinary class definitions,
    and into a\r\ncentralized place where it can be handled in a consistent and reliable
    way.\r\nCelluloid goes a lot farther than we did here by providing excellent fault\r\ntolerance
    mechanisms, the ability to recover from failures, and lots of other\r\ninteresting
    stuff. However, these benefits do come with their own share of\r\ncosts and potential
    pitfalls.\r\n\r\nSo what can go wrong when using actors in Ruby? We've already
    hinted at the potential \r\nissues that can arise due to the issue of [self schizophrenia][self]
    in \r\nproxy objects. Perhaps more complicated is the issue of mutable state:
    while\r\nusing actors guarantees that the state *within* an object will be accessed\r\nsequentially,
    it does not provide the same guarantee for the messages that are\r\nbeing passed
    around between objects. In languages like Erlang, messages consist of immutable
    parameters, so consistency \r\nis enforced at the language level. In\r\nRuby,
    we don't have that constraint, so we either need to solve this problem by\r\nconvention,
    or by freezing the objects we pass around as arguments -- which is quite\r\nrestrictive!\r\n\r\nWithout
    attempting to enumerate all the other things that could\r\ngo wrong, the point
    here is simply that there is no such thing as a golden hammer \r\nwhen it comes
    to concurrent programming. Hopefully this article has\r\ngiven you a basic sense
    of both the benefits and drawbacks of applying the\r\nactor model in Ruby, along
    with enough background knowledge to apply some\r\nof these ideas in your own projects.
    If it has done so, please do share your\r\nstory.\r\n\r\n### Source code from
    this article\r\n\r\nAll of the code from this article is in \r\nPracticing Ruby's
    [example repository][examples],\r\nbut the links below highlight the main points
    of interest:\r\n\r\n* [A solution that leads to deadlocks](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/mutex_uncoordinated/dining_philosophers.rb)\r\n*
    [A coordinated mutex-based solution](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/mutex_coordinated/dining_philosophers.rb)\r\n*
    [An actor-based solution using Celluloid](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/celluloid/dining_philosophers.rb)\r\n*
    [An actor-based solution using a hand-rolled actor library](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/actors_from_scratch/dining_philosophers.rb)\r\n*
    [Minimal implementation of the actor model](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/lib/actors.rb)\r\n*
    [Chopsticks class definition](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/lib/chopstick.rb)\r\n*
    [Table class definition](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/lib/table.rb)\r\n\r\nIf
    you see anything in the code that you have questions about, don't hesitate to\r\nask.\r\n\r\n[examples]:
    https://github.com/elm-city-craftworks/practicing-ruby-examples/tree/master/v6/003\r\n[actors]:
    http://en.wikipedia.org/wiki/Actor_model\r\n[celluloid]: http://celluloid.io/\r\n[philosophers]:
    http://en.wikipedia.org/wiki/Dining_philosophers\r\n[self]: http://en.wikipedia.org/wiki/Schizophrenia_%28object-oriented_programming%29\r\n[afcapel]:
    https://github.com/afcapel\r\n"
- :slug: code-reuse-is-complicated
  :title: 'Code reuse in Ruby: It''s complicated!'
  :summary: "Learn the costs and benefits of the many ways that Ruby lets you reuse
    code.\r\n\r\n"
  :published: 2013-02-12 00:00:00.000000000 Z
  :issue_number: '6.4'
  :volume: 6
  :body: "> NOTE: This article was one of many content experiments published in Volume
    6, which aimed to try out different formats and styles to see what readers thought
    of them.\r\n\r\nIn many of our articles, I have attempted to discuss the question
    of code reuse in Ruby (particularly composition vs. inheritance), but have found
    it difficult to express these ideas in our traditional format. Ruby's code sharing
    semantics cannot be easily expressed in a simple linear story arc, so a more formal
    style might help reveal the deeply interconnected concepts that make up this topic.\r\n\r\nBecause
    it fits the structure a bit better, I've rendered this article in PDF format.
    Please [download the document](http://notes.practicingruby.com/2013-02-12-code-reuse-in-ruby.pdf)
    and let me know what you think!\r\n"
- :slug: debugging-without-doom-and-gloom
  :title: Debugging without the doom and gloom
  :summary: Use stack traces, the Pry console, and tests to hunt bugs with confidence.
    (w. Carol Nichols)
  :published: 2013-02-26 00:00:00.000000000 Z
  :issue_number: '6.5'
  :volume: 6
  :body: "*This article was contributed by Carol Nichols\r\n([@carols10cents](http://twitter.com/carols10cents),\r\n[carols10cents@rstat.us](https://rstat.us/users/Carols10cents)),
    one of the\r\nactive maintainers of [rstat.us](https://rstat.us). Carol is also
    involved in\r\nthe Pittsburgh Ruby community, and is a co-organizer of the [Steel
    City Ruby\r\nConf](http://steelcityrubyconf.org/). At the time of writing this
    article,\r\nshe was busy doing Rails development for [Think\r\nThrough Math](http://www.thinkthroughmath.com/).*\r\n\r\nWhenever
    our code breaks, it can be hard to remain calm. Debugging\r\noften occurs when
    production is down, customers are experiencing a problem, and\r\nmanagers are
    asking for status updates every five minutes. In this situation, panicking\r\nis
    a natural response, but it can easily disrupt your troubleshooting process. It
    may\r\nlead to changing code on hunches rather than on evidence or writing\r\nuntested
    code. By rushing to fix things immediately, you may make\r\nthings worse or not
    know which of your changes actually\r\nfixed the problem. As many of us have learned
    the hard way: a\r\nchaotic debugging process is no fun for you, and no fun for
    the people\r\nwho rely on your software.\r\n\r\nHaving a calm and collected way
    of approaching software defects goes a long way,\r\nespecially if you also have
    a firm grasp of the tools and techniques that can\r\nhelp make the debugging process
    easier. This article is meant to help you with\r\nboth of those things, so let's
    get started.\r\n\r\n## Don't Panic!\r\n\r\nIf external pressures are stressing
    you out, either disable\r\nthe feature that is causing the problem, or roll the
    production code back to a known\r\nstable state before attempting to investigate
    further. Even\r\nif it isn't ideal from a usability standpoint, functioning software
    with a\r\nfew missing features is still more useful than unstable and potentially\r\ndangerous
    software.\r\n\r\nOnce you've reproduced the issue in a development environment,
    you can start to narrow down the problem using\r\na divide-and-conquer strategy.
    If you suspect the problem is coming from your\r\napplication code, you might
    try starting with an end-to-end reproduction and\r\nthen gradually eliminate components
    until you find the source of the issue.\r\nHowever, if you think the issues are
    coming from the infrastructure your\r\nproject is built on top of (libraries,
    services, frameworks, and even Ruby\r\nitself!), it might be better to start with
    minimal stand-alone examples to test your \r\nassumptions about your application's
    integration points. Picking a good \r\nangle of attack depends on the nature of
    the problem, so don't be afraid to spend some time\r\nfiguring out the right questions
    to ask -- even if you're under pressure.\r\n\r\nRegardless of your starting point,
    you won't be guaranteed to find the source\r\nof your problem right away. However,
    each new experiment you try out will add yet another constraint to your \r\nproblem
    space, making it easier to reason about what is going\r\nwrong. The fear of the
    unknown is a big part of what causes us to panic in the\r\nfirst place, and so
    this approach will help you build up the confidence you\r\nneed in order to maintain
    a calm mindset as you work.\r\n\r\nThroughout the rest of this article, we'll
    discuss some things that will \r\nhelp you find bugs, fix them, and make sure
    they stay fixed. But keep \r\nthis in mind: they work best if you don't panic!\r\n\r\n>
    Editor's Note: *Don't Panic* is the motivating\r\n> force behind several of the
    maintenance policies for practicingruby.com. For\r\n> more on this topic, see
    Lessons 4 and 5 from [Issue\r\n> 5.6](https://practicingruby.com/articles/91)\r\n\r\n##
    Read stack traces\r\n\r\nStack traces are ugly. They typically present themselves
    as a wall of text \r\nin your terminal when you aren't expecting them. When pairing,
    I've often seen people\r\nignore stack traces entirely and just start changing
    the code. But stack\r\ntraces do have valuable information in them, and learning
    to pick out the\r\nuseful parts of the stack trace can save you a lot of time
    in trying to narrow\r\ndown the problem.\r\n\r\nThe two most valuable pieces of
    information are the resulting error message\r\n(which is usually shown at the
    beginning of the stack trace in Ruby) and the\r\nlast line of your code that was
    involved (which is often in middle). The\r\nerror message will tell you *what*
    went wrong, and the last line of your\r\ncode will tell you *where* the problem
    is coming from.\r\n\r\nA particularly horrible stack trace is [this 1400 line
    trace](https://gist.github.com/carols10cents/4751381/raw/b75bdb41e7fa8ded54d13dc786808b464357effe/gistfile1.txt)\r\nfrom
    a Rails app using JRuby running on websphere. In this case, the error message\r\n*\"ERROR
    [Default Executor-thread-15]\"* is not very helpful. The vast majority of the
    lines are\r\ncoming from JRuby's Java code and are also uninformative. However,
    skimming\r\nthrough and looking for lines that don't fit in, there are some lines
    that are\r\nlonger than the others (shown wrapped and trimmed below for clarity):\r\n\r\n```\r\nrubyjit.ApplicationHelper\r\n
    \ $$entity_label_5C9C81BAF0BBC4018616956A9F87C663730CB52E.\r\n  __file__(/..LONGPREFIX../app/helpers/application_helper.rb:232)\r\n
    \ \r\nrubyjit.ApplicationHelper\r\n  $$entity_label_5C9C81BAF0BBC4018616956A9F87C663730CB52E\r\n
    \ .__file__(/..LONGPREFIX../app/helpers/application_helper.rb)\r\n```\r\n\r\nThese
    lines of the stack trace point to the last line of the Rails code that\r\nwas
    involved, line 232 of *application_helper.rb*. But this particular line\r\nof
    code was simply concatenating two strings together -- making it pretty\r\nclear
    that the problem was not caused by our application code! By trying\r\nvarious
    \ values for those strings, we eventually found the cause of the\r\nproblem: an
    [encoding-related bug](https://github.com/jruby/jruby/issues/366) in\r\nJRuby
    was causing a Ruby 1.9 specific feature to be called from within Ruby 1.8\r\nmode.
    Even though our stack trace was very unpleasant to read and did not\r\nprovide
    us with a useful error message, tracing the exception down to a\r\nparticular
    line number was essential for identifying what would have otherwise\r\nbeen a
    needle in a haystack.\r\n\r\nOf course, there are some edge cases where line numbers
    are not very helpful. One is\r\nthe dreaded *\"syntax error, unexpected $end,
    expecting keyword_end\"* error, which\r\nwill usually point to the end of one
    of your files. It actually means you're\r\nmissing an `end` somewhere in that
    file. However, these situations are rare, and\r\nso it makes sense to skim stack
    traces for relevant line numbers\r\nthat might give you a clue about where your
    bug is coming from.\r\n\r\nIf all else fails, you can always try doing a web search
    for the name of the\r\nexception and its message -- even if the results aren't
    directly related to your\r\nissue, they may give you useful hints that can help
    you discover the right\r\nquestions to ask about your problem.\r\n\r\n## Use debugging
    tools\r\n\r\nDebugging tools (such as ruby-debug) are useful because they allow
    you to inspect your code and its \r\nenvironment while it's actually running.
    However, this is also true about using\r\na REPL (such as irb), and many Rubyists
    tend to strongly prefer the latter\r\nbecause it is a comfortable workflow for
    more than just troubleshooting.\r\n\r\nThe [Pry](http://pryrepl.org/) REPL is
    becoming increasingly popular, because it\r\nattempts to serve as both a debugger
    and an interactive console simultaneously.\r\nPlacing the `binding.pry` command
    anywhere in your codebase will launch you into\r\na Pry session whenever that
    line of code is executed. From there, you can do\r\nthings like inspect the values
    in variables or run some arbitrary code. Much like \r\nirb, this lets you try
    out ideas and hypotheses quickly. If you can't easily\r\nthink of a way to capture
    the debugging information you need with some simple\r\nprint statements or a logger,
    it's a sign that using Pry might get you \r\nsomewhere.\r\n\r\nThis kind of workflow
    is especially useful when control flow gets complicated,\r\nsuch as when working
    with events or threads. For example, suppose we wanted to\r\nget a closer look
    at the behavior of [the actor model](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/master/v6/003/lib/actors.rb)\r\nfrom
    the Dining Philosopher's problem from [Issue 6.3](https://practicingruby.com/articles/100).
    \r\nHere's how we would inspect what's happening in the `Waiter#request_to_eat`\r\nmethod:\r\n\r\n```ruby\r\nrequire
    \"pry\"\r\n\r\nclass Waiter\r\n  # ...\r\n\r\n  def request_to_eat(philosopher)\r\n
    \   binding.pry\r\n    return if @eating.include?(philosopher)\r\n\r\n    @eating
    << philosopher\r\n    philosopher.async.eat\r\n  end\r\nend\r\n```\r\n\r\nBecause
    the `Waiter` class is an actor, it will execute the requests to eat in\r\nsequence,
    but they will be queued up asynchronously. As soon as one is\r\nactually executed,
    we will be dropped into a Pry session:\r\n\r\n```console\r\nFrom: (..)/dining_philosophers.rb
    @ line 61 Waiter#request_to_eat:\r\n\r\n    60: def request_to_eat(philosopher)\r\n
    => 61:   binding.pry\r\n    62:   return if @eating.include?(philosopher)\r\n
    \   63:\r\n    64:   @eating << philosopher\r\n    65:   philosopher.async.eat\r\n
    \   66: end\r\n\r\n[1] pry(#<Waiter>)>\r\n```\r\n\r\nFrom here, we can deeply
    interrogate the current state of our program,\r\nrevealing that the `philosopher`
    references an `Actor::Proxy` \r\nobject, which in turn wraps a `Philosopher` object
    \r\n(Schopenhauer in this case):\r\n\r\n```\r\n# NOTE: this output cleaned up
    somewhat for clarity\r\n\r\n[1] pry(#<Waiter>)> ls philosopher\r\nActor::Proxy#methods:
    async  method_missing  send_later  terminate\r\ninstance variables: @async_proxy
    \ @mailbox  @mutex  @running  @target  @thread\r\n[2] pry(#<Waiter>)> cd philosopher/@target\r\n[3]
    pry(#<Philosopher>):2> ls\r\nPhilosopher#methods: dine  drop_chopsticks  eat  take_chopsticks
    \ think\r\nself.methods: __pry__\r\ninstance variables: @left_chopstick  @name
    \ @right_chopstick  @waiter\r\nlocals: _  __  _dir_  _ex_  _file_  _in_  _out_
    \ _pry_\r\n[4] pry(#<Philosopher>):2> @name\r\n=> \"Schopenhauer\"\r\n[5] pry(#<Philosopher>):2>
    cd\r\n[6] pry(#<Waiter>)> @eating.count\r\n=> 0\r\n```\r\n\r\nOnce we're ready
    to move on to the next call to `request_to_eat`, we simply call\r\n`exit`. That
    immediately launches a new console that allows us to determine\r\nthat Schopenhauer's
    is already in the `@eating` queue by the time Aristotle's request\r\nis starting
    to be processed:\r\n\r\n```\r\n[1] pry(#<Waiter>)> cd philosopher/@target\r\n[2]
    pry(#<Philosopher>):2> @name\r\n=> \"Aristotle\"\r\n[3] pry(#<Philosopher>):2>
    cd\r\n[4] pry(#<Waiter>)> @eating.count\r\n=> 1\r\n[5] pry(#<Waiter>)> cd @eating.first/@target\r\n[6]
    pry(#<Philosopher>):2> @name\r\n=> \"Schopenhauer\"\r\n```\r\n\r\nImagine for
    a moment that there was a defect in this code. Replicating this \r\nexact situation
    in a test where we can access the values of\r\n`@eating` and the internals of
    the `philosopher` argument at these \r\nparticular points in the execution would\r\nnot
    be straightforward, but Pry makes it easier to casually poke at these\r\nvalues
    as part of an ad-hoc exploration. If there was a bug to be found here,\r\nPry
    could help you identify the conditions that trigger it, and then other\r\ntechniques
    could be used to reproduce the issue once its root cause\r\nwas discovered.\r\n\r\nThis
    particular use case merely scratches the surface of Pry's capabilities -- \r\nthere
    are many commands that Pry provides that are powerful tools for inspecting your\r\ncode
    while it's running. That said, it is not a complete substitute for\r\na traditional
    debugger. For example, gdb can be useful for hunting down\r\nhard-to-investigate
    issues such as segfaults in MRI's C code. If you're interested in that kind\r\nof
    thing, you may want to check out [this talk from Heath Lilley](http://vimeo.com/54736113)\r\nabout
    using gdb to determine why a Ruby program was crashing.\r\n\r\nYou don't always
    need to use a heavyweight debugging utility to solve\r\nyour problems. Whenever
    you can get away with it, it's reasonable to use the\r\nmost simple thing that
    could possibly work; it's amazing how much a decent log\r\nfile or some well placed
    print statements can tell you about what's going on in\r\nyour code. But whenever
    you feel like those approaches are starting to get\r\ncumbersome, don't be afraid
    to break out the power tools.\r\n\r\n## Lean on tests, but don't overspecify\r\n\r\nWhenever
    you need to fix a bug, you're writing a test first, right? This\r\nserves multiple
    purposes: it gives you a convenient way to reproduce the issue\r\nwhile you're
    experimenting, and if added to your test suite, it will help\r\nyou detect regressions
    in future changes.\r\n\r\nRegardless of whether the tests you write end up becoming
    a permanent part of\r\nyour test suite or not, they still provide a useful way
    to record your \r\ndiscoveries and experiments during a debugging session. For
    example, you might \r\nstart with an end-to-end acceptance test that is able to
    reproduce the problem \r\nand then write smaller and smaller tests as you are
    narrowing down where the \r\nissue is occurring until you get to a unit test that
    covers the root cause.\r\nFrom there, you can fix the issue, run all the tests
    to confirm the fix, \r\nand then finally remove the redundant tests that only
    reproduce the problem \r\nindirectly. \r\n\r\nBut why bother removing intermediate
    tests? It's mostly just a matter of\r\ngood housekeeping that helps maintain the
    clarity of your test suite. For\r\nexample, negative tests like \"it should not
    crash when given special characters\" \r\nare mostly just noise at the acceptance
    test level, unless someone could\r\nreasonably assume that the tested feature
    wouldn't support that use case.\r\nFor a real example of this kind of over-specification,
    here is a test that I \r\nadded to [rstat.us' codebase](https://github.com/hotsh/rstat.us/commit/26444ea95ec8da12d4e74764bf52bdaad18e7776)\r\na
    while ago:\r\n\r\n```ruby\r\nit \"lets you update your profile even if you use
    a different case in the url\" do\r\n  u = Factory(:user, :username => \"LADY_GAGA\")\r\n
    \ a = Factory(:authorization, :user => u)\r\n  log_in(u, a.uid)\r\n  visit \"/users/lady_gaga/edit\"\r\n
    \ bio_text = \"To be or not to be\"\r\n  fill_in \"bio\", :with => bio_text\r\n
    \ click_button \"Save\"\r\n\r\n  assert_match page.body, /#{bio_text}/\r\nend\r\n```\r\n\r\nRather
    than adding another test for the case of going to the url for username\r\n\"lady_gaga\"
    when the username is \"LADY_GAGA\" (don't ask why I chose Lady Gaga,\r\nI don't
    remember), I could have instead updated\r\n[the existing happy path test](https://github.com/hotsh/rstat.us/blob/26444ea95ec8da12d4e74764bf52bdaad18e7776/test/acceptance/profile_test.rb#L45)\r\nto
    encompass this situation (effectively replacing the existing happy path test\r\nwith
    this special case test). In this way, both the special case and the happy path\r\nwould
    be tested, but with less duplication.\r\n\r\nIf in doubt, it's probably better
    to have a few extra tests cornering a defect\r\nthan too few, but just keep in
    mind that like all other code, your tests have a\r\nmaintenance overhead along
    with a potential to become brittle. As with\r\nall things, having a sense of balance
    pays off here.\r\n\r\n## Reflections\r\n\r\nEven though sometimes it seems like
    software has a mind of its own, computers\r\nonly do what a human has told them
    to do at some point. So next time you end up\r\nfacing a painful defect, remember
    the following things:\r\n\r\n* You can figure out why a bug is happening by using
    deterministic processes to narrow down where the\r\nproblem is happening. \r\n\r\n*
    You can learn to pick out the useful parts of stack traces, even if they\r\nseem
    heavily obfuscated at first.\r\n\r\n* You can use debugging tools to experiment
    with what your code is\r\nactually doing as it runs, especially in cases where
    it wouldn't\r\nbe easy to work out what was going on straight from your log files.\r\n\r\n*
    You can write tests that help you while debugging and then turn some\r\nor all
    of them into useful regression tests that will help make your\r\ncodebase more
    stable as it grows. \r\n\r\nThanks for reading. Now go figure out some bugs! <3"
- :slug: cleaning-up-bloated-method-interfaces
  :title: Cleaning up bloated method interfaces
  :summary: Tame a complex method interface using keyword arguments and parameter
    objects.
  :published: 2013-03-12 00:00:00.000000000 Z
  :issue_number: '6.6'
  :volume: 6
  :body: "> **NOTE:** This issue of Practicing Ruby was one of several content experiments
    \r\nthat was run in Volume 6. It uses a cookbook format (e.g. problem -> solution
    -> discussion)\r\ninstead of the traditional long-form article format we use in
    most Practicing Ruby articles.\r\n\r\n**Problem: A method has many parameters,
    making it hard to remember its\r\ninterface.**\r\n\r\nSuppose we were building
    a HTTP client library called `HyperClient`. A trivial\r\nrequest might look like
    this:\r\n\r\n```ruby\r\nhttp = HyperClient.new(\"example.com\")\r\nhttp.get(\"/\")\r\n```\r\n\r\nBut
    we would probably need to support some other features as well, such as \r\naccessing
    HTTP services running on non-standard ports, and routing \r\nrequests through
    a proxy. If we simply add these features \r\nwithout careful design consideration,
    we may end up\r\nwith the following bloated interface for `HyperClient.new`: \r\n\r\n```ruby\r\nhttp
    = HyperClient.new(\"example.com\", 1337, \r\n                       \"internal.proxy.example.com\",
    8080, \r\n                       \"myuser\", \"mypassword\")\r\n```\r\n\r\nIf
    the above code looks familiar to you, it's because it is modeled directly\r\nafter
    Ruby's `Net::HTTP` standard library; a codebase which\r\nis often critized for
    it's poor API design! There are many reasons \r\nwhy this style of interface is
    bad, but three obvious issues stand out:\r\n\r\n* Without a single unambiguous
    way of sorting the parameters, it is very\r\ndifficult to remember their order.\r\n\r\n*
    This style of interface makes it hard to set defaults for parameters in a\r\nflexible
    way. For example, consider the difficulty of setting default values for\r\nthe
    `service_port` and `proxy_port` in the code above.\r\n\r\n* If the `HyperClient`
    API changes and a new optional parameter is introduced, \r\nit must either be
    added to the end of the arguments list or risk breaking \r\nall calls that relied
    on the previous order of the parameters.\r\n\r\nFortunately, all of the above
    points can be addressed by designing a better\r\nmethod interface.\r\n\r\n---\r\n\r\n**Solution:
    Use a combination of keyword arguments and parameter objects to\r\ncreate interfaces
    that are both memorable and maintainable.**\r\n\r\nWhenever a method's interface
    accumulates several related arguments, it is a\r\nsign that introducing a parameter
    object might be helpful. In this \r\nparticular example, we can easily group together
    the proxy-related arguments \r\nas shown below:\r\n\r\n```ruby\r\nproxy = HyperClient::Proxy.new(\"internal.proxy.example.com\",\r\n
    \                              :port     =>  8080,\r\n                               :username
    => \"myuser\",\r\n                               :password => \"mypass\")\r\n```\r\n\r\nBy
    switching to keyword arguments, it becomes obvious what\r\neach of these parameters
    represent, and there is no need to list them\r\nin a particular order. This basic
    idea can also be extended to simplify \r\nthe interface of the original `HyperClient`
    object:\r\n\r\n```ruby\r\nhttp = HyperClient.new(\"example.com\", :port  => 1337,
    :proxy => proxy) \r\n```\r\n\r\nThis new constructor looks and feels more comfortable
    to use, because it\r\nintroduces some structure to separate essential parameters
    from\r\noptional ones while grouping related concepts together. This\r\nmakes
    it easier to recall the right bits of knowledge at the right time.\r\n\r\n---\r\n\r\n**Discussion**\r\n\r\nBoth
    interfaces for `HyperClient.new` handle the most common use case \r\nin the same
    way:\r\n\r\n```ruby\r\nhttp = HyperClient.new(\"example.com\")\r\n```\r\n\r\nWhere
    they differ is when you have extra parameters. Dealing with\r\ndefault values
    in the former is *much* uglier. For example, if\r\n`HyperClient` provided default
    ports for both the service and the\r\nproxy, you'd need to do something like this
    when using a username\r\nand password:\r\n\r\n```ruby\r\nhttp = HyperClient.new(\"example.com\",
    nil, \r\n                       \"internal.proxy.example.com\", nil,\r\n                       \"myuser\",
    \"mypassword\")\r\n```                       \r\n\r\nIn the improved code, those
    parameters could simply be omitted:\r\n\r\n```ruby\r\nproxy = HyperClient::Proxy.new(\"internal.proxy.example.com\",\r\n
    \                              :username => \"myuser\",\r\n                               :password
    => \"mypass\")\r\n\r\nhttp = HyperClient.new(\"example.com\", :proxy => proxy)\r\n```\r\n\r\nBut
    this is a consequence of using keyword arguments -- it has \r\nlittle to do with
    the fact that we've introduced the `HyperClient::Proxy` \r\nparameter object.
    For example, if the following API were used instead,\r\nit would be trivial to
    fall back to default values for `:service_port` and\r\n`:proxy_port` if they were
    not explicitly provided:\r\n\r\n```ruby\r\nhttp = HyperClient.new(\"google.com\",\r\n
    \                      :proxy_address   => \"internal.proxy.example.com\",\r\n
    \                      :proxy_username  => \"myuser\",\r\n                       :proxy_password
    \ => \"mypass\")\r\n```\r\n\r\nThe following signature supports this kind of behavior,
    using Ruby 2.0's \r\nkeyword arguments:\r\n\r\n```ruby\r\nclass HyperClient\r\n
    \ def initialize(service_address, service_port: 80, \r\n                 proxy_address:
    \ nil, proxy_port: 8080, \r\n                 proxy_username: nil, proxy_password:
    nil)\r\n\r\n    # ...        \r\n  end\r\nend\r\n``` \r\n\r\nThis style of design
    isn't especially painful to work with for the end-user, \r\nand it has a fairly
    wide precedent in Ruby library design. However, taking this\r\napproach comes
    with three significant drawbacks:\r\n\r\n* An interface with many similarly named
    parameters that are \r\ndifferentiated only by a prefix (e.g. `service_port` vs.
    `proxy_port`)\r\nis still intention-revealing and memorable, but the repetition
    \r\nintroduces line noise that hurts readability.\r\n\r\n* Validating and transforming
    inputs becomes increasingly complex \r\nas method interfaces become bloated. Think
    about the various\r\nchecks that would need to be done in the previous example
    to\r\nverify what proxy settings should be used, if any.\r\n\r\n* Each and every
    new parameter introduced into a method's interface \r\ncreates a new set of branches
    that need to be covered by tests,\r\nand considered during debugging.\r\n\r\nTo
    see how these issues are mitigated by the introduction of the\r\n`HyperClient::Proxy`
    object, think through what the validation\r\nand transformation work might look
    like in both the example shown\r\nabove, and in the code shown below:\r\n\r\n```ruby\r\nclass
    HyperClient\r\n  def initialize(service_address, port: 80, proxy: nil)\r\n    #
    ...\r\n  end\r\n\r\n  class Proxy\r\n    def initialize(address, port: 8080, username:
    nil, password: nil)\r\n      # ...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAlthough
    the two implementations will end up sharing a lot of code in \r\ncommon, introducing
    a formal parameters object allows you to hide\r\nsome of the ugly details from
    the `HyperClient` class that would\r\notherwise end up in its constructor. This
    is good for both testability\r\nand maintainability.\r\n\r\nDespite its utility,
    it is possible to take this technique too far. \r\nFor example, introducing a
    `HyperClient::Service` object to wrap the service \r\naddress and port is probably
    more trouble than its worth, because it does not\r\nhide enough complexity to
    have a net positive impact on maintainability.That said,\r\ndesign decisions are
    highly context dependent and need to \r\nbe revisited as requirements grow and
    change. Suppose that wanted to support\r\nboth SSL and HTTP basic authentication
    were in this library; \r\nthen adding a `HyperClient::Service` object might start
    to make sense!\r\nThis rise in necessary complexity shifts the balance of things
    to make\r\nan extra layer of indirection seem worthwhile, where it may not have
    before.\r\n\r\nThe thing to remember is that being influenced by features that
    will soon be \r\nimplemented is part of the design process, but considering vague
    scenarios \r\nthat may or may not happen in the far future is more akin to gazing
    into a \r\ncrystal ball. The former is productive; the latter is potentially harmful.\r\n\r\n---\r\n\r\n**Conclusions**\r\n\r\nWhen
    designing method interfaces, don't bother trying to get them perfect,\r\nbecause
    they will eventually end up changing anyway. However, don't just ignore\r\ntheir
    design either -- keep in mind that good APIs makes easy things easy and hard \r\nthings
    possible. The techniques we've discussed in this recipe should help you\r\navoid
    some of the most common mistakes people make, but the rest is up to you!\r\n\r\nIf
    you want to learn more about method-level interface design, James Noble wrote\r\na
    great paper on the topic called [Arguments and\r\nResults](http://www.laputan.org/pub/patterns/noble/noble.pdf).
    I strongly\r\nrecommend reading his work, as well as [Issue 2.14](https://practicingruby.com/articles/shared/vpxpovppchww)
    \r\nand [Issue 2.15](https://practicingruby.com/articles/shared/mupuergickjz)
    of\r\nPracticing Ruby, which cover the same topic with some Ruby-specific examples."
- :slug: demeter-archaeology
  :title: 'The Law of Demeter: Some archaeological notes'
  :summary: Explore the history of a classic design principle and how it relates to
    Ruby. (w. David A. Black)
  :published: 2013-03-26 00:00:00.000000000 Z
  :issue_number: '6.7'
  :volume: 6
  :body: "*This article was contributed by [David A. Black](https://twitter.com/david_a_black),
    Lead Developer at Cyrus Innovation. David is a long-time Ruby developer, author,
    trainer, \r\nspeaker, and community event organizer. He is the author of The Well-Grounded
    Rubyist (Manning Publications, 2009).* \r\n\r\nA lot has been written and said
    about the Law of Demeter. I'd read and heard a\r\nlot about the law before I ever
    went back and looked at the seminal, original\r\npapers that described it. In
    spite of how much I thought I knew about the law, I\r\nfound those original papers
    quite enlightening and absorbing. \r\n\r\nI've been particularly absorbed in two
    articles: the 1988 OOPSLA paper\r\n\"Object-Oriented Programming: An Objective
    Sense of Style\" by Karl J.\r\nLieberherr, Ian M. Holland, and Arthur J.Riel,
    and the 1989 article \"Assuring\r\nGood Style for Object-Oriented Programs\" by
    Lieberherr and Holland. \r\nThe two papers are of course closely related. But
    what I've found interesting,\r\naside from just the process of studying and absorbing
    information about the Law\r\nof Demeter at its source, is considering the ways
    in which they differ. \r\n\r\nBoth papers posit that there are different versions
    of the Law of Demeter. But\r\nthe taxonomies they construct for the law differ
    considerably from each other.\r\nA lot of further thought and work, evidently,
    went into the law between 1988 and\r\n1989. \r\n\r\nI'm going to put the two taxonomies,
    and the differences between them, under a\r\nmicroscope -- at least, a medium-powered
    microscope. I won't recapitulate\r\neverything in the two articles, but I'll go
    into enough detail to set the\r\nstage for some reflective and interpretive observations
    about why the law might\r\nhave evolved in the ways it did in a relatively short
    time. \r\n\r\nI'll then conclude with a couple of speculative, open-ended thoughts
    about the\r\nLaw of Demeter as it relates to general problems of code organization
    and best\r\npractices in programming -- a probably small-scale but hopefully interesting\r\nperspective
    that I've dubbed \"Metademeter\". \r\n\r\n## THE 1988 TAXONOMY\r\n\r\n> **Note:**
    In addition to the type and object versions of the law described here,\r\nthe
    1988 article talks about the *strong* and *weak* versions of the law. That\r\ndistinction
    has to do with whether or not it's considered permissible to send\r\nmessages
    to inherited instance variables. The strong version says no; the weak\r\nversion
    says yes. I'm not going to go into detail about that aspect of the 1988\r\ntaxonomy,
    but it's certainly worth a look at the original article.\r\n\r\nIn 1988, the three
    authors state the Law of Demeter, initially, in the following\r\nterms: \r\n\r\nFor
    all classes C, and for all methods M attached to C, all objects to which M\r\nsends
    a message must be instances of classes associated with the following\r\nclasses:
    \r\n\r\n```\r\n  1. The argument classes of M (including C).\r\n  2. The instance
    variable classes of C.\r\n\r\n  (Objects created by M, or by functions or methods
    which M calls, and objects\r\n  in global variables are considered as arguments
    of M.) \r\n\r\n  (pg. 325)\r\n```\r\n\r\nThere follows an extensive treatment
    of the motivation for and implications of\r\nthe law. Included in this treatment
    is consideration of a case where strict\r\nadherence to the law nonetheless runs
    contrary to its intended effect. Consider\r\na case where there's a kind of circular
    structure to the instance variable types\r\nof a set of classes. The following
    example is adapted from the article, and while Ruby doesn't enforce instance variable
    classes, the code illustrates the basic difficulty the authors identify: \r\n\r\n```ruby\r\n
    \ class A\r\n    def initialize\r\n      @b, @c, @d, @e = B.new, C.new, D.new,
    E.new\r\n    end\r\n\r\n    def bad_style\r\n      b.d.e\r\n    end\r\n\r\n    attr_reader
    :b, :c, :d, :e\r\n  end\r\n\r\n  class B\r\n    def initialize\r\n      @c, @d
    = C.new, D.new\r\n    end\r\n\r\n    attr_reader :c, :d\r\n  end\r\n\r\n  class
    C; end\r\n\r\n  class D\r\n    def initialize\r\n      @e = E.new\r\n    end\r\n\r\n
    \   attr_reader :e\r\n  end\r\n\r\n  class E; end\r\n\r\n  a = A.new\r\n  a.bad_style\r\n```\r\n\r\nThe
    `bad_style` instance method in class `A`, called at the end of the example, triggers
    a series of calls. The first, a call to the reader method `b`, returns `a`'s instance
    variable `@b`, which is an instance of class `B`. Then the message `d` is sent
    to that `B` instance; the result is an instance of `D`, namely the instance held
    in the instance variable `@d` of the `B` instance. Sending `d` to a `B` instance
    is legal, Demeter-wise, because one of `a`'s instance variables is of class `B`.
    Then the `D` instance gets the message `e`; this is also OK for the same reason.
    \r\n\r\nSo you've only \"talked to\" objects belonging to classes corresponding
    to\r\ninstance variables of your instance of `A`, but, as the article states,
    *\"the\r\nmethod looks two levels deep into the structure of instance variable
    first,\r\nviolating the ideals of information-hiding and maintainability.\"* \r\n\r\nThe
    authors propose a second formulation of the law as a way around this\r\nproblem.
    Note that here the law is stated in terms of objects, not classes:\r\n\r\n```\r\n
    \ For all classes C, and for all methods M attached to C, all objects to which
    M\r\n  sends a message must be:\r\n\r\n    * M's argument objects, including the
    self object or...\r\n    * The instance variable objects of C. \r\n\r\n  (Objects
    created by M, or by functions or methods which M calls, and objects\r\n  in global
    variables are considered as arguments of M.) \r\n\r\n  (327)\r\n```\r\n\r\nThe
    downside to this object version of the Law of Demeter is that it makes it\r\nhard
    to do compile-time checking. The conclusion of the authors is that *\"to\r\nretain
    easy compile-time checking we require the Law's formulation in terms of\r\ntypes.
    We feel that such path[o]logical cases as the one above will not occur\r\noften
    enough to cause problems\" (327).*\r\n\r\nStill, the object version of the law
    serves as an important guide for\r\nprogrammers. Toward the end of the article,
    the authors provide formulations of\r\nthe law for several specific object-oriented
    languages, using the law's object\r\nversion. Of the languages for which they
    offer such formulations, the closest to\r\nRuby is Smalltalk-80. In that language,
    the authors state that message-sending\r\nshould be restricted to:\r\n\r\n* an
    argument object of [the method] M including objects in pseudo variables\r\n  \"self\"
    and \"super\" or\r\n* an instance variable object of the class to which M is attached.
    \r\n  (332)\r\n\r\nAs before, newly-created objects and objects in global variables
    count as\r\nargument objects.\r\n\r\nThe *object* version of the law casts a somewhat
    wider net, as far as languages\r\nare concerned, than the first, *class* version.
    Certainly for a dynamic language\r\nlike Ruby, where static code analysis can
    do relatively little for you and\r\ncompile-time checking doesn't exist, the object
    version makes sense. It also\r\nmakes sense in languages where there's no such
    thing as the *type* of an\r\ninstance variable; Ruby instance variables, for example,
    can be assigned any\r\nobject and even different objects at different times. The
    object version of the\r\nlaw of Demeter, as laid out in 1988, doesn't specifically
    address the matter of\r\nreassigning to instance variables but might provide enough
    structure and\r\ndiscipline to give you pause if you find yourself doing that.
    \r\n\r\nLet's move a year forward. \r\n\r\n## THE 1989 TAXONOMY\r\n\r\nLike the
    1988 article, the 1989 article presents the Law of Demeter in two major\r\nversions:
    the class version and the object version. Here, though, the\r\ndefinitions of
    the two versions have changed in interesting ways, and the class\r\nversion, in
    turn, is broken down into the minimization version and the strict\r\nversion.
    \r\n\r\nThe 1989 taxonomy of the law rests on the notion of clients and suppliers.\r\nClients
    are methods; suppliers are classes. If method M calls method N on an\r\ninstance
    of class C (or on class C itself), then M is a client of both the\r\nmethod N
    and the class C. In turn, C is a supplier to M. (There are some further\r\nsubtleties
    but this is the thrust of how clients and suppliers relate to each\r\nother.)
    \r\n\r\nIn the client/supplier relationship, the supplier class may be an *acquaintance*\r\nclass
    (what's often paraphrased as a \"stranger\"), or it may be a preferred\r\nsupplier
    (sometimes called a \"friend\"). Preferred suppliers, in brief, include:\r\n\r\n*
    the subcategory *preferred acquaintance*, consisting of:\r\n  * the class(es)
    of object(s) instantiated inside the client method\r\n  * the class(es) of global
    object(s)\r\n* the class of an instance variable (or a superclass)\r\n* the class
    of an argument to the method (or a superclass)\r\n\r\nThe article summarizes the
    two sub-versions of the class version of the law as follows:\r\n\r\n```\r\n  Minimization
    version: Minimize the number of acquaintance classes of all\r\n  methods.\r\n\r\n
    \ Strict version: All methods may have only preferred-supplier classes. \r\n  (40-41)\r\n```\r\n\r\nAs
    you can see, the 1989 taxonomy involves more terms and definitions than the\r\n1988
    taxonomy. It's a denser account of the law. But there's something gained\r\nfor
    the added complexity. Everything is organized from the root of the structure\r\nupward.
    The categories of newly created objects and global variables, both of\r\nwhich
    were literally added via parenthetical addenda to the 1988 versions of the\r\nlaw,
    are more smoothly integrated into the model in 1989. Every imaginable\r\nobject
    that might be sent a message falls somewhere on one consistent spectrum,\r\nranging
    from mere acquaintance (to be avoided) to preferred acquaintance\r\n(acceptable
    but still flagged as not quite a full *friend*) to preferred\r\nsupplier (the
    real friends). I have found that the 1989 taxonomy requires\r\nlonger and deeper
    study than the 1988 taxonomy, but that it repays careful\r\nreading.\r\n\r\nAnd
    that's just the class version of the law. As before, there's also an object\r\nversion,
    summarized as follows:\r\n\r\n```\r\n  All methods may have only preferred-supplier
    objects. \r\n```\r\n\r\nNote the shift, subtle but important, from *classes* to
    *objects*, as compared\r\nwith the strict version of the class version of the
    law. Focusing on objects\r\nallows for inclusion of such constructs as self and
    super. Moreover, the authors\r\nmake the following interesting point about the
    object version of the law:\r\n\r\n```\r\n    While the object version of the law
    expresses what is really wanted, it cannot\r\n    be enforced at compile time.
    The object version serves as an additional guide\r\n    in addition to the class
    version of the law (42).\r\n```  \r\n\r\nThere's a kind of \"bend before you break\"
    principle at work here. The Law of\r\nDemeter is not all-or-nothing, as regards
    the ability to do compile-time\r\nchecking. It's also something that you can,
    and in some cases must, bake into\r\nyour programming habits as you go along.
    \r\n\r\nAs in 1988, the 1989 authors present a kind of checklist of how to enforce
    the\r\nlaw in the cases of several specific languages (C++, CLOS, Eiffel, Flavors,
    and\r\nSmalltalk-80). Interestingly, the 1989 account of how to apply the language
    to\r\nC++ recommends the strict version of the class form of the law -- whereas
    in\r\n1988, the C++ guidelines suggested the object version. For the other languages,\r\nthe
    1989 guidelines refer to the object version, though there's some explanatory\r\ntext
    suggesting that in any statically-typed language (including Eiffel), \"the\r\nclass
    form is most useful because it can be checked by a modified compiler\"\r\n(47).
    \r\n\r\nOnce again, the Smalltalk-80 criteria come the closest to what we might\r\nformulate
    for Ruby:\r\n\r\n```\r\n  Smalltalk-80, object form. In all message expressions
    inside method M the\r\n  receiver must be one of the following objects:\r\n    *
    an argument object of M, including objects in the pseudovariables Self and\r\n
    \     Super,\r\n    * an immediate part of Self, or\r\n    * an object that is
    either an object created directly by M or an object in a\r\n      global variable
    (47).\r\n```\r\n\r\n(An \"immediate part of Self\" can be an instance variable.
    It is not explicitly stated in the article whether or not the concept of \"immediate
    part\" can also include collection elements.) \r\n\r\nThe salient point here is
    that the framers of the Law of Demeter were at pains\r\nto welcome dynamic languages
    to the fold. This is directly related to the\r\ncomplexity of the taxonomy of
    the law. Exploding the law into several versions\r\nand sub-versions allows for
    close, reasoned analysis of what can and cannot be\r\nchecked at compile time,
    as well as other details and underpinnings of the law's\r\nrationale and logic.
    In the end, though, everything converges back on the\r\noriginal purpose: providing
    programmers using object-oriented languages with a\r\nset of principles that reduce
    inter-class dependencies. \r\n\r\n## METADEMETER\r\n\r\nThe Law of Demeter is
    engineered to help programmers using object-oriented\r\nlanguages gain a lot of
    clarity of code for a relatively small price. Of course,\r\nthere's a whole world
    of refactoring out there; the Law of Demeter is not the\r\nonly guideline, or
    set of guidelines, for making code better, clearer, and more\r\nmaintainable.
    It would be a mistake to lump all refactorings as \"Demeter-ish\";\r\nthat does
    justice neither to the Law of Demeter nor to the other refactorings. \r\n\r\nAnd
    yet... I'm intrigued by the possibility that recognizable aspects of the Law\r\nof
    Demeter might surface in contexts other than those for which the law was\r\noriginally
    formulated. I'm not going to push this point very far. I've got one\r\nexample
    that I find suggestive, and I'll leave it at that. See what you think. \r\n\r\nThe
    1989 article describes a programming technique that the authors call\r\n*lifting*.
    To illustrate lifting, here's an example of an acquaintance class,\r\nand a Demeter
    violation:\r\n\r\n```ruby\r\n  class Plane\r\n    attr_accessor :name\r\n  end\r\n\r\n
    \ class Flight\r\n    attr_accessor :plane\r\n  end\r\n\r\n  class Person\r\n
    \   def itinerary_for(flight)\r\n      \"Flight on #{flight.plane.name}\"\r\n
    \   end\r\n  end\r\n```\r\n\r\nHere, `Plane` is an acquaintance class of `Person`.
    `Flight` isn't; `Flight` is a\r\npreferred supplier class, because it's the class
    of an argument. `Flight` is a\r\nfriend; `Plane` isn't, and by calling name on
    a plane object we're operating\r\noutside of the Law of Demeter. \r\n\r\nYou can
    fix this Demeter violation by \"lifting\" the method that provides the\r\ninformation
    into the external class:\r\n\r\n```ruby\r\n  class Plane\r\n    attr_accessor
    :name\r\n  end\r\n\r\n  class Flight\r\n    attr_accessor :plane\r\n    def plane_name\r\n
    \     plane.name\r\n    end\r\n  end\r\n\r\n  class Person\r\n    def itinerary_for(flight)\r\n
    \     \"Flight on #{flight.plane_name}\"\r\n    end\r\n  end\r\n```\r\n\r\nNote
    that this code is longer than the original. It's not uncommon for\r\nDemeter-compliant
    code to have more methods than non-compliant code. The gain,\r\non the other hand,
    lies in the way the code is organized, and the ease with\r\nwhich the code can
    be maintained and changed. If you change the way `Plane#name`\r\nworks, and you
    want to make sure it's still used consistently in all your code,\r\nyou only need
    to hunt for classes that use `Plane` objects as arguments or\r\ninstance variables,
    and make sure the code is still correct. In the first\r\nversion of the plane
    code, you'd have to dig deep into every class in the\r\nprogram, since you have
    no guidelines for figuring out where `Plane#name` is\r\nlikely to be called or
    not called. \r\n\r\nNow for the part about aspects of Demeter cropping up outside
    the original\r\ncontext. I'm thinking specifically of programming controllers
    and view templates\r\nin Rails. Templates are already a bit of an oddity, in terms
    of object-oriented\r\nprogramming, because of the way they share instance variables
    with controller\r\nactions: assign something to `@buyer` in the controller, and
    you can use `@buyer` in\r\nthe view. Instance variables always belong to self,
    and self in the controller\r\nis different from self in the view -- yet the instance
    variables resurface. \r\n\r\nIn case you've ever wondered, this is brought about
    by an explicit assignment\r\nmechanism: when a view object is created, it copies
    over the controller's\r\ninstance variables one by one into instance variables
    of its own. So we've got a\r\ndomain-specific and kind of hybrid situation: two
    self objects sharing, or\r\nappearing to share, instance variables.\r\n\r\nSo
    where does lifting come in, in any sense reminiscent of the Law of Demeter?\r\n\r\nConsider
    a view snippet like this:\r\n\r\n```erb\r\n  <% @user.friends.each do |friend|
    %>\r\n    <% friend.items.each do |iitem| %>\r\n      <%= friend.name %> has a(n)
    <%= item.description %>\r\n    <% end %>\r\n  <% end %>\r\n```\r\n\r\nI don't
    want to get into a whole debate here about whether or not it's ever\r\nacceptable
    to hit the database from the views. My philosophy has always been\r\nthat you
    should be allowed to send a message to any object that the controller\r\nshares
    with the view. By that reckoning, @user.friends would be acceptable, and\r\nit's
    up to the controller to eager-load the friends if it wants to. \r\n\r\nBut what
    about `friend.items`? Here we're wandering out on a limb; we're an extra\r\nlevel
    of remove from the original object. I can't claim that this is exactly the\r\nsituation
    envisioned by the framers of the Law of Demeter -- but it reminds me\r\nstrongly
    of Demeter-ish situations. And I would propose a Demeter-ish solution,\r\nbased
    on the lifting technique: \"lift\" one of the method calls back into the\r\ncontroller.
    Here's a simple version:\r\n\r\n```ruby\r\n  def show\r\n    @user = current_user\r\n
    \   @friends = @user.friends\r\n  end\r\n```\r\n\r\nAnd then in the view:\r\n\r\n```erb\r\n
    \ <% @friends.each do |friend| %>\r\n    <% friend.items.each do |item| %>\r\n
    \     <%= friend.name %> has a(n) <%= item.description %>\r\n    <% end %>\r\n
    \ <% end %>\r\n```\r\nIn \"metademeter\" terms, we're talking only to the immediate
    parts of the\r\n`@friends` object -- in this case, the elements of a collection.
    I believe there's\r\nroom for debate, within discussions of the law itself, on
    whether or not\r\ncollection elements count as *immediate parts* of an object.
    But here it seems a\r\ngood fit. Again, keep in mind that this is just an observation
    of what I would\r\ncall a Demeter-ish way of thinking about code. The Rails controller/view\r\nrelation
    is not the same as the relation between and among classes and methods\r\nthat
    the Law of Demeter directly addresses. And the object whose immediate\r\nparts
    I'm restricting myself to is not the self object; it is, itself, an\r\ninstance
    variable object. Still, I think we could do worse in a situation like\r\nthis
    than to be inspired to think of a motto like \"talk only to your friends\",\r\nunderstanding
    \"friends\" to be objects that lie one method call away from the\r\noriginal ActiveRecord
    objects handed off by the controller. \r\n\r\nThat's the extent of my metademeter
    musings. Meanwhile I hope you'll continue to\r\nstudy and contemplate the Law
    of Demeter, and explore the many writings and\r\ndiscussions and debates that
    you'll find surrounding it. I've presented no more\r\nthan a subset of what has
    been or can be said; but I hope that this trip back\r\nto the original statements
    on the law has been engaging and worthwhile.\r\n\r\n## REFERENCES AND FURTHER
    READING\r\n\r\n* [The 1988 article (in special OOPSLA issue of SIGPLAN Notices)](http://www.ccs.neu.edu/research/demeter/papers/law-of-demeter/oopsla88-law-of-demeter.pdf)\r\n\r\n*
    [The 1989 article, available through IEEE](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=35588&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D35588)\r\n\r\n*
    [A somewhat different version of the 1989 article, in PostScript form](ftp://ftp.ccs.neu.edu/pub/research/demeter/documents/papers/LH89-law-of-demeter.ps)\r\n\r\n*
    [Another 1988 document, with some further/interim reflections on the Law of Demeter,
    by Lieberherr and Holland](http://www.ccs.neu.edu/research/demeter/papers/law-of-demeter/law-formulations/ss.tex)\r\n\r\n*
    [An excellent account of the Law of Demeter and its practical uses, by David Bock](\r\nhttp://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf)\r\n\r\n*
    [Practicing Ruby Issue 5.2: Rocket Science and the Law of Demeter](https://practicingruby.com/articles/shared/gulrqynwlywm)"
- :slug: from-scripting-to-oop
  :title: 'From adhoc script  to object-oriented program '
  :summary: Gradually convert a  "throwaway" procedural program into a well-defined
    domain model.
  :published: 2013-04-10 00:00:00.000000000 Z
  :issue_number: '6.8'
  :volume: 6
  :body: "> **NOTE:** This issue of Practicing Ruby was one of several content experiments
    \r\nthat was run in Volume 6. It uses a cookbook format (e.g. problem -> solution
    -> discussion)\r\ninstead of the traditional long-form article format we use in
    most Practicing Ruby articles.\r\n\r\n**Problem: An adhoc script has devolved
    into an unmaintainable mess**\r\n\r\nImagine that you're working on a shipping
    cost estimation program for a small\r\nbusiness that uses a courier service for
    regional deliveries. Part of the task\r\nfor building that tool would involve
    importing pricing information from\r\nsome data source, such as this CSV file:\r\n\r\n```\r\n06770,$12.00\r\n06512,$14.00\r\n06510,$15.30\r\n06701,$12.15\r\n```\r\n\r\nA
    real dataset would be more complex, but this minimal example exposes the\r\ninformation
    we're interested in: what it costs to ship something from our\r\nfacility to somewhere
    else, based on the destination's zip code.\r\n\r\nNow suppose that we want to
    build a simple data store which will be updated\r\ndaily with the latest pricing
    information. We then could easily write a script\r\nusing a few of Ruby's standard
    libraries (`PStore`, `BigDecimal`, and `CSV`),\r\nwhich would normalize the data
    in a way that could be used by the user-facing\r\ncost estimation program. If
    we could assume the source CSV data was validated\r\nbefore we processed it, the
    program could be as simple as what you see below:\r\n\r\n```ruby\r\nrequire \"csv\"\r\nrequire
    \"pstore\"\r\nrequire \"bigdecimal\"\r\n\r\nstore = PStore.new(\"shipping_rates.store\")\r\n\r\nstore.transaction
    do\r\n  CSV.foreach(ARGV[0] || \"rates.csv\") do |r|\r\n    zip    = r[0]\r\n
    \   amount = BigDecimal.new(r[1][1..-1])\r\n    \r\n    store[zip] = amount\r\n
    \ end\r\nend\r\n```\r\n\r\nBut in reality, most businesses environments do not
    make things like this easy\r\nfor you. You'd probably quickly discover that the
    source data could have\r\nany number of problems with it, ranging from duplicate
    entries to inconsistently\r\nformatted fields. Because this kind of data often
    originates from people who are\r\nentering information into Excel by hand, they
    can even be littered with typos!\r\n\r\nTo help mitigate these issues somewhat,
    you need a combination of\r\nsanity-checking validations and basic logging so
    that when something goes wrong\r\nyou know why it happened. After adding those
    features, your simple script might\r\ncollapse into the mess you see below:\r\n\r\n```ruby\r\nrequire
    \"csv\"\r\nrequire \"pstore\"\r\nrequire \"bigdecimal\"\r\n\r\nstore = PStore.new(\"shipping_rates.store\")\r\n\r\nstore.transaction
    do\r\n  processed_zipcodes  = []\r\n  \r\n  CSV.foreach(ARGV[0] || \"rates.csv\")
    do |r|\r\n    raise unless r[0][/\\A\\d{5}\\z/]\r\n    raise unless r[1][/\\A\\$\\d+\\.\\d{2}\\z/]\r\n
    \   \r\n    zip    = r[0]\r\n    amount = BigDecimal.new(r[1][1..-1])\r\n\r\n
    \   raise \"duplicate entry: #{zip}\" if processed_zipcodes.include?(zip)\r\n
    \   processed_zipcodes << zip\r\n    \r\n    next if store[zip] == amount\r\n\r\n
    \   if store[zip].nil?\r\n      STDERR.puts(\"Adding new entry for #{zip}: #{'%.2f'
    % amount}\")\r\n    elsif store[zip] != amount\r\n      STDERR.puts(\"Updating
    entry for #{zip}: \"+\r\n                  \"was #{'%.2f' % store[zip]}, now #{'%.2f'
    % amount}\")\r\n    end\r\n    \r\n    store[zip] = BigDecimal.new(amount)\r\n
    \ end\r\nend\r\n```\r\n\r\nOnce your code ends up like this, it becomes increasingly
    difficult to \r\nadd new features or make any sort of change without breaking
    \r\nsomething. Because this style of program is fairly difficult to test,\r\nthe
    maintenance problems can be made even worse by the fact that bugs may \r\nend
    up not being discovered until long after they're introduced.\r\n\r\nProcedural
    scripts are great when you can throwaway the code once you've\r\ncompleted your
    task, or for solving simple problems that you are reasonably\r\nsure the requirements
    will never change for. For everything else,\r\nmore structure pays off in the
    long run. It's clear that this program\r\nis in the latter category, so how do
    we fix it?\r\n\r\n---\r\n\r\n**Solution: Redesign the script as an object-oriented
    program**\r\n\r\nThe thing that makes ad-hoc scripts complicated to reason about\r\nas
    they grow is that they blend all their concerns together -- both \r\nlogically
    and conceptually. For that reason, it is worthwhile to\r\nstart thinking in terms
    of functions and objects as soon as your\r\nprogram exceeds more than a paragraph
    or two of code.\r\n\r\nImagine that the script portion of your importer tool was
    reduced\r\nto the following code:\r\n\r\n```ruby\r\nrequire \"csv\"\r\n\r\nImporter.update(\"shipping_rates.store\")
    do |store|\r\n  CSV.foreach(ARGV[0] || \"rates.csv\") do |r|\r\n    info = PriceInformation.new(zipcode:
    r[0], shipping_rate: r[1])\r\n    \r\n    store[info.zipcode] = info.shipping_rate\r\n
    \ end\r\nend\r\n```\r\n\r\nThis brings us back to about the same level of detail
    expressed in the\r\nnave implementation of the importer script, albeit with a
    few custom classes\r\nthrown into the mix. It hides a lot of detail\r\nfrom the
    reader, but its core purpose is obvious: it iterates over a CSV file\r\nto create
    a mapping of zipcodes to shipping rates in a datastore. \r\n\r\nTo see where the
    real work is being done, we need to look at the\r\n`PriceInformation` and `Importer`
    class definitions. We'll start by taking a\r\nlook at the former, because it has
    fewer moving parts to consider:\r\n\r\n```ruby\r\nrequire \"bigdecimal\"\r\n\r\nclass
    PriceInformation\r\n  ZIPCODE_MATCHER = /\\A\\d{5}\\z/\r\n  PRICE_MATCHER   =
    /\\A\\$\\d+\\.\\d{2}\\z/\r\n\r\n  def initialize(zipcode: raise, shipping_rate:
    raise)\r\n    raise \"Zipcode validation failed\"       unless zipcode[ZIPCODE_MATCHER]\r\n
    \   raise \"Shipping rate validation failed\" unless shipping_rate[PRICE_MATCHER]\r\n
    \   \r\n    @zipcode       = zipcode \r\n    @shipping_rate = BigDecimal.new(shipping_rate[1..-1])\r\n
    \ end\r\n\r\n  attr_reader :zipcode, :shipping_rate\r\nend\r\n```\r\n\r\nHere
    we see that `PriceInformation` applies the same validations and\r\ntransformations
    as shown in the script version of this program, but\r\nencapsulates them in its
    constructor. This makes sure that a `PriceInformation`\r\nobject will either represent
    valid data or not be instantiated at all, \r\nwhich makes it so that the main
    script does not need to concern itself \r\nwith these issues. Even if these validations
    or transformations become\r\nmore complex over time, the calling code should not
    need to change.\r\n\r\nIn a similar vein, the `Importer` class attempts to encapsulate
    the details\r\nabout some lower level concepts at a higher level of abstraction.
    It's\r\nfunctionality is a bit more involved than the `PriceInformation` class,\r\nso
    take a few minutes to study it before moving on:\r\n\r\n```ruby\r\nrequire \"pstore\"\r\n\r\nclass
    Importer\r\n  def self.update(filename)\r\n    store = PStore.new(filename)\r\n\r\n
    \   store.transaction do\r\n      yield new(store)\r\n    end\r\n  end\r\n\r\n
    \ def initialize(store)\r\n    self.store    = store\r\n    self.imported = []\r\n
    \ end\r\n\r\n  def []=(key, new_value)\r\n    raise_if_duplicate(key)\r\n\r\n
    \   old_value = store[key]\r\n\r\n    return if old_value == new_value # nothing
    to do!\r\n\r\n    if old_value.nil?\r\n      ChangeLog.new_record(key, new_value)\r\n
    \   else\r\n      ChangeLog.updated_record(key, old_value, new_value)\r\n    end\r\n\r\n
    \   store[key] = new_value\r\n  end\r\n\r\n  private\r\n\r\n  attr_accessor :store,
    :imported\r\n\r\n  def raise_if_duplicate(key)\r\n    raise \"Duplicate key in
    import data: #{key}\" if imported.include?(key)\r\n    imported << key\r\n  end\r\nend\r\n```\r\n\r\nDespite
    the complexity of its implementation, this class presents a very minimal\r\nuser
    interface, consisting of only `Importer.update` and `Importer#[]=`. The\r\n`Importer.update`
    method is responsible for instantiating a `PStore` object,\r\ninitiating a transaction,
    and then wrapping it in an `Importer` instance to\r\nlimit access to its internals.
    From there, the only method available to the user\r\nis `Importer#[]=`, which
    wraps `PStore#[]=` with two important features:\r\n\r\n1. Single-assignment semantics:
    once a key has been set to particular value, it\r\ncannot be reset from within
    the same `Importer` instance. This is because we\r\nwant to raise an exception
    whenever we encounter duplicate keys in the data\r\nwe're importing.\r\n\r\n2.
    Update notifications: For debugging purposes, we want to know whether a\r\nrecord
    is introducing a new key, or updating the value associated with\r\nan old one.
    Rather than cluttering up this class with the particular log\r\nmessages associated
    with those events, we delegate to a `ChangeLog` helper\r\nobject, which is shown
    below:\r\n\r\n```ruby\r\nclass << (ChangeLog = Object.new)\r\n  def new_record(key,
    value)\r\n    STDERR.puts \"Adding #{key}: #{f(value)}\"\r\n  end\r\n\r\n  def
    updated_record(key, old_value, new_value)\r\n    STDERR.puts \"Updating #{key}:
    Was #{f(old_value)}, Now #{f(new_value)}\" \r\n  end\r\n\r\n  private\r\n\r\n
    \ def f(value)\r\n    '%.2f' % value\r\n  end\r\nend\r\n```\r\n\r\nWith this last
    detail exposed, you've walked through the complete \r\nobject-oriented solution
    to this problem. It is much longer than the\r\nscript version, but also much more
    organized. Before we wrap things up, \r\nlet's talk a bit more about the costs
    and benefits involved in introducing\r\nmore structure into your programs.\r\n\r\n---\r\n\r\n**Discussion**\r\n\r\nThe
    best thing about unstructured code is that nothing is hidden from view. \r\nTo
    understand a script, you start at the top of the file and read downwards, \r\nmentally
    evaluating the state changes and iterators you encounter along the way.\r\n\r\nObject-oriented
    programs are much more logically complex, because they \r\nrepresent a network
    of collaborators rather than a linear set of instructions.\r\nFor example, whenever
    we make a call to `Importer#[]=`, messages are sent to the\r\n`ChangeLog` helper
    object as well as to an instance of `PStore`, but these\r\ndetails are not at
    all visible when you read the caller code. The more objects\r\nthat exist within
    a system, the more complex their interactions get, and so\r\nit is not uncommon
    to end up with call graphs that are both wide and deep.\r\n\r\nBut when it comes
    to visibility, the strength of scripted solutions is also their \r\nweakness,
    and the weakness of object-oriented programs is also their strength:\r\n\r\n*
    In an adhoc script, you cannot make simple decisions about your code\r\nwithout
    considering the entire program. Even something as straightforward\r\nas renaming
    a variable used for temporary storage must be carefully considered,\r\nbecause
    everything exists within a single namespace; anything more involved\r\nthan that
    is simply inviting trouble unless you can keep the entire program\r\nin your head
    at once.\r\n\r\n* In an object-oriented program, the walls erected between different
    objects give\r\nyou freedom to make sweeping changes to internal structures, as
    long as their\r\ninterfaces are preserved. You can even rewire entire subnetworks
    of functionality\r\nfrom your programs, as long as you know what features depend
    on them. When\r\ndone well, the fact that you cannot keep an entire object-oriented
    program\r\nin your head is not much of a concern, because the layered abstractions\r\nmake
    it so you don't have to.\r\n\r\nThe real challenge involved in writing object-oriented
    programs is that they'll\r\nonly be as useful as the mental model they represent.
    This is why it can\r\nactually be helpful to start off with less structure (even
    none at all!), and\r\ngradually work your way towards something more organized.
    After all,\r\nthere is nothing worse than an abstract solution in search of a
    concrete problem!\r\n"
- :slug: avoiding-brittleness-in-data-munging
  :title: Avoiding brittleness in data munging projects
  :summary: Process data and generate reports without writing unmaintainable spaghetti
    code.
  :published: 2013-04-23 00:00:00.000000000 Z
  :issue_number: '6.9'
  :volume: 6
  :body: "> **NOTE:** This issue of Practicing Ruby was one of several content experiments
    \r\nthat was run in Volume 6. It uses a cookbook format (e.g. problem -> solution
    -> discussion)\r\ninstead of the traditional long-form article format we use in
    most Practicing Ruby articles.\r\n\r\n**Problem: Code for data munging projects
    can easily become brittle.**\r\n\r\nWhenever you work on a project that involves
    a significant amount of [data\r\nmunging](http://en.wikipedia.org/wiki/Data_munging),
    you can expect to get some mud on your boots. Even if the individual\r\naggregation
    and transformation steps are simple, complexity arises from\r\nmessy process of
    assembling a useful data processing pipeline. With each\r\nnew change in requirements,
    this problem can easily be compounded in\r\nbrittle systems that have not been
    designed with malleability in mind.\r\n\r\nAs an example, imagine that you are
    implementing a tool that\r\ndelivers auto-generated email newsletters by aggregating
    and \r\nfiltering links from Reddit. The following workflow provides\r\na rough
    outline of what that sort of program would need to\r\ndo in order to complete
    its task:\r\n\r\n1. Map the raw JSON data from Reddit's API to an intermediate
    format that can be\r\nused throughout the rest of the program.\r\n\r\n3. Apply
    filters to ignore links that have already been included in a previous\r\nnewsletter,
    or fall below a minimum score threshold. \r\n\r\n4. Convert the curated list of
    links into a human readable format.\r\n\r\n5. Send out the formatted list via
    email using GMail's SMTP servers.\r\n\r\nSome will look at this set of steps and
    see a standalone script as the right\r\ntool for the job: the individual steps
    are simple, and the time investment is\r\nsmall enough that you could throw the
    entire script away and start again if you\r\nend up facing significant changes
    in requirements.\r\n\r\nOthers will see this as a perfect opportunity to put together
    an elegant domain\r\nmodel that supports a classic object-oriented design style.
    By encapsulating all\r\nof these ideas in generalized abstractions, endless changes
    would be possible in\r\nthe future, thus justifying the upfront design cost.\r\n\r\nBoth
    of these perspectives have merit, but it would be unwise to set up a\r\nfalse
    dichotomy between formal design and skipping the design process entirely. \r\nInteresting
    solutions to this problem also exist in the space between these two extremes,\r\nand
    so we'll take a look at one of them now.\r\n\r\n---\r\n\r\n**Solution: Reduce
    the cost of rework by organizing your codebase into\r\nisolated single-purpose
    components.**\r\n\r\nUnlike the typical web application which has a wide range
    of end-points serving \r\northogonal concerns, the workflow for data munging projects
    often more closely \r\nresembles a flow-chart, with clearly defined beginning
    and end points. The\r\nstep-by-step nature of data munging projects makes them
    most naturally fit the \r\nprocedural programming paradigm. This is a source of
    tension in Ruby,\r\nbecause of its heavy object-oriented bias at the language
    level.\r\n\r\nA reasonable compromise is to embrace \"procedural programming with\r\nobjects\".
    Rather than discussing this technique in the abstract,\r\nwe will instead explore
    what it looks like in practice by seeing\r\nhow it can be used to build the Reddit
    curation tool we\r\ndiscussed earlier.\r\n\r\nLet's start with the script that
    implements the core workflow of the program:\r\n\r\n```ruby\r\nrequire_relative
    \"../lib/spyglass/actions/load_history_file\"\r\nrequire_relative \"../lib/spyglass/actions/fetch_links\"\r\nrequire_relative
    \"../lib/spyglass/actions/format_message\"\r\nrequire_relative \"../lib/spyglass/actions/deliver_message\"\r\n\r\nbasedir
    = File.dirname(__FILE__)\r\n\r\nhistory   = Spyglass.load_history_file(\"#{basedir}/history.store\")
    \    #1\r\nmin_score = 20\r\n\r\nselected_links = Spyglass.fetch_links(\"ruby\").select
    do |link|         #2\r\n  link.score >= min_score && history.new?(link)                        #3\r\nend\r\n\r\nhistory.update(selected_links)
    \                                        #4\r\n\r\nmessage = Spyglass.format_message(links:
    selected_links, \r\n                                  template: \"#{basedir}/message.erb\")
    \ #5\r\n\r\nSpyglass.deliver_message(subject: \"Links for you!!!!!!\",               #6\r\n
    \                        message: message)\r\n```\r\n\r\nThis code looks a bit
    different than the typical Ruby snippet, because rather\r\nthan instantiating
    objects directly and then calling methods on them, it is\r\nsimply calling methods
    on the `Spyglass` module. It is obvious from the\r\n`require_relative` calls that
    these features have been individually enabled,\r\nwhich is also a non-standard
    way of doing thing.\r\n\r\nIf you set aside the quirks of this code for a moment,
    it should still be fairly\r\neasy to read. Here's a rough English translation
    of what's going on:\r\n\r\n1. A history log is being loaded from a file.\r\n2.
    Links in the \"ruby\" sub-reddit are being fetched and filtered\r\n3. Links are
    filtered out if they're below a score threshold or have been\r\nselected in a
    previous run of the program.\r\n4. The history log is updated with the newly selected
    links\r\n5. The selected links are formatted into a human readable message\r\n6.
    The message is delivered with the subject \"Links for you!!!!!!\"\r\n\r\nBecause
    the six steps above pretty much directly line up with the high-level\r\nrequirements
    of the project, it is safe to say that this code is sufficiently\r\nexpressive.
    But to properly evaluate the overall design, we'll need to dig into\r\nthe code
    that implements these features. Let's proceed by walking through the\r\nfeatures
    in the order that they are used.\r\n\r\nFirst up is the `Spyglass.load_history_file`
    procedure:\r\n\r\n```ruby\r\nrequire_relative \"../data/history\"\r\n\r\nmodule
    Spyglass\r\n  def self.load_history_file(filename)\r\n    Data::History.new(filename)\r\n
    \ end\r\nend\r\n```\r\n\r\nThis method is a trivial stub that creates an instance
    of the\r\n`Spyglass::Data::History` class shown below:\r\n\r\n```ruby\r\nrequire
    \"pstore\"\r\n\r\nmodule Spyglass\r\n  module Data\r\n    class History\r\n      def
    initialize(filename)\r\n        @store = PStore.new(filename)\r\n      end\r\n\r\n
    \     def new?(link)\r\n        @store.transaction { @store[link.url].nil? }\r\n
    \     end\r\n\r\n      def update(links)\r\n        @store.transaction do\r\n
    \         links.each { |link| @store[link.url] = true }\r\n        end\r\n      end\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nFrom this definition, we can infer that
    the job of the `History` \r\nobject is to keep track of which URLs have been selected
    in \r\nprevious runs of the program. It uses a `PStore` object as\r\nits persistence
    method, but that is mostly an implementation detail.\r\n\r\nWith an understanding
    of how `Spyglass.load_history_file` works and \r\nwhat type of object it returns,
    we can now move on to investigating\r\nthe `Spyglass.fetch_links` procedure:\r\n\r\n```ruby\r\nrequire
    \"json\"\r\nrequire \"open-uri\"\r\n\r\nrequire_relative \"../data/link\"\r\n\r\nmodule
    Spyglass\r\n  def self.fetch_links(category)\r\n    document = open(\"http://api.reddit.com/r/#{category}?limit=100\").read\r\n\r\n
    \   JSON.parse(document)[\"data\"][\"children\"].map do |e|\r\n      e = e[\"data\"]\r\n\r\n
    \     Data::Link.new(url: e[\"url\"], score: e[\"score\"], title: e[\"title\"])\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nThis method is responsible for making an
    HTTP request to the Reddit API to\r\ncapture a JSON document representing the
    raw data about links in a particular\r\nsubreddit. It then parses that document
    and transforms it into `Data::Link`\r\nobjects. A quick look at the class definition
    for `Data::Link` reveals that it\r\nis a straightforward value object with no
    interesting business logic:\r\n\r\n```ruby\r\nmodule Spyglass\r\n  module Data\r\n
    \   class Link\r\n      def initialize(url: raise, score: raise, title: raise)\r\n
    \       @url   = url\r\n        @score = score\r\n        @title = title\r\n      end\r\n\r\n
    \     attr_reader :url, :score, :title\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAs
    simple as it is, the `Data::Link` object is a very important part of this \r\nprogram,
    because every other feature that refers to links assumes that\r\nthey conform
    to this interface. In other words, we've set in stone here\r\nthat the data our
    program is interested in when it comes to links are\r\nits `score`, `url`, and
    `title`. Any changes to this interface would\r\nrequire widespread changes throughout
    our program.\r\n\r\nBased on what you've seen so far, you should be able to understand
    exactly how\r\nthis program works up to step #4 in its main script. Only two steps
    remain:\r\nformatting the list of curated links into a human readable message,
    and\r\ndelivering it to someone.\r\n\r\nThe formatting procedure (i.e. `Spyglass.format_message`)
    is extremely basic, \r\nas it is nothing more than a minimal wrapper around the
    `ERB` standard \r\nlibrary:\r\n\r\n```ruby\r\nrequire \"erb\"\r\n\r\nmodule Spyglass\r\n
    \ def self.format_message(links: raise, template: raise)\r\n    ERB.new(File.read(template),
    nil, \"-\").result(binding)\r\n  end\r\nend\r\n```\r\n\r\nThis code is somewhat
    generalized, allowing an arbitrary template to\r\npresent the list of links. In
    the case of this particular script, we use a\r\nsimple text-based template that
    looks like this:\r\n\r\n```\r\nHere are some links you might enjoy!\r\n<% links.each
    do |link| -%>\r\n\r\n  <%= link.title %>:\r\n  <%= link.url   %>\r\n<% end %>\r\nHave
    fun!\r\n-greg\r\n```\r\n\r\nWhen evaluated, this template spits out plain-text
    output that looks similar to\r\nwhat you see below:\r\n\r\n```\r\nHere are some
    links you might enjoy!\r\n\r\n  _why updated his site:\r\n  http://whytheluckystiff.net\r\n\r\n
    \ Teabag: A Javascript test runner built on top of Rails:\r\n  https://github.com/modeset/teabag\r\n\r\n
    \ Ruby 2.0 Works Hard So You Can Be Lazy:\r\n  http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy\r\n\r\nHave
    fun!\r\n-greg\r\n```\r\n\r\nFrom here, all that remains is to fire this message
    out via email, which is\r\nhandled by the `Spyglass.deliver_message` procedure:\r\n\r\n```ruby\r\nrequire
    \"mail\"\r\n\r\nMail.defaults do\r\n  delivery_method :smtp, {\r\n    :address
    \             => 'smtp.gmail.com',\r\n    :port                 => '587',\r\n
    \   :user_name            => ENV[\"GMAIL_USER\"],\r\n    :password             =>
    ENV[\"GMAIL_PASSWORD\"],\r\n    :authentication       => :plain,\r\n    :enable_starttls_auto
    => true\r\n  }\r\nend\r\n\r\nmodule Spyglass  \r\n  def self.deliver_message(message:
    raise, subject: raise)\r\n    mail = Mail.new\r\n\r\n    mail.from = ENV[\"GMAIL_USER\"]\r\n
    \   mail.to   = ENV[\"SPYGLASS_RECIPIENT\"]\r\n\r\n    mail.subject = subject\r\n
    \   mail.body    = message \r\n\r\n    mail.deliver!\r\n  end\r\nend\r\n```\r\n\r\nThis
    is not as easy to read as many of the previous procedures, because it\r\ninvolves
    some configuration code. However, on closer investigation we can easily\r\nsee
    that this is a thin wrapper around the `Mail` gem, and that it uses three\r\nenvironment
    variables for its settings: `GMAIL_USER`, `GMAIL_PASSWORD`, and\r\n`SPYGLASS_RECIPIENT`.
    This means that the main script for this program needs to\r\nhave these values
    set before it can be run, as in the example below:\r\n\r\n```console\r\n$ GMAIL_USER=\"test@gmail.com\"
    GMAIL_PASSWORD=\"password\" \\\r\n  SPYGLASS_RECIPIENT=\"test@test.com\" ruby
    examples/reddit.rb\r\n```\r\n\r\nIf you have a GMail account, you can actually
    give this a try by cloning\r\nthe [practicing-ruby-examples\r\nrepository](https://github.com/elm-city-craftworks/practicing-ruby-examples/tree/master/v6/009)\r\nand
    running something similar to the line shown above in the *v6/009* folder.\r\nBut
    as long as you understand the general idea behind this program, don't worry\r\nif
    you can't test it for yourself right now.\r\n\r\nAssuming that you have been able
    to understand this walk-through, you may already\r\nhave some sense of why this
    solution is a reasonable middle ground between ad\r\nhoc scripting and formal
    object-oriented design. However, we should discuss the\r\nbenefits and costs in
    more detail before we wrap things up here.\r\n\r\n---\r\n\r\n**Discussion**\r\n\r\nThe
    primary difference between object-oriented programming and \"procedural\r\nprogramming
    with objects\" is that the former binds certain behaviors to\r\nencapsulated data,
    and the latter decouples its data from its behavior.\r\n\r\nObject-oriented design
    is best suited for problems where most of the interesting\r\ndetails exist in
    the messages that are passed between objects. In other words,\r\nwhen you have
    a complex set of interactions between a network of communicating\r\nobjects, it
    makes good sense to tightly bind together state and behavior.\r\nHowever, this
    comes at the cost of indirection, and so it becomes hard to keep a\r\nmental model
    in your mind of what the call graph looks like for even a single\r\nrequest.\r\n\r\nBy
    contrast, data munging projects are procedural in nature, and so you have a\r\ngood
    sense of what needs to happen at each step in the process. The final\r\nprogram
    represents a chain of transformations and filters on relatively simple\r\ndata
    structures, with some side effects thrown in along the way. Because each\r\nstep
    tends to be a very concrete action, the abstraction benefit that objects\r\ncan
    offer is negated by the fact that so much is subject to change in the whole\r\nsystem.\r\n\r\nIf
    you go back and read through the [codebase we discussed in this\r\narticle](https://github.com/elm-city-craftworks/practicing-ruby-examples/tree/master/v6/009),\r\nyou
    will find that the data objects are trivially understandable, and the\r\nactions
    are context-independent. Although they are not pure functions, each of\r\nthe
    actions can be fully understood in terms of its inputs, outputs, and\r\nexternal
    dependencies. This makes it possible to make changes to the internals\r\nwithout
    thinking about their impact on the overall program, as long as the\r\nreturn values
    do not change.\r\n\r\nAnother interesting benefit of \"procedural programming
    with objects\" is that a\r\nlack of internal behavioral dependencies makes it
    so that you can easily change\r\nthe signature of a single action without requiring
    a cascade of changes\r\nthroughout the system. The main script might need to be
    updated, but such\r\nrevisions would be trivial.\r\n\r\nHowever, it is important
    to remember that all of these benefits come from the\r\nfact that data munging
    projects occupy a special domain where certain benefits\r\nof object-oriented
    programming are not especially important. You may want to\r\nconsider adopting
    a traditional object-oriented design if any of the following\r\nconditions apply:\r\n\r\n*
    You have actions that need to store data in instance variables, rather than\r\nsimply
    returning value objects or using repository objects like the `History`\r\nobject
    in this example.\r\n\r\n* You have actions that need to call other actions in
    order to get their job\r\ndone, rather than relying on simple data objects that
    rarely change.\r\n\r\n* You have actions that need to operate as a multi-step
    state machine, rather\r\nthan a single-purpose procedure that you can fire and
    forget.\r\n\r\nAll of the above are symptoms that the benefits of object-oriented
    design will\r\noutweigh its costs, and Ruby *is* a deeply object-oriented language,
    so you\r\nwon't lose out by heading in that direction. However, if you are stuck
    in the\r\nplace between a throwaway script and a full object-oriented program,
    the example\r\nshown in this article might help you find a nice compromise.\r\n"
- :slug: low-cost-approach-to-side-projects
  :title: A low cost approach to working on side projects
  :summary: Save time by building a standalone feature before designing a complete
    product.
  :published: 2013-05-07 00:00:00.000000000 Z
  :issue_number: '6.10'
  :volume: 6
  :body: "> **NOTE:** This issue of Practicing Ruby was one of several content experiments
    \r\nthat was run in Volume 6. It uses a cookbook format (e.g. problem -> solution
    -> discussion)\r\ninstead of the traditional long-form article format we use in
    most Practicing Ruby articles.\r\n\r\n**Problem: It is hard to work on side projects
    without obsessing over technical\r\ndetails and infrastructure decisions.**\r\n\r\nThere
    are lots of reasons to work on projects in your spare time, but there are \r\ntwo
    that stand out above the rest: scratching a personal itch by solving a \r\nreal
    problem, and gaining a better understanding of various programming tools \r\nand
    techniques. Because these two motivating factors are competing interests, \r\nit
    pays to set explicit goals before working on a new side project.\r\n\r\nThat said,
    remembering this lesson is always a constant struggle for me. \r\nWhenever I'm
    brainstorming about a new project while taking a walk or sketching\r\nsomething
    on a white board, I tend to develop big dreams that extend far\r\nbeyond what
    I can realistically accomplish in my available free time. To show\r\nyou exactly
    what I mean, I can share the back story on what that lead me to \r\nwrite the
    article you're reading now:\r\n\r\n> Because I have a toddler to take care of
    at home,\r\nmeal planning can be a major source of stress for me. My wife and
    I are \r\noften too distracted to do planning in advance -- so we often need to
    make a \r\ndecision on what to eat, put together a shopping list, go to the grocery
    \r\nstore, and then come home and cook all in a single afternoon. \r\nWhenever
    this proves to be too much of a challenge for us, we order \r\ntakeout or heat
    up some frozen junk food. Unsurprisingly,\r\nthis happens far more often than
    we'd like it to.\r\n\r\n> To make matters worse, our family cookbook has historically
    consisted of a \r\ncollection of haphazardly formatted recipes from various different
    sources. Over time, we've\r\nmade changes to the way we cook these recipes, but
    these revisions almost\r\nnever get written down. So for the most part, our recipes
    are inaccurate, \r\nhard to read, and can only be cooked by whichever one of us
    knows its quirks.\r\nMost of them aren't even labeled with the name of the dish,
    so you need to\r\nskim the instructions to find out what kind of dish it is!\r\n\r\n>
    On one of my afternoon walks, I decided I wanted to build a program\r\nthat would
    help us solve some of these problems, so that we could make fewer\r\ntrips to
    the grocery store each week, while reducing the friction and cognitive\r\nload
    involved in preparing a decent home cooked meal. It all seemed so simple in\r\nmy
    head, until I started writing out my ideas!\r\n\r\nBy the time I got done with
    my brain dump, the following items were on the \r\nwish list of things I wanted
    to accomplish in this side project:\r\n\r\n* I figured this would be a great time
    to try out Rails 4, because this project\r\nwould obviously need to be a web application
    of some sort.\r\n\r\n* It would be another opportunity for me to play around with
    Bootstrap.\r\nI am weak at frontend development, but I am also bothered by poor
    visual \r\ndesign and usability, so it seems to be a toolset that's worth learning
    for\r\nsomeone like me.\r\n\r\n* I had been meaning to explore using the Pandoc
    toolchain from within Ruby programs\r\nto produce HTML and PDF output from Markdown
    files, so this would be a perfect \r\nchance to try that out. This would allow
    me to have recipes look nice both\r\non the web and in print.\r\n\r\n* It would
    be really cool if the meal planner would look for patterns in our\r\neating habits
    and generate recommendations for us once it had enough data to\r\ndraw some interesting
    conclusions.\r\n\r\n* It would be nice to have a way of standardizing units of
    measures so that we\r\ncould trivially scale recipes and combine multiple recipes
    into a shopping list\r\nautomatically.\r\n\r\n* It would be neat to support revision
    control and variations on recipes within\r\nthe web application, in addition to
    basic CRUD functionality and search.\r\n\r\n* It would be great to be able to
    input a list of ingredients we have on hand\r\nand get back the recipes that match
    them.\r\n\r\nI won't lie to you, the system described above still sounds awesome
    to\r\nme. Building it would involve lots of fun technological challenges, and\r\nit'd
    be amazing to have such a powerful tool available to me. But it also\r\nrepresents
    a completely unreasonable set of goals for someone who has so little\r\nproductive
    free time that even cooking dinner seems like too much work.\r\nSadly, it's easy
    to forget that sometimes.\r\n\r\nTo make a long story short: my initial brainstorming
    session proved to be \r\na pleasant day dream, but it wasn't a real solution to
    my problems. Instead, \r\nwhat I needed was an approach that could deliver modest
    results in fractions \r\nof an hour rather than expecting to put in weeks of hard
    work. To do that, \r\nI'd have to radically scale back my expectations and set
    out in search of \r\nsome low hanging fruit.\r\n\r\n---\r\n\r\n**Solution: Build
    a single useful feature and see how well it works in practice \r\nbefore attempting
    to design a full-scale application or library.**\r\n\r\nWhen I catch myself getting
    caught up in *architectural astronaut* mode, \r\nI tend to bring myself back down
    to earth by completely inverting my approach. \r\nI drop the notion of building
    a perfect system, and instead focus on\r\nbuilding a single useful feature as
    quickly as possible without\r\nany concern for elegance.\r\n\r\nLike paratroopers
    in the night, the goal is not to find the exact right\r\nplace to start from,
    but instead to dive head first into unknown territory\r\nand try to secure a foothold.
    Although there were many possible starting\r\npoints for working on my meal planner,
    I decided to start with the one that\r\nseemed most simple in my mind: generating
    randomized selections of dishes \r\nto cook over a three day timespan.\r\n\r\nBecause
    this feature involved automating a small part of what was originally \r\na completely
    manual process, the first step was to do a bit of tedious\r\ndata entry work.
    I thumbed through our binder of recipes and pulled out 16 \r\nof them that we
    had cooked recently. I then used a felt-tipped pen to\r\nnumber each recipe in
    ascending order, which yielded a rudimentary\r\nway of looking up recipes by number.\r\n\r\nThis
    may seem like an ugly way of doing things, but I did it to save myself \r\nthe
    trouble of figuring out how to convert my haphazardly printed recipes\r\ninto
    text-based source files. I also wanted to defer the decision of what to \r\n\"officially\"
    name each dish, and this way of labeling things allowed me to \r\ndo that in the
    same way that an autoincrementing primary key does for \r\ndatabase records.\r\n\r\nOnce
    I finished manually indexing my recipes, I compiled a CSV file \r\nthat looked
    something like what you see below:\r\n\r\n```\r\nname,label\r\n\"Veggie Cassarole
    w. Swiss Chard + Baguette\",1\r\n\"Stuffed Mushroom w. Leeks + Shallots\",2\r\n\"Lentil
    Soup w. Leeks + Kale\",3\r\n\"Spinach + White Bean Soup\",4\r\n```\r\n\r\nThis
    dataset introduces some human-readable names for the dishes, because \r\nI didn't
    want to have to thumb through the recipe book to see what \r\n\"Dish #4\" is actually
    made out of. This system also has an advantage of \r\nbeing truly arbitrary, unlike
    alphabetical order in which \r\n\"Spinach + White Bean Soup\" is just as reasonable
    a label as \r\n\"White Bean + Spinach Soup\", but the two would appear in totally
    \r\ndifferent positions in the book. Although this may have been premature \r\noptimization,
    it came at a low cost and gave me some peace of mind, \r\nso that made it worthwhile
    to me.\r\n\r\nBefore writing any code, I manually tested the index to see how
    easy it\r\nwould be to look up a recipe by number. It proved to be no more complicated\r\nthan
    flipping to a particular page of a book, so it turned out to be a \r\ngood enough
    system to start with. After that quick usability test,\r\nI hacked together the
    following script to give me randomized meal selections:\r\n\r\n\r\n```ruby\r\nrequire
    \"csv\"\r\n\r\ncandidates = []\r\n\r\nCSV.foreach(\"recipes.csv\", :headers =>
    true) { |row| candidates << row }\r\n\r\nputs \"How about this menu?\\n\\n\" +
    candidates\r\n  .sample(3)\r\n  .map { |e| \"* #{e['name']} (#{e['label']})\"
    }\r\n  .join(\"\\n\")\r\n```\r\n\r\nWhen run, this script produces the following
    output:\r\n\r\n```\r\nHow about this menu?\r\n\r\n* Tunisian Chickpea Stew (10)\r\n*
    Tomato + Feta w. Green Bean Salad (13)\r\n* Stuffed Mushroom w. Leeks + Shallots
    (2)\r\n```\r\n\r\nThe first time I used this new tool, I had to run it a couple
    times \r\nin order to come up with three dishes that appealed to me at that moment.\r\nHowever,
    this was still far less daunting than trying to choose three\r\ndishes directly
    from our disorganized cookbook. With only about 30 minutes \r\nof work invested
    into this project (not counting the ridiculously \r\nambitious brainstorming session),
    I already had a tool that\r\nwas doing something useful for me. Content with my
    progress for the day,\r\nI plucked my chosen recipes from the binder we keep them
    in and headed off \r\nto the grocery store.\r\n\r\nWhile shopping for ingredients
    and cooking the meals, I was reminded how \r\nterribly organized most of our recipes
    truly were. Some even made it hard\r\nto see exactly what ingredients were needed,
    and nearly all of them listed\r\nsteps in a semi-arbitrary sequence of muddled
    paragraphs. Almost none of the\r\nrecipes were at the scale we tended to cook
    them at, so we'd need to do mental\r\nmath both when cooking and when shopping
    which occasionally lead us to make\r\nmistakes.\r\n\r\nI knew I didn't have the
    available free time to build a full-blown content management \r\nsystem for our
    recipes, but I wondered whether I could apply the lesson learned\r\nfrom earlier
    that day to improve things in a low cost way. I eventually realized\r\nthat my
    idea of using Pandoc to convert markdown formatted recipes into PDFs \r\nwouldn't
    be so bad if I didn't need to build a whole system around it, so I \r\ndecided
    to take a few recipes and manually format them in a way that was \r\nappealing
    to me. \r\n\r\nMy personal preferences for organizing recipes is not\r\nespecially
    important here, but if you're curious, \r\n[check out this sample document](http://notes.practicingruby.com/barley_risotto.pdf).\r\nThe
    main goal I had was to limit the amount of information I needed to keep in my\r\nmind
    at any given point in time, and to make the different transition points in\r\nthe
    cooking process explicitly clear.\r\n\r\nThe process of formatting the recipes
    this way was time consuming, \r\nand actually took longer than writing the randomizer
    program and preparing \r\nits data. With that in mind, I decided that I would
    work on this as I found \r\ntime for it, rather than trying to get everything
    normalized into this\r\nformat all at once. The improved formatting definitely
    made a difference,\r\nbut I had to consider whether my time might be better used
    elsewhere.\r\n\r\nDespite the mixed results, the lesson I learned from this experiment
    is that if\r\nhad I focused on solving the content management problem first, I
    may have spent\r\na good chunk of time building a complex system without\r\ngaining
    an appreciation for the actual data entry costs. I also came to\r\nrealize that
    markdown files in a git repository seemed to be every bit\r\nas comfortable for
    me as a web application could be, and I didn't need\r\nto build anything in order
    to use them. This would be a terrible UI for\r\na general purpose application,
    but it worked great for me.\r\n\r\nOver the course of a couple weeks, I kept using
    the meal randomizer with \r\nsome degree of success, finding small opportunities
    to improve it along \r\nthe way. Two main issues surfaced fairly early on in my
    use of the program:\r\n\r\n1. Without some way of filtering recommended meals
    based on how much effort they \r\nrequired, I had to mentally ignore our more
    time-consuming dishes most\r\nof the time.\r\n\r\n2. Sixteen dishes is too small
    of a selection to get enough variety to avoid\r\nduplicate suggestions and repeatedly
    seeing dishes you've ate recently.\r\n\r\nFor the first issue, I decided that
    I didn't need something as precise as preparation \r\ntime in minutes, but instead
    could use a simple subjective rating system from 1-5 \r\nwhere the low end represents
    dishes that can be made almost instantaneously \r\n(like a grilled cheese sandwich),
    the middle represents a dish we'd cook on a regular\r\nevening, and the high end
    represents an all-day cooking session. I'd set up\r\nthe program to select dishes
    with an effort score of 3 or lower by default, but allow\r\nfor the limit to be
    set via an argument.\r\n\r\nBut it's easy to see that fixing the first problem
    would only make the second\r\nissue worse. I briefly thought through some clever
    solutions to the variety problem, like\r\nkeeping track of a history or doing
    other things to make the selection process smarter,\r\nbut eventually decided
    that simply increasing the number of dishes in the data set\r\nwould be easiest.
    So I dug back into some of our other recipes that we had online,\r\nand also added
    things like sandwiches and other quick meals that we don't cook\r\nfrom a recipe.
    Most of these didn't have a printout in our cookbook, so I just\r\nlabeled them
    with an \"X\", to indicate that they'd need to be imported later.\r\n\r\nThanks
    to my active laziness, the script only required very minor changes. The\r\nupdated
    version is shown below:\r\n\r\n```ruby\r\nrequire \"csv\"\r\n\r\ncandidates =
    []\r\neffort     = ARGV[0] ? Integer(ARGV[0]) : 3\r\n\r\nCSV.foreach(\"recipes.csv\",
    :headers => true) { |row| candidates << row }\r\n\r\nputs \"How about this menu?\\n\\n\"
    + candidates\r\n  .select { |e| Integer(e['effort']) <= effort }\r\n  .sample(3)\r\n
    \ .map { |e| \"* #{e['name']} (#{e['label']})\" }\r\n  .join(\"\\n\")\r\n```\r\n\r\nSimilarly,
    the CSV file only required a tiny bit of rework to add the effort\r\nratings:\r\n\r\n```\r\nname,label,effort\r\n\"Veggie
    Cassarole w. Swiss Chard + Baguette\",1,3\r\n\"Stuffed Mushroom w. Leeks + Shallots\",2,3\r\n\"Lentil
    Soup w. Leeks + Kale\",3,3\r\n\"Spinach + White Bean Soup\",4,2\r\n...\r\n```\r\n\r\nWith
    a dataset including over 30 dishes, and a filter that removed the most \r\ncomplex
    ones by default, the variety of the recommendations got a lot \r\nbetter. This
    greatly reduced the number of times I needed to run the script\r\nbefore I could
    put together a meal plan. A smarter selection algorithm\r\ncould definitely make
    the tool even more helpful, but these small changes \r\nmade a huge difference
    on their own.\r\n\r\nAnother week passed, and I eventually realized that I don't
    particularly\r\nlike having to pop open a terminal and run a command line program
    simply\r\nto decide what I want to have for dinner. After another half hour of
    work, \r\nI wrapped the script in a minimal web interface using Sinatra. Throwing
    \r\nthat app up onto Heroku allowed me to do my meal planning via the web \r\nbrowser.
    The UI is nothing special, but it gets the job done:\r\n\r\n![](http://i.imgur.com/Y1C3sxt.png)\r\n\r\nAs
    you might expect, the code that implements this UI isn't\r\nespecially exciting,
    it's just basic glue code and an ERB \r\ntemplate:\r\n\r\n```ruby\r\nrequire \"sinatra\"\r\nrequire
    \"csv\"\r\n\r\ndef meal_list(candidates, effort)\r\n  \"<ul>\" + \r\n    candidates.select
    { |e| Integer(e['effort']) <= effort }\r\n              .sample(3)\r\n              .map
    { |e| \"<li>#{e['name']} (#{e['label']})</li>\" }\r\n              .join + \r\n
    \ \"</ul>\"\r\nend\r\n\r\nget \"/\" do\r\n  candidates = []\r\n  effort     =
    Integer(params.fetch(\"effort\", 3))\r\n  meal_list  = \"#{File.dirname(__FILE__)}/../recipes.csv\"\r\n\r\n
    \ CSV.foreach(meal_list, :headers => true) do |row| \r\n    candidates << row
    \r\n  end\r\n\r\n  @selected = meal_list(candidates, effort)\r\n  \r\n  erb :index\r\nend\r\n\r\n__END__\r\n\r\n@@index\r\n<html>\r\n
    \ <body>\r\n    <h1>How about these meals?</h1>\r\n    <%= @selected %>\r\n  </body>\r\n</html>\r\n```\r\n\r\nIt's
    worth noting that the code above is about at the level of complexity\r\nwhere
    more formal development practices start to pay off. But since I \r\nmanaged to
    squeeze three weeks of active use out of the tool before\r\ngetting to this point,
    I definitely won't mind doing some cleanup work \r\nif and when I decide to add
    more features to it.\r\n\r\n**Discussion**\r\n\r\nThe main thing I hope you will
    take away from this article is that \"keeping\r\nthings simple\" is term that
    we say often but rarely practice. This can have a\r\npainful effect on our daily
    work, but is disasterous for our side projects,\r\nbecause we often work on them
    with a tight time budget. \r\n\r\nSpeaking from personal experience, I've lost
    count of how many Rails applications \r\nskeletons I've built that started with
    big dreams and ended up with nothing more \r\nthan a couple database models, a
    few half-finished CRUD forms, and an\r\nauthentication system, but no actual features
    to speak of. I guess I am\r\njust extremely good at overestimating how much time
    and motivation I'll\r\nhave for building the things I think of day to day.\r\n\r\nIncreasingly,
    I've been trying to think of software as a support system for\r\nsolving human
    problems, rather than some sort of artifact that holds intrinsic\r\nvalue. Software
    is extremely expensive to build and maintain, so it pays to\r\nwrite as little
    code as possible. This does not just mean writing terse\r\nprograms: it means
    spending more time and creativity on practical problem\r\nsolving, so that you
    can focus your energy on making people's lives\r\neasier rather than obsessing
    over technical issues. Adopting this mindset\r\ncan lead you to being more thoughtful
    when you build software for others,\r\nbut it also serves as a reminder that you
    can and should enjoy the fruits \r\nof your own labor.\r\n\r\nEven though programming
    can be fun in its own right, you don't need to view\r\nevery software project
    as an opportunity to solve interesting coding puzzles.\r\nWhen measured in terms
    of functional value rather than implementation details,\r\nsometimes the most
    elegant solution is a script that you cobbled together during\r\na lunch break,
    because it cost you almost nothing but still managed to do\r\nsomething useful
    for you. These opportunities appear around every corner, you\r\njust need to be
    prepared to take advantage of them when they arise. I hope\r\nthe story I've shared
    in this article has helped you learn what to look out for.\r\n\r\n*Do you have
    an example of some code you wrote that took very little effort but\r\nstill ended
    up being very useful for you? If so, please share your story in\r\nthe comments
    section below.*\r\n"
- :slug: simulating-tiny-worlds
  :title: Simulating tiny worlds for fun and profit
  :summary: Practice exploratory programming by modeling forest fires, rabbit populations,
    and diseases.
  :published: 2013-06-04 00:00:00.000000000 Z
  :issue_number: '7.1'
  :volume: 7
  :body: "As programmers we are very comfortable with the idea of using\r\nsoftware
    to solve concrete problems. However, it is easy to\r\nunderestimate the role that
    code can play in problem-solving itself, and that blindspot can hinder our creativity
    in a number of ways.\r\n\r\nIn this article, I will walk you through some fun
    examples that demonstrate how code can be used as an exploratory thinking tool,
    and then reflect upon how that kind of workflow might be applied to everyday programming
    tasks.\r\n\r\n## Setting the stage\r\n\r\nThe source of my motivation for writing
    on this topic is the [StarLogo](http://education.mit.edu/starlogo/) programming
    environment and Mitchel Resnick's excellent book \"Turtles, Termites, and Traffic
    Jams\", both of which illustrate the potential for software to be used as a mind-expanding
    thinking tool.\r\n\r\nAs the title of the book implies, StarLogo is an environment
    that facilitates simplistic modeling of scenarios that occur in the natural world.
    The purpose of the tool is not to create environments that closely emulate reality,
    but instead, to encourage exploration and discovery in simple, tightly constrained
    microcosms. Apart from being an intellectual curiosity, this sort of toolset provides
    a powerful way to intuitively experience deep concepts that range from self-organization
    and emergent behavior to massive parallelism.\r\n\r\nIn the spirit of exploration,
    I won't attempt to make a case for those claims by way of a top-down explanation.
    Instead, we'll now walk through a few scenarios that are easily implemented using
    StarLogo-style modeling. The examples I've chosen are based on ideas from StarLogo
    and Resnick's book, but I have ported them to JRuby to allow you to explore the
    concepts without having to familiarize yourself with a new environment first.
    The engine I built is called [Terrarium](https://github.com/sandal/terrarium),
    and it is very much a rough prototype, but it should still be good enough to introduce
    you to these ideas with minimal friction.\r\n\r\n## Scenario I: Forest fires\r\n\r\nThe
    environment in the StarLogo model consists of a two-dimensional grid of \"patches\",
    which are in some ways similar to cellular automata models such as Conway's Game
    of Life. \r\n\r\nUsing only patch color to represent state, we could apply the
    following ruleset to simulate a rough sketch of a forest fire:\r\n\r\n1. Start
    by building a forest. For the sake of simplicity, we can begin with an empty grid
    and then randomly paint some of its patches green.\r\n\r\n2. To ignite our fire,
    we can pick a random patch in the grid and paint it red.\r\n\r\n3. Each green
    patch then needs to repeatedly check to see if any of its neighbors are red, and
    if so, it becomes red itself, spreading the fire.\r\n\r\nApplying these three
    trivial rules results in the following behavior:\r\n\r\n![](http://i.imgur.com/MtAbXPF.gif)\r\n\r\nAlthough
    this animation should be fairly straightforward to understand, it is worth pointing
    out one small detail about the geometry of a StarLogo-style world: rather than
    being an infinite grid like Conway's Game of Life, it is a torus, where the left
    side is connected to the right, and the top is connected to the bottom. This explains
    why the fire (which starts at the bottom of the screen) quickly overflows onto
    the top of the screen in this animation.\r\n\r\nThe code that was used to generate
    this visualization is shown below, and is nearly a direct translation of the rules
    shown above:\r\n\r\n```ruby\r\nTerrarium::Scenario.define do\r\n  # Rule 1: Build
    the forest\r\n  patches do\r\n    with_probability(0.5) { set_color :green } \r\n
    \ end\r\n\r\n  # Rule 2. Start the fire\r\n  random_patch { set_color :red }\r\n\r\n
    \ # Rule 3. Spread the fire\r\n  patches! do\r\n    if color == :green && neighbors.any?
    { |e| e.color == :red }\r\n      set_color :red\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIt
    is here where you can catch the first glimpse of what I meant by \"code as a thinking
    tool\". With Terrarium as our engine and StarLogo-style data modeling, we don't
    need to think at all about the structure or inner workings of our program, but
    instead can immediately turn our ideas into code. This takes what would cost us
    hours in upfront modeling and reduces it to minutes of effort.\r\n\r\nBeing able
    to work at this very high level of abstraction allows us to try variations and
    experiments as soon as we think of them. A simple idea to try out with this model
    is to see how the fire spreads at various levels of tree density. You will find
    that at 50% (which is what is shown above), the fire will pretty much always spread
    across the forest, but at 30%, the opposite is true. Is there a critical tipping
    point between those two bounds? If so, why is it there? These are the kinds of
    thoughts that arise when you can focus on ideas rather than code.\r\n\r\n## Scenario
    II: Infectious disease\r\n\r\nAs you may have guessed from the name of the language,
    StarLogo also implements the *turtle graphics* model found in the Logo programming
    language. Both languages were developed by same research group at MIT, and so
    if you are familiar with Logo turtles, you will find that StarLogo's creatures
    move around the world in a similar way to their classical ancestors.\r\n\r\nHowever,
    that is where the similarities end. While the average Logo turtle lives a solitary
    life, StarLogo's creatures can be commanded en-masse, in groups of hundreds or
    thousands. Where the Logo turtle is mostly used for drawing lines (albeit in some
    very clever ways), the StarLogo creature is capable of having much more complex
    interactions with its world, including the other creatures in it.\r\n\r\nTake
    for example the problem of modeling the spread of a contagious disease through
    a population of creatures. If we allow ourselves to paper over any inconsistencies
    with reality by using a bit of imagination, the following rules are sufficient
    for emulating this scenario:\r\n\r\n1. Arrange a group of healthy creatures into
    a crowd\r\n3. Infect some of the creatures with the disease\r\n4. Allow the creatures
    to slowly move about their world\r\n5. The disease will spread from sick to healthy
    creatures whenever they come into contact with each other.\r\n6. After a set period
    of \"sick time\", the creature will either die or recover, based on probability.
    (Recovered creatures can be re-infected if they come into contact with sick creatures,
    dead creatures simply disappear.)\r\n\r\nWhen applied to a population of 200 StarLogo
    creatures, these rules produce a pattern similar to what is shown in the following
    animation:\r\n\r\n![](http://i.imgur.com/dZ6czuf.gif)\r\n\r\nHere we see the disease
    quickly spreading from a few infected individuals to the majority of the population.
    However, the rate of infection then dampens due to the following factors:\r\n\r\n*
    As the creatures wander around, they become less densely packed together, which
    reduces the frequency at which they transmit disease to one another.\r\n\r\n*
    If a creature eventually dies from an infection, that stops it from continuing
    to spread the disease, because it gets removed from the world upon its death.\r\n\r\n*
    If the creature recovers, it can be reinfected, but by then the creatures have
    already spread out enough to prevent rapid chain reactions from occuring.\r\n\r\nAll
    of these conditions are effected by a number of variables, including population
    size, population density, duration of sick time, number of initially infected
    creatures, speed of movement of the creatures, and the probability of death vs.
    recovery in the infected population. In addition to this, the whole system is
    subject to some degree of fluctuation due to the randomness in both the movement
    and initial layout of the population.\r\n\r\nTaking a purely analytical approach
    towards thinking through the relationships between all of these variables would
    be a challenging task to say the least. However, it does not take much specialized
    knowledge at all to model this problem using StarLogo-style creatures. In fact,
    the code below is all you need to implement this scenario. Try reading it one
    rule at a time while looking at the animation, and you should be able to piece
    together the main concepts even if you've never heard of StarLogo before reading
    this article:\r\n\r\n```ruby\r\nTerrarium::Scenario.define do\r\n  healthy_color
    = :cyan\r\n  sick_color    = :yellow\r\n\r\n  initial_population = 200\r\n  crowd_range
    \       = 5..15\r\n  sick_time          = 5\r\n  infection_density  = 0.02\r\n
    \ movement_speed     = 0.2\r\n  \r\n  create_creatures(initial_population)\r\n
    \ \r\n  # rule 1: arrange a group of healthy creatures into a crowd\r\n  creatures
    do \r\n    lt rand(0..359)\r\n    fd rand(crowd_range)\r\n\r\n    data[:sick_time]
    = 0\r\n    set_color healthy_color\r\n  end\r\n\r\n  # rule 2: infect some creatures\r\n
    \ creatures do\r\n    with_probability(infection_density) do\r\n      set_color
    sick_color\r\n      \r\n      data[:sick_time] = sick_time\r\n    end\r\n  end\r\n\r\n
    \ # rule 3: allow the creatures to move about randomly\r\n  creatures! do\r\n
    \   lt rand(1..40)\r\n    rt rand(1..40)\r\n\r\n    fd movement_speed\r\n  end\r\n\r\n
    \ # rule 4: spread disease on contact\r\n  creatures! do\r\n    next unless color
    == healthy_color\r\n\r\n    if nearby_creatures.any? { |e| e.color == sick_color
    }\r\n      set_color sick_color\r\n      \r\n      data[:sick_time] = sick_time\r\n
    \   end\r\n  end\r\n\r\n  # rule 5: recover or die based on probability \r\n  creatures!(1)
    do\r\n    next unless color == sick_color\r\n\r\n    if data[:sick_time] > 0\r\n
    \     data[:sick_time] -= 1 \r\n    else\r\n      coinflip ? set_color(healthy_color)
    : destroy\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nBecause it's the live interactions
    in this system that are complex and not its rules, you cannot easily predict the
    patterns that will emerge from this program by simply reading its source code.
    However, by repeatedly running the program and testing various assumptions you
    have about the system, you can rapidly gain an intuitive sense for the patterns
    that arise. In that sense, exploratory programming environments can have an effect
    similar to that of plotting a mathematical formula: although they can't give you
    a precise answer to your question, they can very quickly communicate the main
    points of a story.\r\n\r\n## Scenario III: Rabbits in a cabbage patch\r\n\r\nAs
    you may have already guessed, StarLogo's data model doesn't just give you creatures
    and patches, but it also supports interactions between the two. Because both the
    creatures and patches can encapsulate arbitrarily complex data, and because StarLogo
    provides a solid API for various kinds of common tasks, the richness of behavior
    that can be expressed through these interactions is mind boggling.\r\n\r\nThe
    full StarLogo environment can tackle problems like ant foraging behavior with
    ease, a problem that I labored with for weeks and spent two issues of Practicing
    Ruby on ([Issue 5.8](https://practicingruby.com/articles/92) and [Issue 5.9](https://practicingruby.com/articles/93)).
    However, the features I've ported from StarLogo into the Terrarium project are
    somewhat limited, so we'll tackle a more basic scenario that will still give you
    a sense of how creatures and patches can interact with one another.\r\n\r\nWe'll
    now take a stab at implementing a simple ecosystem in which hungry rabbits wander
    around doing what rabbits tend to do: eating, procreating, and dying. This is
    the sort of predator/prey modeling problem that you might find on a school math
    test, but we'll approach it informally rather than brushing up on our differential
    equations.\r\n\r\nHere are the rules that will get our ecosystem up and running:\r\n\r\n1.
    Create a cabbage patch by randomly coloring some patches green\r\n2. On each iteration
    of the simulation, give each patch a small chance to sprout cabbage, facilitating
    regrowth.\r\n3. Arrange a crowd of rabbits in the cabbage patch.\r\n4. Allow the
    rabbits to wander randomly around the cabbage patch\r\n5. Rabbits eat any cabbage
    they encounter. This sets the patch color back to black, and increases the energy
    of the rabbits.\r\n6. Rabbits gradually lose energy over time. If their energy
    is fully depleted, they die.\r\n7. Rabbits also breed (asexually!) when they have
    enough energy. The parent's energy is reduced, and then it produces an exact clone
    of itself at its current location.\r\n\r\nOnce set into action, these constaints
    give rise to the dynamic system you see in the animation below. To make sense
    of what's going on, ignore the rabbits and focus on the oscillating growing and
    shrinking of the cabbage patch:\r\n\r\n![](http://i.imgur.com/3iese1f.gif)\r\n\r\nWhat
    you're seeing happen here is a basic cycle that tends to proceed in the following
    fashion:\r\n\r\n* Whenever the rabbits have plenty of cabbage to eat, they breed,
    and their population numbers rise.\r\n\r\n* As the rabbit population rises, the
    cabbage gets eaten more rapidly, reducing the amount of total food available to
    the rabbits in the cabbage patch.\r\n\r\n* As food sources dwindle, rabbits tend
    to stop breeding and some also die of starvation, causing their population levels
    to drop.\r\n\r\n* A smaller rabbit population leads to slower cabbage consumption,
    which results in rapid regrowth and plenty of cabbage for the rabbits to eat.\r\n\r\n*
    This in turn leads the rabbits to stop dying from starvation and start breeding
    again, starting the cycle all over again.\r\n\r\nThe fact that we've reproduced
    this cycle is not a particularly profound result: you could have guessed it without
    ever bothering to create a simulation. However, if you treat the basic problem
    as a starting point and then continue your explorations from there, many more
    surprising results can be found. \r\n\r\nIn my casual experiments I found that
    the system is surprisingly tolerant to singular catastrophic events (such as killing
    off 90% of the rabbits or the cabbage), because the two populations naturally
    force each other into balance. However, very small changes to the rate of cabbage
    regrowth, or to the amount of energy the rabbits gain from eating the cabbage
    can have disasterous effects that lead to extinction. I found these patterns interesting,
    because they were opposite to my intuition. \r\n\r\nPerhaps a more significant
    point though is that I doubt I would have even thought to try out those ideas
    if I were working with a formal equation rather than a dynamic and lively visualization.
    Because I'm not a visually-oriented learner, this really surprised me!\r\n\r\nThe
    full source code for this scenario is shown below, and you're should skim it at
    least, but you don't need to get bogged down in the details unless you plan to
    play around with StarLogo or my Terrarium engine after you're done reading this
    article. If you're feeling a bit tired by now, you can skip right past it to the
    next section without losing too much.  \r\n\r\n```ruby\r\nTerrarium::Scenario.define
    do\r\n  cabbage_density    = 0.5 \r\n  regrowth_rate      = 0.02\r\n  initial_population
    = 200\r\n  initial_energy     = 8\r\n  food_energy        = 5\r\n  hatch_threshold
    \   = 10\r\n  hatched_energy     = 0.25\r\n\r\n  cabbage_color = :green\r\n  rabbit_color
    \ = :white\r\n  soil_color    = :black\r\n\r\n  # rule 1: create cabbage patch\r\n
    \ patches do \r\n    set_color soil_color\r\n    with_probability(cabbage_density)
    { set_color(cabbage_color) } \r\n  end\r\n\r\n  # rule 2: cabbage regrowth\r\n
    \ patches! do\r\n    with_probability(regrowth_rate) { set_color(cabbage_color)
    } \r\n  end\r\n\r\n  create_creatures(200)\r\n\r\n  # rule 3: arrange a crowd
    of rabbits\r\n  creatures do \r\n    lt rand(0..359)\r\n    fd rand(5..25)\r\n\r\n
    \   data[:energy] = initial_energy\r\n\r\n    set_color rabbit_color\r\n  end\r\n\r\n
    \ # rule 4: let the rabbits wander\r\n  creatures! { rt(rand(1...40)); lt(rand(1..40));
    fd(1) }\r\n  \r\n  # rule 5: rabbits eat any cabbage they encounter, gaining energy\r\n
    \ creatures! do \r\n    update_patch do |patch| \r\n      if patch.color == cabbage_color\r\n
    \       patch.set_color soil_color\r\n        data[:energy] += food_energy\r\n
    \     end\r\n    end\r\n  end\r\n  \r\n  # rule 6: the rabbits are always losing
    energy\r\n  creatures! { data[:energy] -= 1 }\r\n\r\n  # rule 7: when the rabbits
    run out of energy, they die\r\n  creatures! { destroy if data[:energy] < 1 }\r\n\r\n
    \ # rule 8: when rabbits have enough energy, they clone themselves\r\n  #         (but
    it costs them some energy)\r\n  creatures! do \r\n    if data[:energy] > hatch_threshold\r\n
    \     data[:energy] *= hatched_energy\r\n\r\n      hatch\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n##
    Exploratory programming as a first-class paradigm?\r\n\r\nEven though we've managed
    to pack a lot of interesting behavior into a small amount of code, the examples
    I've shown here barely scratch the surface of StarLogo and capabilities. While
    my Terrarium engine is nothing more than a poor man's implementation of a few
    of StarLogo's features, the full StarLogo language is elegantly designed and carefully
    thought out.\r\n\r\nBut the goal of this article was not to introduce you to a
    shiny piece of technological infrastucture, it was meant to get you thinking about
    a different kind of workflow than what we tend to use day to day.  Even through
    the smudged window I've had you look through, it should be clear to see that the
    style of programming used in StarLogo has several powerful benefits:\r\n\r\n1.
    Thoughts can be expressed directly\r\n2. Feedback is given continuously \r\n3.
    Failure comes at a very low cost\r\n4. The problem domain is well constrained\r\n5.
    Objects can be directly acted upon\r\n\r\nWhile most of the tools I use when I'm
    programming have at least some of these positive traits, it's rare to experience
    the effect of all of them simultaneously. However, a few positive examples do
    come \r\nto mind. In particular, the various web browser development tools (like
    Firebug or the tools that ship with Chrome) support this kind of workflow.\r\n\r\nWhen
    it comes to frontend web development tools, I've always been amazed at how much
    it is possible to incrementally evolve a design by tweaking various page elements
    until you're happy with them. I think that much of the effectiveness of this technique
    is due to the benefits listed above. Here is a specific example to illustrate
    that point:\r\n\r\n1. If you want to change a font size of a given block of text,
    it's as easy as clicking that text and editing a single attribute.\r\n\r\n2. You
    see the results immediately on your screen. \r\n\r\n3. If you don't like the results,
    you can easily revert your changes. And if you made a mistake when you were editing
    things, it should be immediately obvious based on what does (or doesn't) get displayed
    on the screen.\r\n\r\n4. Although the environment is very sophisticated, the scope
    is constrained enough where the available actions are fairly clear at any given
    point in time. \r\n\r\n5. Finally, because you are often looking at things within
    the scope of a single element that you are working with directly, you can use
    extremely localized thinking without harmful consequences.\r\n\r\nUnfortunately,
    I can't easily come up with similar examples when it comes to backend web frameworks.
    If you narrow the scope, similar workflows can be applied to very simple HTTP
    services running on Sinatra, but once you need anything more complex than that
    it becomes much too broad of a problem to solve.\r\n\r\nTo be fair, Rails has
    some elements baked into it that facilitate a certain amount of exploratory programming
    (the console, scaffolding, etc.). However, these features have always felt to
    me as if they were not taken nearly far enough, and that there is still room for
    a much higher level toolkit, even if it would only be useful for rapid prototyping.
    \r\n\r\nIn an ideal world, I would love to be able to describe a useful full-stack
    feature in a web application in a dozen lines or less, but I've never seen anything
    that gets me even close to that level of abstraction. Of course, web architecture
    is sufficiently obtuse to make this a genuinely hard problem to solve, so I'm
    not surprised that there isn't an obvious solution out there just yet.\r\n\r\nBut
    web programming (particularly general-purpose web programming) is really at a
    lower level than where this paradigm really could shine. It seems to me that there
    is nearly infinite possibility for what one might call \"domain-specific development
    environments\". For example, could we build programmable tools for book publishers
    that sit somewhere between a WYSIWYG editor and DocBook XML? Could we build drop-in
    management panels for business metrics that can be programmed at a high enough
    level that an analyst could use them with minimal help from their programming
    team? Is there hope that we can put these kinds of high-powered but easy-to-use
    tools into the hands of musicians, artists, teachers, and charity volunteers?\r\n\r\nPerhaps
    the best use of a general purpose programming language it to build domain-specific
    environments that help cross a bridge from low-level infrastructure to high-level
    ideas. But because this is all just a pie-in-the-sky dream that may never end
    up becoming a reality, I will let you be the judge! Please share your thoughts
    in the comments below.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
- :slug: implementing-an-http-file-server
  :title: Implementing a minimal HTTP server in Ruby
  :summary: Build just enough HTTP functionality from scratch to serve up static files.
    (w. Luke Francl)
  :published: 2013-07-02 00:00:00.000000000 Z
  :issue_number: '7.2'
  :volume: 7
  :body: "*This article was written by Luke Francl, a Ruby developer living in\r\nSan
    Francisco. He is a developer at [Swiftype](https://swiftype.com) where he\r\nworks
    on everything from web crawling to answering support requests.*\r\n\r\nImplementing
    a simpler version of a technology that you use every day can\r\nhelp you understand
    it better. In this article, we will apply this\r\ntechnique by building a simple
    HTTP server in Ruby.\r\n\r\nBy the time you're done reading, you will know how
    to serve files from your\r\ncomputer to a web browser with no dependencies other
    than a few standard\r\nlibraries that ship with Ruby. Although the server\r\nwe
    build will not be robust or anywhere near feature complete,\r\nit will allow you
    to look under the hood of one of the most fundamental\r\npieces of technology
    that we all use on a regular basis.\r\n\r\n## A (very) brief introduction to HTTP\r\n\r\nWe
    all use web applications daily and many of us build\r\nthem for a living, but
    much of our work is done far above the HTTP level.\r\nWe'll need come down from
    the clouds a bit in order to explore\r\nwhat happens at the protocol level when
    someone clicks a \r\nlink to *http://example.com/file.txt* in their web browser.
    \r\n\r\nThe following steps roughly cover the typical HTTP request/response lifecycle:\r\n\r\n1)
    The browser issues an HTTP request by opening a TCP socket connection to\r\n`example.com`
    on port 80. The server accepts the connection, opening a\r\nsocket for bi-directional
    communication.\r\n\r\n2) When the connection has been made, the HTTP client sends
    a HTTP request:\r\n\r\n```\r\nGET /file.txt HTTP/1.1\r\nUser-Agent: ExampleBrowser/1.0\r\nHost:
    example.com\r\nAccept: */*\r\n```\r\n\r\n3) The server then parses the request.
    The first line is the Request-Line which contains\r\nthe HTTP method (`GET`),
    Request-URI (`/file.txt`), and HTTP version (`1.1`).\r\nSubsequent lines are headers,
    which consists of key-value pairs delimited by `:`. \r\nAfter the headers is a
    blank line followed by an optional message body (not shown in\r\nthis example).\r\n\r\n4)
    Using the same connection, the server responds with the contents of the file:\r\n\r\n```\r\nHTTP/1.1
    200 OK\r\nContent-Type: text/plain\r\nContent-Length: 13\r\nConnection: close\r\n\r\nhello
    world\r\n```\r\n\r\n5) After finishing the response, the server closes the socket
    to terminate the connection.\r\n\r\nThe basic workflow shown above is one of HTTP's
    most simple use cases,\r\nbut it is also one of the most common interactions handled
    by web servers.\r\nLet's jump right into implementing it!\r\n\r\n## Writing the
    \"Hello World\" HTTP server\r\n\r\nTo begin, let's build the simplest thing that
    could possibly work: a web server\r\nthat always responds \"Hello World\" with
    HTTP 200 to any request. The following\r\ncode mostly follows the process outlined
    in the previous section, but is\r\ncommented line-by-line to help you understand
    its implementation details:\r\n\r\n```ruby\r\nrequire 'socket' # Provides TCPServer
    and TCPSocket classes\r\n\r\n# Initialize a TCPServer object that will listen\r\n#
    on localhost:2345 for incoming connections.\r\nserver = TCPServer.new('localhost',
    2345)\r\n\r\n# loop infinitely, processing one incoming\r\n# connection at a time.\r\nloop
    do\r\n\r\n  # Wait until a client connects, then return a TCPSocket\r\n  # that
    can be used in a similar fashion to other Ruby\r\n  # I/O objects. (In fact, TCPSocket
    is a subclass of IO.)\r\n  socket = server.accept\r\n\r\n  # Read the first line
    of the request (the Request-Line)\r\n  request = socket.gets\r\n\r\n  # Log the
    request to the console for debugging\r\n  STDERR.puts request\r\n\r\n  response
    = \"Hello World!\\n\"\r\n\r\n  # We need to include the Content-Type and Content-Length
    headers\r\n  # to let the client know the size and type of data\r\n  # contained
    in the response. Note that HTTP is whitespace\r\n  # sensitive, and expects each
    header line to end with CRLF (i.e. \"\\r\\n\")\r\n  socket.print \"HTTP/1.1 200
    OK\\r\\n\" +\r\n               \"Content-Type: text/plain\\r\\n\" +\r\n               \"Content-Length:
    #{response.bytesize}\\r\\n\" +\r\n               \"Connection: close\\r\\n\"\r\n\r\n
    \ # Print a blank line to separate the header from the response body,\r\n  # as
    required by the protocol.\r\n  socket.print \"\\r\\n\"\r\n\r\n  # Print the actual
    response body, which is just \"Hello World!\\n\"\r\n  socket.print response\r\n\r\n
    \ # Close the socket, terminating the connection\r\n  socket.close\r\nend\r\n```\r\nTo
    test your server, run this code and then try opening `http://localhost:2345/anything`\r\nin
    a browser. You should see the \"Hello world!\" message. Meanwhile, in the output
    for\r\nthe HTTP server, you should see the request being logged:\r\n\r\n```\r\nGET
    /anything HTTP/1.1\r\n```\r\n\r\nNext, open another shell and test it with `curl`:\r\n\r\n```\r\ncurl
    --verbose -XGET http://localhost:2345/anything\r\n```\r\n\r\nYou'll see the detailed
    request and response headers:\r\n\r\n```\r\n* About to connect() to localhost
    port 2345 (#0)\r\n*   Trying 127.0.0.1... connected\r\n* Connected to localhost
    (127.0.0.1) port 2345 (#0)\r\n> GET /anything HTTP/1.1\r\n> User-Agent: curl/7.19.7
    (universal-apple-darwin10.0) libcurl/7.19.7\r\n              OpenSSL/0.9.8r zlib/1.2.3\r\n>
    Host: localhost:2345\r\n> Accept: */*\r\n>\r\n< HTTP/1.1 200 OK\r\n< Content-Type:
    text/plain\r\n< Content-Length: 13\r\n< Connection: close\r\n<\r\nHello world!\r\n*
    Closing connection #0\r\n```\r\n\r\nCongratulations, you've written a simple HTTP
    server! Now we'll \r\nbuild a more useful one.\r\n\r\n## Serving files over HTTP\r\n\r\nWe're
    about to build a more realistic program that is capable of \r\nserving files over
    HTTP, rather than simply responding to any request\r\nwith \"Hello World\". In
    order to do that, we'll need to make a few \r\nchanges to the way our server works.\r\n\r\nFor
    each incoming request, we'll parse the `Request-URI` header and translate it into\r\na
    path to a file within the server's public folder. If we're able to find a match,
    we'll\r\nrespond with its contents, using the file's size to determine the `Content-Length`,\r\nand
    its extension to determine the `Content-Type`. If no matching file can be found,\r\nwe'll
    respond with a `404 Not Found` error status.\r\n\r\nMost of these changes are
    fairly straightforward to implement, but mapping the\r\n`Request-URI` to a path
    on the server's filesystem is a bit more complicated due\r\nto security issues.
    To simplify things a bit, let's assume for the moment that a\r\n`requested_file`
    function has been implemented for us already that can handle\r\nthis task safely.
    Then we could build a rudimentary HTTP file server in the following way:\r\n\r\n```ruby\r\nrequire
    'socket'\r\nrequire 'uri'\r\n\r\n# Files will be served from this directory\r\nWEB_ROOT
    = './public'\r\n\r\n# Map extensions to their content type\r\nCONTENT_TYPE_MAPPING
    = {\r\n  'html' => 'text/html',\r\n  'txt' => 'text/plain',\r\n  'png' => 'image/png',\r\n
    \ 'jpg' => 'image/jpeg'\r\n}\r\n\r\n# Treat as binary data if content type cannot
    be found\r\nDEFAULT_CONTENT_TYPE = 'application/octet-stream'\r\n\r\n# This helper
    function parses the extension of the\r\n# requested file and then looks up its
    content type.\r\n\r\ndef content_type(path)\r\n  ext = File.extname(path).split(\".\").last\r\n
    \ CONTENT_TYPE_MAPPING.fetch(ext, DEFAULT_CONTENT_TYPE)\r\nend\r\n\r\n# This helper
    function parses the Request-Line and\r\n# generates a path to a file on the server.\r\n\r\ndef
    requested_file(request_line)\r\n  # ... implementation details to be discussed
    later ...\r\nend\r\n\r\n# Except where noted below, the general approach of\r\n#
    handling requests and generating responses is\r\n# similar to that of the \"Hello
    World\" example\r\n# shown earlier.\r\n\r\nserver = TCPServer.new('localhost',
    2345)\r\n\r\nloop do\r\n  socket       = server.accept\r\n  request_line = socket.gets\r\n\r\n
    \ STDERR.puts request_line\r\n\r\n  path = requested_file(request_line)\r\n\r\n
    \ # Make sure the file exists and is not a directory\r\n  # before attempting
    to open it.\r\n  if File.exist?(path) && !File.directory?(path)\r\n    File.open(path,
    \"rb\") do |file|\r\n      socket.print \"HTTP/1.1 200 OK\\r\\n\" +\r\n                   \"Content-Type:
    #{content_type(file)}\\r\\n\" +\r\n                   \"Content-Length: #{file.size}\\r\\n\"
    +\r\n                   \"Connection: close\\r\\n\"\r\n\r\n      socket.print
    \"\\r\\n\"\r\n\r\n      # write the contents of the file to the socket\r\n      IO.copy_stream(file,
    socket)\r\n    end\r\n  else\r\n    message = \"File not found\\n\"\r\n\r\n    #
    respond with a 404 error code to indicate the file does not exist\r\n    socket.print
    \"HTTP/1.1 404 Not Found\\r\\n\" +\r\n                 \"Content-Type: text/plain\\r\\n\"
    +\r\n                 \"Content-Length: #{message.size}\\r\\n\" +\r\n                 \"Connection:
    close\\r\\n\"\r\n\r\n    socket.print \"\\r\\n\"\r\n\r\n    socket.print message\r\n
    \ end\r\n\r\n  socket.close\r\nend\r\n```\r\n\r\nAlthough there is a lot more
    code here than what we saw in the\r\n\"Hello World\" example, most of it is routine
    file manipulation\r\nsimilar to the kind we'd encounter in everyday code. Now
    there\r\nis only one more feature left to implement before we can serve\r\nfiles
    over HTTP: the `requested_file` method.\r\n\r\n## Safely converting a URI into
    a file path\r\n\r\nPractically speaking, mapping the Request-Line to a file on
    the \r\nserver's filesystem is easy: you extract the Request-URI, scrub \r\nout
    any parameters and URI-encoding, and then finally turn that \r\ninto a path to
    a file in the server's public folder:\r\n\r\n```ruby\r\n# Takes a request line
    (e.g. \"GET /path?foo=bar HTTP/1.1\")\r\n# and extracts the path from it, scrubbing
    out parameters\r\n# and unescaping URI-encoding.\r\n#\r\n# This cleaned up path
    (e.g. \"/path\") is then converted into\r\n# a relative path to a file in the
    server's public folder\r\n# by joining it with the WEB_ROOT.\r\ndef requested_file(request_line)\r\n
    \ request_uri  = request_line.split(\" \")[1]\r\n  path         = URI.unescape(URI(request_uri).path)\r\n\r\n
    \ File.join(WEB_ROOT, path)\r\nend\r\n```\r\n\r\nHowever, this implementation
    has a very bad security problem that has affected\r\nmany, many web servers and
    CGI scripts over the years: the server will happily\r\nserve up any file, even
    if it's outside the `WEB_ROOT`.\r\n\r\nConsider a request like this:\r\n\r\n```\r\nGET
    /../../../../etc/passwd HTTP/1.1\r\n```\r\n\r\nOn my system, when `File.join`
    is called on this path, the \"..\" path components\r\nwill cause it escape the
    `WEB_ROOT` directory and serve the `/etc/passwd` file.\r\nYikes! We'll need to
    sanitize the path before use in order to prevent this\r\nkind of problem.\r\n\r\n>
    **Note:** If you want to try to reproduce this issue on your own machine,\r\nyou
    may need to use a low level tool like *curl* to demonstrate it. Some browsers
    change the path to remove the \"..\" before sending a request to the server.\r\n\r\nBecause
    security code is notoriously difficult to get right, we will borrow our\r\nimplementation
    from [Rack::File](https://github.com/rack/rack/blob/master/lib/rack/file.rb).\r\nThe
    approach shown below was actually added to `Rack::File` in response to a [similar\r\nsecurity
    vulnerability](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-0262)
    that\r\nwas disclosed in early 2013:\r\n\r\n```ruby\r\ndef requested_file(request_line)\r\n
    \ request_uri  = request_line.split(\" \")[1]\r\n  path         = URI.unescape(URI(request_uri).path)\r\n\r\n
    \ clean = []\r\n\r\n  # Split the path into components\r\n  parts = path.split(\"/\")\r\n\r\n
    \ parts.each do |part|\r\n    # skip any empty or current directory (\".\") path
    components\r\n    next if part.empty? || part == '.'\r\n    # If the path component
    goes up one directory level (\"..\"),\r\n    # remove the last clean component.\r\n
    \   # Otherwise, add the component to the Array of clean components\r\n    part
    == '..' ? clean.pop : clean << part\r\n  end\r\n\r\n  # return the web root joined
    to the clean path\r\n  File.join(WEB_ROOT, *clean)\r\nend\r\n```\r\n\r\nTo test
    this implementation (and finally see your file server in action), \r\nreplace
    the `requested_file` stub in the example from the previous section \r\nwith the
    implementation shown above, and then create an `index.html` file \r\nin a `public/`
    folder that is contained within the same directory as your\r\nserver script. Upon
    running the script, you should be able to \r\nvisit `http://localhost:2345/index.html`
    but NOT be able to reach any\r\nfiles outside of the `public/` folder.\r\n\r\n##
    Serving up index.html implicitly\r\n\r\nIf you visit `http://localhost:2345` in
    your web browser, you'll see a 404 Not\r\nFound response, even though you've created
    an index.html file. Most real web\r\nservers will serve an index file when the
    client requests a directory. Let's\r\nimplement that.\r\n\r\nThis change is more
    simple than it seems, and can be accomplished by adding\r\na single line of code
    to our server script:\r\n\r\n```diff\r\n# ...\r\npath = requested_file(request_line)\r\n\r\n+
    path = File.join(path, 'index.html') if File.directory?(path)\r\n\r\nif File.exist?(path)
    && !File.directory?(path)\r\n# ...\r\n```\r\n\r\nDoing so will cause any path
    that refers to a directory to have \"/index.html\" appended to\r\nthe end of it.
    This way, `/` becomes `/index.html`, and `/path/to/dir` becomes\r\n`path/to/dir/index.html`.\r\n\r\nPerhaps
    surprisingly, the validations in our response code do not need\r\nto be changed.
    Let's recall what they look like and then examine why\r\nthat's the case:\r\n\r\n```ruby\r\nif
    File.exist?(path) && !File.directory?(path)\r\n  # serve up the file...\r\nelse\r\n
    \ # respond with a 404\r\nend\r\n```\r\n\r\nSuppose a request is received for
    `/somedir`. That request will automatically be converted by our server into `/somedir/index.html`.
    If the index.html exists within `/somedir`, then it will be served up without
    any problems. However, if `/somedir` does not contain an `index.html` file, the
    `File.exist?` check will fail, causing the server to respond with a 404 error
    code. This is exactly what we want!\r\n\r\nIt may be tempting to think that this
    small change would make it possible to remove the `File.directory?` check, and
    in normal circumstances you might be able to safely do with it. However, because
    leaving it in prevents an error condition in the edge case where someone attempts
    to serve up a directory named `index.html`, we've decided to leave that validation
    as it is.\r\n\r\nWith this small improvement, our file server is now pretty much
    working as we'd expect it to. If you want to play with it some more, you can grab
    the [complete source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/tree/master/v7/002)
    from GitHub.\r\n\r\n## Where to go from here\r\n\r\nIn this article, we reviewed
    how HTTP works, then built a simple web\r\nserver that can serve up files from
    a directory. We've also examined\r\none of the most common security problems with
    web applications and\r\nfixed it. If you've made it this far, congratulations!
    That's a lot\r\nto learn in one day.\r\n\r\nHowever, it's obvious that the server
    we've built is extremely limited.\r\nIf you want to continue in your studies,
    here are a few recommendations\r\nfor how to go about improving the server:\r\n\r\n*
    According to the HTTP 1.1 specification, a server must minimally\r\nrespond to
    GET and HEAD to be compliant. Implement the HEAD response.\r\n* Add error handling
    that returns a 500 response to the client\r\nif something goes wrong with the
    request.\r\n* Make the web root directory and port configurable.\r\n* Add support
    for POST requests. You could implement CGI by executing\r\na script when it matches
    the path, or implement \r\nthe [Rack spec](http://rack.rubyforge.org/doc/SPEC.html)
    to\r\nlet the server serve Rack apps with `call`.\r\n* Reimplement the request
    loop using [GServer](http://www.ruby-doc.org/stdlib-2.0/libdoc/gserver/rdoc/GServer.html)\r\n(Ruby's
    generic threaded server) to handle multiple connections.\r\n\r\nPlease do share
    your experiences and code if you decide to try any of\r\nthese ideas, or if you
    come up with some improvement ideas of your own.\r\nHappy hacking!\r\n\r\n*We'd
    like to thank Eric Hodel, Magnus Holm, Piotr Szotkowski, and \r\nMathias Lafeldt
    for reviewing this article and providing feedback \r\nbefore we published it.*\r\n\r\n>
    NOTE: If you'd like to learn more about this topic, consider doing the Practicing
    Ruby self-guided course on [Streams, Files, and Sockets](https://practicingruby.com/articles/study-guide-1?u=dc2ab0f9bb).
    You've already completed one of its reading exercises by working through this
    article!\r\n\r\n> SEE ALSO: A [similar HTTP server](https://github.com/emilyhorsman/practicing-ruby-examples/blob/v7_002python/v7/002python27/http_server.py)
    written in Python, contributed by [Emily Horsman](http://emilyhorsman.com/)."
- :slug: exploratory-data-analysis
  :title: Using data to explore questions about our lives
  :summary: Aggregate and analyze 500+ data points from a SMS-based mood study using
    R and Ruby. (w. Jia Wu)
  :published: 2013-08-06 00:00:00.000000000 Z
  :issue_number: '7.3'
  :volume: 7
  :body: "> This issue was a collaboration with my wife, Jia Wu. Jia is an associate
    scientist at the Yale Child Study Center, where she spends a good portion of her
    time analyzing brainwave data from various EEG experiments. Although this article
    focuses on very basic concepts, her background in statistical programming was
    very helpful whenever I got stuck on something. That said, if you find any mistakes
    in this article, you can blame me, not her.\r\n\r\nOne human quirk that fascinates
    me is the huge disparity between our moment-to-moment experiences and our perception
    \ of past events. This is something that I've read about a lot in pop-psych books,
    and also is one of the main reasons that I practice insight meditation. However,
    it wasn't until I read Daniel Kahneman's book \"Thinking, Fast and Slow\" that
    I realized just how strongly separated our *experiencing self* is from our *remembering
    self*. \r\n\r\nIn both Kahneman's book and [his talk at TED\r\n2010](http://www.ted.com/talks/daniel_kahneman_the_riddle_of_experience_vs_memory.html),\r\nhe
    uses a striking example comparing two colonoscopy patients who recorded their\r\npain
    levels periodically throughout their procedure. Although modern sedation\r\ntechniques
    have made this a much less painful procedure, no anethesia was used\r\nduring
    this study, which pretty much guaranteed that both patients would\r\nbe in for
    an unpleasant experience.\r\n\r\nFrom the data Kahneman shows, the first patient
    had a much shorter procedure \r\nand reported much less overall pain than the
    \r\nsecond patient. However, when asked later about how painful their colonoscopy
    \r\nwere, the first patient remembered it to be much more unpleasant than \r\nthe
    second patient did. How can that be?\r\n\r\nAs it turns out, how an event ends
    has a lot to do with how we will perceive the overall experience when we recall
    it down the line. In the colonoscopy study, the first patient reported a high
    pain spike immediately before the end of their procedure, where the second patient
    had pain that was gradually reduced before the procedure ended. This is the explanation
    Kahneman offers as to why the first patient remembered their colonoscopy to be
    far worse of an experience than the second patient remembered it to be. \r\n\r\nThis
    disparity between experience and memory isn't just a one-off observation -- it's
    a robust finding, and it is has been repeated in many different contexts. The
    lesson to be learned here is that we cannot trust our remembering mind to give
    a faithful account of the things we experience day-to-day. The unfortunate cost
    that comes along with this reality is that we're not as good about making judgements
    about our own well being as we could be if we did not have this cognitive limitation.\r\n\r\nI
    thought about this idea for a long time, particularly as it related to my day-to-day
    happiness. Like most software developers (and probably *all* writers), my work
    has a lot of highs and lows to it -- so my gut feeling was that my days could
    be neatly divided into good days and bad days. But because Kahneman had taught
    me that my intuitions couldn't be trusted, I eventually set out to turn this psychological
    problem into an engineering problem by recording and analyzing my own mood ratings
    over time.\r\n\r\n## Designing an informal experiment\r\n\r\nI wanted my mood
    study to be rigorous enough to be meaningful on a personal level, but I had no
    intentions of conducting a tightly controlled scientific study. What I really
    wanted was to build a simple breadcrumb trail of mood ratings so that I didn't
    need to rely on memory alone to gauge my overall sense of well-being over time.\r\n\r\nAfter
    thinking through various data collection strategies, I eventually settled on SMS
    messages as my delivery mechanism. The main reason for going this route was that
    I needed a polling device that could follow me everywhere, but one that wouldn't
    badly disrupt whatever I was currently doing. Because I use a terrible phone that
    pretty much can only be used for phone calls and texting, this approach made it
    possible for me to regularly update my mood rating without getting sucked into
    all the things that would distract me on a computer.\r\n\r\nTo make data entry
    easy, I used a simple numerical scale for tracking my mood:\r\n\r\n* Very Happy
    (9): No desire to change anything about my current experience.\r\n* Happy (7-8):
    \ Pleased by the current experience, but may still be slightly tired, distracted,
    or anxious.\r\n* Neutral (5-6): Not bothered by my current experience, but not
    necessarily enjoying it.\r\n* Unhappy (3-4): My negative feelings are getting
    in the way of me doing what I want to do.\r\n* Very Unhappy (1-2): Unable to do
    what I want because I am overwhelmed with negative feelings.\r\n\r\nOriginally
    I had intended to collect these mood updates over the course of several weeks
    without any specific questions in mind. However, Jia convinced me that having
    at least a general sense of what questions I was interested in would help me organize
    the study better -- so I started to think about what I might be able to observe
    from this seemingly trivial dataset.\r\n\r\nAfter a short brainstorming session,
    we settled on the following general questions:\r\n\r\n* How stable is my mood
    in general? In other words, how much variance is there over a given time period?\r\n*
    Are there any patterns in the high and low points that I experience each day?
    How far apart are the two?\r\n* Does day of the week and time of day have any
    effect on my mood?\r\n\r\nThese questions helped me ensure that the data I intended
    to collect was sufficient. Once we confirmed that was the case, we were ready
    to start writing some code!\r\n\r\n## Building the necessary tools\r\n\r\nTo run
    this study, I used two small toolchains: one for data collection, and one for
    reporting.\r\n\r\nThe job of the data collection toolchain was primarily to deal
    with sending and receiving text messages at randomized intervals. It stored my
    responses into database records similar to what you see below:\r\n\r\n```\r\n[{:id=>485,
    :message=>\"8\", :recorded_at=>1375470054},\r\n {:id=>484, :message=>\"8\", :recorded_at=>1375465032},\r\n
    {:id=>483, :message=>\"8\", :recorded_at=>1375457397},\r\n {:id=>482, :message=>\"9\",
    :recorded_at=>1375450750},\r\n {:id=>481, :message=>\"8\", :recorded_at=>1375411347},
    ...]\r\n```\r\n\r\nTo support this workflow, I relied almost entirely on external
    services, including Twilio and Heroku. As a result, the whole data collection
    toolchain I built consisted of around 80 lines of code spread across two simple
    [rake tasks](https://github.com/sandal/dwbh/blob/pr-7.3/Rakefile) and a small
    Sinatra-based [web service](https://github.com/sandal/dwbh/blob/pr-7.3/dwbh.rb).
    Here's the basic storyline that describes how these two little programs work:\r\n\r\n1.
    Every ten minutes between 8:00am and 11:00pm each day, the randomizer in the `app:remind`
    task gets run. It has a 1:6 chance of triggering a mood update reminder.\r\n\r\n2.
    Whenever the randomizer sends a reminder, it does so by hitting the `/send-reminder`
    route on my web service, which causes Twilio to deliver a SMS message to my phone.\r\n\r\n3.
    I respond to those messages with a mood rating. This causes Twilio to fire a webhook
    that hits the `/record-mood` route on the Sinatra app with the message data as
    GET parameters. The response data along with a timestamp are then stored in a
    database for later processing.\r\n\r\n4. Some time later, the reporting toolchain
    will hit the `/mood-logs.csv` route to download a dump of the whole dataset, which
    includes the raw data shown above along with a few other computed fields that
    make reporting easier.\r\n\r\nAfter a bit of hollywood magic involving a menagerie
    of R scripts, some more rake tasks, and a bit of Prawn-based PDF generation code,
    the reporting toolchain ends up spitting out a [two-page PDF report](http://notes.practicingruby.com/docs/7.3-mood-report.pdf)
    that looks like what you see below:\r\n\r\n[![](http://i.imgur.com/Ersv9fw.png)](http://notes.practicingruby.com/docs/7.3-mood-report.pdf)\r\n\r\nWe'll
    be discussing some of the details about how the various graphs get generated and
    the challenges involved in implementing them later on in this article, but if
    you want to get a sense of what the Ruby glue code looks in the reporting toolchain,
    I'd recommend looking at its [Rakefile](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/Rakefile).
    The tasks it provides allow me to type `rake generate-report` in a console and
    cause the following chain of events to happen:\r\n\r\n1. The latest mood data
    get downloaded from the Sinatra app in CSV format.\r\n\r\n2. All of the R-based
    graphing scripts are run, outputting a bunch of image files.\r\n\r\n3. A PDF is
    generated to cleanly present those images in a single document.\r\n\r\n4. The
    CSV data and image files are then be deleted, because they're no longer needed.\r\n\r\nBetween
    this reporting code and the data aggregation toolchain, I ended up with a system
    that has been very easy to work with for the many weeks that I have been running
    this study. The whole user experience boils down to pressing a couple buttons
    on my phone when I'm prompted to do so, and then typing a single command to generate
    reports whenever I want to take a look at them.\r\n\r\nAt a first glance, the
    way this system is implemented may look a bit like its hung together with shoestrings
    and glue, but the very loose coupling between its components has made it easy
    to both work on individual pieces in isolation, and to make significant changes
    without a ton of rework. It seems like the [worse is better](http://en.wikipedia.org/wiki/Worse_is_better)
    mantra applies well to this sort of project.\r\n\r\nI'd be happy to discuss the
    design of these two toolchains with you once you've finished this article, but
    for now let's look at what all those graphs are saying about my mood.\r\n\r\n##
    Analyzing the results\r\n\r\nThe full report for my mood study consists of four
    different graphs generated via the R stats language, each of which gives us a
    different way of looking at the data:\r\n\r\n* Figure 1 provides a view of the
    average mood ratings across the whole time period\r\n* Figure 2 tracks the daily
    minimum and maximums for the whole time period.\r\n* Figure 3 shows the average
    mood rating and variance broken out by day of week\r\n* Figure 4 plots the distribution
    of the different mood ratings at various times of day.\r\n\r\nThe order above
    is the same as that of the PDF report, and it is essentially sorted by the largest
    time scales down to the shortest ones. Since that is a fairly natural way to look
    at this data, we'll discuss it in the same order in this article.\r\n\r\n---\r\n\r\n**Figure
    1 ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/moving-summary.R)):**\r\n\r\n![Summary](http://i.imgur.com/KtdTzkI.jpg)\r\n\r\nI
    knew as soon as I started working on this study that I'd want to somehow capture
    the general trend of the entire data series, but I didn't anticipate how noisy
    it would be to [plot nearly 500 data points](http://i.imgur.com/NlIlgMI.png),
    many of which were too close together to visually distinguish from one another.
    To lessen the noise, I decided to plot a moving average instead of the individual
    ratings over time, which is what you see in **Figure 1** above.\r\n\r\nIt's important
    to understand the tradeoffs here: by smoothing out the data, I lost the ability
    to see what the individual ratings were at any given time. However, I gained the
    ability to easily discern the following bits of useful information:\r\n\r\n* How
    my experiences over a period of a couple days compare to the global average (green
    horizontal line), and to the global standard deviation (gray horizontal lines).
    This information could tell me whether my day-to-day experience has been improving
    or getting worse over time, and also how stable the swings in my mood have been
    recently compared to what might be considered \"typical\" for me across a large
    time span.\r\n\r\n* Whether my recent mood updates indicated that my mood was
    trending upward or downward, and roughly how long I could expect that to last.\r\n\r\nWithout
    rigorous statistical analysis and a far less corruptable means of studying myself,
    these bits of information could never truly predict the future or even be used
    as the primary basis for decision making. However, the extra information has been
    helping me put my mind in a historical perspective that isn't purely based on
    my remembered experiences, and that alone has turned out to be extremely useful
    to me.\r\n\r\n> **Implementation notes ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/moving-summary.R)):**\r\n>\r\n>
    I chose to use an exponentially-smoothed weighted average here, mostly because
    I wanted to see the trend line change direction as quickly as possible whenever
    new points of data hinted that my mood was getting better or worse over time.
    There are lots of different techniques for doing weighted averages, and this one
    is actually a little more complicated than some of the other options out there.
    If I had to implement the computations myself I may have chosen a more simple
    method. But since an exponential moving average function already existed in the
    [TTR package](http://rss.acs.unt.edu/Rdoc/library/TTR/html/MovingAverages.html),
    it didn't really cost me any extra effort to model things this way.\r\n\r\n>I
    had first seen this technique used in [The Hacker's Diet](http://www.fourmilab.ch/hackdiet/www/subsection1_2_4_0_4.html#SECTION0240400000000000000),
    where it proved to be a useful means of cancelling out the noise of daily weight
    fluctuations so that you could see if you were actually gaining or losing weight.
    I was hoping it would have the same effect for me with my mood monitoring, and
    so far it has worked as well as I expected it would.\r\n\r\n>\r\n>It's also worth
    noting that in this graph, the curve represents something close to a continous
    time scale. To accomplish this, I converted the UNIX timestamps into fractional
    days from the moment the study had started. It's not perfect, but it has the neat
    effect of making visible changes to the graph after even a single new data point
    has been recorded.\r\n\r\n---\r\n\r\n**Figure 2 ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/daily-min-max.R)):**\r\n\r\n\r\n![Min
    Max](http://i.imgur.com/hv9X1vA.jpg)\r\n\r\nIn a purely statistical sense, the
    highest and lowest values reported for each day might not be especially relevant.
    However, the nature of this particular study made me feel it was important to
    track them. After all, even if the \"average\" mood for two days were both around
    7, a day where the lowest mood rating was a 1 will certainly be different sort
    of day than one where the lowest rating was a 5! For this reason, **Figure 2**
    shows the extreme high and low for each day in the study. This information is
    useful for the following purposes:\r\n\r\n* Determining what my daily peak experiences
    are like on average. For example, we can see from this data that there was only
    one day where I didn't report at least a single rating of 7 or higher, and that
    most days my high point was either an 8 or 9. \r\n\r\n* Determining what my daily
    low points are like on average. Reading the data shown above, we can see that
    there were only three days in the entire study that I reported a low rating of
    1, but that about one in five days had a low rating of 4 or less. \r\n\r\n* Visualizing
    the range between high and low points on a daily basis. This can be seen by looking
    at the space between the two lines: the smaller the distance, the smaller the
    range of the mood swing for that day.\r\n\r\nA somewhat obvious limitation of
    this visualization is that the range of moods recorded in a day do not necessarily
    reflect the range of moods actually experienced throughout that day. In most of
    the other ways I've sliced up the dataset, we can hope that averaging will smooth
    out some of the ill effects of missing information, but this view in particular
    can be easily corrupted by a single \"missed event\" per day. The key point here
    is that **Figure 2** can only be viewed as a rough sketch of the overall trend,
    and not a precise picture of day-to-day experience.\r\n\r\n> **Implementation
    notes ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/daily-min-max.R)):**\r\n>\r\n>
    This was an extremely straightforward graph to produce using standard R functions,
    so there isn't too much to discuss about it. However, it's worth pointing out
    for folks who are unfamiliar with R that the support for data aggregation built
    into the language is excellent. Here is the code that takes the raw mood log entries
    and rolls them up by daily minimum and maximum:\r\n>\r\n> `data_max <- aggregate(rating
    ~ day, data, max)`\r\n>\r\n> `data_min <- aggregate(rating ~ day, data, min)`\r\n>\r\n>
    Because R is such a special-purpose language, it includes many neat data manipulation
    features similar to this one.\r\n\r\n---\r\n\r\n**Figure 3 ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/day-of-week.R)):**\r\n\r\n\r\n![Day
    of week](http://i.imgur.com/yTSuSLW.jpg)\r\n\r\nThis visualization shows the mean
    and standard deviation for all mood updates broken out by day of week. Looking
    at my mood data in this way provides the following information:\r\n\r\n* Whether
    or not certain days of the week have better mood ratings on average than others.\r\n*
    Whether or not certain days of the week have more consistent mood ratings than
    others.\r\n* What the general ups-and-downs look like in a typical week in my
    life\r\n\r\nIf you look at the data points shown in **Figure 3** above, you'll
    see that the high points (Monday and Friday) stand out noticeably from the low
    points (Wednesday and Saturday). However, to see whether that difference is significant
    or not, we need to be confident that what we're observing isn't simply a result
    of random fluctuations and noise. This is where some basical statistical tests
    are needed.\r\n\r\nTo test for difference in the averages between days, we ran
    a one-way ANOVA test, and then did a pairwise test with FDR correction. Based
    on these tests we were able to show a significant difference (p < 0.01) between
    Monday+Wednesday, Monday+Saturday, and Friday+Saturday. The difference between
    Wednesday+Friday was not significant, but was close (p = 0.0547). I don't want
    to get into a long and distracting stats tangent here, but if you are curious
    about what the raw results of the computations ended up looking like, take a look
    at [this gist](https://gist.github.com/sandal/6147469).\r\n\r\n> **Implementation
    notes ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/day-of-week.R)):**\r\n\r\n>
    An annoying thing about R is that despite having very powerful graphing functionality
    built into the language, it does not have a standard feature for drawing error
    bars. We use a small [helper function](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/helpers.R#L2-L5)
    to handle this work, which is based on code we found in [this blog post](http://bmscblog.wordpress.com/2013/01/23/error-bars-with-r
    ).\r\n\r\n> Apart from the errorbars issue and the calls to various statistical
    reporting functions, this code is otherwise functionally similar to what is used
    to generate **Figure 2**.\r\n\r\n---\r\n\r\n**Figure 4 ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/frequency.R)):**\r\n\r\n\r\n![Frequency](http://i.imgur.com/cbJxa8K.png)\r\n\r\nThe
    final view of the data shows the distribution of mood ratings broken out by time
    of day. Because the number of mood ratings recorded in each time period weren't
    evenly distributed, I decided to plot the frequency of the mood rating values
    by percentage rather than total count for each. Presenting the data this way allows
    the five individual graphs to be directly compared to one another, because it
    ensures that they all use the same scale.\r\n\r\nWhenever I look at this figure,
    it provides me with the following information:\r\n\r\n* How common various rating
    values are, broken out by time of day.\r\n* How stable my mood is at a given time
    of day\r\n* What parts of the day are more or less enjoyable than others on average\r\n\r\nThe
    most striking pattern I saw from the data shown above was that the percentage
    of negative and negative-leaning ratings gradually increased throughout the day,
    up until 8pm, and then they rapidly dropped back down to similar levels as the
    early morning. In the 8am-11am time period, mood ratings of five or under account
    for about 7% of the overall distribution, but in the 5pm to 8pm slot, they account
    for about 20% of the ratings in that time period. Finally, the whole thing falls
    off a cliff in the 8pm-11pm slot and the ratings of five or lower drop back down
    to under 7%. It will be interesting to see whether or not this pattern holds up
    over time.\r\n\r\n> **Implementation notes ([view source code](https://github.com/elm-city-craftworks/practicing-ruby-examples/blob/pr-7.3/v7/003/frequency.R)):**\r\n\r\n>
    Building this particular visualization turned out to be more complicated than
    I had hoped for it to be. It may be simply due to my relative inexperience with
    R, but I found the `hist()` function to be cumbersome to work with due to a bunch
    of awkward defaults. For example, the default settings caused the mood ratings
    of 1 and 2 to be grouped together, for reasons I still only vaguely understand.
    Also, the way that I implemented grouping by time period can probably be improved
    greatly.\r\n\r\n> Feedback on how to clean up this code is welcome!\r\n\r\n##
    Mapping a story to the data\r\n\r\nBecause this was a very personal study, and
    because the data itself has very low scientific validity, I shouldn't embellish
    the patterns I observed with wild guesses about their root causes. However, I
    can't resist, so here are some terrible narrations for you to enjoy!\r\n\r\n*I
    learned that although genuine bad days are actually somewhat rare in my life,
    when they're bad, they can be really bad:*\r\n\r\n![](http://i.imgur.com/j0p6Nie.png)\r\n\r\n*I
    learned that I probably need to get better at relaxing during my days off:* \r\n\r\n![](http://i.imgur.com/ktCRWsC.png)\r\n\r\n*I
    learned that like most people, as I get tired it's easier for me to get into a
    bad mood, and that rest helps recharge my batteries:*\r\n\r\n![](http://i.imgur.com/F3nfsHf.gif)\r\n\r\nAlthough
    these lessons may not be especially profound, it is fun to see even rudimentary
    evidence for them in the data I collected. If I keep doing this study, I can use
    these observations to try out some different things in the hopes of optimizing
    my day-to-day sense of well being.\r\n\r\n## Reflections\r\n\r\nGiven that this
    article started with a story about a colonoscopy and ended with an animated GIF,
    I think it's best to leave it up to you to draw your own conclusions about what
    you can take away from it. But I would definitely love to hear your thoughts on
    any part of this project, so please do share them!\r\n"
- :slug: improving-legacy-systems
  :title: Making incremental improvements to legacy systems
  :summary: Experience the challenge of overhauling one of Practicing Ruby's oldest
    features. (w. Jordan Byron)
  :published: 2013-09-05 00:00:00.000000000 Z
  :issue_number: '7.4'
  :volume: 7
  :body: "When you look at this photograph of highway construction, what do you see?\r\n\r\n![](http://i.imgur.com/eej11xZ.jpg)\r\n\r\nIf
    your answer was \"ugly urban decay\", then you are absolutely right! But because
    this construction project is only a few miles away from my house, I can tell you
    a few things about it that reveal a far more interesting story:\r\n\r\n* On the
    far left side of the photo, you can see the first half of a newly constructed
    suspension bridge. At the time this picture was taken, it was serving five lanes
    of northbound traffic.\r\n\r\n* Directly next to that bridge, cars are driving
    southbound on what was formerly the northbound side of our old bridge, serving
    3 lanes of traffic.\r\n\r\n* Dominating the rest of the photograph is the mostly
    deconstructed southbound side of our old bridge, a result of several months of
    active work.\r\n\r\nSo with those points in mind, what you are looking at here
    is an *incremental improvement* to a critical traffic bottleneck along the main
    route between New York City and Boston. This work was accomplished with hardly
    any service interruptions, despite the incredibly tight constraints on the project.
    This is legacy systems work at the highest level, and there is much we can learn
    from it that applies equally well to code as it does to concrete.\r\n\r\n## Case
    study: Improving one of Practicing Ruby's oldest features\r\n\r\nNow that we've
    set the scene with a colorful metaphor, it is time to see how these ideas can
    influence the way we work on software projects. To do that, I will walk you through
    a major change we made to practicingruby.com that involved a fair amount of legacy
    coding headaches. You will definitely see some ugly code along the way, but hopefully
    a bit of cleverness will shine through as well.\r\n\r\nThe improvement that we
    will discuss is a complete overhaul of Practicing Ruby's content sharing features.
    Although I've encouraged our readers to share our articles openly since our earliest
    days, several awkward implementation details made this a confusing process:\r\n\r\n*
    You couldn't just copy-paste links to articles. You needed to explictly click
    a share button that would generate a public share link for you.\r\n\r\n* If you
    did copy-paste an internal link from the website rather than explicitly generating
    a share link, those who clicked on that link would be immediately asked for registration
    information without warning. This behavior was a side-effect of how we did authorization
    and not an intentional \"feature\", but it was super annoying to folks who encountered
    it.\r\n\r\n* If you visited a public share link while logged in, you'd see the
    guest view rather than the subscriber view, and you'd need to click a \"log in\"
    button to see the comments, navbar, etc.\r\n\r\n* Both internal paths and share
    paths were completely opaque (e.g. \"articles/101\" and \"/articles/shared/zmkztdzucsgv\"),
    making it hard to know what a URL pointed to without\r\nvisiting it.\r\n \r\nDespite
    these flaws, subscribers did use Practicing Ruby's article sharing mechanism.
    They also made use of the feature in ways we didn't anticipate -- for example,
    it became the standard workaround for using Instapaper to read our content offline.
    As time went on, we used this feature for internal needs as well, whether it was
    to give away free samples, or to release old content to the public. To make a
    long story short, one of our most awkward features eventually also became one
    of the most important.\r\n\r\nWe avoided changing this system for quite a long
    while because we always had something else to work on that seemed more urgent.
    But after enough time had passed, we decided to pay down our debts. In particular,
    we wanted to make the following changes:\r\n\r\n* We wanted to switch to subscriber-based
    share tokens rather than generating a new share token for each and every article.
    As long as a token was associated with an active subscriber, it could then be
    used to view any of our articles.\r\n\r\n* We wanted to clean up and unify our
    URL scheme. Rather than having internal path like \"/articles/101\" and share
    path like \"/articles/shared/zmkztdzucsgv\", we would have a single path for both
    purposes that looked like this:\r\n\r\n```\r\n/articles/improving-legacy-systems?u=dc2ab0f9bb\r\n```\r\n\r\n*
    We wanted to make sure to be smart about authorization. Guests who visited a link
    with a valid share key would always see the \"guest view\" of that article, and
    logged in subscribers would always see the \"subscriber view\". If a key was invalid
    or missing, the guest would be explicitly told that the page was protected, rather
    than dropped into our registration process without warning.\r\n\r\n* We wanted
    to make sure to make our links easy to share by copy-paste, whether it was from
    anywhere within our web interface, from the browser location bar, or even in the
    emails we send to subscribers. This meant making sure we put your share token
    pretty much anywhere you might click on an article link.\r\n\r\nLaying out this
    set of requirements helped us figure out where the destination was, but we knew
    intuitively that the path to get there would be a long and winding road. The system
    we initially built for sharing articles did not take any of these concepts into
    account, and so we would need to find a way to shoehorn them in without breaking
    old behavior in any significant way. We also would need to find a way to do this
    *incrementally*, to avoid releasing a ton of changes to our system at once that
    could be difficult to debug and maintain. The rest of this article describes how
    we went on to do exactly that, one pull request at a time.\r\n\r\n> **NOTE:**
    Throughout this article, I link to the \"files changed\" view of pull requests
    to give you a complete picture of what changed in the code, but understanding
    every last detail is not important. It's fine to dig deep into some pull requests
    while skimming or skipping others.\r\n\r\n## Step 1: Deal with authorization failures
    gracefully\r\n\r\nWhen we first started working on practicingruby.com, we thought
    it would be convenient to automatically handle Github authentication behind the
    scenes so that subscribers rarely needed to explicitly click a \"sign in\" button
    in order to read articles. This is a good design idea, but we only really considered
    the happy path while building and testing it.\r\n\r\nMany months down the line,
    we realized that people would occasionally share internal links to our articles
    by accident, rather than explicitly generating public links. Whenever that happened,
    the visitor would be put through our entire registration process without warning,
    including:\r\n\r\n* Approving our use of Github to authorize their account\r\n*
    Going through an email confirmation process\r\n* Getting prompted for credit card
    information\r\n\r\nMost would understandably abandon this process part of the
    way through. In the best case scenario, our application's behavior would be seen
    as very confusing, though I'm sure for many it felt downright rude and unpleasant.
    It's a shame that such a bad experience could emerge from what was actually good
    intentions both on our part and on whoever shared a link to our content in the
    first place. Think of what a different experience it might have been if the visitor
    had been redirected to our landing page where they could see the following message:\r\n\r\n![](http://i.imgur.com/kA3ePJI.png)\r\n\r\nAlthough
    that wouldn't be quite as nice as getting free access to an article that someone
    wanted to share with them, it would at least avoid any confusion about what had
    just happened. My first attempt at introducing this kind of behavior into the
    system looked like what you see below:\r\n\r\n```ruby\r\nclass ApplicationController
    < ApplicationController::Base\r\n  # ...\r\n  \r\n  def authenticate\r\n    return
    if current_authorization \r\n   \r\n    flash[:notice] = \r\n      \"That page
    is protected. Please sign in or sign up to continue\"\r\n      \r\n    store_location\r\n
    \   redirect_to(root_path)\r\n  end\r\nend \r\n```\r\n\r\nWe deployed this code
    and for a few days, it seemed to be a good enough stop-gap measure for resolving
    this bug, even if it meant that subscribers might need to click a \"sign in\"
    button a little more often. However, I realized that it was a bit too naive of
    a solution when I received an email asking why it was necessary to click \"sign
    in\" in order to make the \"subscribe\" button work. My quick fix had broken our
    registration system. :cry:\r\n\r\nUpon hearing that bad news, I immediately pulled
    this code out of production after writing a test that proved this problem existed
    on my feature branch but not in master. A few days later, I put together a quick
    fix that got my tests passing. My solution was to extract a helper method that
    decided how to handle authorization failures. The default behavior would be to
    redirect to the root page and display an error message as we did above, but during
    registrations, we would automatically initiate a Github authentication as we had
    done in the past:\r\n\r\n```ruby\r\nclass ApplicationController < ApplicationController::Base\r\n
    \ # ...\r\n  \r\n  def authenticate\r\n    return if current_authorization \r\n
    \  \r\n    store_location\r\n    redirect_on_auth_failure\r\n  end\r\n  \r\n  def
    redirect_on_auth_failure\r\n    flash[:notice] = \r\n      \"That page is protected.
    Please sign in or sign up to continue\"\r\n      \r\n    redirect_to(root_path)\r\n
    end\r\nend\r\n\r\nclass RegistrationController < ApplicationController\r\n  #
    ...\r\n  \r\n  def redirect_on_auth_failure\r\n    redirect_to login_path \r\n
    \ end\r\nend \r\n```\r\n\r\nThis code, though not especially well designed, seemed
    to get the job done without too much trouble. It also served as a useful reminder
    that I should be on the lookout for holes in the test suite, which in retrospect
    should have been obvious given the awkward behavior of the original code. As they
    say, hindsight is 20/20!\r\n\r\n\r\n> HISTORY: Deployed 2013-07-26 and then reverted
    a few days later due to the registration bug mentioned above. Redeployed on 2013-08-06,
    then merged three days later. \r\n>\r\n>[View complete diff](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/145/files)\r\n\r\n##
    Step 2: Add article slugs\r\n\r\nWhen we first started working on practicingruby.com,
    we didn't put much thought to what our URLs looked like. In the first few weeks,
    we were rushing to get features like syntax highlighting and commenting out the
    door while keeping up with the publication schedule, and so we didn't have much
    energy to think about the minor details.\r\n\r\nEven if it made sense at the time,
    this is one decision I came to regret. In particular, I  disliked the notion that
    the paths that subscribers saw (e.g. \"/articles/101\") were completely different
    than the ones we generated for public viewing (e.g. \"/articles/shared/zmkztdzucsgv\"),
    with no direct way to associate the two. When you add in the fact that both of
    these URL schemes are opaque, it definitely stood out as a poor design decision
    on our part.\r\n\r\nTechnically speaking, it would be possible to unify the two
    different schemes using subscriber tokens without worrying about the descriptiveness
    of the URLs, perhaps using paths like \"/articles/101?u=dc20f9bb\". However, since
    we would need to be messing around with article path generation as it was, it
    seemed like a good idea to make those paths much more attractive by adding slugs.
    The goal was to have a path like: \"/articles/improving-legacy-systems?u=dc2ab0f9bb\".
    \r\n\r\nBecause we knew article slugs would be easy to implement, we decided to
    build and ship them before moving on to the more complicated changes we had planned
    to make. The pair of methods below are the most interesting implementation details
    from this changeset:\r\n\r\n```ruby\r\nclass Article < ActiveRecord::Base\r\n
    \ # ...\r\n\r\n  def self.[](key)\r\n    find_by_slug(key) || find_by_id(key)\r\n
    \ end\r\n\r\n  def to_param\r\n    if slug.present?\r\n      slug\r\n    else\r\n
    \     id.to_s\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe `Article[]` method
    is a drop-in replacement for `Article.find` that allows lookup by slug or by id.
    This means that both `Article[101]` and `Article['improving-legacy-code']` are
    valid calls, each of them returning an `Article` object. Because we only call
    `Article.find()` in a few places in our codebase, it was easy to swap those calls
    out to use `Article[]` instead.\r\n\r\nThe `Article#to_params` method is used
    internally by Rails to generate paths. So wherever `article_url` or `article_path`
    get called with an `Article` object, this method will be called to determine what
    gets returned. If the article has a slug associated, it'll return something like
    \"/articles/improving-legacy-code\". If it doesn't have a slug set yet, it will
    return the familiar opaque database ids, i.e. \"/articles/101\".\r\n\r\nThere
    is a bit of an inconsistency in this design worth noting: I chose to override
    the `to_params` method, but not the `find` method on my model. However, since
    the former is a method that is designed to be overridden and the latter might
    be surprising to override, I felt somewhat comfortable with this design decision.\r\n\r\nAlthough
    it's not worth showing the code for it, I also added a redirect to the new style
    URLs whenever a slug existed for an article. By doing this, I was able to effectively
    deprecate the old URL style without breaking existing links. While we won't ever
    disable lookup by database ID, this at least preserves some consistency at the
    surface level of the application.\r\n\r\n> HISTORY: Deployed 2013-08-16 and then
    merged the next day. Adding slugs to articles was a manual process that I completed
    a few days after the feature shipped.\r\n>\r\n> [View complete diff](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/155/files)\r\n\r\n##
    Step 3: Add subscriber share tokens\r\n\r\nIn theory it should have been nearly
    trivial to implement subscriber-based share tokens. After all, we were simply
    generating a random string for each subscriber and then appending it to the end
    of article URLs as a GET parameter (e.g. \"u=dc20f9bb\"). In practice, there were
    many edge cases that would complicate our implementation.\r\n\r\nThe ideal situation
    would be to override the `article_path` and `article_url` methods to add the currently
    logged in user's share token to any article links throughout the application.
    However, we weren't able to find a single place within the Rails call chain where
    such a global override would make sense. It would easy enough to get this kind
    of behavior in both our views and controllers by putting the methods in a helper
    and then mixing that helper into our ApplicationController, but it wasn't easy
    to take the same approach in our tests and mailers. To make matters worse, some
    of the places we wanted to use these path helpers would have access to the ones
    rails provided by default, but would not include our overrides, and so we'd silently
    lose the behavior we wanted to add.\r\n\r\nWe were unable to find an elegant solution
    to this problem, but eventually settled on a compromise. We built a low level
    object for generating the URLs with subscriber tokens, as shown below:\r\n\r\n```ruby\r\nclass
    ArticleLink\r\n  include Rails.application.routes.url_helpers\r\n\r\n  def initialize(article,
    params)\r\n    self.article = article\r\n    self.params = params\r\n  end\r\n\r\n
    \ def path(token)\r\n    article_path(article, params_with_token(token))\r\n  end\r\n\r\n
    \ def url(token)\r\n    article_url(article, params_with_token(token))\r\n  end\r\n\r\n
    \ private\r\n\r\n  attr_accessor :params, :article\r\n\r\n  def params_with_token(token)\r\n
    \   {:u => token}.merge(params)\r\n  end\r\nend\r\n```\r\n\r\nThen in our `ApplicationHelper`,
    we added the following bits of glue code:\r\n\r\n```ruby\r\nmodule ApplicationHelper\r\n
    \ def article_url(article, params={})\r\n    return super unless current_user\r\n\r\n
    \   ArticleLink.new(article, params).url(current_user.share_token)\r\n  end\r\n\r\n
    \ def article_path(article, params={})\r\n    return super unless current_user\r\n\r\n
    \   ArticleLink.new(article, params).path(current_user.share_token)\r\n  end\r\nend\r\n```\r\n\r\nAdding
    these simple shims made it so that we got the behavior we wanted in the ordinary
    use cases of `article_url` and `article_path`, which were in our controllers and
    views. In our mailers and tests, we opted to use the `ArticleLink` object directly,
    because we needed to explicitly pass in tokens in those areas anyway. Because
    it was impossible for us to make this code completely DRY, this convention-based
    design was the best we could come up with.\r\n\r\nAs part of this changeset, I
    modified the redirection code that I wrote when we were introducing slugs to also
    take tokens into account. If a subscriber visited a link that didn't include a
    share token, it would rewrite the URL to include their token. This was yet another
    attempt at introducing a bit of consistency where there previously was none.\r\n\r\n>
    HISTORY: Deployed code to add tokens upon visiting an article on 2013-08-20, then
    did a second deploy to update the archives and library links the next day, merged
    on 2013-08-23.\r\n>\r\n> [View complete diff](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/158/files)\r\n\r\n##
    Step 4: Redesign and improve broadcast mailer\r\n\r\nI use a very basic web form
    in our admin panel to send email announcements out to Practicing Ruby subscribers.
    Originally, this feature relied on sending messages in batches, which was the
    simple thing to do when we assumed we'd be sending an identical message to everyone:\r\n\r\n```ruby\r\nclass
    BroadcastMailer < ActionMailer::Base\r\n  def deliver_broadcast(message={})\r\n
    \   @body = message[:body]\r\n\r\n    user_batches(message) do |users|\r\n      mail(\r\n
    \       :to => \"gregory@practicingruby.com\",\r\n        :bcc => users,\r\n        :subject
    => message[:subject]\r\n      ).deliver\r\n    end\r\n  end\r\n\r\n  private\r\n\r\n
    \ def user_batches(message)\r\n    yield(message[:to]) && return if message[:commit]
    == \"Test\"\r\n\r\n    User.where(:notify_updates => true).to_notify.\r\n      find_in_batches(:batch_size
    => 25) do |group|\r\n        yield group.map(&:contact_email)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nDespite
    being a bit of a hack, this code served us well enough for a fairly long time.
    It even supported a basic \"test mode\" that allowed me to send a broadcast email
    to myself before sending it out everyone. However, the design would need to change
    greatly if we wanted to include share tokens in the article links we emailed to
    subscribers. We'd need to send out individual emails rather than sending batched
    messages, and we'd also need to implement some sort of basic mail merge functionality
    to handle article link generation.\r\n\r\nI don't want to get too bogged down
    in details here, but this changeset turned out to be far more complicated than
    I expected. For starters, the way we were using `ActionMailer` in our original
    code was incorrect, and we were relying on undefined behavior without realizing
    it. Because the `BroadcastMailer` had been working fine for us in production and
    its (admittedly mediocre) tests were passing, we didn't notice the problem until
    we attempted to change its behavior. After attempting to introduce code that looked
    like this, I started to get all sorts of confusing test failures:\r\n\r\n```ruby\r\nclass
    BroadcastMailer < ActionMailer::Base\r\n  # NOTE: this is an approximation, but
    it captures the basic idea...\r\n  def deliver_broadcast(message={})\r\n    @body
    = message[:body]\r\n\r\n    User.where(:notify_updates => true).to_notify.each
    do |user|\r\n      mail(:to => user.contact_email, :subject => message[:subject]).deliver\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nEven though this code appeared to work as
    expected in development (sending individual emails to each recipient), in my tests,
    `ActionMailer::Base.deliveries` was returning N copies of the first email sent
    in this loop. After some more playing around with ActionMailer and semi-fruitless
    internet searches, I concluded that this was because we weren't using the mailers
    in the officially sanctioned way. We'd need to change our code so that the mailer
    returned a `Mail` object, rather than handling the delivery for us.\r\n\r\nBecause
    I didn't want that logic to trickle up into the controller, and because I expected
    things might get more complicated as we kept adding more features to this object,
    I decided to introduce an intermediate service object to handle some of the work
    for us, and then greatly simplify the mailer object. I also wanted to make the
    distinction between sending a test message and sending a message to everyone more
    explicit, so I took the opportunity to do that as well. The resulting code ended
    up looking something similar to what you see below:\r\n\r\n```ruby\r\nclass Broadcaster\r\n
    \ def self.notify_subscribers(params)\r\n    BroadcastMailer.recipients.each do
    |email|\r\n      BroadcastMailer.broadcast(params, email).deliver\r\n    end\r\n
    \ end\r\n\r\n  def self.notify_testers(params)\r\n    BroadcastMailer.broadcast(params,
    params[:to]).deliver\r\n  end\r\nend\r\n\r\nclass BroadcastMailer < ActionMailer::Base\r\n
    \ def self.recipients\r\n    User.where(:notify_updates => true).to_notify.map(&:contact_email)\r\n
    \ end\r\n\r\n  def broadcast(message, email)\r\n    mail(:to => email,\r\n         :subject
    => message[:subject])\r\n  end\r\nend\r\n```\r\n\r\nWith this code in place, I
    had successfully converted the batch email delivery to individual emails. It was
    time to move on to adding a bit of code that would give me mail-merge functionality.
    I decided to use Mustache for this purpose, which would allow me to write emails
    that look like this:\r\n\r\n```\r\nHere is an awesome article I wrote:\r\n\r\n{{#article}}improving-legacy-systems{{/article}}\r\n```\r\n\r\nMustache
    would then run some code behind the scenes and turn that message body into the
    following output:\r\n\r\n```\r\nHere is an awesome article I wrote:\r\n\r\nhttp://practicingruby.com/articles/improving-legacy-systems?u=dc20f9bb\r\n```\r\n\r\nAs
    a proof of concept, I wrote a bit of code that handled the article link expansion,
    but didn't handle share tokens yet. It only took two extra lines in `BroadcastMailer#broadcast`
    to add this support:\r\n\r\n```ruby\r\nclass BroadcastMailer < ActionMailer::Base\r\n
    \ # ...\r\n  \r\n  def broadcast(message, email)\r\n    article_finder = ->(e)
    { article_url(Article[e]) }\r\n\r\n    @body = Mustache.render(message[:body],
    :article => article_finder)\r\n\r\n    mail(:to => email,\r\n         :subject
    => message[:subject])\r\n  end\r\nend\r\n```\r\n\r\nI deployed this code in production
    and sent myself a couple test emails, verifying that the article links were getting
    expanded as I expected them to. I had planned to work on adding the user tokens
    immediately after running those live tests, but at that moment realized that I
    had overlooked an important issue related to performance.\r\n\r\nPrevious to this
    changeset, the `BroadcastMailer` was responsible for sending about 16 emails at
    a time (25 people per email). But now, it would be sending about 400 of them!
    Even though we use a DelayedJob worker to handle the actual delivery of the messages,
    it might take some significant amount of time to insert 400 custom-generated emails
    into the queue. Rather than investigating that problem right away, I decided to
    get myself some rest and tackle it the next day with Jordan.    \r\n\r\n> HISTORY:
    Deployed on 2013-08-22, and then merged the next day.\r\n>\r\n> [View complete
    diff](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/162/files)\r\n\r\n##
    Step 5: Test broadcast mailer's performance\r\n\r\nBefore we could go any farther
    with our work on the broadcast mailer, we needed to check the performance implications
    of switching to non-batched emails. We didn't need to do a very scientific test
    -- we just needed to see how severe the slowdown was. Because our previous code
    ran without a noticeable delay, pretty much anything longer than a second or two
    would be concerning to us.\r\n\r\nTo conduct our test, we first populated our
    development environment with 2000 users (about 5x as many active users as we had
    on Practicing Ruby at the time). Then, we posted a realistic email in the broadcast
    mailer form, and kept an eye on the messages that were getting queued up via the
    Rails console. After several seconds we hadn't even queued up 100 jobs, so it
    became clear that performance very well could be a concern.\r\n\r\nTo double check
    our estimates, and to form a more realistic test, we temporarily disabled our
    DelayedJob worker on the server and then ran the broadcast mailer in our live
    environment. Although the mailer did finish up queuing its messages without the
    request timing out, it took about half a minute to do so. With this information
    in hand, we cleared out the test jobs so that they wouldn't actually be delivered,
    and then spent a bit of time lost in thought.\r\n\r\nUltimately, we learned several
    important things from this little experiment:\r\n\r\n1. The mail building and
    queuing process was definitely slow enough to worry us.\r\n2. In the worst case
    scenario, I would be able to deal with a 30 second delay in delivering broadcasts,
    but we would need to fix this problem if we wanted to unbatch other emails of
    ours, such as comment notifications.\r\n3. The most straightforward way to deal
    with this problem would be to run the entire mail building and queuing process
    in the background.\r\n\r\nThe first two points were not especially surprising
    to us, but the third concerned us a bit. While we have had good luck using DelayedJob
    in conjunction with the MailHopper gem to send email, we had some problems in
    the past with trying to handle arbitrary jobs with it. We suspected this had to
    do with some of our dependencies being outdated, but never had time to investigate
    properly. With our fingers crossed, we decided to hope for the best and plan for
    the worst.\r\n\r\n## Step 6: Process broadcast mails using DelayedJob\r\n\r\nOur
    first stab at backgrounding the work done by\r\n`Broadcaster.notify_subscribers`
    \ was to simply change the call to\r\n`Broadcaster.delay.notify_subscribers`.
    \r\n\r\nIn theory, this small change should have done the\r\ntrick: the method
    is conceptually nothing more than a \"fire and forget\"\r\nfunction that did not
    need to interact in any way with its caller. But after\r\nspending a long time
    staring at an incredibly confusing error log, we\r\nrealized that it wasn't safe
    to assume that DelayedJob would cleanly serialize\r\na Rails `params` hash. Constructing
    our own hash to pass into the\r\n`Broadcaster.notify_subscribers` method resolved
    those issues, and we ended up\r\nwith the following code in `BroadcastsController`:\r\n\r\n```ruby\r\nmodule
    Admin\r\n  class BroadcastsController < ApplicationController\r\n    def create\r\n
    \     # ...\r\n\r\n      # build our own hash to avoid DelayedJob serialization
    issues\r\n      message = { :subject => params[:subject],\r\n                  :body
    \   => params[:body] } \r\n\r\n      if params[:commit] == \"Test\"\r\n        message[:to]
    = params[:to]\r\n\r\n        Broadcaster.notify_testers(message)\r\n      else\r\n
    \       Broadcaster.delay.notify_subscribers(message)\r\n      end\r\n\r\n      #
    ...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAfter tweaking our test suite slightly
    to take this change into account, we\r\nwere back to green fairly quickly. We
    experimented with the delayed broadcasts\r\nlocally and found that it resolved
    our slowness issue in the UI. The worker\r\nwould still take a little while to
    build all those mails and get them queued\r\nup, but since it was being done in
    the background it no longer was much of a\r\nconcern to us.\r\n\r\nWe were cautiously
    optimistic that this small change might fix our issues, so\r\nwe deployed the
    code to production and did another live test. Unfortunately,\r\nthis lead us to
    a new error condition, and so we had to go back to the drawing board. \r\nEventually
    we came across [this Github issue](https://github.com/collectiveidea/delayed_job/issues/350),
    which hinted (indirectly) that we might be running into one of the many issues
    with YAML parsing on Ruby 1.9.2.\r\n\r\nWe could have attempted to do yet another
    workaround to avoid updating our\r\nRuby version, but we knew that this was not
    the first, second, or even third time that we had been bitten by the fact that
    we were still running an ancient\r\nand poorly supported version of Ruby. In fact,
    we realized that wiping the\r\nslate clean and provisioning a whole new VPS might
    be the way to go, because\r\nthat way we could upgrade all of our platform dependencies
    at once.\r\n\r\nSo with that in mind, Jordan went off to work on getting us a
    new production\r\nenvironment set up, and we temporarily put this particular changeset
    on hold.\r\nThere was still plenty of work for me to do that didn't rely on upgrading
    our\r\nproduction environment, so I kept working against our old server while
    he tried to spin up a new one.\r\n\r\n> HISTORY: Deployed for live testing on
    2013-08-23 but then immediately pulled\r\n> from production upon failure. Redeployed
    to our new server on 2013-08-30,\r\n> then merged the following day.\r\n>\r\n>
    [View complete diff](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/164)\r\n\r\n##
    Step 7: Support share tokens in broadcast mailer\r\n\r\nNow that we had investigated
    the performance issues with the mailer and had a plan in place to fix them, it
    was time for me to finish what I had planned to work on in the first place: adding
    share tokens to article links in emails.\r\n\r\nThe changes to `BroadcastMailer`
    were fairly straightforward: pass a `User` rather than an email address into the
    `broadcast` method, and then use `ArticleLink` to generate a customized link based
    on the subscriber's share token: \r\n\r\n```ruby\r\nclass BroadcastMailer < ActionMailer::Base\r\n
    \ def self.recipients\r\n    User.where(:notify_updates => true).to_notify\r\n
    \ end\r\n\r\n  def broadcast(message, subscriber)\r\n    article_finder = ->(e)
    { \r\n      ArticleLink.new(Article[e]).url(subscriber.share_token) \r\n    }\r\n\r\n
    \   @body = Mustache.render(message[:body], :article => article_finder)\r\n\r\n
    \   mail(:to => subscriber.contact_email,\r\n         :subject => message[:subject])\r\n
    \ end\r\nend\r\n```\r\n\r\nThe only complication of rewiring `BroadcastMailer`
    this way is that it broke our test mailer functionality. Because the test mailer
    could send a message to any email address (whether there was an account associated
    with it or not), we wouldn't be able to look up a valid `User` record to pass
    to the `BroadcastMailer`. The code below shows my temporary solution to this API
    compatibility problem:\r\n\r\n```ruby\r\nclass Broadcaster\r\n   # ...\r\n   \r\n
    \ def self.notify_testers(params)\r\n    subscriber = Struct.new(:contact_email,
    :share_token)\r\n                       .new(params[:to], \"testtoken\")\r\n\r\n
    \   BroadcastMailer.broadcast(params, subscriber).deliver\r\n  end\r\nend\r\n```\r\n\r\nUsing
    a `Struct` object to generate an interface shim as I've done here is not the most
    elegant solution, but it gets the job done. A better solution would be to create
    a container object that could be used by both `notify_subscribers` and `notify_testers`,
    but I wasn't ready to make that design decision yet.\r\n\r\nWith these changes
    in place, I was able to do some live testing to verify that we had managed to
    get share tokens into our article links. Now all that remained was to add the
    logic that would allow these share tokens to permit guest access to articles.\r\n\r\n>
    HISTORY: Deployed 2013-08-24, then merged on 2013-08-29.\r\n>\r\n> [View complete
    diff](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/165)\r\n\r\n##
    Step 8: Allow guest access to articles via share tokens\r\n\r\nWith all the necessary
    underplumbing in place, I was finally ready to model the new sharing mechanism.
    The end goal was to support the following behavior:\r\n\r\n- Subscribers see the
    full article w. comments whenever they are logged in\r\n- With a valid token in
    the URL, guests see our \"shared article\" view.\r\n- Without a valid token, guests
    see the \"protected page\" error\r\n- Links that use a token from an expired account
    are disabled\r\n- Old-style share links redirect to the new-style subscriber token
    links\r\n\r\nThe main challenge was that there wasn't an easy way to separate
    these concepts from each other, at least not in a meaningful way. However, we
    were able to reuse large chunks of existing code to do this, so most of the work
    was just tedious rewiring of controller actions while layering in a few more tests
    here and there.\r\n\r\nThe changes that needed to be made to support these behaviors
    were not that hard to make, but I did feel concerned about how complicated our
    `ArticlesController#show` action was getting. Including the relevant filters,
    here is what it looked like after all the changes were made (skim it, but don't
    bother trying to understand it!):\r\n\r\n```ruby\r\nclass ArticlesController <
    ApplicationController\r\n  before_filter :find_article, :only => [:show, :edit,
    :update, :share]\r\n  before_filter :update_url, :only => [:show]\r\n  before_filter
    :validate_token, :only => [:show]\r\n\r\n  skip_before_filter :authenticate, :only
    => [:show, :shared, :samples]\r\n  skip_before_filter :authenticate_user, :only
    => [:show, :shared, :samples]\r\n\r\n  def show\r\n    store_location\r\n    decorate_article\r\n\r\n
    \   if current_user\r\n      mixpanel.track(\"Article Visit\", :title => @article.subject,\r\n
    \                                     :user_id => current_user.hashed_id)\r\n\r\n
    \     @comments = CommentDecorator.decorate(@article.comments\r\n                                                    .order(\"created_at\"))\r\n
    \   else\r\n      shared_by = User.find_by_share_token(params[:u]).hashed_id\r\n\r\n
    \     mixpanel.track(\"Shared Article Visit\", :title => @article.subject,\r\n
    \                                           :shared_by => shared_by)\r\n\r\n      render
    \"shared\"\r\n    end\r\n  end\r\n\r\n  private\r\n\r\n  def find_article\r\n
    \   @article = Article[params[:id]]\r\n\r\n    render_http_error(404) unless @article\r\n
    \ end\r\n\r\n  def update_url\r\n    slug_needs_updating = @article.slug.present?
    && params[:id] != @article.slug\r\n    missing_token = current_user && params[:u].blank?\r\n\r\n
    \   redirect_to(article_path(@article)) if slug_needs_updating || missing_token\r\n
    \ end\r\n\r\n  def validate_token\r\n    return if current_user.try(:active?)\r\n\r\n
    \   unless params[:u].present? && \r\n           User.find_by_share_token_and_status(params[:u],
    \"active\")\r\n      attempt_user_login # helper that calls authenticate + authenticate_user\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nThis is clearly not a portrait of healthy
    code! In fact, it looks suspiciously similiar to the code samples that \"lost
    the plot\" in Avdi Grimm's contributed article on [confident coding](https://practicingruby.com/articles/confident-ruby).
    That said, it's probably more fair to say that there wasn't much of a well defined
    plot when this code was written in the first place, and my attempts to modify
    it only muddied things further. \r\n\r\nIt was hard for me to determine whether
    or not I should attempt to refactor this code right away or wait until later.
    From a purely technical perspective, the answer was obvious that this code needed
    to be cleaned up. But looking at it from another angle, I wanted to make sure
    that the external behavior of the system was what I actually wanted before I invested
    more time into optimizing its implementation. I didn't have insight at this point
    in time to answer that question, so I decided to leave the code messy for the
    time being until I had a chance to see how well the new sharing mechanism performed
    in production. \r\n\r\n> HISTORY: Deployed on 2013-08-26 and then merged on 2013-08-29.\r\n>\r\n>
    [View complete diff](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/173)\r\n\r\n##
    Step 9: Get practicingruby.com running on our new VPS\r\n\r\nWhile I kept working
    on the sharing mechanism, Jordan was busy setting up a new production environment
    for us. We set up a temporary subdomain new.practicingruby.com for this purpose,
    and that allowed us to do some live testing while he got everything up and running.\r\n\r\nTechnically
    speaking, we only need to upgrade our Ruby version in order to fix the problems
    we encountered with DelayedJob, so spinning up a new VPS instance purely for that
    purpose might sound a bit overkill at first glance. However, starting with a blank
    slate environment allowed us to upgrade the rest of our serverside dependencies
    at a relaxed pace, without worrying about potentially causing large amounts of
    site downtime. Spinning up the new environment in parallel before decommissioning
    the old one also meant that we could always switch back to our old environment
    if we encountered any problems during the migration to the new server.\r\n\r\nOn
    2013-08-30, we decided to migrate to the new environment. The first step was to
    pull in the delayed broadcast mailer code and do live tests similar to the ones
    we had done earlier. After we found that those went smoothly, we decided to do
    a complete end-to-end test by using the new system to deliver an announcement
    about the planned maintenance downtime. That worked without any issues, and so
    at that time we were ready to perform the cut over.\r\n\r\nWe made sure to copy
    over all the data from our old environment immediately after putting it into maintenance
    mode, and then we updated our DNS entries to point practicingruby.com at the new
    server. After the DNS records propagated, we used a combination of watching our
    logs and our analytics dashboard (Mixpanel) to see how things were going. There
    were only two minor hiccups before everything got back to normal:\r\n\r\n* We
    had a small issue with our Oauth configuration on Github, but resolving it was
    trivial after we realized that it was not in fact a DNS-related problem, but an
    issue on our end.\r\n\r\n* We realized as soon as we spun up our cron jobs on
    the new server that our integration with Mailchimp's API had broken. The gem we
    were using was not Ruby 2.0 compatible, but we never realized this in development
    because we use it only in a tiny cleanup script that runs behind the scenes on
    the server. Thankfully because we had isolated this dependency from our application
    code, [changing it was very easy](https://github.com/elm-city-craftworks/practicing-ruby-web/pull/177/files).\r\n\r\nThese
    two issues were the only problems we needed to debug under pressure throughout
    all the work we described in this article. Given how much we changed under the
    hood, I am quite proud of that fact.\r\n\r\n## Reflections\r\n\r\nThe state of
    practicingruby.com immediately after our server migration was roughly comparable
    to that of the highway construction photograph that you saw at the beginning of
    this article: some improvements had been made, but there was still plenty of old
    cruft left around, and lots of work left to be done before things could be considered
    finished. My goal in writing this article was not to show a beautiful end result,
    but instead to illustrate a process that is seldom discussed.\r\n\r\nIn the name
    of preserving realism, I dragged you through some of our oldest and worst code,
    and also showed you some newer code that isn't much nicer looking than our old
    stuff. Along the way, we used countless techniques that feel more like plumbing
    work than interesting programming work. Each step along the way, we used a different
    technique to glue one bit of code to another bit of code without breaking old
    behaviors, because there was no good one-size fits all solution to turn to. We
    got the job done, but we definitely got our hands dirty in the process.\r\n\r\nI
    feel fairly confident that some of the changes I showed in this article are ones
    that I will be thankful for in the long haul, while others I will come to regret.
    The trouble of course is knowing which will be which, and only time and experience
    can get me there. But hopefully by sharing my own experiences with you, you can
    learn something from my mistakes, too!\r\n\r\n> Special thanks goes to Jordan
    Byron (the maintainer of practicingruby.com) for collaborating with me on this
    article, and for helping Practicing Ruby run smoothly over the years.\r\n"
- :slug: low-level-computing
  :title: Exploring low-level computing concepts with Ruby
  :summary: Implement a minimal simulator of the classic 6502 processor using nothing
    but JRuby.
  :published: 2013-10-01 00:00:00.000000000 Z
  :issue_number: '7.5'
  :volume: 7
  :body: "> This issue of Practicing Ruby was directly inspired by Nick Morgan's\r\n>
    [Easy 6502](http://skilldrick.github.io/easy6502/) tutorial. While\r\n> the Ruby
    code in this article is my own, the bytecode for the\r\n> Snake6502 game was shamelessly
    stolen from Nick. Be sure to check\r\n> out [Easy 6502](http://skilldrick.github.io/easy6502/)
    if this topic \r\n> interests you; it's one of the best programming tutorials
    I've ever seen.\r\n\r\n\r\nThe sea of numbers you see below is about as close
    to the metal as programming gets:\r\n\r\n```\r\n0600: 20 06 06 20 38 06 20 0d
    06 20 2a 06 60 a9 02 85 \r\n0610: 02 a9 04 85 03 a9 11 85 10 a9 10 85 12 a9 0f
    85 \r\n0620: 14 a9 04 85 11 85 13 85 15 60 a5 fe 85 00 a5 fe \r\n0630: 29 03 18
    69 02 85 01 60 20 4d 06 20 8d 06 20 c3 \r\n0640: 06 20 19 07 20 20 07 20 2d 07
    4c 38 06 a5 ff c9 \r\n0650: 77 f0 0d c9 64 f0 14 c9 73 f0 1b c9 61 f0 22 60 \r\n0660:
    a9 04 24 02 d0 26 a9 01 85 02 60 a9 08 24 02 d0 \r\n0670: 1b a9 02 85 02 60 a9
    01 24 02 d0 10 a9 04 85 02 \r\n0680: 60 a9 02 24 02 d0 05 a9 08 85 02 60 60 20
    94 06 \r\n0690: 20 a8 06 60 a5 00 c5 10 d0 0d a5 01 c5 11 d0 07 \r\n06a0: e6 03
    e6 03 20 2a 06 60 a2 02 b5 10 c5 10 d0 06 \r\n06b0: b5 11 c5 11 f0 09 e8 e8 e4
    03 f0 06 4c aa 06 4c \r\n06c0: 35 07 60 a6 03 ca 8a b5 10 95 12 ca 10 f9 a5 02
    \r\n06d0: 4a b0 09 4a b0 19 4a b0 1f 4a b0 2f a5 10 38 e9 \r\n06e0: 20 85 10 90
    01 60 c6 11 a9 01 c5 11 f0 28 60 e6 \r\n06f0: 10 a9 1f 24 10 f0 1f 60 a5 10 18
    69 20 85 10 b0 \r\n0700: 01 60 e6 11 a9 06 c5 11 f0 0c 60 c6 10 a5 10 29 \r\n0710:
    1f c9 1f f0 01 60 4c 35 07 a0 00 a5 fe 91 00 60 \r\n0720: a2 00 a9 01 81 10 a6
    03 a9 00 81 10 60 a2 00 ea \r\n0730: ea ca d0 fb 60 \r\n```\r\n\r\nAlthough you
    probably can't tell by looking at it, what you see here\r\nis assembled machine
    code for the venerable 6502 processor that powered \r\nmany of the classic video
    games of the 1980s. When executed in simulated\r\nenvironment, this small set
    of cryptic instructions produces a minimal\r\nversion of the Snake arcade game,
    as shown below:\r\n\r\n![](http://i.imgur.com/0DsKeoy.gif)\r\n\r\nIn this article,
    we will build a stripped down 6502 simulator \r\nin JRuby that is complete enough
    to run this game. If you haven't done much \r\nlow-level programming before, don't
    worry! Most of what follows is \r\njust ordinary Ruby code. I will also be showing
    you a ton of examples \r\nalong the way, and those should help keep you on track.
    You might also\r\nwant to grab [full source code](https://github.com/sandal/vintage)
    for \r\nthe simulator, so that you can experiment with it while \r\nreading through
    this article.\r\n\r\n## Warmup exercise: Reverse engineering Snake6502\r\n\r\nAn
    interesting property of machine code is that if you know its structure,\r\nyou
    can convert it back into assembly language. Among other things,\r\nthe ability
    to disassemble machine code is useful for debugging and\r\nexploration purposes.
    Let's try this out on Snake6502! \r\n\r\nThe output below shows memory locations,
    machine code, and assembly code for the\r\nfirst 28 instructions of the game.
    These instructions are responsible for\r\ninitializing the state of the snake
    and the apple before the main event \r\nloop kicks off. You don't need to understand
    exactly how they work right\r\nnow, just try to get a feel for how the code in
    the `hexdump` column corresponds\r\nto the code in the `assembly` column:\r\n\r\n```\r\naddress
    \ hexdump     assembly\r\n------------------------------\r\n$0600    20 06 06
    \   JSR $0606\r\n$0603    20 38 06    JSR $0638\r\n$0606    20 0d 06    JSR $060d\r\n$0609
    \   20 2a 06    JSR $062a\r\n$060c    60          RTS\r\n$060d    a9 02       LDA
    #$02\r\n$060f    85 02       STA $02\r\n$0611    a9 04       LDA #$04\r\n$0613
    \   85 03       STA $03\r\n$0615    a9 11       LDA #$11\r\n$0617    85 10       STA
    $10\r\n$0619    a9 10       LDA #$10\r\n$061b    85 12       STA $12\r\n$061d
    \   a9 0f       LDA #$0f\r\n$061f    85 14       STA $14\r\n$0621    a9 04       LDA
    #$04\r\n$0623    85 11       STA $11\r\n$0625    85 13       STA $13\r\n$0627
    \   85 15       STA $15\r\n$0629    60          RTS\r\n$062a    a5 fe       LDA
    $fe\r\n$062c    85 00       STA $00\r\n$062e    a5 fe       LDA $fe\r\n$0630    29
    03       AND #$03\r\n$0632    18          CLC\r\n$0633    69 02       ADC #$02\r\n$0635
    \   85 01       STA $01\r\n$0637    60          RTS\r\n```\r\n\r\nIf you look
    at the output carefully, you'll be able to notice some patterns even\r\nif you
    don't understand what the instructions themselves are meant to do. For\r\nexample,
    each instruction is made up of between 1-3 bytes of machine code. The\r\nfirst
    byte in each instruction tells us what operation it is, and the remaining\r\nbytes
    (if any) form its operand.\r\n\r\nIf you take a look at the first four instructions,
    it is easy to see that the\r\nopcode `20` corresponds to the `JSR` instruction.
    Forming its operand is\r\nsimilarly straightforward, because it's the same number
    in both places, \r\njust with opposite byte order:\r\n\r\n```\r\n20 06 06 -> JSR
    $0606  \r\n20 38 06 -> JSR $0638\r\n20 0d 06 -> JSR $060d\r\n20 2a 06 -> JSR $062a\r\n```\r\n\r\nIf
    you ignore the symbols in front of the numbers for the moment, mapping single\r\nbyte
    operands is even easier, because they're represented the same way in both\r\nthe
    machine code and the assembly code. Knowing that the `85` opcode maps\r\nto the
    `STA` operation, it should be easy to see how `11, 13, 15` map to\r\n`$11, $13,
    $15` in the following example:\r\n\r\n```\r\n85 11  -> STA $11\r\n85 13  -> STA
    $13\r\n85 15  -> STA $15\r\n```\r\n\r\nBut the symbols in front of the numbers
    in assembly language obviously mean\r\nsomething. If you carefully look at the
    machine code, you'll be able to find\r\nthat the same operation can have multiple
    different opcodes, each of which\r\nidentify a particular kind of operand:\r\n\r\n```\r\na9
    0f -> LDA #$0f\r\na5 fe -> LDA $fe\r\n```\r\n\r\nWithout getting into too much
    detail here, the example above shows us that both\r\n`a9` and `a5` correspond
    to the `LDA` instruction. The difference between the\r\ntwo opcodes is that `a9`
    treats its operand as an immediate value, and `a5` \r\ninterprets it as a memory
    address. In assembly code, this difference is\r\nrepresented syntactically (`#$xx`
    vs. `$xx`), but in the machine code we must\r\nrely on numbers alone.\r\n\r\nThe
    various ways of interpreting operands (called \"addressing modes\") are\r\nprobably
    the most confusing part of working with 6502 code. There are\r\nabout a dozen
    of them, and to get Snake6502 running, we need to implement\r\nmost of them. The
    good news is that every addressing mode is just a\r\nroundabout way of converting
    an operand into a particular address in memory, and once you have that\r\naddress,
    the operations themselves do not care about how you computed it.\r\nOnce you sweep
    all that stuff under the rug, you can end up with clean\r\noperation definitions
    like this:\r\n\r\n```ruby\r\n# NOTE: 'e' refers to the address that was computed
    from the instruction's\r\n# operand and addressing mode.\r\n\r\nLDA { cpu[:a]
    = mem[e]  } \r\nSTA { mem[e]  = cpu[:a] }\r\n```\r\n\r\nThis realization also
    tells us that the memory module will not need to take\r\naddressing modes into
    account as long as they're precomputed elsewhere. With\r\nthat in mind, let's
    get started building a storage model for our simulator.\r\nWe'll deal with the
    hairy problem of addressing modes later.\r\n\r\n## Memory\r\n\r\nExcept for a
    few registers that are used to store intermediate\r\ncomputations, the 6502 processor
    relies on its memory for pretty much\r\neverything. Program code, data, and the
    system stack all reside in \r\nthe same 16-bit addressing space. Even flow control
    is entirely\r\ndependent on memory: the program counter itself is nothing more\r\nthan
    an address that is used to look up the next instruction to run.\r\n\r\nThis \"all
    in one bucket\" approach is a double-edged sword. It makes it harder to\r\nwrite
    safe programs, but the tradeoff is that the storage model itself is very\r\nsimple.
    Conceptually, the memory module is nothing more than a mapping \r\nbetween 16-bit
    addresses and 8-bit values:\r\n\r\n```ruby\r\ndescribe \"Storage\" do\r\n  let(:mem)
    { Vintage::Storage.new }\r\n\r\n  it \"can get and set values\" do\r\n    mem[0x1337]
    = 0xAE\r\n\r\n    mem[0x1337].must_equal(0xAE)\r\n  end\r\n\r\n  # ...\r\nend\r\n```\r\n\r\nBut
    because the program counter keeps track of a 'current location' \r\nin memory
    at any point in time, there is a lot more we can do with \r\nthis simple structure.
    Let's walk through the remaining tests \r\nfor `Vintage::Storage` to see what
    else it implements.\r\n\r\n**Program loading**\r\n\r\nWhen a program is loaded
    into memory, there is nothing special about the \r\nway it is stored, it's just
    like any other data. In a real 6502 processer,\r\na register is used to store
    the address of the \r\nnext instruction to be run, and that address is used to
    read an opcode\r\nfrom memory. In our simulator, we can let the `Storage` class
    keep track \r\nof this number for us, incrementing it whenever we call \r\nthe
    `Storage#next` method.\r\n\r\nThe following test shows how to load a program and
    then walk its code one byte at a time:\r\n\r\n```ruby\r\nit \"can load a bytecode
    sequence into memory and traverse it\" do\r\n  bytes = [0x20, 0x06, 0x06]\r\n\r\n
    \ mem.load(bytes)\r\n  mem.pc.must_equal(program_offset) # load() does not increment
    counter\r\n\r\n  bytes.each { |b| mem.next.must_equal(b) }\r\n\r\n  mem.pc.must_equal(program_offset
    + 3)\r\nend\r\n```\r\n\r\nThe starting position of the program can be an arbitrary
    location, but\r\nto maintain compatibility with the simulator from the Easy6502
    tutorial, we\r\ninitialize the program counter to `0x600`:\r\n\r\n```ruby\r\nlet(:program_offset)
    { Vintage::Storage::PROGRAM_OFFSET }\r\n\r\nit \"sets an initial position of $0600\"
    do\r\n  program_offset.must_equal(0x0600)\r\n\r\n  mem.pc.must_equal(program_offset)\r\nend\r\n```\r\n\r\n**Flow
    control + branching**\r\n\r\nVery rudimentary flow control is supported by setting
    the \r\nprogram counter to a particular address, which causes the \r\nprocessor
    to `jump` to the instruction at that address:\r\n\r\n```ruby\r\nit \"implements
    jump\" do\r\n  mem.jump(program_offset + 0xAB)\r\n\r\n  mem.pc.must_equal(program_offset
    + 0xAB)\r\nend\r\n```\r\n\r\nBranching can be implemented by only calling `jump`
    when a\r\ncondition is met:\r\n\r\n```ruby\r\nit \"implements conditional branching\"
    do\r\n  big   = 0xAB\r\n  small = 0x01\r\n\r\n  # a false condition does not affect
    mem.pc\r\n  mem.branch(small > big, program_offset + 5)\r\n  mem.pc.must_equal(program_offset)\r\n\r\n
    \ # true condition jumps to the provided address\r\n  mem.branch(big > small,
    program_offset + 5)\r\n  mem.pc.must_equal(program_offset + 5)\r\nend\r\n```\r\n\r\nThis
    test case is a bit contrived, so let's take a look at \r\nsome real Snake6502
    code that illustrates how branching meant to be used:\r\n\r\n```\r\n$064d    a5
    ff     LDA $ff      # read the last key pressed on the keyboard\r\n$064f    c9
    77     CMP #$77     # check if the key was \"w\" (ASCII code 0x77)\r\n$0651    f0
    0d     BEQ $0660    # if so, jump forward to $0660 \r\n$0653    c9 64     CMP
    #$64     # check if the key was \"d\" (ASCII code 0x64)\r\n$0655    f0 14     BEQ
    $066b    # if so, jump forward to $066b\r\n$0657    c9 73     CMP #$73     # check
    if the key was \"s\" (ASCII code 0x73)\r\n$0659    f0 1b     BEQ $0676    # if
    so, jump forward to $0676\r\n$065b    c9 61     CMP #$61     # check if the key
    was \"a\" (ASCII code 0x61)\r\n$065d    f0 22     BEQ $0681    # if so, jump forward
    to $0681\r\n```\r\n\r\nPresumably, the code at `$0660` starts a procedure that
    moves the snake's\r\nhead up, the code at `$066b` moves it to the right, and so
    on. In other words,\r\nif one of these `BEQ` instructions finds a match, it will
    jump to the right place \r\nin the code to handle the relevant condition. But
    if no match is found, the \r\nprocessor will happily continue on to whatever code
    comes after this set of \r\ninstructions in the program.\r\n\r\nThe tricky thing
    about using instructions that rely on `jump` (and consequently,\r\n`branch`) is
    that they are essentially GOTO statements. When you see one of\r\nthese statements
    in the code, you know exactly what instruction will be executed\r\nnext, but there's
    no way of telling if it will ever return to the location\r\nit was called from.
    To get around this problem, we need support for subroutines\r\nthat know how to
    return to where they've been called from. And to implement\r\n*those*, we need
    a system stack.\r\n\r\n**Stack operations**\r\n\r\nHere are the tests for how
    we'd like our stack to behave:\r\n\r\n```ruby\r\nlet(:stack_origin) { Vintage::Storage::STACK_ORIGIN
    }\r\nlet(:stack_offset) { Vintage::Storage::STACK_OFFSET }\r\n\r\nit \"has a 256
    element stack between 0x0100-0x01ff\" do\r\n  stack_offset.must_equal(0x0100)\r\n
    \ stack_origin.must_equal(0xff) # this value gets added to the offset\r\nend\r\n\r\nit
    \"implements stack-like behavior\" do\r\n  mem.sp.must_equal(stack_origin)\r\n\r\n
    \ mem.push(0x01)\r\n  mem.push(0x03)\r\n  mem.push(0x05)\r\n\r\n  mem.sp.must_equal(stack_origin
    - 3)\r\n\r\n  mem.pull.must_equal(0x05)\r\n  mem.pull.must_equal(0x03)\r\n  mem.pull.must_equal(0x01)\r\n\r\n
    \ mem.sp.must_equal(stack_origin)\r\nend\r\n```\r\n\r\nAs the tests indirectly
    suggest, the stack is a region in memory \r\nbetween`$0100` and `$01ff`, indexed
    by a stack pointer (`sp`).\r\nEach time a value is pushed onto the stack, the
    value of the \r\nstack pointer is decremented, and each time a value is pulled,
    \r\nthe pointer is incremented. This makes it so that the stack\r\npointer always
    tells you where the \"top of the stack\" is.\r\n\r\n**Subroutines**\r\n\r\nWith
    a stack in place, we'll have most of what we need to implement\r\n\"Jump to subroutine\"
    (`jsr`) and \"Return from subroutine\" (`rts`)\r\nfunctionality. The behavior
    of these features will end up \r\nlooking something like this:\r\n\r\n```ruby\r\nit
    \"implements jsr/rts\" do\r\n  mem.jsr(0x0606)\r\n  mem.jsr(0x060d)\r\n\r\n  mem.pc.must_equal(0x060d)\r\n\r\n
    \ mem.rts\r\n  mem.pc.must_equal(0x0606)\r\n\r\n  mem.rts\r\n  mem.pc.must_equal(program_offset)\r\nend\r\n```\r\n\r\nTo
    make the above test pass, `jsr` needs to `push` the current \r\nprogram counter
    onto the stack before executing a `jump` to the \r\nspecified address. Later when
    `rts` is called, the address is\r\npulled out of the stack, and then another `jump`
    is executed\r\nto bring you back to where the last `jsr` command was executed.\r\nThis
    works fine even in nested subroutine calls, due to the\r\nnature of how stacks
    work.\r\n\r\nThe only tricky part is that addresses are 16-bit values, but \r\nstack
    entries are limited to single byte values. To get around\r\nthis problem, we need
    a couple helper functions to convert\r\na 16-bit number into two bytes, and vice-versa:\r\n\r\n```ruby\r\nit
    \"can convert two bytes into a 16 bit integer\" do\r\n  mem.int16([0x37, 0x13]).must_equal(0x1337)\r\nend\r\n\r\nit
    \"can convert a 16 bit integer into two bytes\" do\r\n  mem.bytes(0x1337).must_equal([0x37,
    0x13])\r\nend\r\n```\r\n\r\nThese helpers will also come in handy later, when
    we need to deal with\r\naddressing modes.\r\n\r\n**Implementation**\r\n\r\nBehavior-wise,
    there is a lot of functionality here. In a high level\r\nenvironment it would
    feel a lot like we were mixing distinct concerns,\r\nbut at the low level we're
    working at it's understandable that nearly\r\ninfinite flexibility is desireable.\r\n\r\nDespite
    the conceptual complexity, the `Storage` class is extremely easy to \r\nimplement.
    In fact, it takes less than 80 lines of code if you don't\r\nworry about validations
    and robustness:\r\n\r\n```ruby\r\nmodule Vintage\r\n  class Storage\r\n    PROGRAM_OFFSET
    = 0x0600\r\n    STACK_OFFSET   = 0x0100\r\n    STACK_ORIGIN   = 0xff\r\n\r\n    def
    initialize\r\n      @memory = Hash.new(0)\r\n      @pc     = PROGRAM_OFFSET\r\n
    \     @sp     = STACK_ORIGIN\r\n    end\r\n\r\n    attr_reader :pc, :sp\r\n\r\n
    \   def load(bytes)\r\n      index = PROGRAM_OFFSET\r\n\r\n      bytes.each_with_index
    { |c,i| @memory[index+i] = c }\r\n    end\r\n\r\n    def [](address)\r\n      @memory[address]\r\n
    \   end\r\n\r\n    def []=(address, value)\r\n      @memory[address] = (value
    & 0xff)\r\n    end\r\n\r\n    def next\r\n      @memory[@pc].tap { @pc += 1 }\r\n
    \   end\r\n\r\n    def jump(address)\r\n      @pc = address\r\n    end\r\n\r\n
    \   def branch(test, address)\r\n      return unless test\r\n\r\n      @pc = address\r\n
    \   end\r\n\r\n    def jsr(address)\r\n      low, high = bytes(@pc)\r\n\r\n      push(low)\r\n
    \     push(high)\r\n\r\n      jump(address)\r\n    end\r\n\r\n    def rts\r\n
    \     h = pull\r\n      l = pull\r\n\r\n      @pc = int16([l, h])\r\n    end\r\n\r\n
    \   def push(value)\r\n      @memory[STACK_OFFSET + @sp] = value\r\n      @sp
    -= 1\r\n    end\r\n\r\n    def pull\r\n      @sp += 1\r\n\r\n      @memory[STACK_OFFSET
    + @sp]\r\n    end\r\n\r\n    def int16(bytes)\r\n      bytes.pack(\"c*\").unpack(\"v\").first\r\n
    \   end\r\n\r\n    def bytes(num)\r\n      [num].pack(\"v\").unpack(\"c*\")\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nFor such boring code, its a bit surprising
    to think that it can be a fundamental\r\nbuilding block for generic computing.
    Keep in mind of course that we're building\r\na simulation and not a real piece
    of hardware, and we're doing it in one of the\r\nhighest level languages you can
    use.\r\n\r\nIf it already feels like we're cheating, just wait until you see the
    next trick!\r\n\r\n## Memory-mapped I/O\r\n\r\nTo implement Snake6502, our simulator
    needs to be able to generate random\r\nnumbers, read keyboard input, and also
    display graphics on the screen. None of\r\nthese features are directly supported
    by the 6502 instruction set, so that means\r\nthat every individual system had
    to come up with its own way of doing things.\r\nThis is one of many things that
    causes machine code (especially old-school\r\nmachine code) to not be directly
    portable from one system to another.\r\n\r\nBecause we're trying to get Snake6502
    to run in our simulator without modifying\r\nits bytecode, we're more-or-less
    constrained to following the approach used by\r\nthe Easy6502 simulator: memory-mapped
    I/O.\r\n\r\nThis approach is actually very easy to implement in a simulated environment:
    you\r\nadd hooks around certain memory addresses so that when they are accessed,
    they\r\nexecute some custom code rather than directly reading or writing a \r\nvalue
    to memory. In the case of Snake6502, we expect the following behaviors:\r\n\r\n*
    Reading from `$fe`  returns a random 8-bit integer.\r\n* Reading from `$ff` retrieves
    the ASCII code of the last key \r\npressed on the keyboard.\r\n* Writing to addresses
    between `$0200` to `$05ff` will render\r\npixels to the screen. (`$0200` is the
    top-left corner\r\nof the 32x32 display, and `$05ff` is the bottom-right corner.)\r\n\r\nThese
    features could be added directly to the `Storage` class,  but it would\r\nfeel
    a bit awkward to clutter up a generic module with some very specific edge\r\ncases.
    For that reason, it is probably better to implement them as a module\r\nmixin:
    \r\n\r\n```ruby\r\nmodule Vintage\r\n  module MemoryMap\r\n    RANDOMIZER  = 0xfe\r\n
    \   KEY_PRESS   = 0xff\r\n    PIXEL_ARRAY = (0x0200..0x05ff)\r\n\r\n    attr_accessor
    :ui\r\n\r\n    def [](address)\r\n      case address\r\n      when RANDOMIZER\r\n
    \       rand(0xff)\r\n      when KEY_PRESS\r\n        ui.last_keypress\r\n      else\r\n
    \       super\r\n      end\r\n    end\r\n\r\n    def []=(k, v)\r\n      super\r\n\r\n
    \     if PIXEL_ARRAY.include?(k)\r\n        ui.update(k % 32, (k - 0x0200) / 32,
    v % 16)\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou probably already
    have a good idea of how `MemoryMap` works from seeing\r\nits implementation, but
    it wouldn't hurt to see an example of how it is\r\nused before we move on. Here's
    how to display a single pixel on the \r\nscreen, randomly varying its color until
    the spacebar (ASCII code 0x20) \r\nis pressed:\r\n\r\n```ruby\r\nmem = Vintage::Storage.new\r\nmem.extend(Vintage::MemoryMap)\r\n\r\nmem.ui
    = Vintage::Display.new \r\n\r\n(mem[0x0410] = mem[0xfe]) until mem[0xff] == 0x20
    \r\n```\r\n\r\nIt's worth noting that this is the only code in the entire simulator
    that\r\ndirectly depends on a connection to some sort of user interface, and the\r\nprotocol
    consists of just two methods: `ui.update(x, y, color)` and\r\n`ui.last_keypress`.
    In our case, we use a JRuby-based GUI, but anything\r\nelse could be substituted
    as long as it implemented these two methods.\r\n\r\nAt this point, our storage
    model is pretty much complete. We now can \r\nturn our attention to various number
    crunching features.\r\n\r\n## Registers and Flags\r\n\r\nIn order to get Snake6502
    to run, we need all six of\r\nthe programmable registers that the processor provides.
    We've handled two of\r\nthem already (the stack pointer and the program counter),
    so we just have four\r\nmore to implement: A, X, Y, and P. A few design constraints
    will help make this\r\nwork go a whole lot faster:\r\n\r\n* Most of the operations
    that can be done on A are done the same way on X and Y,\r\nso we can implement
    some generic functions that operate on all three of them.\r\n\r\n* We can implement
    the status register (P) as a collection of individual\r\nattributes, rather than
    seven 1-bit flags packs into a single byte.\r\n\r\n* Because Snake6502 only relies
    on the (c)arry, (n)egative, and (z)ero flags\r\nfrom the status register, we can
    skip implementing the other four status flags \r\nand still have a playable game.\r\n\r\nWith
    those limitations in mind, let's work through some specs to understand\r\nhow
    this model ought to behave. For starters, we'll be building a `Vintage::CPU` \r\nthat
    implements three registers and three flags, initializing them all to \r\nzero
    by default:\r\n\r\n```ruby\r\ndescribe \"CPU\" do\r\n  let(:cpu) { Vintage::CPU.new
    }\r\n\r\n  let(:registers) { [:a, :x, :y] }\r\n  let(:flags)     { [:c, :n, :z]
    }\r\n  \r\n  it \"initializes registers and flags to zero\" do\r\n    (registers
    + flags).each { |e| cpu[e].must_equal(0) }\r\n  end\r\n\r\n   #...\r\nend\r\n```\r\n\r\nIt
    will be possible to directly set registers via the `#[]=` method, because\r\nthe
    behavior will be the same for all three registers:\r\n\r\n```ruby\r\nit \"allows
    directly setting registers\" do\r\n  registers.each do |e|\r\n    value  = rand(0xff)\r\n\r\n
    \   cpu[e] = value\r\n    cpu[e].must_equal(value)\r\n  end\r\nend\r\n```\r\n\r\nHowever,
    because flags don't have the same update semantics as registers, we \r\nwill not
    allow directly setting them via `#[]=`:\r\n\r\n```ruby\r\nit \"does not allow
    directly setting flags\" do\r\n  flags.each do |e|\r\n    value  = rand(0xff)\r\n\r\n
    \   err = -> { cpu[e] = value }.must_raise(ArgumentError)\r\n    err.message.must_equal
    \"#{e.inspect} is not a register\"\r\n  end\r\nend\r\n```\r\n\r\nThe carry flag
    (c) can toggled via the `set_carry` and `clear_carry` \r\nmethods. We'll need
    this later for getting the `CPU`  into\r\na clean state whenever we do addition
    and subtraction \r\noperations:\r\n\r\n```ruby\r\nit \"allows setting the c flag
    via set_carry and clear_carry\" do\r\n  cpu.set_carry\r\n  expect_flags(:c =>
    1)\r\n\r\n  cpu.clear_carry\r\n  expect_flags(:c => 0)\r\nend\r\n```\r\n\r\nSome
    other instructions will require us to set the carry flag\r\nbased on arbitrary
    conditions, so we'll need support for that as well:\r\n\r\n```ruby\r\nit \"allows
    conditionally setting the c flag via carry_if\" do\r\n  # true condition\r\n  x
    = 3\r\n  cpu.carry_if(x > 1)\r\n\r\n  expect_flags(:c => 1)\r\n\r\n  # false condition\r\n
    \ x = 0\r\n  cpu.carry_if(x > 1)\r\n\r\n  expect_flags(:c => 0)\r\nend\r\n```\r\n\r\nThe
    N and Z flags are set based on whatever result the `CPU` last processed:\r\n\r\n```ruby\r\nit
    \"sets z=1 when a result is zero, sets z=0 otherwise\" do\r\n  cpu.result(0)\r\n
    \ expect_flags(:z => 1)\r\n\r\n  cpu.result(0xcc)\r\n  expect_flags(:z => 0)\r\nend\r\n\r\nit
    \"sets n=1 when result is 0x80 or higher, n=0 otherwise\" do\r\n  cpu.result(rand(0x80..0xff))\r\n
    \ expect_flags(:n => 1)\r\n\r\n  cpu.result(rand(0x00..0x7f))\r\n  expect_flags(:n
    => 0)\r\nend\r\n```\r\n\r\nThe `result` method also returns a number truncated
    to fit in a single byte,\r\nbecause pretty much every place we could store a number
    in this system\r\nexpects 8-bit integers:\r\n\r\n```ruby\r\nit \"truncates results
    to fit in a single byte\" do\r\n  cpu.result(0x1337).must_equal(0x37)\r\nend  \r\n```\r\n\r\nTo
    help keep the `CPU` in a consistent state and to simplify the work\r\ninvolved
    in many of the 6502 instructions, we automatically call `cpu.result`\r\nwhenever
    a register is set via `CPU#[]=`. The tests below show the \r\nthe effects of that
    behavior:\r\n\r\n```ruby\r\n  it \"implicitly calls result() when registers are
    set\" do\r\n    registers.each do |e|\r\n      cpu[e] = 0x100\r\n      \r\n      cpu[e].must_equal(0)\r\n
    \     expect_flags(:z => 1, :n => 0)\r\n\r\n      cpu[e] -= 1\r\n      \r\n      cpu[e].must_equal(0xff)\r\n
    \     expect_flags(:z => 0, :n => 1)\r\n    end\r\n  end\r\n```\r\n\r\nHere's
    an implementation that satisfies all of the tests we've seen so far:\r\n\r\n```ruby\r\nmodule
    Vintage\r\n  class CPU\r\n    def initialize\r\n      @registers = { :a => 0,
    :x => 0, :y => 0 }\r\n      @flags     = { :z => 0, :c => 0, :n => 0 }\r\n    end\r\n\r\n
    \   def [](key)\r\n      @registers[key] || @flags.fetch(key)\r\n    end\r\n\r\n
    \   def []=(key, value)\r\n      unless @registers.key?(key)\r\n        raise
    ArgumentError, \"#{key.inspect} is not a register\" \r\n      end\r\n\r\n      @registers[key]
    = result(value)\r\n    end\r\n\r\n    def set_carry\r\n      @flags[:c] = 1\r\n
    \   end\r\n\r\n    def clear_carry\r\n      @flags[:c] = 0\r\n    end\r\n\r\n
    \   def carry_if(test)\r\n      test ? set_carry : clear_carry\r\n    end\r\n\r\n
    \   def result(number)\r\n      number &= 0xff\r\n\r\n      @flags[:z] = (number
    == 0 ? 1 : 0)\r\n      @flags[:n] = number[7]\r\n\r\n      number\r\n    end\r\n
    \ end\r\nend\r\n```\r\n  \r\nPutting it all together, the role of the `CPU` class
    is mostly just to do some\r\nbasic numerical housekeeping that will make implementing
    6502 instructions\r\neasier. Consider for example, the `CMP` and `BEQ` operations,
    which can\r\nbe used together to form a primitive sort of `if` statement. We saw
    these two\r\noperations used together in the earlier example of keyboard input
    handling:\r\n\r\n```\r\n$064f    c9 77     CMP #$77     # check if the key was
    \"w\" (ASCII code 0x77)\r\n$0651    f0 0d     BEQ $0660    # if so, jump forward
    to $0660 \r\n```\r\n\r\nUsing a combination of the `CPU` and `Storage` objects
    we've already built, we'd\r\nbe able to define the `CMP` and `BEQ` operations
    as shown below:\r\n\r\n```ruby\r\nCMP do \r\n  cpu.carry_if(cpu[:a] >= mem[e])\r\n\r\n
    \ cpu.result( cpu[:a] - mem[e] )\r\nend\r\n\r\nBEQ { mem.branch(cpu[:z] == 1,
    e) }\r\n```\r\n\r\nEven if we ignore the `cpu.carry_if` call, we know from what
    we've seen\r\nalready that if `CPU#result` is called with a zero value, it will
    set the Z flag\r\nto 1. We also know that when `Storage#branch` is called with
    a true value, it\r\nwill jump to the specified address, otherwise it will do nothing
    at all. Putting\r\nthose two facts together with the Snake6502 shown above tells
    us that if the\r\nvalue in the A register is `0x77`, execution will jump to `$0600`.\r\n\r\nAt
    this point, we're starting to see how 6502 instructions can be\r\nmapped onto
    the objects we've already built, and that means we're \r\nclose to the finish
    line.  Before we get there, we only have two obstacles\r\nto clear: implementing
    addressing modes to handle operands, and building\r\na program runner that knows
    how to map raw 6502 code to the operation \r\ndefinitions shown above.\r\n\r\n##
    Addressing Modes\r\n\r\n> **NOTE:** The explanation that follows barely scrapes
    the surface of\r\nthis topic. If you want to really understand 6502 addressing
    modes, you should check\r\nout the [relevant section](http://skilldrick.github.io/easy6502/#addressing)\r\nin
    the Easy6502 tutorial.\r\n\r\nIn the very first exercise where we disassembled
    the first few instructions\r\nof Snake6502, we discovered the presence of several
    addressing modes\r\nthat cause operands to be interpreted in various different
    ways. To get\r\nthe game running, we will need to handle a total of eight different
    \r\naddressing modes.\r\n\r\nThis is a lot of different ways to generate an address,
    and its intimidating \r\nto realize we're only implementing an incomplete subset
    of what the 6502 processor \r\nprovides. However, its important to keep in mind
    that the only data structure \r\nwe have to work with is a simple mapping from
    16-bit integers to 8-bit \r\nintegers. Among other things, clever indexing can
    give us the functionality we'd\r\nexpect from variables, references, and arrays
    -- all the stuff that doesn't have\r\na direct representation in machine code.\r\n\r\nI'm
    going to show the definitions for all of the addressing modes used by\r\nSnake6502
    below, which probably won't make much sense at first glance. But try\r\nto see
    if you can figure out what some of this code doing:\r\n\r\n```ruby\r\nmodule Vintage\r\n
    \ module Operand\r\n    def self.read(mem, mode, x, y)\r\n      case mode\r\n
    \     when \"#\" # Implicit \r\n        nil\r\n      when \"@\" # Relative\r\n
    \       offset = mem.next\r\n\r\n        mem.pc + (offset <= 0x80 ? offset : -(0xff
    - offset + 1)) \r\n      when \"IM\" # Immediate\r\n        mem.pc.tap { mem.next
    }\r\n      when \"ZP\" # Zero Page\r\n        mem.next\r\n      when \"ZX\" #
    Zero Page, X\r\n        mem.next + x\r\n      when  \"AB\" # Absolute\r\n        mem.int16([mem.next,
    mem.next])\r\n      when \"IX\" # Indexed Indirect\r\n        e = mem.next\r\n\r\n
    \       mem.int16([mem[e + x], mem[e + x + 1]])\r\n      when \"IY\" # Indirect
    Indexed\r\n        e = mem.next\r\n\r\n        mem.int16([mem[e], mem[e+1]]) +
    y\r\n      else\r\n        raise NotImplementedError, mode.inspect\r\n      end\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nNow let's walk through them one-by-one.
    You can refer to the source code above as needed\r\nto make sense of the following
    examples.\r\n\r\n1) The implicit addressing mode is meant for instructions that
    either don't operate \r\non a memory address at all, or can infer the address
    internally. An example\r\nwe've already seen is the `RTS` operations that is used
    to return from a subroutine --\r\nit gets its data from the stack rather than
    from an operand, making it a single\r\nbyte instruction. \r\n\r\n2) The relative
    addressing mode is used by branches only. Consider\r\nthe following example:\r\n\r\n```\r\n$0651
    \   f0 0d     BEQ $0660    # if Z=1, jump to $0660 \r\n```\r\n\r\nBy the time
    the `$0d` operand is read, the program counter will be set to\r\n`$0653`. If you
    add these two numbers together, you get the address to jump to\r\nif Z=1: `$0660`.\r\n\r\n3)
    Immediate addressing is used when you want to have an instruction work on the\r\noperand
    itself. To do so, we return the operand's address, then increment the \r\nprogram
    counter as normal. In the example below, the computed address (`e`) \r\nis `0x0650`,
    and `mem[e] == 0x77`:\r\n\r\n```\r\n$064f    c9 77     CMP #$77\r\n```\r\n\r\n4)
    Zero page addressing is straightforward, it is simply refers to any address\r\nbetween
    `$00` and `$ff`. These are convenient for storing program data in, and\r\nare
    faster to access because they do not require combining two bytes into a 16\r\nbit
    integer. We've already seen copious use of this address mode throughout\r\nthe
    examples in this article, particularly when working with keyboard input\r\n(`$ff`)
    and random number generation (`$fe`).\r\n\r\n5) Zero page, X indexing is used
    for iterating over some simple sequences in\r\nmemory. For example, Snake6502
    stores the position of each part of the snakes\r\nbody in byte pairs starting
    at memory location `$10`. Using this addressing\r\nmode, it is possible to walk
    over the array by simply incrementing the X\r\nregister as you go.\r\n\r\n6) We've
    also seen plenty of examples of absolute addressing, especially when\r\nlooking
    at `JSR` operations. The only complication involved in processing\r\nthese addresses
    is that two bytes need to be read and then assembled into\r\na 16bit integer.
    But since we've had to do that in several places already,\r\nit should be easy
    enough to understand.\r\n\r\n7) Indexed indirect addressing gives us a way to
    dynamically compute an address\r\nfrom other addresses that we've stored in memory.
    That sounds really confusing,\r\nbut the following example should help clear it
    up. The code below is responsible\r\nfor moving the snake by painting a white
    pixel at its updated head position, and\r\npainting a black pixel at its old tail
    position:\r\n\r\n```\r\n$0720    a2 00       LDX #$00\r\n$0722    a9 01       LDA
    #$01\r\n$0724    81 10       STA ($10,X) \r\n$0726    a6 03       LDX $03\r\n$0728
    \   a9 00       LDA #$00\r\n$072a    81 10       STA ($10,X) \r\n```\r\n\r\nThe
    first three lines are hardcoded to look at memory locations `$10` and `$11` \r\nto
    form an address in the pixel array that refers to the new head of the \r\nsnake.
    The next three lines do something similar for the tail of the snake,\r\nbut with
    a twist: because the length of the snake is dynamic, it needs to\r\nbe looked
    up from memory. This value is stored in memory location `$03`.\r\nSo to unpack
    the whole thing, `STA ($10, X)` will take the address `$10`, add to\r\nit the
    number of bytes in the whole snake array, and then look up the address\r\nstored
    in the last position of that array. That address points to the snake's\r\ntail
    in the pixel array, which ends up getting set to black by this instruction.\r\n\r\n8)
    Indirect indexed addressing gives us yet another way to walk over multibyte\r\nstructures.
    In nake6502, this addressing mode is only used for drawing the\r\napple on the
    screen. Its position is stored in a 16-bit value stored \r\nin `$00` and `$01`,
    and the following code is used to set its color to a \r\nrandom value:\r\n\r\n```\r\n$0719
    \   a0 00       LDY #$00\r\n$071b    a5 fe       LDA $fe\r\n$071d    91 00       STA
    ($00),Y\r\n```\r\n\r\nThere are bound to be more interesting uses of these addressing
    modes, but we\r\nwe've certainly covered enough ground for now! Don't worry if
    you didn't\r\nunderstand this section that well, it took me many times reading
    the Easy6502\r\ntutorial and the source code for Snake6502 before I figured these
    out myself.\r\n\r\n## 6502 Simulator (finally!)\r\n\r\nWe are now finally at the
    point where all the hard stuff is done, and all that\r\nremains is to wire up
    the simulator itself. In other words, it's time for\r\nthe fun part of the project.\r\n\r\nThe
    input for the simulator will be a binary file containing the\r\nassembled program
    code for Snake6502. The bytes in that file not meant to\r\nbe read as printable
    characters, but they can be inspected using a hex editor:\r\n\r\n```\r\n$ hexdump
    examples/snake.rom\r\n0000000 20 06 06 20 38 06 20 0d 06 20 2a 06 60 a9 02 85\r\n0000010
    02 a9 04 85 03 a9 11 85 10 a9 10 85 12 a9 0f 85\r\n0000020 14 a9 04 85 11 85 13
    85 15 60 a5 fe 85 00 a5 fe\r\n0000030 29 03 18 69 02 85 01 60 20 4d 06 20 8d 06
    20 c3\r\n0000040 06 20 19 07 20 20 07 20 2d 07 4c 38 06 a5 ff c9\r\n0000050 77
    f0 0d c9 64 f0 14 c9 73 f0 1b c9 61 f0 22 60\r\n0000060 a9 04 24 02 d0 26 a9 01
    85 02 60 a9 08 24 02 d0\r\n0000070 1b a9 02 85 02 60 a9 01 24 02 d0 10 a9 04 85
    02\r\n0000080 60 a9 02 24 02 d0 05 a9 08 85 02 60 60 20 94 06\r\n0000090 20 a8
    06 60 a5 00 c5 10 d0 0d a5 01 c5 11 d0 07\r\n00000a0 e6 03 e6 03 20 2a 06 60 a2
    02 b5 10 c5 10 d0 06\r\n00000b0 b5 11 c5 11 f0 09 e8 e8 e4 03 f0 06 4c aa 06 4c\r\n00000c0
    35 07 60 a6 03 ca 8a b5 10 95 12 ca 10 f9 a5 02\r\n00000d0 4a b0 09 4a b0 19 4a
    b0 1f 4a b0 2f a5 10 38 e9\r\n00000e0 20 85 10 90 01 60 c6 11 a9 01 c5 11 f0 28
    60 e6\r\n00000f0 10 a9 1f 24 10 f0 1f 60 a5 10 18 69 20 85 10 b0\r\n0000100 01
    60 e6 11 a9 06 c5 11 f0 0c 60 c6 10 a5 10 29\r\n0000110 1f c9 1f f0 01 60 4c 35
    07 a0 00 a5 fe 91 00 60\r\n0000120 a2 00 a9 01 81 10 a6 03 a9 00 81 10 60 a2 00
    ea\r\n0000130 ea ca d0 fb 60\r\n0000135\r\n```\r\n\r\nThe challenge that is left
    to be completed is to process\r\nthe opcodes and operands in this file and turn
    them into\r\na running program. To do that, we will make use of a CSV file \r\nthat
    lists the operation name and addressing mode for each opcode \r\nfound in file:\r\n\r\n```\r\n00,BRK,#\r\n10,BPL,@\r\n18,CLC,#\r\n20,JSR,AB\r\n#
    ... rest of instructions go here ...\r\nE6,INC,ZP\r\nE8,INX,#\r\nE9,SBC,IM\r\nF0,BEQ,@\r\n```\r\n\r\nOnce
    we know the addressing mode for a given operation, we can read its\r\noperand
    and turn it into an address (denoted by `e`). And once we have *that*, \r\nwe
    can execute the commands that are defined in following DSL:\r\n\r\n```ruby\r\n#
    NOTE: This file contains definitions for every instruction used \r\n# by Snake6502.
    Most of the functionality here is a direct result\r\n# of simple calls to Vintage::Storage
    and Vintage::CPU instances.\r\n\r\nNOP { }\r\nBRK { raise StopIteration }\r\n\r\n\r\nLDA
    { cpu[:a] = mem[e] }\r\nLDX { cpu[:x] = mem[e] }\r\nLDY { cpu[:y] = mem[e] }\r\n\r\nTXA
    { cpu[:a] = cpu[:x] }\r\n\r\nSTA { mem[e] = cpu[:a] }\r\n\r\n## Counters\r\n\r\nINX
    { cpu[:x] += 1 }\r\nDEX { cpu[:x] -= 1 }\r\n\r\nDEC { mem[e] = cpu.result(mem[e]
    - 1) }\r\nINC { mem[e] = cpu.result(mem[e] + 1) } \r\n\r\n## Flow control\r\n\r\nJMP
    { mem.jump(e) }\r\n\r\nJSR { mem.jsr(e) }\r\nRTS { mem.rts }\r\n\r\nBNE { mem.branch(cpu[:z]
    == 0, e) }\r\nBEQ { mem.branch(cpu[:z] == 1, e) }\r\nBPL { mem.branch(cpu[:n]
    == 0, e) }\r\nBCS { mem.branch(cpu[:c] == 1, e) }\r\nBCC { mem.branch(cpu[:c]
    == 0, e) }\r\n\r\n## Comparisons\r\n\r\nCPX do \r\n  cpu.carry_if(cpu[:x] >= mem[e])\r\n\r\n
    \ cpu.result(cpu[:x] - mem[e]) \r\nend\r\n\r\nCMP do \r\n  cpu.carry_if(cpu[:a]
    >= mem[e])\r\n\r\n  cpu.result(cpu[:a] - mem[e]) \r\nend\r\n\r\n\r\n## Bitwise
    operations\r\n\r\nAND { cpu[:a] &= mem[e] }\r\nBIT { cpu.result(cpu[:a] & mem[e])
    }\r\n\r\nLSR do\r\n  t = (cpu[:a] >> 1) & 0x7F\r\n \r\n  cpu.carry_if(cpu[:a][0]
    == 1)\r\n  cpu[:a] = t\r\nend\r\n\r\n## Arithmetic\r\n\r\nSEC { cpu.set_carry
    \  }\r\nCLC { cpu.clear_carry }\r\n\r\nADC do \r\n  t = cpu[:a] + mem[e] + cpu[:c]\r\n\r\n
    \ cpu.carry_if(t > 0xff)\r\n  cpu[:a] = t\r\nend\r\n\r\nSBC do\r\n  t  = cpu[:a]
    - mem[e] - (cpu[:c] == 0 ? 1 : 0)\r\n\r\n  cpu.carry_if(t >= 0)\r\n  cpu[:a] =
    t\r\nend\r\n```\r\n\r\nWe can treat both the opcode lookup CSV and the instructions
    definitions DSL \r\nas configuration files, to be loaded into the configuration
    object \r\nshown below:\r\n\r\n```ruby\r\nrequire \"csv\"\r\n\r\nmodule Vintage\r\n
    \ class Config\r\n    CONFIG_DIR = \"#{File.dirname(__FILE__)}/../../config\"\r\n\r\n
    \   def initialize(name)\r\n      load_codes(name)\r\n      load_definitions(name)\r\n
    \   end\r\n\r\n    attr_reader :definitions, :codes\r\n\r\n    private\r\n\r\n
    \   def load_codes(name)\r\n      csv_data = CSV.read(\"#{CONFIG_DIR}/#{name}.csv\")\r\n
    \                   .map { |r| [r[0].to_i(16), [r[1].to_sym, r[2]]] }\r\n\r\n
    \     @codes = Hash[csv_data]\r\n    end\r\n\r\n    def load_definitions(name)\r\n
    \     @definitions = {}\r\n\r\n      instance_eval(File.read(\"#{CONFIG_DIR}/#{name}.rb\"))\r\n
    \   end\r\n\r\n    def method_missing(id, *a, &b)\r\n      return super unless
    id == id.upcase\r\n\r\n      @definitions[id] = b\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThen
    finally, we can tie everything together with a `Simulator` object that\r\ninstantiates
    all the objects we need, and kicks off a program execution loop:\r\n\r\n```ruby\r\nmodule
    Vintage\r\n  class Simulator\r\n    EvaluationContext = Struct.new(:mem, :cpu,
    :e)\r\n      \r\n    def self.run(file, ui)\r\n      config = Vintage::Config.new\r\n
    \     cpu    = Vintage::CPU.new\r\n      mem    = Vintage::Storage.new\r\n\r\n
    \     mem.extend(MemoryMap)\r\n      mem.ui = ui\r\n      \r\n      mem.load(File.binread(file).bytes)\r\n\r\n
    \     loop do\r\n        code = mem.next\r\n\r\n        op, mode = config.codes[code]\r\n
    \       if name\r\n          e = Operand.read(mem, mode, cpu[:x], cpu[:y])\r\n\r\n
    \         EvaluationContext.new(mem, cpu, e)\r\n                           .instance_exec(&config.definitions[op])\r\n
    \       else\r\n          raise LoadError, \"No operation matches code: #{'%.2x'
    % code}\"\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAt
    this point, you're ready to play Snake! Or if you've been following closely\r\nalong
    with this article all the way to the end, you're probably more likely to\r\nhave
    a cup of coffee or take a nap from information overload. Either way,\r\ncongratulations
    for making it all the way through this long and winding\r\nissue of Practicing
    Ruby!\r\n\r\n## Further Reading\r\n\r\nThis article and the [Vintage simulator](http://github.com/sandal/vintage)
    is built on top of a ton of other\r\npeople's ideas and learning resources. Here
    are some of the works I referred to\r\nwhile researching this topic:\r\n\r\n*
    [Easy 6502](http://skilldrick.github.io/easy6502/) by Nick Morgan\r\n* [Mos Technology
    6502](http://en.wikipedia.org/wiki/MOS_Technology_6502) @ Wikipedia\r\n* [Rockwell
    6502 Programmer's Manual](http://homepage.ntlworld.com/cyborgsystems/CS_Main/6502/6502.htm)
    \ by Bluechip\r\n* [NMos 6502 opcodes](http://www.6502.org/tutorials/6502opcodes.html)
    by John Pickens\r\n* [r6502](https://github.com/joelanders/r6502) by Joe Landers"
- :slug: infrastructure-automation
  :title: Infrastructure automation by example
  :summary: Discover why infrastructure automation matters by exploring real Chef
    recipes. (w. Mathias Lafeldt)
  :published: 2013-11-12 00:00:00.000000000 Z
  :issue_number: '7.6'
  :volume: 7
  :body: "> This issue of Practicing Ruby was a collaboration with Mathias Lafeldt\r\n([@mlafeldt](https://twitter.com/mlafeldt)),
    an Infrastructure\r\nDeveloper living in Hamburg, Germany. If Mathias had to choose
    the one\r\nInternet meme that best describes his work, it would certainly be\r\n_Automate
    all the things!_ \r\n\r\nFor at least as long as Ruby has been popular among web
    developers, it has also\r\nbeen recognized as a useful tool for system administration
    work. Although it was\r\nfirst used as a clean alternative to Perl for adhoc scripting,
    Ruby quickly\r\nevolved to the point where it became an excellent platform for
    large scale \r\ninfrastructure automation projects. \r\n\r\nIn this article, we'll
    explore realistic code that handles various system\r\nautomation tasks, and discuss
    what benefits the automated approach has over \r\ndoing things the old-fashioned
    way. We'll also see first-hand what it means to treat\r\n\"infrastructure as code\",
    and the impact it has on building maintainable systems. \r\n\r\n## Prologue: Why
    does infrastructure automation matter?\r\n\r\nTwo massive infrastructure automation
    systems have been built in \r\nRuby ([Puppet][puppet] and [Chef][chef]), both
    of which have entire open-source\r\necosystems supporting them. But because these
    frameworks were built by and for\r\nsystem administrators, infrastructure automation
    is often viewed as a\r\nspecialized skillset by Ruby programmers, rather than
    something that everyone\r\nshould learn. This is probably an incorrect viewpoint,
    but it is one that is\r\neasy to hold without realizing the consequences.\r\n\r\nSpeaking
    from my own experiences, I had always assumed that infrastructure\r\nautomation
    was a problem that mattered mostly for large-scale public web\r\napplications,
    internet service providers, and very complicated enterprise\r\nprojects. In those
    kinds of environments, the cost of manually setting up\r\nservers would obviously
    be high enough to justify using a \r\nsophisticated automation framework. But
    because I never encountered those\r\nscenarios in my own work, I was content to
    do things the old-fashioned way:\r\nreading lots of \"works for me\" instructions
    from blog posts, manually typing\r\ncommands on the console, and swearing loudly
    whenever I broke something. For\r\nthings that really matter or tasks that seemed
    too tough for me to do on my own,\r\nI'd find someone else to take care of it
    for me.\r\n\r\nThe fundamental problem was that my system-administration related
    pain wasn't \r\nsevere enough to motivate me to learn a whole new way of doing
    things. Because\r\nI never got curious enough about the topic, I didn't realize
    that infrastructure \r\nautomation has other benefits beyond eliminating the costs\r\nof
    doing repetitive and error-prone manual configuration work. In particular,\r\nI
    vastly underestimated the value of treating \"infrastructure as code\",\r\nespecially
    as it relates to creating systems that are abstract, modular,\r\ntestable, understandable,
    and utterly hackable. Narrowing the problem down to\r\nthe single issue of reducing
    repetitive labor, I had failed to see that\r\ninfrastructure automation has the
    potential to eliminate an entire class of\r\nproblems associated with manual system
    configuration.\r\n\r\nTo help me get unstuck from this particular viewpoint, Mathias
    Lafeldt offered\r\nto demonstrate to me why infrastructure automation matters,
    even if you aren't\r\nmaintaining hundreds of servers or spending dozens of hours
    a week babysitting\r\nproduction systems. To teach me this lesson, Mathias built
    a [Chef cookbook][pr-cookbook] to completely automate the process of building
    an environment suitable for running [Practicing Ruby's web application][pr-web],
    starting with nothing but a bare Ubuntu\r\nLinux installation. The early stages
    of this process weren't easy: Jordan and I\r\nhad to answer more questions about
    our system setup than I\r\never thought would be necessary. But as things fell
    into place and\r\nrecipes started getting written, the benefits of being able
    to conceptualize a\r\nsystem as code rather than as an amorphous blob of configuration
    files and\r\ninterconnected processes began to reveal themselves.\r\n\r\nThe purpose
    of this article is not to teach you how to get up and running with\r\nChef, nor
    is it meant to explain every last detail of the cookbook that\r\nMathias built
    for us. Instead, it will help you learn about the core concepts of\r\ninfrastructure
    automation the same way I did: by tearing apart a handful of real\r\nuse cases
    and seeing what you can understand about them. If you've never used\r\nan automated
    system administration workflow before, or if you've only ever run\r\ncookbooks
    that other people have provided for you, this article will give you a\r\nmuch
    better sense of why the idea of treating \"infrastructure as code\" matters.\r\nIf
    you already know the answer to that question, you may still benefit from\r\nlooking
    at the problem from a beginner's mindset. In either case, we have\r\na ton of
    code to work our way through, so let's get started!\r\n\r\n## A recipe for setting
    up Ruby \r\n\r\nLet's take a look at how Chef can be used \r\nto manage a basic
    Ruby installation. As you can see below, Chef\r\nuses a pure Ruby domain-specific
    language for defining its recipes,\r\nso it should be easy to read even if you've
    never worked with\r\nthe framework before:\r\n\r\n```ruby\r\ninclude_recipe \"ruby_build\"\r\n\r\nruby_version
    = node[\"practicingruby\"][\"ruby\"][\"version\"]\r\n\r\nruby_build_ruby(ruby_version)
    { prefix_path \"/usr/local\" }\r\n\r\nbash \"update-rubygems\" do\r\n  code   \"gem
    update --system\"\r\n  not_if \"gem list | grep -q rubygems-update\"\r\nend\r\n\r\ngem_package
    \"bundler\"\r\n```\r\n\r\nAt the high level, this recipe is responsible for handling
    the following tasks: \r\n\r\n1. Installing the `ruby-build` command line tool.\r\n2.
    Using `ruby-build` to compile and install Ruby to `/usr/local`.\r\n3. Updating
    RubyGems to the latest version.\r\n4. Installing the bundler gem.\r\n\r\nUnder
    the hood, a lot more is happening. Let's take a closer look at each\r\nstep to
    understand a bit more about how Chef recipes work.\r\n\r\n**Installing ruby-build**\r\n\r\n```ruby\r\ninclude_recipe
    \"ruby_build\"\r\n```\r\n\r\nIncluding the default recipe from the [ruby_build
    cookbook](https://github.com/fnichol/chef-ruby_build) \r\nin our own code takes
    care of installing the `ruby-build` command line utility, \r\nand also handles
    installing a bunch of low-level packages that are required to compile Ruby \r\non
    an Ubuntu system. But all of this work happens behind the scenes -- we just need
    \r\nto make use of the `ruby_build_ruby` command this cookbook provides and the
    rest will be \r\ntaken care of for us.\r\n\r\n**Compiling and installing Ruby**\r\n\r\n```ruby\r\nruby_version
    = node[\"practicingruby\"][\"ruby\"][\"version\"]\r\n\r\nruby_build_ruby(ruby_version)
    { prefix_path \"/usr/local\" }\r\n```\r\n\r\nIn our recipe, the version of Ruby
    we want to install is not specified\r\nexplicitly, but instead set elsewhere using
    Chef's attribute system.\r\nIn the cookbook's [default attributes file][pr-cookbook-attributes],
    you'll find an entry that\r\nlooks like this:\r\n\r\n```ruby\r\ndefault[\"practicingruby\"][\"ruby\"][\"version\"]
    = \"2.0.0-p247\"\r\n```\r\n\r\nChef has a very flexible and very complicated [attribute
    management system][chef-attributes], but its main purpose is the same as any configuration
    \r\nsystem: to keep source code as generic as possible by not hard-coding\r\napplication-specific
    values. By getting these values out of the\r\nsource file and into well-defined
    locations, it also makes it\r\neasy to see all of our application-specific configuration
    \r\ndata at once.\r\n\r\n**Updating RubyGems**\r\n\r\n```ruby\r\nbash \"update-rubygems\"
    do\r\n  code   \"gem update --system\"\r\n  not_if \"gem list | grep -q rubygems-update\"\r\nend\r\n```\r\n\r\nIn
    this code we make use of a couple shell commands, the \r\nfirst of which is obviously
    responsible for updating RubyGems.\r\nThe second command is a guard that prevents
    the gem update\r\ncommand from running more than once.\r\n\r\nMost actions in
    Chef have similar logic baked into them to\r\nmake sure operations are only carried
    out when necessary. These \r\nguard clauses are handled internally whenever there
    is a well defined \r\ncondition to check for, so you don't need to think about
    them often.\r\nIn the case of shell commands the operation is potentially arbitrary,\r\nso
    a custom guard clause is necessary.\r\n\r\n**Installing bundler**\r\n\r\n```ruby\r\ngem_package
    \"bundler\"\r\n```\r\n\r\nThis command is roughly equivalent to typing `gem install
    bundler` on the\r\ncommand line. Because we installed Ruby into `/usr/local`,
    it will be used as\r\nour system Ruby, and so we can use `gem_package` without
    any additional\r\nsettings. More complicated system setups would involve a bit
    more\r\ncode than what you see above, but for our purposes we're able to keep
    \r\nthings simple.\r\n\r\nPutting all of these ideas together, we end up not just
    with an understanding of\r\nhow to go about installing Ruby using a Chef recipe,
    but also a glimpse\r\nof a few of the benefits of treating \"infrastructure as
    code\". As we\r\ncontinue to work through more complicated examples, those benefits\r\nwill
    become even more obvious.\r\n\r\n## A recipe for setting up process monitoring
    \r\n\r\nNow that we've tackled a simple example of a Chef recipe, let's work through
    \r\na more interesting one. The following code is what we use for installing\r\nand
    configuring the [God][god] process monitoring framework:\r\n\r\n```ruby\r\ninclude_recipe
    \"practicingruby::_ruby\"\r\n\r\ngem_package \"god\"\r\n\r\ndirectory \"/etc/god\"
    do\r\n  owner \"root\"\r\n  group \"root\"\r\n  mode  \"0755\"\r\nend\r\n\r\nfile
    \"/etc/god/master.conf\" do\r\n  owner    \"root\"\r\n  group    \"root\"\r\n
    \ mode     \"0644\"\r\n  notifies :restart, \"service[god]\"\r\n\r\n  home     =
    node[\"practicingruby\"][\"deploy\"][\"home_dir\"] \r\n  god_file = \"#{home}/current/config/delayed_job.god\"\r\n\r\n
    \ content \"God.load('#{god_file}') if File.file?('#{god_file}')\"\r\nend\r\n\r\ncookbook_file
    \"/etc/init/god.conf\" do\r\n  source \"god.upstart\"\r\n  owner  \"root\"\r\n
    \ group  \"root\"\r\n  mode   \"0644\"\r\nend\r\n\r\nservice \"god\" do\r\n  provider
    Chef::Provider::Service::Upstart\r\n  action   [:enable, :start]\r\nend\r\n```\r\n\r\nThe
    short story about this recipe is that it handles the following tasks:\r\n\r\n1.
    Installing the `god` gem.\r\n2. Setting up some configuration files for `god`.\r\n3.
    Registering `god` as a service to run at system boot.\r\n4. Starting the `god`
    service as soon as the recipe is run.\r\n\r\nBut that's just the 10,000 foot view
    -- let's get down in the weeds a bit.\r\n\r\n**Installing god via RubyGems**\r\n\r\n```ruby\r\ninclude_recipe
    \"practicingruby::_ruby\"\r\n\r\ngem_package \"god\"\r\n```\r\n\r\nGod is distributed
    as a gem, so we need to make sure Ruby is installed\r\nbefore we can make use
    of it. To do this, we include the Ruby installation\r\nrecipe that was shown earlier.
    If the Ruby recipe hasn't run yet, it will\r\nbe executed now, but if it has already
    run then `include_recipe` will\r\ndo nothing at all. In either case, we can be
    sure that we have a\r\nworking Ruby configuration by the time the `gem_package`
    command is called.\r\n\r\nThe `gem_package` command itself works exactly the same
    way as it did when we\r\nused it to install Bundler in the Ruby recipe, so there's
    nothing new to say\r\nabout it.\r\n\r\n**Setting up a master configuration file**\r\n\r\n```ruby\r\ndirectory
    \"/etc/god\" do\r\n  owner \"root\"\r\n  group \"root\"\r\n  mode  \"0755\"\r\nend\r\n\r\nfile
    \"/etc/god/master.conf\" do\r\n  owner    \"root\"\r\n  group    \"root\"\r\n
    \ mode     \"0644\"\r\n  notifies :restart, \"service[god]\"\r\n\r\n  home     =
    node[\"practicingruby\"][\"deploy\"][\"home_dir\"] \r\n  god_file = \"#{home}/current/config/delayed_job.god\"\r\n\r\n
    \ content \"God.load('#{god_file}') if File.file?('#{god_file}')\"\r\nend\r\n```\r\n\r\nA
    master configuration file is typically used with God to load\r\nall of the process-specific
    configuration files for a whole system \r\nwhen God starts up. In our case, we
    only have one process to watch, \r\nso our master configuration is a simple one-line
    shim that points at the\r\n[delayed_job.god][pr-web-dj] file that is deployed
    alongside our Rails \r\napplication.\r\n\r\nBecause our `/etc/god/master.conf`
    file is so trivial, we directly specify \r\nits contents in the recipe itself
    rather than using one of Chef's more\r\ncomplicated mechanisms for dealing with
    configuration files. In this\r\nparticular case, manually creating the file would
    certainly involve\r\nless work, but we'd lose some of the benefits that Chef is
    providing here.\r\n\r\nIn particular, it's worth noticing that file permissions
    and ownership\r\nare explicitly specified in the recipe, that the actual location\r\nof
    the file is configurable, and that Chef will send a notification\r\nto restart
    God whenever this file changes. All of these things\r\nare the sort of minor details
    that are easily forgotten when\r\nmanually managing configuration files on servers.\r\n\r\n**Running
    god as a system service**\r\n\r\nGod needs to be running at all times, so we want
    to make sure that it started on\r\nsystem reboot and cleanly terminated when the
    system is shut down. To do that, we\r\ncan configure God to run as an Upstart
    service. To do that, we need to create\r\nyet another configuration file:\r\n\r\n```ruby\r\ncookbook_file
    \"/etc/init/god.conf\" do\r\n  source \"god.upstart\"\r\n  owner  \"root\"\r\n
    \ group  \"root\"\r\n  mode   \"0644\"\r\nend\r\n```\r\n\r\nThe `cookbook_file`
    command used here is similar to the `file` command, but has a\r\nspecialized purpose:
    To copy files from a cookbook's `files` directory to\r\nsome location on the system
    being automated. In this case, we're\r\nusing the `files/default/god.upstart`
    cookbook file as our source, and it\r\nlooks like this:\r\n\r\n```\r\ndescription
    \"God is a monitoring framework written in Ruby\"\r\n\r\nstart on runlevel [2345]\r\nstop
    on runlevel [!2345]\r\n\r\npre-start exec god -c /etc/god/master.conf\r\npost-stop
    exec god terminate\r\n```\r\n\r\nHere we can see exactly what commands are going
    to be used to start and \r\nshutdown God, as well as the runlevels that it will
    be started and\r\nstopped on. We can also see that the `/etc/god/master.conf`
    file we\r\ncreated earlier will be loaded by God whenever it starts up.\r\n\r\nNow
    all that remains is to enable the service to run when the system\r\nboots, and
    also tell it to start up right now:\r\n\r\n```ruby\r\nservice \"god\" do\r\n  provider
    Chef::Provider::Service::Upstart\r\n  action   [:enable, :start]\r\nend\r\n```\r\n\r\nIt's
    worth mentioning here that if we didn't explicitly specify the\r\n`Service::Upstart`
    provider, Chef would expect the service\r\nconfiguration file to be written as
    a [System-V init\r\nscript][god-init], which are written at a much lower level
    of abstraction. There\r\nisn't anything wrong with doing things that way, but
    Upstart\r\nscripts are definitely more readable. \r\n\r\nBy this point, we've
    already seen how Chef can be used to install packages,\r\nmanage configuration
    files, run arbitrary shell commands, \r\nand set up system services. That knowledge
    alone will take you far,\r\nbut let's look at one more recipe to discover a few
    more \r\nadvanced features before we wrap things up.\r\n\r\n## A recipe for setting
    up an Nginx web server \r\n\r\nThe recipe we use for configuring Nginx is the
    most complicated one in\r\nPracticing Ruby's cookbook, but it mostly just combines
    and expands upon the\r\nconcepts we've already discussed. Try to see what you
    can\r\nunderstand of it before reading the explanations that follow, but don't\r\nworry
    if every last detail isn't immediately clear to you:\r\n\r\n```ruby\r\nnode.set[\"nginx\"][\"worker_processes\"]
    \    = 4\r\nnode.set[\"nginx\"][\"worker_connections\"]   = 768\r\nnode.set[\"nginx\"][\"default_site_enabled\"]
    = false\r\n\r\ninclude_recipe \"nginx::default\"\r\n\r\nssl_dir = ::File.join(node[\"nginx\"][\"dir\"],
    \"ssl\")\r\ndirectory ssl_dir do\r\n  owner \"root\"\r\n  group \"root\"\r\n  mode
    \ \"0600\"\r\nend\r\n\r\ndomain_name = node[\"practicingruby\"][\"rails\"][\"host\"]\r\nbash
    \"generate-ssl-files\" do\r\n  cwd   ssl_dir\r\n  flags \"-e\"\r\n  code <<-EOS\r\n
    \   DOM=#{domain_name}\r\n    openssl genrsa -out $DOM.key 4096\r\n    openssl
    req -new -batch -subj \"/CN=$DOM\" -key $DOM.key -out $DOM.csr\r\n    openssl
    x509 -req -days 365 -in $DOM.csr -signkey $DOM.key -out $DOM.crt\r\n    rm $DOM.csr\r\n
    \ EOS\r\n  notifies :reload, \"service[nginx]\"\r\n  not_if   { ::File.exists?(::File.join(ssl_dir,
    domain_name + \".crt\")) }\r\nend\r\n\r\ntemplate \"#{node[\"nginx\"][\"dir\"]}/sites-available/practicingruby\"
    do\r\n  source \"nginx_site.erb\"\r\n  owner  \"root\"\r\n  group  \"root\"\r\n
    \ mode   \"0644\"\r\n  variables(:domain_name => domain_name)\r\nend\r\n\r\nnginx_site
    \"practicingruby\" do\r\n  enable true\r\nend\r\n```\r\n\r\nWhen you put all the
    pieces together, this recipe is responsible for the\r\nfollowing tasks:\r\n\r\n1.
    Overriding some default Nginx configuration values.\r\n2. Installing Nginx and
    managing it as a service.\r\n3. Generating a self-signed SSL certificate based
    on a configurable domain name.\r\n4. Using a template to generate a site-specific
    configuration file.\r\n5. Enabling Nginx to serve up our Rails application.\r\n\r\nIn
    this recipe even more than the others we've looked at, a lot of the details\r\nare
    handled behind the scenes. Let's dig a bit deeper to see what's really\r\ngoing
    on.\r\n\r\n**Installing and configuring Nginx**\r\n\r\nWe rely on the nginx cookbook
    to do most of the hard work of \r\nsetting up our web server for us. Apart\r\nfrom
    overriding a few default attributes, we only need to include the\r\n`nginx:default`
    recipe into our own code to install the relevant software \r\npackages, generate
    an `nginx.conf` file, and to provide all the necessary\r\ninit scripts to manage
    Nginx as a service. The following four lines\r\nof code take care of all of that
    for us:\r\n\r\n```ruby\r\nnode.set[\"nginx\"][\"worker_processes\"]     = 4\r\nnode.set[\"nginx\"][\"worker_connections\"]
    \  = 768\r\nnode.set[\"nginx\"][\"default_site_enabled\"] = false\r\n\r\ninclude_recipe
    \"nginx::default\"\r\n```\r\n\r\nThe interesting thing to notice here is that
    unlike the typical server\r\nconfiguration file, only the things we explicitly
    changed are visible here.\r\nAll the rest of the defaults are set automatically
    for us, and we don't\r\nneed to be concerned with their values until the time
    comes when we decide we\r\nneed to change them. By hiding all the details that
    do not matter to us,\r\nChef recipes tend to be much more intention revealing
    than\r\nthe typical server configuration file.\r\n\r\n**Generating SSL keys**\r\n\r\nIn
    a real production environment, we would probably copy SSL credentials\r\ninto
    place rather than generating them on the fly. However, since\r\nthis particular
    cookbook provides a blueprint for building an experimental testbed\r\nrather than
    an exact clone of our live system, we handle this task internally to make the
    system a little bit more developer-friendly.\r\n\r\nThe basic idea behind the
    following code is that we want to generate an SSL\r\ncertificate and private key
    for whatever domain name you'd like, so that \r\nit is possible to serve up the
    application over SSL within a virtualized \r\nstaging environment. But since that
    is somewhat of an obscure use case, you\r\ncan focus on what interesting Chef
    features are being used\r\nin the following code rather than the particular shell
    code being executed:\r\n\r\n```ruby\r\nssl_dir = ::File.join(node[\"nginx\"][\"dir\"],
    \"ssl\")\r\ndirectory ssl_dir do\r\n  owner \"root\"\r\n  group \"root\"\r\n  mode
    \ \"0600\"\r\nend\r\n\r\ndomain_name = node[\"practicingruby\"][\"rails\"][\"host\"]\r\nbash
    \"generate-ssl-files\" do\r\n  cwd   ssl_dir\r\n  flags \"-e\"\r\n  code <<-EOS\r\n
    \   DOM=#{domain_name}\r\n    openssl genrsa -out $DOM.key 4096\r\n    openssl
    req -new -batch -subj \"/CN=$DOM\" -key $DOM.key -out $DOM.csr\r\n    openssl
    x509 -req -days 365 -in $DOM.csr -signkey $DOM.key -out $DOM.crt\r\n    rm $DOM.csr\r\n
    \ EOS\r\n  notifies :reload, \"service[nginx]\"\r\n  not_if   { ::File.exists?(::File.join(ssl_dir,
    domain_name + \".crt\")) }\r\nend\r\n```\r\n\r\nAs you read through this code,
    you may have noticed that `::File` is used\r\ninstead of `File`, which looks a
    bit awkward. The problem here is that\r\nChef defines its own `File` class that
    ends up having a naming collision with\r\nRuby's core class. So to safely make
    use of Ruby's `File` class, we need to\r\nexplicitly do our constant lookup from
    the top-level namespace. This is just a\r\nsmall side effect of how Chef's recipe
    DSL is implemented, but it is\r\nworth noting to clear up any confusion.\r\n\r\nWith
    that distraction out of the way, we can skip right over the `directory`\r\ncode
    which we've seen in earlier recipes, and turn our attention to the `bash`\r\ncommand
    and its options. This example is far more interesting than the one we\r\nused
    to update RubyGems earlier, because in addition to specifying a command to\r\nexecute
    and a `not_if` guard clause, it also does all of the following things:\r\n\r\n*
    Switches the working directory to the SSL directory we created within our Nginx
    directory.\r\n* Sets the `-e` flag, which will abort the script if any command
    fails to run successfully.\r\n* Uses a service notification to tell Nginx to reload
    its configuration files\r\n\r\nFrom this we see that executing shell code via
    a Chef recipe isn't quite the\r\nsame thing as simply running some commands in
    a console. The entire surrounding\r\ncontext is also specified and verified, making
    it a whole lot more likely\r\nthat things will work the way you expect them to.
    If these benefits were\r\nharder to see in the Ruby installation recipe, they
    should be easier to\r\nrecognize now.\r\n\r\n**Configuring Nginx to serve up Practicing
    Ruby**\r\n\r\nAlthough the [nginx cookbook](https://github.com/opscode-cookbooks/nginx)
    takes care \r\nof setting up our `nginx.conf` file for us, it does not manage
    site \r\nconfigurations for us. We need to take care of that ourselves and\r\ntweak
    some settings dynamically, so that means telling our\r\nrecipe to make use of
    a template:\r\n\r\n```ruby\r\ntemplate \"#{node[\"nginx\"][\"dir\"]}/sites-available/practicingruby\"
    do\r\n  source \"nginx_site.erb\"\r\n  owner  \"root\"\r\n  group  \"root\"\r\n
    \ mode   \"0644\"\r\n  variables(:domain_name => domain_name)\r\nend\r\n```\r\n\r\nThe
    [full template](https://github.com/elm-city-craftworks/practicing-ruby-cookbook/blob/master/templates/default/nginx_site.erb)\r\nis
    a rather long file full of the typical Nginx boilerplate, but the small\r\nexcerpt
    below shows how it is customized using ERB to insert some dynamic\r\ncontent:\r\n\r\n```erb\r\nserver
    {\r\n  listen 80;\r\n  server_name <%= \"#{@domain_name} www.#{@domain_name}\"
    %>;\r\n  rewrite ^ https://$server_name$request_uri? permanent;\r\n}\r\n```\r\n\r\nOnce
    the configuration file is generated and stored in the right place, we\r\nenable
    it using the following command:\r\n\r\n```ruby\r\nnginx_site \"practicingruby\"
    do\r\n  enable true\r\nend\r\n```\r\n\r\nUnder the hood, the [nxensite](https://github.com/Dreyer/nxensite)
    script is used \r\nto do the actual work of enabling the site, but that implementation
    detail is \r\ndeliberately kept hidden from view.\r\n\r\nAt this point, we have
    studied enough features of Chef to establish a basic\r\nliteracy that will facilitate
    reading a wide range of recipes with only\r\na little bit of effort. At the very
    least, you now have enough\r\nknowledge to make sense of every recipe in Practicing
    Ruby's cookbook.\r\n\r\n## A cookbook for building a (mostly) complete Rails environment
    \r\n\r\nThe goal of this article was to give you a sense of what kinds of building\r\nblocks
    that Chef recipes are made up of so that you could see various\r\ninfrastructure
    automation concepts in practice. If you feel like you've\r\nmade it that far,
    you may now be interested in looking at how a complete\r\nautomation project is
    sewn together.\r\n\r\nThe full [Practicing Ruby cookbook][pr-cookbook] contains
    a total of eight recipes,\r\nthree of which we've already covered in this article.
    The five recipes\r\nwe did not discuss are responsible for handling the\r\nfollowing
    chores:\r\n\r\n* Creating and managing a deployment user account to be used by
    Capistrano.\r\n* Installing PostgreSQL and configuring a database for use with
    our Rails app.\r\n* Configuring Unicorn and managing it as an Upstart service.\r\n*
    Setting up some folders and files needed to deploy our Rails app.\r\n* Installing
    and managing MailCatcher as a service, to make email testing easier.\r\n\r\nIf
    you are curious about how these recipes work, go ahead and read them! Many\r\nare
    thin wrappers around external cookbook dependencies, and none of them use\r\nany
    Chef features that we haven't already discussed. Attempting to\r\nmake sense of
    how these recipes work would be a great way to test your \r\nunderstanding of
    what we covered in this article.\r\n\r\nIf you want to take things a step farther,
    you can actually try to provision a\r\nproduction-like environment for Practicing
    Ruby on your own system. The\r\ncookbook's [README file](https://github.com/elm-city-craftworks/practicing-ruby-cookbook#readme)
    is fairly detailed, and we have things set up to work within a\r\nvirtual machine
    that can run in isolation without having a negative impact\r\non your own development
    environment. We also simplify a few things to make\r\nsetup easier, such as swapping
    out GitHub authentication for OmniAuth developer\r\nmode, making most service
    integrations optional, and other little tweaks that\r\nmake it possible to try
    things out without having to do a bunch of \r\nconfiguration work.\r\n\r\nI absolutely
    recommend trying to run our cookbook on your own to learn a whole\r\nlot more
    about Chef, but fair warning: to do so you will need to become familiar\r\nwith
    the complex network of underplumbing that we intentionally avoided\r\ndiscussing
    in this article. It's not too hard to work your way through, but\r\nexpect some
    turbulence along the way.\r\n\r\n## Epilogue: What are the costs of infrastructure
    automation?\r\n\r\nThe process of learning from Practicing Ruby's cookbook, and
    the act\r\nof writing this article really convinced me that I had greatly underestimated\r\nthe
    potential benefits that infrastructure automation has to offer. However, it\r\nis
    important to be very clear on one point: there's no such thing as a \r\nfree lunch.\r\n\r\nAt
    my current stage of understanding, I feel the same about Chef as I do about\r\nRails:
    impressed by its vast capabilities, convinced of its utility, and shocked\r\nby
    its complexity. There are a tremendous amount of moving parts that you need\r\nto
    understand before it becomes useful, and many layers of subsystems that need\r\nto
    be wired up before you can actually get any of your recipes to run.\r\n\r\nAnother
    concern is that \"infrastructure as code\" comes with the drawbacks\r\nassociated
    with code and not just the benefits. Third-party cookbooks vary in\r\nquality
    and sometimes need to be patched or hacked to get them to work the way\r\nyou
    want, and some abstractions are leaky and leave you doing some tedious work \r\nat
    a lower level than you'd want. Dependency management is also complicated: using
    external cookbooks means introducing at least one more fragile package \r\ninstaller
    into your life.\r\n\r\nIn the case of Chef in particular, it is also a bit strange
    that although its\r\ninterface is mostly ordinary Ruby code, it has developed
    in a somewhat parallel\r\nuniverse where the user is assumed to know a lot about
    system administration,\r\nand very little about Ruby. This leads to some design
    choices that aren't\r\nnecessarily bad, but are at least surprising to an experienced
    Ruby developer.\r\n\r\nAnd as for infrastructure automation as a whole, well...
    it doesn't fully free\r\nyou from knowing quite a few details about the systems
    you are trying to manage.\r\nIt does allow you to express ideas at a higher level,
    but you still need to\r\nbe able to peel back the veneer and dive into some low
    level system\r\nadministration concepts whenever something doesn't work the way
    you expect it\r\nwould or doesn't support the feature you want to use via its
    high level\r\ninterface. In that sense, an automated system will not necessarily
    reduce\r\nlearning costs, it just has you doing a different kind of learning.\r\n\r\nDespite
    all these concerns, I have to say that this is one skillset that I wish\r\nI had
    picked up years ago, and I fully intend to look for opportunities\r\nto apply
    these ideas in my own projects. I hope after reading this article,\r\nyou will
    try to do the same, and then share your stories about your experiences.\r\n\r\n##
    Recommendations for further reading\r\n\r\nDespite having a very complex ecosystem,
    the infrastructure automation world\r\n(and especially the Chef community) have
    a ton of useful documentation that is\r\nfreely available and easy to get started
    with. Here are a few resources to try\r\nout if you want to continue exploring
    this topic on your own:\r\n\r\n* [Opscode Chef documentation](http://docs.opscode.com):
    The official Chef documentation; comprehensive and really well organized. \r\n\r\n*
    [Opscode public cookbooks](https://github.com/opscode-cookbooks): You can learn
    a lot by reading some of the most widely-used cookbooks in the Chef community.
    For complex examples, definitely check out the [apache2](https://github.com/opscode-cookbooks/apache2)
    and [mysql](https://github.com/opscode-cookbooks/mysql) cookbooks.\r\n\r\n* [#learnchef](https://learnchef.opscode.com/):
    A collection of tutorials and screencasts designed to help you learn Chef.\r\n\r\n*
    [Common Idioms in Chef Recipes](http://www.opscode.com/blog/2013/09/04/demystifying-common-idioms-in-chef-recipes/):
    Explanation of (possibly surprising) idioms that sometimes appear in recipe code.\r\n\r\n*
    [Learning Chef](http://mlafeldt.github.io/blog/2012/09/learning-chef): A friendly
    introduction to Chef written by Mathias.\r\n\r\nIf you've got some experience
    with infrastructure automation and have found\r\nother tutorials or articles that
    you like which aren't listed here, please leave\r\na comment. Mathias will also
    be watching the comments for this article, so\r\ndon't be afraid to ask any general
    questions you have about infrastructure\r\nautomation or Chef, too.\r\n\r\nThanks
    for making it all the way to the end of this article, and happy automating!\r\n\r\n[puppet]:
    http://projects.puppetlabs.com/projects/puppet\r\n[chef]: http://www.opscode.com/chef/\r\n[pr-cookbook]:
    https://github.com/elm-city-craftworks/practicing-ruby-cookbook/tree/1.0.8\r\n[pr-cookbook-attributes]:
    https://github.com/elm-city-craftworks/practicing-ruby-cookbook/blob/1.0.8/attributes/default.rb\r\n[pr-web]:
    https://github.com/elm-city-craftworks/practicing-ruby-web\r\n[chef-attributes]:
    http://docs.opscode.com/essentials_cookbook_attribute_files.html\r\n[God]: http://godrb.com/\r\n[god-init]:
    https://raw.github.com/elm-city-craftworks/practicing-ruby-cookbook/37ca12dc6432dfee955a70b6f2cc288e40782733/files/default/god.sh\r\n[pr-web-dj]:
    https://github.com/elm-city-craftworks/practicing-ruby-web/blob/master/config/delayed_job.god\r\n"
- :slug: wumpus
  :title: 'Hunt the Wumpus: An exercise in creative coding'
  :summary: 'Build Gregory Yob''s classic text-based game from scratch, using the
    provided test suite as a guide. '
  :published: 2013-12-11 00:00:00.000000000 Z
  :issue_number: '7.7'
  :volume: 7
  :body: " [Hunt the Wumpus][wikipedia] is a hide-and-seek game that takes place in
    an underground\r\ncave network full of interconnected rooms. To win the game,
    the player\r\nneeds to locate the evil Wumpus and kill it while avoiding various
    different \r\nhazards that are hidden within in the cave.\r\n\r\nOriginally written
    by Gregory Yob in the 1970s, this game is traditionally\r\nplayed using a text-based
    interface, which leaves plenty up to the\r\nplayer's imagination, and also makes
    programming easier for those who\r\nwant to build Wumpus-like games of their own.\r\n\r\nBecause
    of its simple but clever nature, Hunt the Wumpus has been ported \r\nto many different
    platforms and programming languages over the last several\r\ndecades. In this
    article, you will discover why this blast from the past \r\nserves as an excellent
    example of creative computing, and you'll also \r\nlearn how to implement it from
    scratch in Ruby.\r\n\r\n## Gameplay demonstration\r\n\r\nThere are only two actions
    available to the player throughout the game: to move\r\nfrom room to room, or
    to shoot arrows into nearby rooms in an attempt to kill \r\nthe Wumpus. Until
    the player knows for sure where the Wumpus is, most of their actions \r\nwill
    be dedicated to moving around the cave to gain a sense of its layout:\r\n\r\n
    \   You are in room 1.\r\n    Exits go to: 2, 8, 5\r\n    -----------------------------------------\r\n
    \   What do you want to do? (m)ove or (s)hoot? m\r\n    Where? 2\r\n    -----------------------------------------\r\n
    \   You are in room 2.\r\n    Exits go to: 1, 10, 3\r\n    -----------------------------------------\r\n
    \   What do you want to do? (m)ove or (s)hoot? m\r\n    Where? 10\r\n    -----------------------------------------\r\n
    \   You are in room 10.\r\n    Exits go to: 2, 11, 9\r\n\r\nEven after only a
    couple actions, the player can start to piece together\r\na map of the cave's
    topography, which will help them avoid getting lost\r\nas they continue their
    explorations:\r\n\r\n![](//i.imgur.com/5gCTOAt.png)\r\n\r\nPlay continues in this
    fashion, with the player wandering around until \r\na hazard is detected:\r\n\r\n
    \   What do you want to do? (m)ove or (s)hoot? m\r\n    Where? 11\r\n    -----------------------------------------\r\n
    \   You are in room 11.\r\n    Exits go to: 10, 8, 20\r\n    -----------------------------------------\r\n
    \   What do you want to do? (m)ove or (s)hoot? m\r\n    Where? 20\r\n    -----------------------------------------\r\n
    \   You are in room 20.\r\n    You feel a cold wind blowing from a nearby cavern.\r\n
    \   Exits go to: 11, 19, 17\r\n\r\nIn this case, the player has managed to get
    close\r\nto a bottomless pit, which is detected by the presence of\r\na cold wind
    emanating from an adjacent room.\r\n\r\nBecause hazards are sensed indirectly,
    the player needs to use a deduction\r\nprocess to know for sure which hazards
    are in what rooms. With the knowledge of\r\nthe cave layout so far, the only thing
    that is for certain is there is at least one\r\npit nearby, with both rooms 17
    and 19 being possible candidates. One of them\r\nmight be safe, but there is also
    a chance that BOTH rooms contain pits.\r\nIn a literal sense, the player might
    have reached a dead end:\r\n\r\n![](//i.imgur.com/D6aA2wl.png)\r\n\r\nA risky
    player might chance it and try one of the two rooms, but\r\nthat isn't a smart
    way to play. The safe option is to \r\nbacktrack in search of a different path
    through the cave:\r\n\r\n    What do you want to do? (m)ove or (s)hoot? m\r\n
    \   Where? 11\r\n    -----------------------------------------\r\n    You are
    in room 11.\r\n    Exits go to: 10, 8, 20\r\n    -----------------------------------------\r\n
    \   What do you want to do? (m)ove or (s)hoot? m\r\n    Where? 8\r\n    -----------------------------------------\r\n
    \   You are in room 8.\r\n    You smell something terrible nearby\r\n    Exits
    go to: 11, 1, 7\r\n\r\nChanging directions ends up paying off. Upon entering room
    8,\r\nthe terrible smell that is sensed indicates that the Wumpus is nearby,\r\nand
    because rooms 1 and 11 have already been visited, there\r\nis only one place left
    for the Wumpus to be hiding:\r\n\r\n    What do you want to do? (m)ove or (s)hoot?
    s\r\n    Where? 7\r\n    -----------------------------------------\r\n    YOU
    KILLED THE WUMPUS! GOOD JOB, BUDDY!!!\r\n\r\nAt the end of the hunt, the player's
    map ended up looking like this:\r\n\r\n![](//i.imgur.com/IZnqNNw.png)\r\n\r\nIn
    less fortunate circumstances, the player would need to do a lot more\r\nexploration
    before they could be certain about where the Wumpus \r\nwas hiding. Other hazards
    might also be encountered, including giant bats \r\nthat are capable of moving
    the player to a random location in the cave.\r\nBecause all these factors are
    randomized in each new game, Hunt the Wumpus\r\ncan be played again and again
    without ever encountering an identical\r\ncave layout.\r\n\r\nWe will discuss
    more about the game rules throughout the rest of this\r\narticle, but the few
    concepts illustrated in this demonstration are more \r\nthan enough for us to
    start modeling some of the key game objects.\r\nLet's get to work!\r\n\r\n## Implementing
    \"Hunt the Wumpus\" from scratch\r\n\r\nLike many programs from its era, Hunt
    the Wumpus was designed to \r\nbe hackable. If you look at one of the [original
    publications][atari]\r\nabout the game, you can see that the author actively encourages\r\ntweaking
    its rules, and even includes the full source code \r\nof the game.\r\n\r\nBefore
    you rush off to study the original implementation, remember that \r\nit was written
    four decades ago in BASIC. Unless you consider yourself\r\na technological archaeologist,
    it's probably not the best way to\r\nlearn about the game. With that in mind,
    I've put together a learning\r\nexercise that will guide you through implementing
    some of the core \r\ngame concepts of Hunt the Wumpus -- without getting bogged
    down in\r\nspecific game rules or having to write boring user interface code.\r\n\r\nIn
    particular, I want you to implement three classes that I have \r\nalready written
    the tests for:\r\n\r\n1. A `Wumpus::Room` class to manage hazards and connections
    between rooms\r\n2. A `Wumpus::Cave` class to manage the overall topography of
    the cave\r\n3. A `Wumpus::Player` class that handles sensing and encountering
    hazards\r\n\r\nYou can work through this exercise by [cloning its git repository][wumpus-diy],
    \r\nand following the instructions in the README. I have put the tests for each
    \r\nclass on its own branch, so that you can merge them into your own code \r\none
    at a time until you end up with a complete passing test suite.\r\n\r\nOnce these
    three classes are written, you'll be able to use my UI code \r\nand game logic
    to play a rousing round of Hunt the Wumpus. You'll\r\nalso be able to compare
    your own work to my [reference implementation][wumpus-ref]\r\nof the game, and
    discuss any questions or thoughts with me about\r\nthe differences between our
    approaches.\r\n\r\nThroughout the rest of this article, I will provide design
    and implementation\r\nnotes for each class, as well as a brief overview of how
    the game rules for\r\nHunt the Wumpus can be implemented using these objects.
    These notes\r\nshould help you interpret what the test suite is actually asking\r\nyou
    to build, and will also help you understand my reference\r\nimplementation.\r\n\r\n>
    **NOTE:** If you're short on time or aren't in the mood for hacking\r\nright now,
    you can still get a lot out of this exercise by simply \r\nthinking about how
    you'd write the code to pass the provided test \r\nsuite, and then looking my
    implementation. But it's definitely\r\nbetter to at least *try* to write some
    code yourself, even\r\nif you don't complete the full exercise.\r\n\r\n## Modeling
    rooms \r\n\r\nStructurally speaking, rooms and their connections form a simple
    undirected graph:\r\n\r\n![](//i.imgur.com/p81T0Gn.png)\r\n\r\nOur `Room` class
    will manage these connections, and also make it easy \r\nto query and manipulate
    the hazards that can be found in a room --\r\nincluding bats, pits, and the wumpus
    itself. In particular, we will\r\nbuild an object with the following attributes
    and behaviors:\r\n\r\n```ruby\r\ndescribe \"A room\" do\r\n  it \"has a number\"\r\n
    \ it \"may contain hazards\"\r\n\r\n  describe \"with neighbors\" do\r\n    it
    \"has two-way connections to neighbors\"\r\n    it \"knows the numbers of all
    neighboring rooms\"\r\n    it \"can choose a neighbor randomly\"\r\n    it \"is
    not safe if it has hazards\" \r\n    it \"is not safe if its neighbors have hazards\"\r\n
    \   it \"is safe when it and its neighbors have no hazards\"\r\n  end\r\nend\r\n```\r\n\r\nLet's
    walk through each of these requirements individually and fill\r\nin the necessary
    details.\r\n\r\n1) Every room has an identifying number that helps the player
    keep \r\ntrack of where they are:\r\n\r\n```ruby\r\ndescribe \"A room\" do\r\n
    \ let(:room) { Wumpus::Room.new(12) }\r\n\r\n  it \"has a number\" do\r\n    room.number.must_equal(12)\r\n
    \ end\r\n\r\n  # ...\r\nend\r\n```\r\n\r\n2) Rooms may contain hazards, which
    can be added or removed as the \r\ngame progresses:\r\n\r\n```ruby\r\nit \"may
    contain hazards\" do \r\n  # rooms start out empty\r\n  assert room.empty?\r\n\r\n
    \ # hazards can be added\r\n  room.add(:wumpus)\r\n  room.add(:bats)\r\n\r\n  #
    a room with hazards isn't empty\r\n  refute room.empty?\r\n\r\n  # hazards can
    be detected by name\r\n  assert room.has?(:wumpus)\r\n  assert room.has?(:bats)\r\n\r\n
    \ refute room.has?(:alf)\r\n\r\n  # hazards can be removed\r\n  room.remove(:bats)\r\n
    \ refute room.has?(:bats)\r\nend\r\n```\r\n\r\n3) Each room can be connected to
    other rooms in the cave:\r\n\r\n```ruby\r\ndescribe \"with neighbors\" do\r\n
    \ let(:exit_numbers) { [11, 3, 7] }\r\n\r\n  before do\r\n    exit_numbers.each
    { |i| room.connect(Wumpus::Room.new(i)) }\r\n  end\r\n\r\n   # ...\r\nend\r\n```\r\n\r\n4)
    One-way paths are not allowed, i.e. all connections between rooms are\r\nbidirectional:\r\n\r\n```ruby\r\nit
    \"has two-way connections to neighbors\" do\r\n  exit_numbers.each do |i| \r\n
    \   # a neighbor can be looked up by room number\r\n    room.neighbor(i).number.must_equal(i)\r\n\r\n
    \   # Room connections are bidirectional\r\n    room.neighbor(i).neighbor(room.number).must_equal(room)\r\n
    \ end\r\nend\r\n```\r\n\r\n5) Each room knows all of its exits, which consist
    of\r\nall neighboring room numbers:\r\n\r\n```ruby\r\nit \"knows the numbers of
    all neighboring rooms\" do\r\n  room.exits.must_equal(exit_numbers)\r\nend\r\n```\r\n\r\n6)
    Neighboring rooms can be selected at random, which is\r\nuseful for certain game
    events:\r\n\r\n```ruby\r\nit \"can choose a neighbor randomly\" do\r\n  exit_numbers.must_include(room.random_neighbor.number)\r\nend\r\n```\r\n\r\n7)
    A room is considered safe only if there are no hazards within it\r\nor any of
    its neighbors:\r\n\r\n```ruby\r\nit \"is not safe if it has hazards\" do\r\n  room.add(:wumpus)\r\n\r\n
    \ refute room.safe?\r\nend\r\n\r\nit \"is not safe if its neighbors have hazards\"
    do\r\n  room.random_neighbor.add(:wumpus)\r\n\r\n  refute room.safe?\r\nend\r\n\r\nit
    \"is safe when it and its neighbors have no hazards\" do\r\n  assert room.safe?\r\nend\r\n```\r\n\r\n**Implementation
    notes**\r\n\r\nBecause this object only handles basic data tranformations, it\r\nshouldn't
    be hard to implement. But if you get stuck, you\r\ncan always look at [my version
    of the Wumpus::Room class][wumpus-room].\r\n\r\n## Modeling the cave\r\n\r\nAlthough
    a game of Hunt the Wumpus can be played with an arbitrary cave layout,\r\nthe
    traditional Wumpus cave is based on the [dodecahedron][]. To\r\nmodel things this
    way, a room is placed at each vertex, and the edges form\r\nthe connections between
    rooms. If you squash the structure to fit in a\r\ntwo-dimensional space, you end
    up with the following graph:\r\n\r\n![](//i.imgur.com/Myxk4vS.png)\r\n\r\nEven
    though it would be technically possible to construct this structure without\r\na
    collection object by connecting rooms together in an ad-hoc fashion,\r\ntraversing
    the structure and manipulating it would be cumbersome. For that\r\nreason, we
    will build a `Wumpus::Cave` object with the following properties:\r\n\r\n```ruby\r\ndescribe
    \"A cave\" do\r\n  it \"has 20 rooms that each connect to exactly three other
    rooms\" \r\n  it \"can select rooms at random\"\r\n  it \"can move hazards from
    one room to another\"\r\n  it \"can add hazards at random to a specific number
    of rooms\"\r\n  it \"can find a room with a particular hazard\"\r\n  it \"can
    find a safe room to serve as an entrance\"\r\nend\r\n```\r\n\r\nSome of these
    features a bit tricky to explain comprehensively through\r\ntests, but the following
    examples should give you a basic idea of\r\nhow they're meant to work.\r\n\r\n1)
    The cave has 20 rooms, and each room is connected to exactly \r\nthree other rooms:\r\n\r\n```ruby\r\ndescribe
    \"A cave\" do\r\n  let(:cave)  { Wumpus::Cave.dodecahedron }\r\n  let(:rooms)
    { (1..20).map { |i| cave.room(i) } }\r\n\r\n  it \"has 20 rooms that each connect
    to exactly three other rooms\" do\r\n    rooms.each do |room|\r\n      room.neighbors.count.must_equal(3)\r\n
    \     \r\n      assert room.neighbors.all? { |e| e.neighbors.include?(room) }\r\n
    \   end\r\n  end\r\nend\r\n```\r\n\r\nThe intent here is to loosly verify that
    the layout is dodecahedron \r\nshaped, but it is more of a sanity check than a
    strict validation.\r\nA stronger check would require us to compute things like
    minimal\r\ncycles for each point, which would make for a much more \r\ncomplicated
    test.\r\n\r\nIn my implementation I use a JSON file that hard-codes the \r\nconnections
    between each room explicitly rather than trying to \r\nautomatically generate
    the layout, so this test is mostly just to catch errors \r\nwith that configuration
    file. If you reuse the [dodecahredon.json][json] \r\nfile in your own code, it
    should make passing these tests easy.\r\n\r\n2) Rooms in the cave can be selected
    randomly:\r\n\r\n```ruby\r\nit \"can select rooms at random\" do\r\n  sampling
    = Set.new\r\n\r\n  # see test/helper.rb for how this assertion works\r\n  must_eventually(\"randomly
    select each room\") do\r\n    new_room = cave.random_room \r\n    sampling <<
    new_room\r\n\r\n    sampling == Set[*rooms] \r\n  end\r\nend\r\n```\r\n\r\nThis
    feature is important for implementing the behavior of giant bats, who move\r\nthe
    player to a random location in the cave. It is also useful for hazard\r\nplacement,
    as we'll see later. The way I test the behavior is a bit awkward,\r\nbut the basic
    idea is that if you keep selecting rooms at random, you'll\r\neventually hit every
    room in the cave.\r\n\r\n3) Hazards can be moved from one room to another:\r\n\r\n```ruby\r\nit
    \"can move hazards from one room to another\" do\r\n  room      = cave.random_room\r\n
    \ neighbor  = room.neighbors.first\r\n\r\n  room.add(:bats)\r\n\r\n  assert room.has?(:bats)\r\n
    \ refute neighbor.has?(:bats)\r\n\r\n  cave.move(:bats, :from => room, :to =>
    neighbor)\r\n\r\n  refute room.has?(:bats)\r\n  assert neighbor.has?(:bats)\r\nend\r\n```\r\n\r\nThis
    test shows bats being moved from a random room to\r\none of its neighbors, but
    `Cave#move` can used to move any hazard\r\nbetween any two rooms in the cave,
    even if they are not\r\nadajecent to each other.\r\n\r\n4) Hazards can be randomly
    distributed throughout the cave:\r\n\r\n```ruby\r\nit \"can add hazards at random
    to a specific number of rooms\" do\r\n  cave.add_hazard(:bats, 3)\r\n\r\n  rooms.select
    { |e| e.has?(:bats) }.count.must_equal(3)\r\nend\r\n```\r\n\r\nFor the most part,
    the work to be done here is just to pick\r\nsome rooms at random and add hazards\r\nto
    them. However, because there is no sense in adding a single\r\ntype of hazard
    to a room more than once, `Cave#add_hazard`\r\nshould take care to select only
    rooms that do not already have\r\nthe specified hazard in them. This is hinted
    at by the specs,\r\nbut because the check is a loose one, just keep this detail\r\nin
    mind while implementing this method.\r\n\r\n5) Rooms can be looked up based on
    the hazards they contain:\r\n\r\n```ruby\r\nit \"can find a room with a particular
    hazard\" do\r\n  cave.add_hazard(:wumpus, 1)\r\n\r\n  assert cave.room_with(:wumpus).has?(:wumpus)\r\nend\r\n```\r\n\r\nIn
    my implementation, I just grab the first room that matches the \r\ncriteria, but
    any matching room would be acceptable. It\r\nwould also make sense to have a `Cave#all_rooms_with`
    method, but it isn't needed for a basic implementation\r\nof the game.\r\n\r\n6)
    A safe entrance can be located:\r\n\r\n```ruby\r\nit \"can find a safe room to
    serve as an entrance\" do\r\n  cave.add_hazard(:wumpus, 1)\r\n  cave.add_hazard(:pit,
    3)\r\n  cave.add_hazard(:bats, 3)\r\n\r\n  entrance = cave.entrance\r\n\r\n  assert
    entrance.safe?\r\nend\r\n```\r\n\r\nThis is where the `Wumpus::Room#safe?` method
    comes in handy. Picking any room\r\nthat passes that condition is enough to get
    the job done here.\r\n\r\n**Implementation notes**\r\n\r\nThe desired behavior
    of the `Wumpus::Cave` class is admittedly a bit\r\nunderspecified here, but in
    many cases minor variations won't effect\r\ngameplay all that much. Some of these
    operations are also intentionally \r\na bit more general than what is strictly
    needed for the game, to permit \r\nsome experimentation with rule changes once
    you have a working implementation. \r\n\r\nThis was a challenging object for me
    to design and test, because many \r\nof the features which are intuitively obvious
    are hard to specify \r\nformally. Do the best you can with building it, and refer\r\nto
    [my implementation of the Wumpus::Cave class][wumpus-cave] whenever \r\nyou hit
    any snags.\r\n\r\n## Modeling the player\r\n\r\nDespite the complexity of the
    cave layout, most game events in \r\nHunt the Wumpus are triggered by local conditions
    based on the \r\nplayer's current room and its direct neighbors. For example,
    \r\nimagine that the player is positioned in Room #1 as shown in \r\nfollowing
    diagram:\r\n\r\n![](//i.imgur.com/A0e5pMn.png)\r\n\r\nWith this setup, the player
    would sense the nearby hazards,\r\nresulting in the following output:\r\n\r\n
    \   You are in room 1.\r\n    You hear a rustling sound nearby\r\n    You smell
    something terrible nearby\r\n    Exits go to: 2, 3, 4\r\n\r\nOrdinarily we'd need
    to do some investigation work to discover which hazards\r\nwere where, but because
    this is a contrived scenario, we don't \r\nneed to guess. Knowing the layout of
    the neighborhood, we can enumerate the \r\npossible outcomes for any player action:\r\n\r\n*
    The player will encounter the wumpus upon moving into room 2.\r\n* The player
    will encounter bats upon moving into room 3.\r\n* The player will not encounter
    any hazards in room 4.\r\n* The player can shoot into room 2 to kill the wumpus.\r\n*
    The player will miss the wumpus by shooting into room 3 or 4.\r\n\r\nIf you take
    this single example and generalize it, you'll find that every turn\r\nof Hunt
    the Wumpus involves only three distinct kinds of events:\r\n\r\n```ruby\r\ndescribe
    \"the player\" do\r\n  it \"can sense hazards in neighboring rooms\" \r\n  it
    \"can encounter hazards when entering a room\"\r\n  it \"can perform actions on
    neighboring rooms\" \r\nend\r\n```\r\n\r\nWith these requirements in mind, it
    is possible for us to model \r\nthe `Wumpus::Player` class as an event-driven
    object that handles \r\neach event type listed above. The only state it needs
    to explicitly\r\nmaintain is a reference to the room currently being explored:
    everything \r\nelse can be managed externally through callbacks. You'll see why
    this\r\nis useful when we look at how the game rules are implemented later,\r\nbut
    for now just try to follow along as best as you can.\r\n\r\nThe test setup for
    the `Wumpus::Player` class is a bit complicated, mostly \r\nbecause we need to
    reconstruct something similar to the layout shown in the\r\nprevious diagram in
    order to meaningfully test its behavior:\r\n\r\n```ruby\r\ndescribe \"the player\"
    do\r\n  let(:player) { Wumpus::Player.new }\r\n\r\n  let(:empty_room) { Wumpus::Room.new(1)
    }\r\n\r\n  let(:wumpus_room) do\r\n    Wumpus::Room.new(2).tap { |e| e.add(:wumpus)
    }\r\n  end\r\n\r\n  let(:bat_room) do\r\n    Wumpus::Room.new(3).tap { |e| e.add(:bats)
    }\r\n  end\r\n\r\n  # ...\r\nend\r\n```\r\n\r\n\r\nIn addition to wiring up some
    rooms, I also register all of the events we're \r\ninterested in tracking during
    setup, using some dummy callbacks that are\r\nmeant to serve as stand-ins for
    real game logic. This is not an\r\nelegant way of building a test harness, but
    it gets the job done:\r\n\r\n```ruby\r\nlet(:sensed)      { Set.new }\r\nlet(:encountered)
    { Set.new }\r\n\r\nbefore do\r\n  empty_room.connect(bat_room)\r\n  empty_room.connect(wumpus_room)\r\n\r\n
    \ player.sense(:bats) do\r\n    sensed << \"You hear a rustling\"\r\n  end\r\n\r\n
    \ player.sense(:wumpus) do\r\n    sensed << \"You smell something terrible\"\r\n
    \ end\r\n\r\n  player.encounter(:wumpus) do\r\n    encountered << \"The wumpus
    ate you up!\"\r\n  end\r\n\r\n  player.encounter(:bats) do\r\n    encountered
    << \"The bats whisk you away!\"\r\n  end\r\n\r\n  player.action(:move) do |destination|\r\n
    \   player.enter(destination)\r\n  end\r\nend\r\n```\r\n\r\nOnce all of that is
    taken care of, the callbacks can be tested in isolated\r\nscenarios:\r\n\r\n```ruby\r\nit
    \"can sense hazards in neighboring rooms\" do\r\n  player.enter(empty_room)\r\n
    \ player.explore_room\r\n\r\n  sensed.must_equal(Set[\"You hear a rustling\",
    \"You smell something terrible\"])\r\n  \r\n  assert encountered.empty?\r\nend\r\n\r\nit
    \"can encounter hazards when entering a room\" do\r\n  player.enter(bat_room)\r\n
    \ encountered.must_equal(Set[\"The bats whisk you away!\"])\r\n  \r\n  assert
    sensed.empty? \r\nend\r\n\r\nit \"can perform actions on neighboring rooms\" do\r\n
    \ player.act(:move, wumpus_room)\r\n  player.room.must_equal(wumpus_room)\r\n\r\n
    \ encountered.must_equal(Set[\"The wumpus ate you up!\"])\r\n  assert sensed.empty?\r\nend\r\n```\r\n\r\nThese
    test cases verify that the right callbacks have been called\r\nby manipulating
    simple sets of strings, but the real use case for \r\nthe `Wumpus::Player` class
    is to trigger  operations on \r\ngame objects as well as the user interface. If
    you are having\r\ntrouble imagining what that would look like, it may help to
    \r\nread ahead a bit further before attempting to get these \r\ntests to pass.\r\n\r\n**Implementation
    notes:**\r\n\r\nLike the `Wumpus::Cave` class, this object is underspecified,
    but you probably\r\ndon't need to build something identical to [my implementation
    of Wumpus::Player][wumpus-player]\r\nin order to get the game to run. However,
    you may want to make an effort\r\nto ensure that callbacks are triggered in the
    order that they are registered,\r\notherwise you can run into some interesting
    edge cases when more than one\r\ncondition is satisfied at the same time.\r\n\r\n##
    Defining the game rules\r\n\r\nWith a foundation in place, implementing the game
    logic for Hunt the\r\nWumpus is very easy. My version of the game simplifies the
    rules, but\r\nhopefully still captures the spirit of the original.  \r\n\r\nAs
    you walk through the following code, you can treat the\r\n`Wumpus::Narrator` object
    as a black box. This is a boring object that\r\nonly does some basic I/O under
    the hood, so your time\r\nwould be better spent focusing on the game logic.\r\n\r\nWith
    that caveat out of the way, let's take a look at how Hunt the Wumpus can be\r\nimplemented
    in terms of the three game objects we just built. To get started, we\r\nneed a
    cave!\r\n\r\n```ruby\r\ncave = Wumpus::Cave.dodecahedron\r\n```\r\n\r\nThis cave
    will contain three pits, three giant bats, and the most evil and\r\nstinky Wumpus
    you could ever imagine:\r\n\r\n```ruby\r\ncave.add_hazard(:wumpus, 1)\r\ncave.add_hazard(:pit,
    3)\r\ncave.add_hazard(:bats, 3)\r\n```\r\n\r\nWe also need a player to navigate
    the cave, and a narrator to regale us with\r\ntales about the player's adventures:\r\n\r\n```ruby\r\nplayer
    \   = Wumpus::Player.new\r\nnarrator  = Wumpus::Narrator.new\r\n```\r\n\r\nWhenever
    a player senses a hazard nearby, the narrator will give us a hint\r\nof what kind
    of trouble lurks just around the bend:\r\n\r\n```ruby\r\nplayer.sense(:bats) do\r\n
    \ narrator.say(\"You hear a rustling sound nearby\") \r\nend\r\n\r\nplayer.sense(:wumpus)
    do\r\n  narrator.say(\"You smell something terrible nearby\")\r\nend\r\n\r\nplayer.sense(:pit)
    do\r\n  narrator.say(\"You feel a cold wind blowing from a nearby cavern.\")\r\nend\r\n```\r\n\r\nIf
    upon entering a room the player encounters the Wumpus, it\r\nwill become startled.
    We'll discuss the detailed consequences\r\nof this later, but the basic idea is
    that it will cause the\r\nWumpus to either run away to an adjacent room, or to
    gobble\r\nthe player up:\r\n\r\n```ruby\r\nplayer.encounter(:wumpus) do\r\n  player.act(:startle_wumpus,
    player.room)\r\nend\r\n```\r\n\r\nWhen bats are encountered, the narrator will
    inform us of\r\nthe event, then a random room will be selected to drop\r\nthe
    player off in. If any hazards are encountered\r\nin that room, the effects will
    be applied immediately,\r\npossibly leading to the player's demise.\r\n\r\nBut
    assuming that the player managed to survive the flight, \r\nthe bats will take
    up residence in the new location. This\r\ncan make navigation very complicated,
    because stumbling\r\nback into that room will cause the player to be moved\r\nto
    yet another random location:\r\n\r\n```ruby\r\nplayer.encounter(:bats) do\r\n
    \ narrator.say \"Giant bats whisk you away to a new cavern!\"\r\n\r\n  old_room
    = player.room\r\n  new_room = cave.random_room\r\n\r\n  player.enter(new_room)\r\n\r\n
    \ cave.move(:bats, from: old_room, to: new_room)\r\nend\r\n```\r\n\r\nIf the player
    happens to come across a bottomless pit, the\r\nstory ends immediately, even though
    the player's journey\r\nwill probably go on forever:\r\n\r\n```ruby\r\nplayer.encounter(:pit)
    do\r\n  narrator.finish_story(\"You fell into a bottomless pit. Enjoy the ride!\")\r\nend\r\n```\r\n\r\nThe
    player's actions are what ultimately ends up triggering game events. \r\nThe movement
    action is straightforward: it simply updates the player's\r\ncurrent location
    and then fires callbacks for any hazards encountered:\r\n\r\n```ruby\r\nplayer.action(:move)
    do |destination|\r\n  player.enter(destination)\r\nend\r\n```\r\n\r\nShooting
    is more complicated, although the way it is implemented here\r\nis still a simplification
    of how the original game worked. In Gregory Yob's\r\nversion, you had only five
    arrows, but they could travel a distance of up to\r\nfive rooms, even shooting
    around corners if you knew the right path. In my\r\nversion, arrows are unlimited
    but can only fire into neighboring rooms.\r\n\r\nIf the player shoots into the
    room that the Wumpus is hiding in, the beast \r\nis slayed and the story ends
    happily ever after. If instead the player shoots\r\ninto the wrong room, then
    no matter where the Wumpus is in the cave, it will \r\nbe startled by the sound.\r\n\r\n```ruby\r\nplayer.action(:shoot)
    do |destination|\r\n  if destination.has?(:wumpus)\r\n    narrator.finish_story(\"YOU
    KILLED THE WUMPUS! GOOD JOB, BUDDY!!!\") \r\n  else\r\n    narrator.say(\"Your
    arrow missed!\")\r\n\r\n    player.act(:startle_wumpus, cave.room_with(:wumpus))\r\n
    \ end\r\nend\r\n```\r\n\r\nWhen the Wumpus is startled, it will either stay where
    it is or move into\r\none of its neighboring rooms. The player will be able to
    hear the Wumpus\r\nmove anywhere in the cave, even if it is not in a nearby room.\r\n\r\nIf
    the Wumpus is in the same room as the player at the end of this process,\r\nit
    will gobble the player up and the game will end in sadness and tears:\r\n\r\n```ruby\r\nplayer.action(:startle_wumpus)
    do |old_wumpus_room|\r\n  if [:move, :stay].sample == :move\r\n    new_wumpus_room
    = old_wumpus_room.random_neighbor\r\n    cave.move(:wumpus, from: old_wumpus_room,
    to: new_wumpus_room)\r\n\r\n    narrator.say(\"You heard a rumbling in a nearby
    cavern.\")\r\n  end\r\n\r\n  if player.room.has?(:wumpus)\r\n    narrator.finish_story(\"You
    woke up the wumpus and he ate you!\")\r\n  end\r\nend\r\n```\r\n\r\nAnd that pretty
    much sums it up. I omitted a few lines of boilerplate\r\ncode that fire up the
    main event loop, but this pretty much covers\r\nall of the code that implements
    the actual game rules. It is designed\r\nto be very hackable, so please do experiment
    with it however you'd like.\r\n\r\nIf you want to review the full game executable
    without the intermingled\r\ncommentary, please see [the bin/wumpus script][wumpus-script].\r\n\r\n##
    Additional Exercises\r\n\r\nHopefully by working through this article you've seen
    for yourself why Hunt the\r\nWumpus is both fun to play and fun to implement.
    If you are looking for more\r\nthings to try, I'd suggest the following activities:\r\n\r\n*
    Limit the number of arrows that the player can shoot, and end the game when\r\nthe
    player runs out of arrows.\r\n\r\n* Try implementing the \"crooked arrow\" behavior
    of the original Wumpus game. To\r\ndo this allow the player to specify a path
    of up to five rooms. Whenever the\r\nplayer guesses an incorrect path, have the
    arrow to bounce into a random room.\r\nIf the arrow ends up hitting the player
    because of this, they lose!\r\n\r\n* Make it harder to guess the connections between
    rooms by randomizing\r\nthe room numbers for each new game while keeping the overall
    shape the same.\r\n\r\n* Try out one of the alternative cave layouts described
    in Gregory Yob's\r\nfollowup publication about [Wumpus 2][atari-2].\r\n\r\n* Add
    new hazards of your own, or other types of game objects that\r\nare beneficial,
    or provide some more depth to the story.\r\n\r\n* Implement a solver bot that
    plays the game automatically.\r\n\r\n* Build a better user interface for the game,
    either improving the text-based\r\nUI or attempting something using a GUI or web-based
    interface. You should\r\nonly need to edit the `Wumpus::Narrator` and `Wumpus::Console`
    objects\r\nin order to replace the current interface.\r\n\r\n* Keep the game behavior
    the same, but try out a different design than the one\r\nI provided here and/or
    improve the test suite.\r\n\r\nIf you try out any of these extra credit exercises,
    please share your work. I'd\r\nbe very interested to see what you come up with.
    Until then, happy hacking!\r\n\r\n[atari]: http://www.atariarchives.org/bcc1/showpage.php?page=247\r\n[atari-2]:
    http://www.atariarchives.org/bcc2/showpage.php?page=244\r\n[wumpus-ref]: https://github.com/elm-city-craftworks/wumpus/tree/reference_implementation\r\n[wumpus-diy]:
    https://github.com/elm-city-craftworks/wumpus\r\n[wumpus-room]: https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/lib/wumpus/room.rb\r\n[wumpus-cave]:
    https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/lib/wumpus/cave.rb\r\n[wumpus-player]:
    https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/lib/wumpus/player.rb\r\n[wumpus-script]:
    https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/bin/wumpus\r\n[wikipedia]:
    http://en.wikipedia.org/wiki/Hunt_the_Wumpus\r\n[dodecahedron]: http://en.wikipedia.org/wiki/Dodecahedron\r\n[json]:
    https://raw.github.com/elm-city-craftworks/wumpus/reference_implementation/data/dodecahedron.json\r\n"
- :slug: sustainable-foss-quality
  :title: 'Sustainable maintenance: Focus on quality first '
  :summary: Learn three useful practices for maintaining high quality open source
    projects (w. Eric Hodel)
  :published: 2014-02-17 00:00:00.000000000 Z
  :issue_number: '7.8'
  :volume: 7
  :body: "> This article was written in collaboration with Eric Hodel\r\n> ([@drbrain](http://twitter.com/drbrain)),
    a developer from Seattle. \r\n> Eric is a Ruby core team member, and he also maintains
    RubyGems \r\n> and RDoc. \r\n\r\nA big challenge in managing open source projects
    is that their codebases tend\r\nto decay as they grow. This isn't due to a lack
    of technically skilled\r\ncontributors, but instead is a result of the gradual
    loss of understandability \r\nthat comes along with any long-term and open-ended
    project \r\nthat has an distributed team of volunteers supporting it.\r\n\r\nOnce
    a project becomes more useful, it naturally attracts a more\r\ndiverse group of
    developers who are interested in adapting the codebase to\r\nmeet their own needs.
    Patches are submitted by contributors who do not fully \r\nunderstand a project's
    implementation, and maintainers merge these patches \r\nwithout fully understanding
    the needs of their contributors. Maintainers \r\nmay also struggle to remember
    the reasoning behind any of their own code that they \r\nhaven't touched in a
    while, but they still need to be able to work with it.\r\n\r\nAs a result of both
    of these influencing factors, mistaken assumptions tend to \r\nproliferate as
    a project grows, and with them come bugs and undefined behaviors. \r\nWhen direct
    knowledge of the codebase becomes limited and unreliable, it's easy to \r\nlet
    code quality standards slip without fully realizing the potential\r\nfor future
    problems. \r\n\r\nIf bad code continues to accumulate in this fashion, improving
    one part of a \r\na project usually means breaking something else in the \r\nprocess.
    Once a maintainer starts spending most of their time fixing bugs, \r\nit gets
    hard to move their project forward in meaningful \r\nways. This is where open
    source development stops being fun, and starts feeling \r\nlike a painful chore.\r\n\r\nNot
    all projects need to end up this way, though. As long as project maintainers \r\nmake
    sure to keep the quality arrow pointing upwards over the long haul, \r\nany bad
    code that temporarily accumulates in a project can always be replaced with \r\nbetter
    code whenever things start getting painful. The real challenge is to \r\nestablish
    healthy maintenance practices that address quality issues \r\nin a consistent
    and sustainable way. \r\n\r\n### Developing a process-oriented approach towards
    quality\r\n\r\nIn this article, we'll discuss three specific tactics we've used
    in \r\nour own projects that can be applied at any stage in the software \r\ndevelopment
    lifecycle. These are not quick fixes; they are helpful \r\nhabits that drive up
    understandability and code quality more and more\r\nas you continue to practice
    them. The good news is that even though \r\nit might be challenging to keep up
    with these efforts on a daily basis, \r\nthe recommendations themselves are very
    simple:\r\n\r\n1. Let external changes drive incremental quality improvements\r\n2.
    Treat all code with inadequate testing as legacy code\r\n3. Expand functionality
    via well-defined extension points \r\n\r\nWe'll now take a look at each of these
    guidelines individually and walk \r\nyou through some examples of how we've put
    them into practice in RDoc, \r\nRubyGems, and Prawn -- three projects that have
    had their own share of \r\nquality issues over the years, but continue to serve
    very diverse \r\ncommunities of users and contributors.\r\n\r\n### 1) Let external
    changes drive incremental quality improvements\r\n\r\nAlthough there is often
    an endless amount of cleanup work that can\r\nbe done in mature software projects,
    there is rarely enough\r\navailable development time to invest in these efforts.
    For programmers \r\nworking on open source in their spare time, it is hard enough\r\nto
    keep up with new incoming requests, so most preventative maintenance \r\nwork
    ends up being deferred indefinitely. When cleanup efforts do happen,\r\nthey tend
    to be done in concentrated bursts and then things go back\r\nto business-as-usual
    from there.\r\n\r\nA better approach is to pay down technical debts little by
    little, not as a\r\ndistinct activity but as part of responding to ordinary change
    requests. There\r\nare only two rules to remember when applying this technique
    in your daily work:\r\n\r\n* Try to avoid making the codebase worse with each
    new change, or at least\r\nminimize new maintenance costs as much as possible.\r\n*
    If there is an easy way to improve the code while doing everyday work, \r\ngo
    ahead and invest a little bit of effort now to make future changes easier. \r\n\r\nThe
    amount of energy spent on meeting these two guidelines should be proportional\r\nto
    the perceived risks and rewards of the change request itself, but typically\r\nit
    doesn't take a lot of extra effort. It may mean spending an extra 10 minutes on
    a\r\npatch that would take an hour to develop, or an extra hour on a patch that
    would\r\ntake a day to prepare. In any case, it should feel like an obviously
    good\r\ninvestment that is well worth the cost you are paying for it.\r\n\r\nThere
    is a great example in Prawn that illustrates this technique being used,\r\nand
    if you want to see it in its raw form, you can check out [this pull\r\nrequest](https://github.com/prawnpdf/prawn/pull/587)
    from Matt Patterson.\r\n\r\nMatt's request was to change the way that Prawn's
    image loading\r\nfeature detected whether it was working with an I/O object or
    a path to\r\na file on disk. Initially Prawn assumed that any object responding
    to `read` \r\nwould be treated as an I/O object, but this was too loose of a test
    and\r\ncaused some subtle failures when working with `Pathname` objects.\r\n\r\nThe
    technical details of the change are not important here, so don't worry if\r\nyou
    don't understand them. Instead, just look at the method that would need to\r\nbe
    altered to fix this problem, and ask yourself whether you would feel\r\ncomfortable
    making a change to it:\r\n\r\n```ruby\r\ndef build_image_object(file)\r\n  file.rewind
    \ if file.respond_to?(:rewind)\r\n  file.binmode if file.respond_to?(:binmode)\r\n\r\n
    \ if file.respond_to?(:read)\r\n    image_content = file.read\r\n  else\r\n    raise
    ArgumentError, \"#{file} not found\" unless File.file?(file)  \r\n    image_content
    = File.binread(file)\r\n  end\r\n  \r\n  image_sha1 = Digest::SHA1.hexdigest(image_content)\r\n\r\n
    \ if image_registry[image_sha1]\r\n    info = image_registry[image_sha1][:info]\r\n
    \   image_obj = image_registry[image_sha1][:obj]\r\n  else\r\n    info = Prawn.image_handler.find(image_content).new(image_content)\r\n\r\n
    \   min_version(info.min_pdf_version) if info.respond_to?(:min_pdf_version)\r\n\r\n
    \   image_obj = info.build_pdf_object(self)\r\n    image_registry[image_sha1]
    = {:obj => image_obj, :info => info}\r\n  end\r\n\r\n  [image_obj, info]\r\nend\r\n```\r\n\r\nAlthough
    this probably isn't the absolute worst code you have ever seen, \r\nit isn't very
    easy to read. Because it takes on many responsibilities,\r\nit's hard to even
    summarize what it is supposed to do! Fortunately for Matt,\r\nthe part that he
    would need to change was only the first few lines of the \r\nmethod, which are
    reasonably easy to group together:\r\n\r\n```ruby\r\ndef build_image_object(file)\r\n
    \ file.rewind  if file.respond_to?(:rewind)\r\n  file.binmode if file.respond_to?(:binmode)\r\n\r\n
    \ if file.respond_to?(:read)\r\n    image_content = file.read\r\n  else\r\n    raise
    ArgumentError, \"#{file} not found\" unless File.file?(file)  \r\n    image_content
    = File.binread(file)\r\n  end\r\n\r\n   # ... everything else \r\nend\r\n```\r\n\r\nThe
    quick fix would have been to edit these lines directly, but Matt recognized\r\nthe
    opportunity to isolate a bit of related functionality and make the code a\r\nlittle
    bit better in the process of doing so. Pushing these lines of code down\r\ninto
    a helper method and tweaking them slightly resulted in the following\r\ncleanup
    to the `build_image_object` method:\r\n\r\n```ruby\r\ndef build_image_object(file)\r\n
    \ io = verify_and_open_image(file)\r\n  image_content = io.read\r\n\r\n  # ...
    everything else\r\nend\r\n```\r\n\r\nIn the newly created helper method, Matt
    introduced his desired change, \r\nwhich is much easier to understand in isolation
    than it would have been in the \r\noriginal `build_image_object` method definition.
    In particular, he changed\r\nthe duck typing test to look for `rewind` rather
    than `read`, in the hopes\r\nthat it would be a more reliable way to detect I/O-like
    objects. Everything \r\nelse would be wrapped in a `Pathname` instance:\r\n\r\n```ruby\r\ndef
    verify_and_open_image(io_or_path)\r\n  if io_or_path.respond_to?(:rewind)\r\n
    \   io = io_or_path\r\n\r\n    io.rewind\r\n\r\n    io.binmode if io.respond_to?(:binmode)\r\n
    \   return io\r\n  end\r\n\r\n  io_or_path = Pathname.new(io_or_path)\r\n  raise
    ArgumentError, \"#{io_or_path} not found\" unless io_or_path.file?\r\n  \r\n  io_or_path.open('rb')\r\nend\r\n```\r\n\r\nAt
    this point, he could have submitted a pull request, because the tests were\r\nstill
    green and the new behavior was working as expected. However, the issue\r\nhe had
    set out to fix in the first place wasn't causing Prawn's tests to fail,\r\nand
    that was a sign that there was some undefined behavior at the root of\r\nthis
    problem. Although Prawn had some tests for reading images referenced by\r\n`Pathname`
    objects, it only had done its checks at a high level, and did not\r\nverify that
    the PDF output was being rendered correctly.\r\n\r\nA test would be needed at
    the lower level to verify that the output was no\r\nlonger corrupted, but this
    kind of testing is slightly tedious to do in Prawn.\r\nNoticing this rough spot,
    Matt created an RSpec matcher to make this kind of\r\ntesting easier to do in
    the future:\r\n\r\n```ruby\r\nRSpec::Matchers.define :have_parseable_xobjects
    do\r\n  match do |actual|\r\n    expect { PDF::Inspector::XObject.analyze(actual.render)
    }.not_to raise_error\r\n    true\r\n  end\r\n  failure_message_for_should do |actual|\r\n
    \   \"expected that #{actual}'s XObjects could be successfully parsed\"\r\n  end\r\nend\r\n```\r\n\r\nFinally,
    he provided a few test cases to demonstrate that his patch\r\nfixed the problem
    he was interested in, and also covered some other \r\ncommon use cases as well:\r\n\r\n```ruby\r\ncontext
    \"setting the length of the bytestream\" do\r\n  it \"should correctly work with
    images from Pathname objects\" do\r\n    info = @pdf.image(Pathname.new(@filename))\r\n
    \   expect(@pdf).to have_parseable_xobjects\r\n  end\r\n\r\n  it \"should correctly
    work with images from IO objects\" do\r\n    info = @pdf.image(File.open(@filename,
    'rb'))\r\n    expect(@pdf).to have_parseable_xobjects\r\n  end\r\n\r\n  it \"should
    correctly work with images from IO objects not set to mode rb\" do\r\n    info
    = @pdf.image(File.open(@filename, 'r'))\r\n    expect(@pdf).to have_parseable_xobjects\r\n
    \ end\r\nend\r\n```\r\n\r\nWhen you put all of these changes together, the total
    value of this patch\r\nis much greater than the somewhat obscure bug it fixed.
    By addressing\r\nsome minor pain points as he worked, Matt also improved Prawn
    in the\r\nfollowing ways:\r\n\r\n* The `build_image_object` method is now more
    understandable because one \r\nof its responsibilities has been broken out into
    its own method.\r\n\r\n* The `verify_and_open_image` method allows us to group
    together all the\r\nbasic guard clauses for determining how to read the image
    data, \r\nmaking it easier to see exactly what those rules are.\r\n\r\n* The added
    tests clarify the intended behavior of Prawn's image loading\r\nmechanism.\r\n\r\n*
    The newly added RSpec matcher will help us to do more\r\nPDF-level checks in future
    tests.\r\n\r\nNone of these changes required a specific and focused effort of
    refactoring or redesign,\r\nit just involved a bit of attention to detail and
    a willingness to make minor\r\nimprovements that would pay off for someone else
    in the future.\r\n\r\nAs a project maintainer, you cannot expect contributors
    to put this level of\r\neffort into their patches -- Matt really went above and
    beyond here. However, \r\nyou can definitely look for these kind of opportunities
    yourself during review \r\ntime, and either ask the contributor to make some revisions,
    or make them yourself \r\nbefore you merge in new changes. No matter who ends
    up doing the work, little by\r\nlittle these kinds of incremental cleanup efforts
    can turn a rough codebase into\r\nsomething pleasant to work with.\r\n\r\n###
    2) Treat all code without adequate testing as legacy code\r\n\r\nHistorically,
    we've defined legacy code as code that was written long before our\r\ntime, without
    any consideration for our current needs. However, any untested\r\ncode can also
    be considered legacy code[^1], because it often\r\nhas many of the same characteristics
    that make outdated systems difficult to\r\nwork with. Open source projects evolve
    quickly, and even very clean code\r\ncan cause a lot of headaches if its intended
    behavior is left undefined.\r\n\r\nTo guard against the negative impacts of legacy
    code, it helps \r\nto continuously update your project's test suite so \r\nthat
    it constantly reflects your current understanding of the problem domain\r\nyou
    are working in. A good starting point is to make sure that your project\r\nhas
    good code coverage and that you keep your builds green in CI.\r\nOnce you've done
    that, the next step is to go beyond the idea of just having\r\nlots of tests and
    start focusing on making your test suite more capable \r\nof catching problems
    before they leak out into released code.\r\n\r\nHere are some things to keep in
    mind when considering the potential \r\nimpact that new changes will have on your
    project's stability:\r\n\r\n* Any behavior change introduced without test\r\ncoverage
    has a good chance of causing a defect or \r\naccidentally breaking backwards-compatibility
    in a future release.\r\n\r\n* A passing test suite is not proof that a change
    is well-defined\r\nand defect-free.\r\n\r\n* The only reliable way to verify that
    existing features have \r\nwell-defined behavior and good test coverage is to\r\nreview
    their code manually.\r\n\r\n* Contributors often don't understand your project's
    problem domain \r\nor its codebase well enough to know how to write good tests
    for\r\ntheir changes without some guidance.\r\n\r\nThese points are not meant
    to imply that each and every pull request\r\nought to be gone over with a fine-tooth
    comb -- they're only meant to \r\nserve as a reminder that maintaining a high
    quality test suite is\r\na harder problem than we often make it out to be. The
    same ideas\r\nof favoring incremental improvements over heroic efforts that\r\nwe
    discussed earlier also apply here. There is no need to\r\nrush towards a perfect
    test suite all at once, as long as it improves\r\non average over time.\r\n\r\nWe'll
    now look at a [pull request](https://github.com/rubygems/rubygems/pull/781/files)
    \r\nthat Brian Fletcher submitted to\r\nRubyGems for a good example of how these
    ideas can be applied \r\nin practice.\r\n\r\nBrian's request was to add support
    for Base64 encoded usernames and\r\npasswords in gem request URLs. Because RubyGems
    already supported\r\nthe use of HTTP Basic Auth with unencoded usernames and passwords
    in\r\nURLs, this was an easy change to make. The desired URL decoding functionality\r\nwas
    already implemented by `Gem::UriFormatter`, so the\r\ninitial commit for this
    pull request involved changing just a single line \r\nof code:\r\n\r\n```diff\r\n
    \    request = @request_class.new @uri.request_uri\r\n \r\n     unless @uri.nil?
    || @uri.user.nil? || @uri.user.empty? then\r\n-      request.basic_auth @uri.user,
    @uri.password\r\n+      request.basic_auth Gem::UriFormatter.new(@uri.user).unescape,\r\n+
    \                        Gem::UriFormatter.new(@uri.password).unescape\r\n     end\r\n
    \r\n     request.add_field 'User-Agent', @user_agent\r\n```\r\n\r\nOn the surface,
    this looks like a fairly safe change to make. Because it only\r\nadds support
    for a new edge case, it should preserve the original behavior\r\nfor URLs that
    did not need to be unescaped. No new test failures were introduced\r\nby this
    patch, and a quick look at the test suite shows that `Gem::UriFormatter`\r\nhas
    some tests covering its behavior.\r\n\r\nAs far as changes go, this one is definitely
    low risk. But if you dig in a\r\nlittle bit deeper, you can find a few things
    to worry about: \r\n\r\n* Even though only a single line of code was changed,
    that line of code\r\nwas at the beginning of a method that is almost 90 lines
    long. This isn't\r\nnecessarily a problem, but it should at least be a warning
    sign to slow\r\ndown and take a closer look at things.\r\n\r\n* A quick look at
    the test suite reveals that although there were tests\r\nfor the `unescape` method
    provided by `GemUri::Formatter`, there were no tests \r\nfor the use of Basic
    Auth in gem request URLs, which means the behavior\r\nthis patch was modifying
    was not formally defined. Because of this, we can't\r\nbe sure that a subtle incompatibility
    wasn't introduced by this patch, \r\nand we wouldn't know if one was introduced
    later due to a change to\r\n`GemUri::Formatter`, either.\r\n\r\n* The new behavior
    introduced by this patch also wasn't verified, which\r\nmeans that it could have
    possibly been accidentally removed in a future \r\nrefactoring or feature patch.
    Another contributor could easily assume \r\nthat URL decoding was incidental rather
    than intentional without\r\ntests that indicated otherwise.\r\n\r\nThese are the
    kind of problems that a detailed review can discover \r\nwhich are often invisible
    at the surface level. However, a much more\r\nefficient maintenance policy is
    to simply assume one or more of the \r\nabove problems exist whenever a change
    is introduced without tests, \r\nand then either add tests yourself or ask contributors
    to add them\r\nbefore merging. \r\n\r\nIn this case, Eric asked Brian to add a
    test after giving him some guidance \r\non how to go about implementing it. For
    reference, this was his exact request:\r\n\r\n> Can you add a test for this to
    test/rubygems/test_gem_request.rb?\r\n>\r\n> You should be able to examine the
    request object through the block #fetch yields to.\r\n\r\nIn response, Brian dug
    in and noticed that the base case of\r\nusing HTTP Basic Auth wasn't covered by
    the tests. So rather than simply \r\nadding a test for the new behavior he added,
    he went ahead and wrote tests \r\nfor both cases:\r\n\r\n```ruby\r\nclass TestGemRequest
    < Gem::TestCase\r\n def test_fetch_basic_auth\r\n    uri = URI.parse \"https://user:pass@example.rubygems/specs.\"
    +\r\n                     Gem.marshal_version\r\n    @request = Gem::Request.new(uri,
    Net::HTTP::Get, nil, nil)\r\n    conn = util_stub_connection_for :body => :junk,
    :code => 200\r\n\r\n    response = @request.fetch\r\n\r\n    auth_header = conn.payload['Authorization']\r\n\r\n
    \   assert_equal \"Basic #{Base64.encode64('user:pass')}\".strip, auth_header\r\n
    \ end\r\n\r\n  def test_fetch_basic_auth_encoded\r\n    uri = URI.parse \"https://user:%7BDEScede%7Dpass@example.rubygems/specs.\"
    +\r\n                    Gem.marshal_version\r\n    @request = Gem::Request.new(uri,
    Net::HTTP::Get, nil, nil)\r\n    conn = util_stub_connection_for :body => :junk,
    :code => 200\r\n\r\n    response = @request.fetch\r\n\r\n    auth_header = conn.payload['Authorization']\r\n\r\n
    \   assert_equal \"Basic #{Base64.encode64('user:{DEScede}pass')}\".strip, \r\n
    \                auth_header\r\n  end\r\nend\r\n```\r\n\r\nIt is hard to overstate
    the difference between a patch with these tests\r\nadded to it and one without
    tests. The original commit introduced a new\r\ndependency and more complex logic
    into a feature that lacked formal definition\r\nof its behavior. But as soon as
    these tests are added to the change request,\r\nRubyGems gains support for a new
    special condition in gem request URLs while \r\ntightening up the definition of
    the original behavior. The tests\r\nalso serve to protect both conditions from
    breaking without being noticed \r\nin the future.\r\n\r\nTaken individually, the
    risks of accepting untested patches are\r\nsmall enough that they don't seem important
    enough to worry about when you are pressed\r\nfor time. But in the aggregate,
    the effects of untested code will pile up until your\r\ncodebase really does become
    unworkable legacy code. For that reason, establishing\r\ngood habits about reviewing
    and shoring up tests on each new change can make a\r\nhuge difference in long-term
    maintainability.\r\n\r\n### 3) Expand functionality via well-defined extension
    points \r\n\r\nMost open source projects can benefit from having two clearly defined
    interfaces:\r\none for end-users, and one for developers who want to extend its
    functionality.\r\nThis point may seem tangentially related to code quality and
    maintainability,\r\nbut a well-defined extension API can greatly increase a project's
    stability.\r\n\r\nWhen its possible to add new functionality to a project without
    patching its\r\ncodebase directly, it becomes easier to separate essential features
    that most\r\npeople will need from features that are only relevant in certain
    rare \r\ncontexts. The ability to support external add-ons in a transparent way
    also\r\nmakes it possible to try experiments outside of your main codebase and
    then\r\nonly merge in features that prove to be both stable and widely used.\r\n\r\nEven
    within the scope of a single codebase, explicitly defining a layer one\r\nlevel
    beneath the surface forces you to think about what the common points\r\nof interaction
    are between your project's features. It also makes testing\r\neasier, because
    feature implementations tend to get slimmed down as the\r\nextension API becomes
    more capable. Each part can then be tested in \r\nisolation without having to
    think about large amorphous blobs\r\nof internal dependencies.\r\n\r\nIt may be
    hard to figure out how to create an extension API when you first start\r\nworking
    on a project, because at that time you probably don't know much\r\nabout the ways
    that people will need to extend its core behavior, and you may\r\nnot even have
    a good sense of what its core feature set should be! This is\r\ncompletely acceptable,
    and it makes sense to focus exclusively on your high-level \r\ninterface at first.
    But as your project matures, you can use the following guidelines to\r\nincrementally
    bring a suitable extension API into existence:\r\n\r\n* With each new feature
    request, ask yourself whether it could be implemented\r\nas an external add-on
    without patching your project's codebase. If not, figure \r\nout what extension
    points would make it possible to do so.\r\n\r\n* For any of your features that
    have become difficult to work with or overly\r\ncomplex, think about what extension
    points would need to be added in\r\norder to extract those features into external
    add-ons.\r\n\r\n* For any essential features that have clearly related functionality,
    \r\nfigure out what it would take to re-implement them on top of well defined
    \r\nextension points rather than relying on lots of private internal code.\r\n\r\nAt
    first, you may start by carrying out these design considerations as simple\r\nthought
    experiments that will indirectly influence the way you implement \r\nthings. Later,
    you can take them more seriously and seek to support\r\nnew functionality via
    external add-ons rather than merging new features \r\nunless there is a very good
    reason to do otherwise. Every project needs to\r\ndiscover the right balance for
    itself, but the basic idea is that the value of a\r\nclear extension API increases
    the longer a project is in active use.\r\n\r\nBecause RDoc has been around for
    a very long time and has a fairly decent extension \r\nAPI, it is a good library
    to look at for examples of what this technique has\r\nto offer. Without asking
    Eric for help, I looked into what it would take to autolink \r\nGithub issues,
    commits, and  version tags in RDoc output. This isn't something I had \r\na practical
    use for, but I figured it  would be a decent way to test how easily I \r\ncould
    extend the RDoc parser.\r\n\r\nI started with the following text as my input data:
    \r\n\r\n```\r\nPlease see #125, #127, and #159\r\n\r\nAlso see @bed324 and v0.14.0\r\n```\r\n\r\nMy
    goal was to produce the following HTML output after telling RDoc what repository\r\nthat
    these issues, commits, and tags referred to:\r\n\r\n```\r\n<p>Please see <a href=\"https://github.com/prawnpdf/prawn/issues/125\">#125</a>,\r\n<a
    href=\"https://github.com/prawnpdf/prawn/issues/127\">#127</a>, and \r\n<a href=\"https://github.com/prawnpdf/prawn/issues/159\">#159</a></p>\r\n\r\n<p>Also
    see <a\r\nhref=\"https://github.com/prawnpdf/prawn/commit/bed324\">@bed324</a>
    and \r\n<a href=\"https://github.com/prawnpdf/prawn/tree/0.14.0\">v0.14.0</a></p>\r\n```\r\n\r\nRendered,
    the resulting HTML would look like this:\r\n\r\n> Please see <a href=\"https://github.com/prawnpdf/prawn/issues/125\">#125</a>,\r\n>
    <a href=\"https://github.com/prawnpdf/prawn/issues/127\">#127</a>, and \r\n> <a
    href=\"https://github.com/prawnpdf/prawn/issues/159\">#159</a></p>\r\n>\r\n> Also
    see <a href=\"https://github.com/prawnpdf/prawn/commit/bed324\">@bed324</a> and
    \r\n> <a href=\"https://github.com/prawnpdf/prawn/tree/0.14.0\">v0.14.0</a></p>\r\n\r\nI
    wasn't concerned about styling or how to fit this new functionality into a\r\nfull-scale
    RDoc run. I just wanted to see if I could take my little\r\nsnippet of sample
    text and replace the GitHub references with their \r\nrelevant links. My experiment
    was focused solely on finding an\r\nsuitable entry point into the system that
    supported these \r\nkinds of extensions.\r\n\r\nAfter about 20 minutes of research
    and tinkering, I was able \r\nto produce the following example:\r\n\r\n```ruby\r\nrequire
    'rdoc'\r\n\r\nREPO_URL = \"https://github.com/prawnpdf/prawn\"\r\n\r\nclass GithubLinkedHtml
    < RDoc::Markup::ToHtml\r\n  def handle_special_ISSUE(special)\r\n    %{<a href=\"#{REPO_URL}/issues/#{special.text[1..-1]}\">#{special.text}</a>}\r\n
    \ end\r\n\r\n  def handle_special_COMMIT(special)\r\n    %{<a href=\"#{REPO_URL}/commit/#{special.text[1..-1]}\">#{special.text}</a>}\r\n
    \ end\r\n\r\n  def handle_special_VERSION(special)\r\n    tag = special.text[1..-1]\r\n\r\n
    \   %{<a href=\"#{REPO_URL}/tree/#{tag}\">#{special.text}</a>}\r\n  end\r\nend\r\n\r\nmarkup
    = RDoc::Markup.new\r\n\r\nmarkup.add_special(/\\s*(\\#\\d+)/, :ISSUE)\r\nmarkup.add_special(/\\s*(@\\h+)/,
    \ :COMMIT)\r\nmarkup.add_special(/\\s*(v\\d+\\.\\d+\\.\\d+)/, :VERSION)\r\n\r\nwh
    = GithubLinkedHtml.new(RDoc::Options.new, markup)\r\n\r\nputs \"<body>#{wh.convert
    ARGF.read}</body>\"\r\n```\r\n\r\nOnce I figured out the right APIs to use, this
    became an easy problem to solve.\r\nIt was clear from the way things were laid
    out that this sort of use case had \r\nalready been considered, and a source dive
    revealed that RDoc also uses these\r\nextension points internally to support its
    own behavior. The only challenge I ran\r\ninto was that these extension points
    were not especially well documented, which\r\nis unfortunately a more common problem
    than it ought to be with open \r\nsource projects. \r\n\r\nIt is often the case
    that extension points are built initially to support \r\ninternal needs rather
    than external use cases, and so they often lag behind \r\nsurface-level features
    in learnability and third-party usability. This is\r\ncertainly a solvable problem,
    and is worth considering when working on\r\nyour own projects. But even without
    documentation, explicit and stable extension\r\npoints can be a hugely powerful
    tool for making a project more maintainable.\r\n\r\n### Reflections\r\n\r\nAs
    you've seen from these examples, establishing high quality standards for open
    \r\nsource projects is a matter of practicality, not pride. Projects that are
    made up \r\nof code that is easy to understand, easy to test, easy to change,
    and easy to \r\nmaintain are far more likely to be sustainable over the long haul
    than projects \r\nthat are allowed to decay internally as they grow.\r\n\r\nThe
    techniques we've discussed in this article are ones that will\r\npay off even
    if you just apply them some of the time, but the more you use them,\r\nthe more
    you'll get in return. The nice thing about these practices is that they\r\nare
    quite robust -- they can be applied in early stage experimental software as\r\nwell
    as in projects that have been used in production for years.\r\n\r\nThe hard part
    of applying these ideas is not in remembering them when things are\r\npainful,
    but instead in keeping up with them when things are going well with\r\nyour project.
    The more contributions you receive, the more important these\r\nstrategies will
    become, but it is also hard to keep up with them because they do\r\nslow down
    the maintenance process a little bit. Whenever you feel that pressure,\r\nremember
    that you are looking out for the future of your project by focusing on\r\nquality,
    and then do what you can to educate others so that they understand why\r\nthese
    issues matter.\r\n\r\nEvery project is different, and you may find that there
    are other ways to keep a\r\nhigh quality standard without following the guidelines
    we've discussed in this\r\narticle. If you have some ideas to share, please let
    us know!\r\n\r\n[^1]: The definition of legacy code as code without tests was
    popularized in 2004 by Michael Feathers, author of the extremely useful [Working
    Effectively with Legacy Code](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)
    book.\r\n"
- :slug: study-guide-1
  :title: A self guided course on streams, files, file formats, and sockets
  :summary: Explore UNIX-style stream processing, binary file formats, the Racc parser
    generator, and socket programming.
  :published: 2014-03-31 00:00:00.000000000 Z
  :issue_number: '7.9'
  :volume: 7
  :body: "This self-guided course will help you learn how to work with the low level
    \r\ntools that you'd usually rely on libraries and frameworks to provide. \r\nEach
    of its four parts will give you a feel for a different kind \r\nof I/O programming
    and text processing work:\r\n\r\n* Standard I/O streams and the filesystem\r\n*
    Encoding and decoding binary files\r\n* Parsing text-based file formats\r\n* Socket
    programming and network I/O\r\n\r\nIn each part of the course, you'll start by
    carefully reading a Practicing Ruby \r\narticle that explores one of the topics
    listed above. You will then work through \r\na set of review questions to test
    your grasp of the material. Finally you'll \r\napply the concepts to realistic
    problems by working on a set of project-based\r\nexercises.\r\n\r\nOnce you've
    completed the entire study guide, you'll know how to do all of the\r\nfollowing
    things:\r\n\r\n* Build command line applications in Ruby that follow the Unix
    philosophy and\r\nwork similarly to other console-based applications you use day
    to day.\r\n\r\n* Encode and decode binary files at the level of bits and bytes,
    and understand\r\nhow primitive data structures are represented in low-level storage
    formats.\r\n\r\n* Work with streams in a memory efficient way, whether they're
    coming from files, \r\nstandard I/O, or the internet.\r\n\r\n* Work with the same
    parser and compiler technology that is used by serious\r\ntext processing libraries
    and programming languages.\r\n\r\n* Understand the basics behind TCP-level socket
    programming, and how to build\r\nsimple client and server software.\r\n\r\nWe
    often take these concepts for granted because our libraries and frameworks take\r\ncare
    of them for us. But this self-guided tour of Ruby's basement will help you\r\nappreciate
    the many low-level tools and techniques we have \r\navailable for solving these
    problems.\r\n\r\nTo begin your journey, fork the [course git repository](https://github.com/elm-city-craftworks/course-001)
    \r\nand then follow the instructions in its [README](https://github.com/elm-city-craftworks/course-001/blob/master/README.md).
    \r\nWork at your own pace, and don't hesitate to ask for help when you need it.
    You\r\ncan submit issues in our tracker for general questions, and pull requests
    when\r\nyou'd like a review of your work. Good luck, and happy hacking!\r\n"
- :slug: information-anatomy
  :title: The anatomy of information in software systems
  :summary: Explore the tradeoffs involved in designing message formats, and the messy
    boundary between humans and computers.
  :published: 2014-09-08 00:00:00.000000000 Z
  :issue_number: '7.10'
  :volume: 7
  :body: "Suppose that you want catch up with your friends \r\nAlice, Bob, and Carol.
    To do this, you might log into your favorite\r\nchat service, join a group chat
    room, and then type in some\r\nsort of friendly greeting and hit the enter key.
    Moments later, your friends would\r\nsee your message appear on their screens,
    and soon after that\r\nthey would probably send you some sort of response. As
    long as\r\ntheir reply was somewhat intelligible, you could be reasonably \r\ncertain
    that your message was successfully communicated, without\r\ngiving much thought
    to the underlying delivery mechanism.\r\n\r\nJust beneath the surface of this
    everyday activity, we find a world \r\nof precise rules and constraints governing
    our \r\ncommunications. In the world of chat clients and servers, the \r\nmeaning
    of your message does not matter, but its structure is \r\nof critical importance.
    Protocols define the format for messages \r\nto be encoded in, and even small
    variations will result \r\nin delivery failures. \r\n\r\nEven though much of this
    internal complexity is hidden by user interfaces,\r\nmessage format requirements
    are not a purely technical\r\nconcern -- they can also directly affect human behavior.
    On Twitter, \r\na message needs to be expressed in 140 characters or less, and
    on \r\nIRC the limit is only a few hundred characters. This single\r\nconstraint
    makes Twitter and IRC fundamentally different from\r\nemail and web forums, so
    it's hard to overstate the impact\r\nthat constraints can have on a communicaitons
    medium.\r\n\r\nIn addition to intentional restrictions on message structure,\r\nthere
    are always going to be incidental technical limitations\r\nthat need to be dealt
    with -- the kinds of quirks that arise\r\nfrom having too much or too little expressiveness[^1]
    in a given\r\nmessage format. These unexpected obstacles are among the most \r\ninteresting
    problems in information exchange, because they are \r\nnot an essential part of
    the job to be done but rather an\r\nemergent property of the way we've decided
    to do the job. \r\n\r\nAs programmers, we're constantly working to bridge the
    gap\r\nbetween people and the machines that serve them. This article\r\nexplores
    the boundary lines between those two disjoint worlds, \r\nand the complicated
    decisions that need to be made \r\nin order to cross the invisible chasm that
    lies between\r\ncomputational structures and human meaning.\r\n\r\n## The medium
    is the message\r\n\r\nTo see the impact a communication medium can have on its
    messages,\r\nlet's work through a practical example. The line of text below is\r\nrepresentative
    of what an IRC-based chat message look like when it \r\nget sent over a TCP socket:\r\n\r\n```\r\nPRIVMSG
    #practicing-ruby-testing :Seasons greetings to you all!\\r\\n\r\n```\r\n\r\nEven
    if you've never used IRC before or looked into its implementation\r\ndetails,
    you can extract a great deal of meaning from this single line \r\nof text. The
    structure is very simple, so it's fairly obvious that\r\n`PRIVMSG` represents
    a command, `#practicing-ruby-testing` represents\r\na channel, and that the message
    to be delivered is \r\n`\"Seasons greetings to you all!\"`. If I asked you to
    parse this\r\ntext to produce the following array, you probably would have\r\nno
    trouble doing so without any further instruction:\r\n\r\n```ruby\r\n[\"PRIVMSG\",
    \"#practicing-ruby-testing\", \"Seasons greetings to you all!\"]\r\n```\r\n\r\nBut
    if this were a real project and not just a thought experiment,\r\nyou might start
    to wonder more about the nuances of the protocol. Here\r\nare a few questions
    that might come up after a few minutes of\r\ncareful thought:\r\n\r\n* What is
    the significance of the `:` character? Does it always signify \r\nthe start of
    the message body, or does it mean something else?\r\n\r\n* Why does the message
    end in `\\r\\n`? Can the message body contain newlines,\r\nand if so, should they
    be represented as `\\n` or `\\r\\n`, or something\r\nelse entirely?\r\n\r\n* Will
    messages always take the form `\"PRIVMSG #channelname :Message Body\\r\\n\"`,
    \r\nor are their cases where additional parameters will be used?\r\n\r\n* Can
    channel names include spaces? How about `:` characters?\r\n\r\nTry as we might,
    no amount of analyzing this single example will answer \r\nthese questions for
    us. That leads us to a very important point: \r\nUnderstanding  the *meaning*
    of a message doesn't necessarily mean that \r\nwe know how to process the information
    contained within it.\r\n\r\n## The meaning of a message depends on its level of
    abstraction\r\n\r\nAt first glance, the text-based IRC protocol made it \r\neasy
    for us to identify the structure and meaning of the various\r\nparts of a chat
    message. But when we thought a little more about what \r\nit would take to actually
    implement the protocol, we quickly ran \r\ninto several questions about how to
    construct well-formed messages.\r\n\r\nA lot of the questions we came up with
    had to do with basic syntax\r\nrules, which is only natural when exploring an
    unfamiliar information\r\nformat. For example, we can guess that the `:` symbol
    is a special character \r\nin the following text, but we can't reliably guess
    its meaning without \r\nreading the formal specification for the IRC protocol:\r\n\r\n```\r\nPRIVMSG
    #practicing-ruby-testing :Seasons greetings to you all!\\r\\n\r\n```\r\n\r\nTo
    see the effect of syntax on our interpretation of information\r\nformats, consider
    what happens when we shift the representation \r\nof a chat message into a generic
    structure that\r\nwe are already familiar with, such as a Ruby array: \r\n\r\n```ruby\r\n[\"PRIVMSG\",
    \"#practicing-ruby-testing\", \"Seasons greetings to you all!\"]\r\n```\r\n\r\nLooking
    at this information, we still have no idea whether it \r\nconstitutes a well-formed
    message to be processed by \r\nour hypothetical IRC-like chat system. But because
    we know Ruby's \r\nsyntax, we understand what is being communicated here at\r\na
    primitive level.\r\n\r\nBefore when we looked at the `PRIVMSG` command expressed
    in\r\nthe format specified by the IRC protocol, we weren't able to\r\nreliably
    determine the rules for breaking the message up\r\ninto its parts by looking at
    a single example. Because\r\nwe didn't already have its syntax memorized, we wouldn't
    even\r\nbe able to reliably parse IRC commands, let alone process them.\r\nBut
    as Ruby programmers, we know what array and string literals\r\nlook like, and
    so we know how to map their syntax to the concepts\r\nbehind them.\r\n\r\nThe
    mundane observation to be made here is that it's easier \r\nto understand a format
    you're familiar with than it is to \r\ninterpret one you've never seen before.
    A far more interesting\r\npoint to discover is that these two examples have fundamental\r\ndifferences
    in meaning, even if they can be interpreted in\r\na way that makes them equivalent
    to one another.\r\n\r\nDespite their superficial similarities, the two examples\r\nwe've
    looked at operate at completely different\r\nlevels of abstraction. The IRC-based
    example directly \r\nencodes the concept of a *chat message*, whereas \r\nour
    Ruby example encodes the concept of an *array of strings*. \r\nIn that sense,
    the former is a direct representation of a \r\ndomain-specific concept, and the
    latter is a indirect \r\nrepresentation built up from general-purpose data structures.\r\nBoth
    can express the concept a chat message, but they're not\r\ncut from the same cloth.\r\n\r\nLet's
    investigate why this difference\r\nin structure matters. Consider what might happen
    if we attempted\r\nto allow whitespace in chat channel names, i.e. \r\n`#practicing
    ruby testing` instead of `#practicing-ruby-testing`.\r\nBy directly substituting
    this new channel name into our `PRIVMSG`\r\ncommand example, we get the text shown
    below:\r\n\r\n```\r\nPRIVMSG #practicing ruby testing :Seasons greetings to you
    all!\\r\\n\r\n```\r\n\r\nHere we run into a syntactic hiccup: If we allow for
    channel\r\nnames to include whitespace, we need to come up with more complex\r\nrules
    for splitting up the message into its different parts. But\r\nif we decide this
    is an ill-formed string, then we need to come\r\nup with a constraint that says
    that the channel parameter\r\ncannot include spaces in it. Either way, we need
    to come up\r\nwith a formal rule that will be applied at parse time,\r\nbefore
    processing even begins.\r\n\r\nNow consider what happens when we use Ruby syntax
    instead:\r\n\r\n```ruby\r\n[\"PRIVMSG\", \"#practicing ruby testing\", \"Seasons
    greetings to you all!\"]\r\n```\r\n\r\nThis is without question a well-formed
    Ruby array, and it will\r\nbe successfully parsed and turned into an internal
    data structure.\r\nBy definition, Ruby string literals allow whitespace in them,
    \r\nand there's no getting around that without writing our own \r\ncustom parser.
    So while the IRC example *must* consider the meaning\r\nof whitespace in channel
    names during the parsing phase, our\r\nRuby example *cannot*. Any additional constraints
    placed on the \r\nformat of channel names would need to be done via logical \r\nvalidations
    rather than syntactic rules.\r\n\r\nThe key insight here is that the concepts
    we're expressing\r\nwhen we encode something in one syntax or another have meaning\r\nbeyond
    their raw data contents. In the IRC protocol\r\na channel is a defined concept
    at the symbolic level, with a \r\nspecific meaning to it. When we encode a channel
    name \r\nas a Ruby string, we can only approximate the concept by starting with\r\na
    more general structure and then applying logical rules to\r\nit to make it a more
    faithful representation of a concept\r\nit cannot directly express. This is not
    unlike translating\r\na word from one spoken language to another which cannot\r\nexpress
    the same exact concept using a single word.\r\n\r\n## Every expressive syntax
    has at least a few corner cases\r\n\r\nConsider once more our fascinating Ruby
    array:\r\n\r\n```ruby\r\n[\"PRIVMSG\", \"#practicing-ruby-testing\", \"Seasons
    greetings to you all!\"]\r\n```\r\n\r\nWe've seen that because its structure is
    highly generic, its\r\nencoding rules are very permissive. Nearly any sequence
    of\r\nprintable characters can be expressed within a Ruby string literal,\r\nand
    so there isn't much ambiguity in expression of ordinary strings.\r\n\r\nDespite
    its general-purpose nature, there are edge cases in Ruby's\r\nstring literal syntax
    that could lead to ambiguous or incomprehensible messages. \r\nFor example, consider
    strings which have `\"` characters within them:\r\n\r\n```\r\n\"My name is: \"Gregory\"\\n\"\r\n```\r\n\r\nThe
    above will generate a syntax error in Ruby, becasuse it ends up\r\ngetting parsed
    as the string `\"My name is: \"`, followed immediately\r\nby the constant `Gregory`,
    followed by the string `\"\\n\"`. Ruby\r\nunderstandably has no way of interpreting
    that nonsense, so\r\nthe parser will fail.\r\n\r\nIf we were only concerned with
    parsing string literals, we could \r\nfind a way to resolve these ambiguities
    by adding some special \r\nparsing rules, but Ruby has a much more complex grammar
    across\r\nits entire featureset. For that reason, it expects you to be\r\na bit
    more explicit when dealing with edge cases like this one.\r\nTo get our string
    to parse, we'd need to do something like this:\r\n\r\n```\r\n\"My name is: \\\"Gregory\\\"\\n\"\r\n```\r\n\r\nBy
    writing `\\\"` instead of `\"`, we tell the parser\r\nto treat the quote character
    as just another character in the string\r\nrather than a symbolic *end-of-string*
    marker. The `\\` acts\r\nas an escape character, which is useful for resolving
    these sorts\r\nof ambiguities. The cost of course is that `\\` itself\r\nbecomes
    a potential source of ambiguity, so you end up having to write\r\n`\\\\` instead
    of `\\` to express backslashes in Ruby\r\nstring literals.\r\n\r\nEdge cases of
    this sort arise in any expressive text-based format.\r\nThey are often easy to
    resolve by adding a few more rules, but in many\r\ncases the addition of new processing
    rules add an even more subtle layer\r\nof corner cases to consider (as we've seen
    w. the `\\` character).\r\nResolving minor ambiguities comes naturally to humans
    because we can\r\nguess at the meaning of a message, but cold-hearted computers\r\ncan
    only follow the explicit rules we've given them.\r\n\r\n## Can we free ourselves
    from the limitations of syntax?\r\n\r\nOne solution to the syntactic ambiguity
    problem is to represent information in\r\na way that is convenient for computers,
    rather than optimizing for\r\nhuman readability. For example, here's the same
    array of strings\r\nrepresented as a raw sequence of bytes in [MessagePack format]:\r\n\r\n```\r\n93
    a7 50 52 49 56 4d 53 47 b8 23 70 72 61 63 74 69 63 69 6e 67 2d 72 75 62 \r\n79
    2d 74 65 73 74 69 6e 67 bd 53 65 61 73 6f 6e 73 20 67 72 65 65 74 69 6e \r\n67
    73 20 74 6f 20 79 6f 75 20 61 6c 6c 21\r\n```\r\n\r\nAt first, this looks like
    a huge step backwards, because it smashes our\r\nability to intuitively extract
    meaning from the message by simply\r\nreading its contents. But when we discover
    that the vast majority of\r\nthese bytes are just encoded character data, things
    get a little\r\nmore comprehensible:\r\n\r\n```ruby\r\n\"\\x93\\xA7PRIVMSG\\xB8#practicing-ruby-testing\\xBDSeasons
    greetings to you all!\"\r\n```\r\n\r\nKnowing that most of the message is the
    same text we've seen in the other\r\nexamples, we only need to figure out what
    the few extra bytes of information\r\nrepresent:\r\n\r\n![](//i.imgur.com/YAh5olr.png)\r\n\r\nLike
    all binary formats, MessagePack is optimized for ease of processing\r\nrather
    than human readability. Instead using text-based symbols to describe \r\nthe structure
    of data, MessagePack uses an entirely numeric encoding format.\r\n\r\nBy switching
    away from brackets, commas, and quotation marks to arbitrary\r\nvalues like `93`,
    `A7`, `B8`, and `BD`, we immediately lose the ability to\r\nvisually distinguish
    between the different structural elements of the \r\nmessage. This makes it harder
    to simply look at a message and know whether\r\nor not it is well-formed, and
    also makes it harder to notice the connections\r\nbetween the symbols and their
    meaning while reading an encoded message.\r\n\r\nIf you squint really hard at
    the yellow boxes in the above diagram, you might\r\nguess that `93` describes
    the entire array, and that `A7`, `B8`, and `BD`\r\nall describe the strings that
    follow them. But `A7`, `B8`, and `BD` need to\r\nbe expressing more than just
    the concept of a *string*, otherwise there\r\nwould be no need to use three different
    values. You might be able to\r\ndiscover the underlying rule by studying the example
    for a while, but\r\nit doesn't just jump out at you the way a pair of opening
    and closing\r\nbrackets might.\r\n\r\nTo avoid leaving you in suspense, here's
    the key concept: MessagePack\r\nattempts to represent seralized data structures
    using as few bytes \r\nas possible, while making processing as fast as possible.
    To do this,\r\nMessagePack uses type headers that tell you exactly what type of\r\ndata
    is encoded, and exactly how much space it takes up in \r\nthe message. For small
    chunks of data, it conveys both of these\r\npieces of information using a single
    byte!\r\n\r\nTake for example the first byte in the message, which has the\r\nhexadecimal
    value of `93`. MessagePack maps the values `90-9F`\r\nto the concept of *arrays
    with up to 15 elements*. This\r\nmeans that an array with zero elements would
    have the type code \r\nof `90` and an array with 15 elements would have the type
    code\r\nof `9F`. Following the same logic, we can see that `93` represents \r\nan
    array with 3 elements.\r\n\r\nFor small strings, a similar encoding process is
    used. Values in \r\nthe range of `A0-BF` correspond to *strings with up to 31
    bytes of data*.\r\nAll three of our strings are in this range, so to compute\r\ntheir
    size, we just need to subtract the bottom of the range\r\nfrom each of them:\r\n\r\n```ruby\r\n#
    note that results are in decimal, not hexadecimal\r\n# String sizes are also computed
    explicitly for comparison\r\n\r\n>> 0xA7-0xA0\r\n=> 7\r\n>> \"PRIVMSG\".size\r\n=>
    7\r\n\r\n>> 0xB8-0xA0\r\n=> 24\r\n>> \"#practicing-ruby-testing\".size\r\n=> 24\r\n\r\n>>
    0xBD-0xA0\r\n=> 29\r\n>> \"Seasons greetings to you all!\".size\r\n=> 29\r\n```\r\n\r\nPiecing
    this all together, we can now see the orderly structure\r\nthat was previously
    obfuscated by the compact nature of the\r\nMessagePack format:\r\n\r\n![](//i.imgur.com/H9lOSex.png)\r\n\r\nAlthough
    this appears to be superficially similar to the structure\r\nof our Ruby array
    example, there are significant differences that\r\nbecome apparent when attempting
    to process the MessagePack data:\r\n\r\n* In a text-based format you need to look
    ahead to find closing\r\nbrackets to match opening brackets, to organize quotation
    marks\r\ninto pairs, etc. In MessagePack format, explicit sizes for each\r\nobject
    are given so you know exactly where its data is stored\r\nin the bytestream.\r\n\r\n*
    Because we don't need to analyze the contents of the message\r\nto determine how
    to break it up into chunks, we don't need\r\nto worry about ambiguous interpretation
    of symbols in the data.\r\nThis avoids the need for introducing escape sequences
    for the\r\nsole purpose of making parsing easier.\r\n\r\n* The explicit separation
    of metadata from the contents of the\r\nmessage makes it possible to read part
    of the message without\r\nanalyzing the entire bytestream. We just need to extract
    all\r\nthe relevant type and size information, and then from there\r\nit is easy
    to compute offsets and read just the data we need.\r\n\r\nThe underlying theme
    here is that by compressing all of the\r\nstructural meaning of the message into
    simple numerical values,\r\nwe convert the whole problem of extracting the message
    into\r\na series of trivial computations: read a few bytes to determine\r\nthe
    type information and size of the encoded data, then\r\nread some content and decode
    it based on the specified type,\r\nthen rinse and repeat.\r\n\r\n## Separating
    structure from meaning via abstract types\r\n\r\nEven though representing our
    message in a binary format allowed\r\nus to make information extraction more precise,
    \r\nthe data type we used still corresponds to concepts that don't exactly\r\nfit
    the intended meaning of our message.\r\n\r\nOne possible way to solve this conceptual
    mapping problem is to completely \r\ndecouple structure from meaning in our message
    format. To do that,\r\nwe could utilize MessagePack's application-specific type
    mechanism;\r\nresulting in a message similar to what you see below:\r\n\r\n![](//i.imgur.com/s3Rjgzz.png)\r\n\r\nThe
    `C7` type code indicates an abstract type, and is followed\r\nby two additional
    bytes: the first provides an arbitrary type\r\nid (between 0-127), and the second
    specifies how many bytes\r\nof data to read in that format. After applying these
    rules,\r\nwe end up with the following structure:\r\n\r\n![](//i.imgur.com/AubaxCk.png)\r\n\r\nThe
    contents of each object in the array is the same as it always\r\nhas been, but
    now the types have changed. Instead of an\r\narray composed of three strings,
    we now have an array that\r\nconsists of elements that each have their own type.\r\n\r\nAlthough
    I've illustrated the contents of each object as text-based\r\nstrings for the
    sake of readability,\r\nthe MessagePack format does not assume that the data associated\r\nwith
    abstract types will be text-based. The decision of\r\nhow to process this data
    is left up to the decoder.\r\n\r\nWithout getting into too many details, let's
    consider how abstract\r\ndata types might be handled in a real Ruby program[^3]
    that processed\r\nMessagePack-based messages. You'd need to make an explicit mapping\r\nbetween
    type identifiers and the handlers for each type, perhaps\r\nusing an API similar
    to what you see below:\r\n\r\n```ruby\r\ndata_types = { 1 => CommandName, 2 =>
    Parameter, 3 => MessageBody }\r\n\r\ncommand = MessagePackDecoder.unpack(raw_bytes,
    data_types)\r\n#  [ CommandName <\"PRIVMSG\">, \r\n#    Parameter   <\"#practicing-ruby-testing\">,
    \r\n#    MessageBody <\"Season greetings to you all!\"> ]\r\n```\r\n\r\nEach handler
    would be responsible for transforming raw byte arrays\r\ninto meaningful data
    objects. For example, the following class might\r\nbe used to convert message
    parameters (e.g. the channel name) into\r\na text-based representation:\r\n\r\n```ruby\r\nclass
    Parameter\r\n  def initialize(byte_array)\r\n    @text = byte_array.pack(\"C*\")\r\n\r\n
    \   raise ArgumentError if @text.include?(\" \")\r\n  end\r\n\r\n  attr_reader
    :text\r\nend\r\n```\r\n\r\nThe key thing to note about the above code sample is
    that\r\nthe `Parameter` handler does not simply convert the raw binary into\r\na
    string, it also applies a validation to ensure that the\r\nstring contains no
    space characters. This is a bit of a\r\ncontrived example, but it's meant to illustrate
    the ability\r\nof custom type handlers to apply their own data integrity\r\nconstraints.\r\n\r\nEarlier
    we had drawn a line in the sand between the \r\narray-of-strings representation
    and the IRC message format\r\nbecause the former was forced to allow spaces in
    strings\r\nuntil after the parsing phase, and the latter was forced\r\nto make
    a decision about whether to allow them or not\r\nbefore parsing could be completed
    at all. The use\r\nof abstract types removes this limitation, allowing us to choose
    when and where to\r\napply our validations, if we apply them at all.\r\n\r\nAnother
    dividing wall that abstract types seem to blur for\r\nus is the question of what
    the raw contents of our message\r\nactually represent. Using our own application-specific
    type\r\ndefinitions make it so that we never need to consider the\r\ncontents
    of our messages to be strings, except as an\r\ninternal implementation detail.
    However, we rely\r\nabsolutely on our decoder to convert data that has been\r\ntagged
    with these arbitrary type identifiers\r\ninto something that matches the underlying
    meaning of \r\nthe message. In introducing abstract types, we have \r\nsomehow
    managed to make our information format more precise \r\nand more opaque at the
    same time.\r\n\r\n## Combining human intuition with computational rigor \r\n\r\nAs
    we explored the MessagePack format, we saw that by coming up with very\r\nprecise
    rules for processing an input stream, we can interpet messages by\r\nrunning a
    series of simple and unambiguous computations. But in the\r\nprocess of making
    things easier for the computer, we complicated\r\nthings for humans. Try as we
    might, we aren't very good at\r\nrapidly extracting meaning from numeric sequences
    like\r\n`93`, `C7 01 07`, `C7 02 18`, and `C7 03 1D`.\r\n\r\nSo now we've come
    full circle in our explorations, realizing that we really do\r\nwant to express
    ourselves using something like the text-based IRC message \r\nformat. Let's look
    at it one last time to reflect on its strengths\r\nand weaknesses:\r\n\r\n```\r\nPRIVMSG
    #practicing-ruby-testing :Seasons greetings to you all!\\r\\n\r\n```\r\n\r\nThe
    main feature of representing our message this way is that because we're\r\nfamiliar
    with the concept of *commands* as programmers, it is easy to see\r\nthe structure
    of the message without even worrying about its exact syntax \r\nrules: we know
    intuitively that `PRIVMSG` is the command being sent,\r\nand that `#practicing-ruby-testing`
    and `Seasons greetings to you all!`\r\nare its parameters. From here, it's easy
    to extract the underlying\r\nmeaning of the message, which is: \"Send the message
    'Seasons greetings to you\r\nall!' to the #practicing-ruby-testing channel\".\r\n\r\nThe
    drawback is that we're hazy on the details: we can't simply guess the rules\r\nabout
    whitespace in parameters, and we don't know exactly how to interpret \r\nthe `:`
    character or the `\\r\\n` at the end of the message. Because a correct \r\nimplementation
    of the IRC protocol will need to consider\r\nvarious edge cases, attempting to
    precisely describe the message format\r\nverbally is challenging. That said, we
    could certainly give\r\nit a try, and see what happens...\r\n\r\n* Messages consist
    of a valid IRC command and its parameters\r\n(if any), followed by `\\r\\n`.\r\n\r\n*
    Commands are either made up solely of letters, or are\r\nrepresented as a three
    digit number.\r\n\r\n* All parameters are separated by a single space character.\r\n\r\n*
    Parameters may not contain `\\r\\n` or the null character (`\\0`).\r\n\r\n* All
    parameters except for the last parameter must not contain\r\nspaces and must not
    start with a `:` character.\r\n\r\n* If the last parameter contains spaces or
    starts with a `:`\r\ncharacter, it must be separated from the rest of the\r\nparameters
    by a `:` character, unless there are exactly\r\n15 parameters in the message.
    \r\n\r\n* When all 15 parameters are present, then the separating `:` \r\ncharacter
    can be omitted, even if the final parameter\r\nincludes spaces.\r\n\r\nThis ruleset
    isn't even a complete specification of the message format, \r\nbut it should be
    enough to show you how specifications written in\r\nprose can quickly devolve
    into the kind of writing you might expect \r\nfrom a tax attorney. Because spoken
    language is inherently fuzzy and \r\nsubjective in nature, it makes it hard to
    be both precise and \r\nunderstandable at the same time.\r\n\r\nTo get around
    these communication barriers, computer scientists\r\nhave come up with *metalanguages*
    to describe the syntactic rules\r\nof protocols and formats. By using precise
    notation with well-defined \r\nrules, it is possible to describe a grammar in
    a way that is both\r\nhuman readable and computationally unambiguous.\r\n\r\nWhen
    we look at the real specification for the IRC message format,\r\nwe see one of
    these metalanguages in use. Below\r\nyou'll see a nearly complete specification[^2]
    for the general form\r\nof IRC messages expressed in [Augmented BackusNaur Form][ABNF]:\r\n\r\n```\r\nmessage
    \   =  command [ params ] crlf\r\ncommand    =  1*letter / 3digit\r\nparams     =
    \ *14( SPACE middle ) [ SPACE \":\" trailing ]\r\n           =/ 14( SPACE middle
    ) [ SPACE [ \":\" ] trailing ]\r\n\r\nnospcrlfcl =  %x01-09 / %x0B-0C / %x0E-1F
    / %x21-39 / %x3B-FF\r\n                ; any octet except NUL, CR, LF, \" \" and
    \":\"\r\n\r\nmiddle     =  nospcrlfcl *( \":\" / nospcrlfcl )\r\ntrailing   =
    \ *( \":\" / \" \" / nospcrlfcl )\r\n\r\nSPACE      =  %x20        ; space character\r\ncrlf
    \      =  %x0D %x0A   ; \"carriage return\" \"linefeed\"\r\nletter     =  %x41-5A
    / %x61-7A       ; A-Z / a-z\r\ndigit      =  %x30-39                 ; 0-9\r\n```\r\n\r\nIf
    you aren't used to reading formal grammar notations, this example may appear\r\nto
    be a bit opaque at first glance. But if you go back and look at the\r\nrules we
    listed out in prose above, you'll find that all of them are expressed\r\nhere
    in a way that leaves far less to the imagination. Each rule tells us\r\nexactly
    what should be read from the input stream, and in what order.\r\n\r\nRepresenting
    syntactic rules this way allows us to clearly understand\r\ntheir intended meaning,
    but that's not the only reason for the formality. \r\nBNF-based grammar notations
    express syntactic rules so precisely that we can \r\nuse them not just as a specification
    for how to build a parser\r\nby hand, but as input data for a code generator that
    can build\r\na highly optimized parser for us. This not only saves development
    effort,\r\nit also reduces the likelihood that some obscure edge case will be\r\nlost
    in translation when converting grammar rules into raw\r\nprocessing code.\r\n\r\nTo
    demonstrate this technique in use, I converted the\r\nABNF representation of the
    IRC message format into a grammar that is \r\nreadable by the [Citrus parser generator][].
    Apart from a few lines of \r\nembedded Ruby code used to transform the input data,
    the following code look \r\nconceptually similar to what you saw above:\r\n\r\n```\r\ngrammar
    IRC\r\n  rule message\r\n    (command params? endline) {\r\n      { :command =>
    capture(:command).value,\r\n        :params  => capture(:params).value }\r\n    }\r\n
    \ end\r\n\r\n  rule command\r\n    letters | three_digit_code \r\n  end\r\n\r\n
    \ rule params\r\n    ( ((space middle)14*14 (space \":\"? trailing)?) |\r\n      ((space
    middle)*14 (space \":\" trailing)?) ) {\r\n      captures.fetch(:middle, []) +
    captures.fetch(:trailing, [])\r\n    }\r\n  end\r\n\r\n  rule middle\r\n    non_special
    (non_special | \":\")*\r\n  end\r\n\r\n  rule trailing\r\n    (non_special | space
    | \":\")+\r\n  end\r\n\r\n  rule letters\r\n    [a-zA-Z]+\r\n  end\r\n\r\n  rule
    three_digit_code\r\n    /\\d{3}/ { to_str.to_i }\r\n  end\r\n\r\n  rule non_special\r\n
    \   [^\\0:\\r\\n ]\r\n  end\r\n\r\n  rule space\r\n    \" \"\r\n  end\r\n\r\n
    \ rule endline\r\n    \"\\r\\n\"\r\n  end\r\nend\r\n```\r\n\r\nLoading this grammar
    into Citrus, we end up with a parser that can correctly\r\nextract the commands
    and paramaters from our original `PRIVMSG` example:\r\n\r\n```ruby\r\nrequire
    'citrus'\r\nCitrus.load('irc')\r\n\r\nmsg = \"PRIVMSG #practicing-ruby-testing
    :Seasons greetings to you all!\\r\\n\"\r\n\r\ndata = IRC.parse(msg).value\r\n\r\np
    data[:command] \r\n#=> \"PRIVMSG\"\r\n\r\np data[:params]\r\n#=> [\"#practicing-ruby-testing\",
    \"Seasons greetings to you all!\"]\r\n```\r\n\r\nIn taking this approach, we're
    forced to accept certain constraints\r\n(like a set of complicated rules about
    where a `:` character can appear), but\r\nwe avoid turning our entire message
    format into meaningless streams of numbers\r\nlike `93` and `C7 01 08`. Even if
    there is a bit more magic going on in the\r\nconversion of a Citrus grammar into
    a functioning parser, we can still see\r\nthe telltale signs of a deterministic
    process lurking just beneath the surface.\r\n\r\nThe decision to express a message
    in a text-based format or a binary format\r\nis one rife with tradeoffs, as we've
    already seen from this single example.\r\nNow that you've seen both approaches,
    consider how you might implement\r\na few different types of message formats.
    Would an audio file be better\r\nrepresented as binary file format, or a text-based
    format? How about\r\na web page? Before you read this article you probably already
    knew the \r\nanswers to those questions, but now hopefully you have a better sense
    of \r\nthe tradeoffs involved in how we choose to represent information in\r\nsoftware
    systems.\r\n\r\n## The philosophical conundrum of information exchange\r\n\r\nComputers
    are mindless automatons, and humans are bad at numbers. This\r\nfriction between
    people and their machines runs so deep that\r\nit's remarkable that any software
    gets built\r\nat all. But because there is gold to be found at the\r\nother side
    of the computational tarpit, we muddle through our differences \r\nand somehow
    manage to make it all work.\r\n\r\nTo work together, computers and humans need
    a bridge between their mutually\r\nexclusive ways of looking at the world. And
    this is what coding is all about!\r\nWe *encode* information into data and source
    code for computers to process,\r\nand then after the work is done, we *decode*
    the results of a computation back\r\ninto a human-friendly message format. \r\n\r\nOnce
    everything is wired up, human users of software can think mostly \r\nin terms
    of meaningful information exchange, and software systems only need to \r\nworry
    about moving numbers around and doing basic arithmetic operations. \r\nAlthough
    it isn't especially romantic, this is how programmers trick computers \r\nand
    humans into cooperating with each other. When done well, people barely\r\nnotice
    the presence of the software system at all, and focus entirely on\r\ntheir job
    to be done. This suits the computer just fine, as it does not\r\ncare at all what
    puny humans think of it.\r\n\r\nAs programmers, we must concern ourselves with
    the needs of both people \r\nand machines. We are responsible for connecting two
    seemingly incompatible worlds,\r\neach with their own set of rules and expectations.
    This is what makes \r\nour job hard, but is also what makes it rewarding and almost
    magical \r\nat times. We've just explored some examples of the sorts of challenges
    that\r\ncan arise along the boundary line between people and machines, \r\nbut
    I'm sure you can think of many more that are present in your own work. \r\n\r\nThe
    next time you come across a tension point in your software design\r\nprocess,
    take a moment to  reflect on these ideas, and see what kind of \r\ninsights arise.
    Is the decision you're about to make meant to\r\nbenefit the people who use your
    software, or the machines that run your code?\r\nConsider the tradeoffs carefully,
    but when in doubt, always choose to \r\nsatisfy the humans. :grin:\r\n\r\n> **NOTE:**
    While writing this article, I was also reading \"Gdel, Escher, Bach\"\r\nin my
    spare time. Though I don't directly use any of its concepts here, Douglas\r\nHofstadter
    deserves credit (and/or blame) for getting me to think deeply\r\non *the meaning
    of meaning* and how it relates to software development.\r\n\r\n[^1]: Having too
    much or too little expressiveness in a format is pretty much a guarantee, because
    even as we get closer to the *Goldilocks Zone*, increasingly subtle edge cases
    tend to proliferate. Since we can't expect perfection, we need to settle for expressiveness
    that's \"good enough\" and the tradeoffs that come along with it.\r\n\r\n[^2]:
    For the sake of simplicity, I omitted the optional prefix in IRC messages which
    contains information about the sender of a message, because it involves somewhat
    complicated URI parsing. See [page 7 of the IRC specification](http://tools.ietf.org/html/rfc2812#page-7)
    for details.\r\n\r\n[^3]: The abstract types API shown in this article is only
    a theoretical example, because the [official MessagePack library](https://github.com/msgpack/msgpack-ruby)
    for Ruby does not support application-specific types as of September 2014, even
    though they're documented in the specification. It may be a fun patch to write
    if you want to explore these topics more, though!\r\n\r\n[MessagePack format]:
    https://github.com/msgpack/msgpack/blob/master/spec.md\r\n[Citrus parser generator]:
    https://github.com/mjackson/citrus\r\n[ABNF]: http://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_Form\r\n"
- :slug: problem-discovery
  :title: Problem discovery comes before problem solving
  :summary: A brief story about why you should play around with problems before trying
    to solve them.
  :published: 2015-03-26 00:00:00.000000000 Z
  :issue_number: '8.1'
  :volume: 8
  :body: "Imagine you're a programmer for a dental clinic, and they need your help
    to build a vacation scheduling system for their staff. Among other things, this
    system will display a calendar to staff members that summarizes all of the currently
    approved and pending vacation requests for the clinic, grouped by role.\r\n\r\nThe
    basic idea here is simple: If a dental assistant wants to take a week off some
    time in July, it'd be more likely to get time off approved for a week where there
    was only one other assistant out of the office than it would be for a week when
    five others were on vacation. Rather than waiting for a manager to review their
    request (which might take a while), this information can be supplied up front
    to make planning easier for everyone.\r\n\r\nYour vacation request system already
    has been implemented weeks ago, so you can easily get all the data you need on
    who is requesting what time off, and who has already had their time off approved.
    Armed with this information, building the request summary calendar should be easy,
    right? Just take all the requests and then group them by employee roles, and then
    spit them out in chronological order. You'll be able to roll out this new feature
    into production by lunch time!\r\n\r\nYou grab your morning coffee, and sit down
    to work. Before you can even open your text editor, an uncomfortable realization
    weighs heavily upon you: Roles are actually a property of shifts, not employees.
    Your clinic is understaffed, and so some employees are cross-trained and need
    to wear multiple hats. To put it bluntly, there's at least one employee that's
    not precisely a receptionist, and would be more adequately described as \"receptionish\".
    She helps out in the billing office at times, and whenever she's working there,
    the clinic is down a receptionist.\r\n\r\nYou do have access to some data about
    individual shifts, so maybe that could be used to determine roles. By the time
    a shift is approved, the role is set, and you know for sure what that employee
    is doing for that day. \r\n\r\nYou think for a little while. You uncover a few
    annoying problems that will need to be solved if you decide to go this route.\r\n\r\nThe
    shift data is coming from a third party shift planning system, and the import
    window is set out only ten weeks into the future.  In practice, shifts aren't
    really firmly committed to until four weeks out, so that makes the practical window
    even smaller. \r\n\r\nThe idea that a given employee's shift in July would be
    set in stone by March is a fantasy, and so even if you could get at that data,
    it wouldn't be perfectly accurate. There's also no guarantee that attempting to
    import five times more data than what you're currently working with won't cause
    problems the whole synchronization system was built in a bit of a hurry, and
    could be fragile in places.\r\n\r\nFeeling the anxiety start to set in, you go
    for a quick walk around the block, and come to the realization that you've gone
    into problem solving mode already, when you really should be more in the problem
    discovery phase of things. You haven't even answered the question of how many
    employees work in multiple different roles, and you're already assuming that's
    a problem that needs a clear solution.\r\n\r\nAn idea pops into your head. You
    rush to your desk, and pop open a Rails console in production. You write a crude
    query and then massage the data with an ugly chain of Enumerable methods, and
    end up with a report that looks like this:\r\n\r\n```ruby\r\n [\"Nikko Bergnaum\",
    [[\"Hygienists\", 5]]],\r\n [\"Anderson Miller\", [[\"Billing\", 50]]],\r\n [\"Bell
    Effertz\", [[\"Hygienists\", 14]]],\r\n [\"Vicky Okuneva\", [[\"Receptionists\",
    30]]],\r\n [\"Lavern Von\", [[\"Assistants\", 37]]],\r\n [\"Crawford Purdy\",
    [[\"Receptionists\", 40]]],\r\n [\"Valentin Daugherty\", [[\"Hygienists\", 61]]],\r\n
    [\"Eudora Bauch\", [[\"Receptionists\", 40]]],\r\n [\"Jaeden Bashirian\", [[\"Assistants\",
    28]]],\r\n [\"Roel Hammes\", [[\"Dentists\", 36]]],\r\n [\"King Schowalter\",
    [[\"Hygienists\", 20]]],\r\n [\"Liam Kovacek\", [[\"Receptionists\", 55]]],\r\n
    [\"Elaina Von\", [[\"Hygienists\", 25]]],\r\n [\"Susie Watsica\", [[\"Hygienists\",
    31]]],\r\n [\"Oswaldo Boyer\", [[\"Hygienists\", 20]]],\r\n [\"Gardner Fay\",
    [[\"Hygienists\", 10]]],\r\n [\"Joanny Beatty\", [[\"Assistants\", 52]]],\r\n
    [\"Beth Yost\", [[\"Hygienists\", 34]]],\r\n [\"Gerry Torphy\", [[\"Hygienists\",
    10]]],\r\n [\"Maureen Terry\", [[\"Hygienists\", 9]]],\r\n [\"Maritza Kemmer\",
    [[\"Billing\", 25]]],\r\n [\"Morton Hudson\", [[\"Dentists\", 61]]],\r\n [\"Santino
    Parker\", [[\"Hygienists\", 49]]],\r\n [\"Jesse Friesen\", [[\"Hygienists\", 31]]],\r\n
    [\"Dillan Krajcik\", [[\"Hygienists\", 44]]],\r\n [\"Travon Koch\", [[\"Hygienists\",
    16]]],\r\n [\"Audreanne Hand\", [[\"Billing\", 47]]],\r\n [\"Coralie Predovic\",
    [[\"Receptionists\", 45]]],\r\n [\"Jovani Schulist\", [[\"Management\", 50]]],\r\n
    [\"Tanner D'Amore\", [[\"Dentists\", 41]]],\r\n [\"Jace Nitzsche\", [[\"Dentists\",
    21]]],\r\n [\"Carolina Waters\", [[\"Receptionists\", 40]]],\r\n [\"Terence Howell\",
    [[\"Dentists\", 39]]],\r\n [\"Leann Pacocha\", [[\"Assistants\", 2]]],\r\n [\"Alvah
    Rippin\", [[\"Dentists\", 50]]],\r\n [\"Lorenzo West\", [[\"Hygienists\", 27]]],\r\n
    [\"Gideon McKenzie\", [[\"Dentists\", 41]]],\r\n [\"Katrine O'Reilly\", [[\"Dentists\",
    51]]],\r\n [\"Briana Ziemann\", [[\"Dentists\", 40]]],\r\n [\"Jerome Harris\",
    [[\"Dentists\", 10]]],\r\n [\"Misael Pagac\", [[\"Assistants\", 51]]],\r\n [\"Krista
    Predovic\", [[\"Assistants\", 32]]],\r\n [\"Carole O'Hara\", [[\"Assistants\",
    42]]],\r\n [\"Adalberto Doyle\", [[\"Management\", 49], [\"Receptionists\", 2]]],\r\n
    [\"Noel Ortiz\", [[\"Management\", 28], [\"Receptionists\", 1]]],\r\n [\"Monique
    McLaughlin\", [[\"Receptionists\", 43], [\"Assistants\", 1]]],\r\n [\"Jaleel Graham\",
    [[\"Billing\", 50], [\"Receptionists\", 18]]],\r\n [\"Ned Reilly\", [[\"Receptionists\",
    50], [\"Assistants\", 1]]],\r\n [\"Enrico Schowalter\", [[\"Receptionists\", 1],
    [\"Assistants\", 55]]],\r\n [\"Caesar Goldner\", [[\"Management\", 30], [\"Receptionists\",
    16]]],\r\n [\"Kirstin Weissnat\", [[\"Receptionists\", 26], [\"Assistants\", 28]]],\r\n
    [\"Guillermo Klein\",\r\n  [[\"Assistants\", 41], [\"Hygienists\", 2], [\"Receptionists\",
    3]]]]\r\n```\r\n\r\nThis listing shows all the shifts planned for the next ten
    weeks, with counts for each employee by role. You copy and paste it into a text
    editor, and delete any of the lines for employees that have a single role. Here's
    what you end up with:\r\n\r\n```ruby\r\n   [\"Adalberto Doyle\", [[\"Management\",
    49], [\"Receptionists\", 2]]],\r\n [\"Noel Ortiz\", [[\"Management\", 28], [\"Receptionists\",
    1]]],\r\n [\"Monique McLaughlin\", [[\"Receptionists\", 43], [\"Assistants\",
    1]]],\r\n [\"Jaleel Graham\", [[\"Billing\", 50], [\"Receptionists\", 18]]],\r\n
    [\"Ned Reilly\", [[\"Receptionists\", 50], [\"Assistants\", 1]]],\r\n [\"Enrico
    Schowalter\", [[\"Receptionists\", 1], [\"Assistants\", 55]]],\r\n [\"Caesar Goldner\",
    [[\"Management\", 30], [\"Receptionists\", 16]]],\r\n [\"Kirstin Weissnat\", [[\"Receptionists\",
    26], [\"Assistants\", 28]]],\r\n [\"Guillermo Klein\",\r\n  [[\"Assistants\",
    41], [\"Hygienists\", 2], [\"Receptionists\", 3]]]]\r\n```\r\n\r\nNow you've whittled
    the list down to only 9 people. In a business that employees over 50 people, this
    is 20% of the workforce, which isn't a tiny number. But taking a closer look at
    the data, you realize something else: even on this list of cross-trained employees,
    most staff members work in a single role the majority of the time, and very rarely
    fill in for another role.\r\n\r\nFiltering the list again, you remove anyone who
    works in a single role at least 90% of the time. After this step, only three employees
    remain on your list:\r\n\r\n```ruby\r\n [\"Jaleel Graham\", [[\"Billing\", 50],
    [\"Receptionists\", 18]]],\r\n [\"Caesar Goldner\", [[\"Management\", 30], [\"Receptionists\",
    16]]],\r\n [\"Kirstin Weissnat\", [[\"Receptionists\", 26], [\"Assistants\", 28]]]]]]]\r\n```\r\n\r\nBecause
    these employees represent only about 5% of the total staff, you've revealed this
    problem as an edge case. For the other six employees that substitute for a different
    role once in a blue moon, you'd have at least 90% accuracy by always labeling
    them by their primary role. It'd be confusing to refer to them as anything else,
    at least for the purposes of vacation planning.\r\n\r\nIn the process of this
    ad-hoc exploration, you've discovered a reasonably accurate method of predicting
    employee roles far out into the future: if at least 90% of the shifts they're
    assigned are for a particular role, assume that is their primary role. Otherwise,
    label them as cross-trained, listing out all the roles they commonly fill in for.
    For example, \r\nJaleel could be listed as \"X-Trained (Billing, Receptionist)\",\r\nKirsten
    as \"X-Trained (Receptionist, Assistant)\", and Caesar as \"X-Trained (Receptionist,
    Management)\".\r\n\r\nTaking this approach will be at least as reliable as using
    the raw shift data, and requires no major technical changes to the system's under-plumbing.
    It's also dynamic, in the sense that the system will adaptively relabel employees
    as cross trained when they're doing more than one role on a regular basis.\r\n\r\nHappy
    with this re-evaluation of the problem, you start working, and you manage to get
    the feature into production before lunch after all. In the worst case scenario,
    you can always come back to this and do more careful analysis, peering into the
    technological and philosophical rabbit hole that made you nervous in the first
    place. But there's a very good chance that this solution will work just fine,
    and so it's worth trying it out before venturing out into the darkness.\r\n\r\nFrom
    this small exercise, you come to a powerful realization:\r\n\r\n> Software isn't
    mathematically perfect reality, it's a useful fiction meant to capture some aspect
    of reality that is interesting or important to humans. Although our technical
    biases may aim for logical purity in the code we write, the humans that use our
    work mainly care about the story we're trying to tell them. We should seek the
    most simple solutions that allow us to tell that story, even if those solutions
    lack technical elegance.\r\n\r\nIn other words, feel free to ignore the man behind
    the curtain."
- :slug: formula-processing
  :title: 'Safely evaluating user-defined formulas and calculations '
  :summary: Learn how to use the Dentaku formula parser/evaluator to run Excel-like
    formulas in Ruby programs (w. Solomon White)
  :published: 2015-09-10 00:00:00.000000000 Z
  :issue_number: '8.2'
  :volume: 8
  :body: "> This article was written in collaboration with Solomon White ([@rubysolo](http://twitter.com/rubysolo)).
    Solomon is a software developer from Denver, where he builds web applications
    with Ruby and ENV.JAVASCRIPT_FRAMEWORK.  He likes code, caffeine, and capsaicin.\r\n\r\nImagine
    that you're a programmer for a company that sells miniature zen gardens, and you've
    been asked to create a  small calculator program that will help determine the
    material costs of the various different garden designs in the company's product
    line.\r\n\r\nThe tool itself is simple: The dimensions of the garden to be built
    will be entered via a web form, and then calculator will output the quantity and
    weight of all the materials that are needed to construct the garden. \r\n\r\nIn
    practice, the problem is a little more complicated, because the company offers
    many different kinds of gardens. Even though only a handful of basic materials
    are used throughout the entire product line, the gardens themselves can consist
    of anything from a plain rectangular design to very intricate and complicated
    layouts. For this reason, figuring out how much material is needed for each garden
    type requires the use of custom formulas.\r\n\r\n> MATH WARNING: You don't need
    to think through the geometric computations being done throughout this article,
    unless you enjoy that sort of thing; just notice how all the formulas are ordinary
    arithmetic expressions that operate on a handful of variables.\r\n\r\nThe following
    diagram shows the formulas used for determining the material quantities for two
    popular products. *Calm* is a minimal rectangular garden, while *Yinyang* is a
    more complex shape that requires working with circles and semicircles: \r\n\r\n![](//i.imgur.com/JlKz2kC.png)\r\n\r\nIn
    the past, material quantities and weights for new product designs were computed
    using Excel spreadsheets, which worked fine when the company only had a few different
    garden layouts. But to keep up with the incredibly high demand for bespoke desktop
    Zen Gardens, the business managers have insisted that their workflow become more
    Agile by moving all product design activities to a web application in THE CLOUD.\r\n\r\nThe
    major design challenge for building this calculator is that it would not be practical
    to have a programmer update the codebase whenever a new product idea was dreamt
    up by the product design team. Some days, the designers have been known to attempt
    at least 32 different variants on a \"snowman with top-hat\" zen garden, and in
    the end only seven or so make it to the marketplace. Dealing with these rapidly
    changing requirements would drive any reasonable programmer insane.\r\n\r\nAfter
    reviewing the project requirements, you decide to build a program that will allow
    the product design team to specify project requirements in a simple, Excel-like
    format and then safely execute the formulas they define within the context of
    a Ruby-based web application.\r\n\r\nFortunately, the [Dentaku](https://github.com/rubysolo/dentaku)
    formula parsing and evaluation library was built with this exact use case in mind.
    Just like you, Solomon White also really hates figuring out snowman geometry,
    and would prefer to leave that as an exercise for the user.\r\n\r\n## First steps
    with the Dentaku formula evaluator\r\n\r\nThe purpose of Dentaku is to provide
    a safe way to execute user-defined mathematical formulas within a Ruby application.
    \ For example, consider the following code:\r\n\r\n```ruby\r\nrequire \"dentaku\"\r\n\r\ncalc
    = Dentaku::Calculator.new\r\nvolume = calc.evaluate(\"length * width * height\",
    \r\n                       :length => 10, :width => 5, :height => 3)\r\n\r\np
    volume #=> 150\r\n```\r\n\r\nNot much is going on here -- we have some named variables,
    some numerical values, and a simple formula: `length * width * height`.  Nothing
    in this example appears to be sensitive data, so on the surface it may not be
    clear why safety is a key concern here. \r\n\r\nTo understand the risks, you consider
    an alternative implementation that allows mathematical formulas to be evaluated
    directly as plain Ruby code. You implement the equivalent formula evaluator without
    the use of an external library, just to see what it would look like:\r\n\r\n```ruby\r\ndef
    evaluate_formula(expression, variables)\r\n   obj = Object.new\r\n\r\n   def obj.context\r\n
    \    binding\r\n   end\r\n\r\n   context = obj.context\r\n\r\n   variables.each
    { |k,v| eval(\"#{k} = #{v}\", context) }\r\n   eval(expression, context)\r\nend\r\n\r\nvolume
    = evaluate_formula(\"length * width * height\",\r\n                  :length =>
    10, :width => 5, :height => 3) \r\n\r\np volume #=> 150\r\n```\r\n\r\nAlthough
    conceptually similar, it turns out these two code samples are worlds apart when
    you consider the implementation details:\r\n\r\n* When using Dentaku, you're working
    with a very basic external domain specific language, which only knows how to represent
    simple numbers, variables, mathematical operations, etc. No direct access to the
    running Ruby process or its data is provided, and so formulas can only operate
    on what is explicitly provided to them whenever a `Calculator` object is instantiated.\r\n\r\n*
    When using `eval` to run formulas as Ruby code, by default any valid Ruby code
    will be executed. Every instantiated object in the process can be accessed, system
    commands can be run, etc. This isn't much different than giving users access to
    the running application via an `irb` console.\r\n\r\nThis isn't to say that building
    a safe way to execute user-defined Ruby scripts isn't possible (it can even be
    practical in certain circumstances), but if you go that route, safe execution
    is something you need to specifically design for. By contrast, Dentaku is safe
    to use with minimally trusted users, because you have very fine-grained control
    over the data and actions those users will be able to work with.\r\n\r\nYou sit
    quietly for a moment and ponder the implications of all of this. After exactly
    four minutes of very serious soul searching, you decide that for the existing
    and forseeable future needs of our overworked but relentlessly optimistic Zen
    garden designers... Dentaku should work just fine. To be sure that you're  on
    the right path, you begin working on a functional prototype to share with the
    product team.\r\n\r\n## Building the web interface\r\n\r\nYou spend a little bit
    of time building out the web interface for the calculator, using Sinatra and Bootstrap.
    It consists of only two screens, both of which are shown below:\r\n\r\n![](//i.imgur.com/h0ftlcF.png)\r\n\r\nPeople
    who mostly work with Excel spreadsheets all day murmur that you must be some sort
    of wizard, and compliment you on your beautiful design. You pay no attention to
    this, because your mind has already started to focus on the more interesting parts
    of the problem.\r\n\r\n> **SOURCE FILES:** [app.rb](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/app.rb)
    // [app.erb](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/views/app.erb)
    // [index.erb](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/views/index.erb)
    // [materials.erb](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/views/materials.erb)\r\n\r\n##
    Defining garden layouts as simple data tables\r\n\r\nWith a basic idea in mind
    for how you'll implement the calculator, your next task is to figure out how to
    define the various garden layouts as a series of data tables.\r\n\r\nYou start
    with the weight calculations table, because it involves the most basic computations.
    The formulas all boil down to variants on the `mass = volume * density` equation:\r\n\r\n![](//i.imgur.com/1VIrDO1.png)\r\n\r\nThis
    material weight lookup table is suitable for use in all of the product definitions,
    but the `quantity` value will vary based both on the dimensions of the garden
    to be built and the physical layout of the garden.\r\n\r\nWith that in mind, you
    turn your attention to the tables that determine how much material is needed for
    each project, starting with the Calm rectangular garden as an example.\r\n\r\nGoing
    back to the diagram from earlier, you can see that the quantity of materials needed
    by the Calm project can be completely determined by the length, width, height,
    and desired fill level for the sandbox:\r\n\r\n![](//i.imgur.com/BfHgoPB.png)\r\n\r\nYou
    could directly use these formulas in project specifications, but it would feel
    a little too low-level. Project designers will need to work with various box-like
    shapes often, and so it would feel more natural to describe the problem with terms
    like perimeter, area, volume, etc. Knowing that the Dentaku formula processing
    engine provides support for creating helper functions, you come up with the following
    definitions for the materials used in the Calm project:\r\n\r\n![](//i.imgur.com/xyYtuAM.png)\r\n\r\nWith
    this work done, you turn your attention to the Yinyang circular garden project.
    Even though it is much more complex than the basic rectangular design, you notice
    that it too is defined entirely in terms of a handful of simple variables -- diameter,
    height, and fill level:\r\n\r\n![](//i.imgur.com/1G0vaNx.png)\r\n\r\nAs was the
    case before, it would be better from a product design perspective to describe
    things in terms of circular area, cylindrical volume, and circumference rather
    than the primary dimensional variables, so you design the project definition with
    that in mind:\r\n\r\n![](//i.imgur.com/d71MgSp.png)\r\n\r\nTo make the system
    easily customizable by the product designers, the common formulas used in the
    various garden layouts will also be stored in a data table rather than hard-coding
    them in the web application. The following table lists the names and definitions
    for all the formulas used in the *Calm* and *Yinyang* projects:\r\n\r\n![](//i.imgur.com/ovOhwEX.png)\r\n\r\nNow
    that you have a rough sense of what the data model will look like, you're ready
    to start working on implementing the calculator program. You may need to change
    the domain model at some point in the future to support more complex use cases,
    but many different garden layouts can already be represented in this format.\r\n\r\n>
    **SOURCE FILES:** [calm.csv](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/db/projects/calm.csv)
    // [yinyang.csv](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/db/projects/yinyang.csv)
    // [materials.csv](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/db/materials.csv)
    // [common_formulas.csv](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/db/common_formulas.csv)\r\n\r\n##
    Implementing the formula processor\r\n\r\nYou start off by building a utility
    class for reading all the relevant bits of project data that will be needed by
    the calculator. For the most part, this is another boring chore -- it involves
    nothing more than loading CSV and JSON data into some arrays and hashes.\r\n\r\nAfter
    a bit of experimentation, you end up implementing the following interface:\r\n\r\n```ruby\r\np
    Project.available_projects \r\n#=> [\"calm\", \"yinyang]\r\n\r\np Project.variables(\"calm\")
    \r\n#=> [\"length\", \"width\", \"height]\r\n\r\np Project.weight_formulas[\"black
    sand\"] \r\n#=> \"quantity * 2.000\r\n\r\np Project.quantity_formulas(\"yinyang\")\r\n
    \         .select { |e| e[\"name\"] == \"black sand\" } #=>\r\n# [{\"name\" =>
    \"black sand\", \r\n#    \"formula\" => \"cylinder_volume * 0.5 * fill\", \r\n#
    \   \"unit\" => \"cu cm}]\r\n\r\np Project.common_formulas[\"cylinder_volume\"]\r\n#=>
    \"circular_area * height\r\n```\r\n\r\nDown the line, the `Project` class will
    probably read from a database rather than text files, but this is largely an implementation
    detail. Rather than getting bogged down in ruminations about the future, you shift
    your attention to the heart of the problem -- the Dentaku-powered `Calculator`
    class.\r\n\r\nThis class will be instantiated with the name of a particular garden
    layout and a set of dimensional parameters that will be used to determine how
    much of each material is needed, and how much the entire garden kit will weigh.
    Sketching this concept out in code, you decide that the `Calculator` class should
    work as shown below:\r\n\r\n```ruby\r\ncalc = Calculator.new(\"yinyang\", \"diameter\"
    => \"20\", \"height\" => \"5\")\r\n\r\np calc.materials.map { |e| [e['name'],
    e['quantity'].ceil, e['unit']] } #=>\r\n# [[\"1cm thick flexible strip\", 472,
    \"sq cm\"],\r\n#  [\"granite slab\", 315, \"sq cm\"],\r\n#  [\"white sand\", 550,
    \"cu cm\"],\r\n#  [\"black sand\", 550, \"cu cm\"]]\r\n\r\np calc.shipping_weight
    #=> 4006\r\n```\r\n\r\nWith that goal in mind, the constructor for the `Calculator`
    class needs to do two chores:\r\n\r\n1. Convert the string-based dimension parameters
    provided via the web form into numeric values that Dentaku understands. An easy
    way to do this is to treat the strings as Dentaku expressions and evaluate them,
    so that a string like `\"3.1416\"` ends up getting converted to a `BigDecimal`
    object under the hood.\r\n\r\n2. Load any relevant formulas needed to compute
    the material quantities and weights -- relying on the `Project` class to figure
    out how to extract these values from the various user-provided CSV files.\r\n\r\nThe
    resulting code ends up looking like this:\r\n\r\n```ruby\r\nclass Calculator\r\n
    \ def initialize(project_name, params={})\r\n    @params = Hash[params.map { |k,v|
    [k,Dentaku(v)] }]  #1\r\n\r\n    @quantity_formulas = Project.quantity_formulas(project_name)
    \ #2\r\n    @common_formulas   = Project.common_formulas\r\n    @weight_formulas
    \  = Project.weight_formulas\r\n  end\r\n\r\n  # ...\r\nend\r\n```\r\n\r\nBecause
    a decent amount of work has already been done to massage all the relevant bits
    of data into exactly the right format, the actual work of computing required material
    quantities is surprisingly simple:\r\n\r\n1. Instantiate a `Dentaku::Calculator`
    object\r\n2. Load all the necessary common formulas into that object (e.g. `circular_area`,
    `cylinder_volume`, etc.)\r\n3. Walk over the various material quantity formulas
    and evaluate them (e.g. `\"black sand\" => \"cylinder_volume * 0.5 * fill\"`)\r\n4.
    Build up new records that map the names of materials in a project to their quantities.\r\n\r\nA
    few lines of code later, and you have a freshly minted `Calculator#materials`
    method:\r\n\r\n```ruby\r\n# class Calculator\r\n\r\n  def materials\r\n    calculator
    = Dentaku::Calculator.new #1\r\n\r\n    @common_formulas.each { |k,v| calculator.store_formula(k,v)
    }  #2\r\n    \r\n    @quantity_formulas.map do |material|\r\n      amt = calculator.evaluate(material['formula'],
    @params) #3\r\n\r\n      material.merge('quantity' => amt) #4\r\n    end\r\n  end\r\n```\r\n\r\nAnd
    for your last trick, you implement the `Calculator#shipping_weight` method. \r\n\r\nBecause
    currently all shipping weight computations are simple arithmetic operations on
    a `quantity` for each material, you don't need to load up the various common formulas
    used in the geometry equations. You just need to look up the relevant weight formulas
    by name, then evaluate them for each material in the list to get a weight value
    for that material. Sum up those values, for the entire materials list, and you're
    done!\r\n\r\n```ruby\r\n# class Calculator\r\n\r\n  def shipping_weight\r\n    calculator
    = Dentaku::Calculator.new\r\n\r\n    # Sum up weights for all materials in project
    based on quantity\r\n    materials.reduce(0.0) { |s, e| \r\n      weight = calculator.evaluate(@weight_formulas[e['name']],
    e)\r\n\r\n      s + weight\r\n    }.ceil\r\n  end\r\n```\r\n\r\nWiring the `Calculator`
    class up to your Sinatra application, you end up with a fully functional program,
    which looks just the same as it did when you mocked up the UI, but actually knows
    how to crunch numbers now.\r\n\r\nAs a sanity check, you enter the same values
    that you have been using to test the `Calculator` object on the command line into
    the Web UI, and observe the results:\r\n\r\n![](//i.imgur.com/26sV6wr.png)\r\n\r\nThey
    look correct. Mission accomplished!!!\r\n\r\n> **SOURCE FILES:** [project.rb](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/project.rb)
    // [calculator.rb](https://github.com/PracticingDeveloper/dentaku-zen-garden/blob/32e518f80b5499990a4f92af6a261594baaba88a/calculator.rb)\r\n\r\n##
    Considering the tradeoffs involved in using Dentaku\r\n\r\nIt was easy to decide
    on using Dentaku in this particular project, for several reasons:\r\n\r\n* The
    formulas used in the project consist entirely of simple arithmetic operations.\r\n\r\n*
    The tool itself is an internal application with no major performance requirements.\r\n\r\n*
    The people who will be writing the formulas already understand basic computing
    concepts.\r\n\r\n* A programmer will available to customize the workflow and assist
    with problems as needed.\r\n\r\nIf even a couple of these conditions were not
    met, the potential caveats of using Dentaku (or any similar formula processing
    tool) would require more careful consideration.\r\n\r\n**Maintainability concerns:**\r\n\r\nEven
    though Dentaku's domain specific language is a very simple one, formulas are still
    a form of code. Like all code, any formulas that run through Dentaku need to be
    tested in some way -- and when things go wrong, they need to be debugged.\r\n\r\nIf
    your use of Dentaku is limited to the sort of thing someone might type into a
    cell of an Excel spreadsheet, there isn't much of a problem to worry about. You
    can fairly easily build some sane error handling, and can provide features within
    your application to allow the user to test formulas before they go live in production.\r\n\r\nThe
    more that user-defined computations start looking like \"real programs\", the
    more you will miss the various niceties of a real programming environment. We
    take for granted things like smart code editors that understand the languages
    we're working in, revision control systems, elaborate testing tools, debuggers,
    package managers, etc. \r\n\r\nThe simple nature of Dentaku's DSL should prevent
    you from ever getting into enough complexity to require the benefits of a proper
    development environment. That said, if the use cases for your project require
    you to run complex user-defined code that looks more like a program than a simple
    formula, Dentaku would definitely be the wrong tool for the job.\r\n\r\n**Performance
    concerns:** \r\n\r\nThe default evaluation behavior of Dentaku is completely unoptimized:
    simply adding two numbers together is a couple orders of magnitude slower than
    it would be in pure Ruby. It is possible to precompile expressions by enabling
    `AST` caching, and this reduces evaluation overhead significantly. Doing so may
    introduce memory management issues at scale though, and even with this optimization
    the evaluator runs several times slower than native Ruby. \r\n\r\nNone of these
    performance issues matter when you're solving a single system of equations per
    request, but if you need to run Dentaku expressions in a tight loop over a large
    dataset, this is a problem to be aware of.\r\n\r\n**Usability concerns:**\r\n\r\nIn
    this particular project, the people who will be using Dentaku are already familair
    with writing Excel-based formulas, and they are also comfortable with technology
    in general. This means that with a bit of documentation and training, they will
    be likely to comfortably use a code-based computational tool, as long as the workflow
    is kept relatively simple.\r\n\r\nIn cases where the target audience is not assumed
    to be comfortable writing code-based mathematical expressions and working with
    raw data formats, a lot more in-application support would be required. For example,
    one could imagine building a drag-and-drop interface for designing a garden layout,
    which would in turn generate the relevant Dentaku expressions under the hood.\r\n\r\nThe
    challenge is that once you get to the point where you need to put a layer of abstraction
    between the user and Dentaku's DSL, you should carefully consider whether you
    actually need a formula processing engine at all. It's certainly better to go
    without the extra complexity when it's possible to do so, but this will depend
    heavily on the context of your particular application.\r\n\r\n**Extensibility
    concerns:** \r\n\r\nSetting up non-programmers with a means of doing their own
    computations can help cut down on a lot of tedious maintenance programming work,
    but the core domain model and data access rules are still defined by the application's
    source code.\r\n\r\nAs requirements change in a business, new data sources may
    need to be wired up, and new pieces of support code may need to be written from
    time to time. This can be challenging, because tweaks to the domain model might
    require corresponding changes to the user-defined formulas.\r\n\r\nIn practice,
    this means that an embedded formula processing system works best when either the
    data sources and core domain model are somewhat stable, or there is a programmer
    actively maintaining the system that can help guide users through any necessary
    changes that come up.\r\n\r\nWith code stored either as user-provided data files
    or even in the application's database, there is also a potential for messy and
    complicated migrations to happen whenever a big change does need to happen. This
    may be especially challenging to navigate for non-programmers, who are used to
    writing something once and having it work forever.\r\n\r\n*NOTE: Yes, this was
    a long list of caveats. Keep in mind that most of them only apply when you go
    beyond the \"let's take this set of Excel sheets and turn it into a nicely managed
    program\" use case and venture into the \"I want to embed an adhoc SDK into my
    application\" territory. The concerns listed above are meant to help you sort
    out what category your project falls into, so that you can choose a modeling technique
    wisely.*\r\n\r\n## Reflections and further explorations\r\n\r\nBy now you've seen
    that a formula parser/evaluator can be a great way to take a messy ad-hoc spreadsheet
    workflow and turn it into a slightly less messy ad-hoc web application workflow.
    This technique provides a way to balance the central management and depth of functionality
    that custom software development can offer with the flexibility and empowerment
    of putting computational modeling directly into the hands of non-programmers.\r\n\r\nAlthough
    this is not an approach that should be used in every application, it's a very
    useful modeling strategy to know about, as long as you keep a close eye on the
    tradeoffs involved.\r\n\r\nIf you'd like to continue studying this topic, here
    are a few things to try out:\r\n\r\n* Grab the [source code for the calculator
    application](https://github.com/PracticingDeveloper/dentaku-zen-garden), and run
    it on your own machine.\r\n\r\n* Create a new garden layout, with some new material
    types and shapes. For example,\r\nyou could try to create a group of concentric
    circles, or a checkerboard style design.\r\n\r\n* [Explore how to extend Dentaku's
    DSL](https://github.com/rubysolo/dentaku#external-functions) with your own Ruby
    functions.\r\n\r\n* Watch [Spreadsheets for developers](https://www.youtube.com/watch?v=0CKru5d4GPk),
    a talk by Felienne Hermans on the power and usefulness of basic spreadsheet software
    for rapid protyping and ad-hoc explorations.\r\n\r\nGood luck with your future
    number crunching, and thanks for reading!"
