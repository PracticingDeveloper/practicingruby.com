<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ways to load code</title>
  <meta name="description" content="There are many ways to load Ruby code, and that has lead to confusion over the years. In this article, I will give you the backstory behind several conventio...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/articles/ways-to-load-code">
  <link rel="alternate" type="application/rss+xml" title="Practicing Ruby" href="http://yourdomain.com/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-33127211-2', 'auto');
    ga('send', 'pageview');
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Practicing Ruby</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="/about">About</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Ways to load code</h1>
    <p class="post-meta"><time datetime="2011-08-23T00:00:00-04:00" itemprop="datePublished">Aug 23, 2011</time> • Gregory Brown</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>There are many ways to load Ruby code, and that has lead to confusion over the years. In this article, I will give you the backstory behind several conventions seen in the wild and share some stories about how I use those conventions in my own code.</p>

<p>The topic of code loading breaks up naturally into two subtopics: loading code
within your own project and loading code from third-party libraries. People tend
to struggle more with loading code properly within their own projects than they
do with loading code from third-party libraries, so that’s what I’ll focus on
exclusively in this issue.</p>

<p>For now, I will focus on the basic mechanics of <code class="highlighter-rouge">load()</code>, <code class="highlighter-rouge">auto_load()</code>,
<code class="highlighter-rouge">require()</code>, and <code class="highlighter-rouge">require_relative()</code>. I’ll discuss how they work so you can
then think about how they can be used within your own projects.</p>

<h3 id="kernelload">Kernel#load</h3>

<p>Suppose we have a file called <em>calendar.rb</em> that contains the code shown here:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Calendar</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">month</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
    <span class="vi">@month</span> <span class="o">=</span> <span class="n">month</span>
    <span class="vi">@year</span>  <span class="o">=</span> <span class="n">year</span>
  <span class="k">end</span>

  <span class="c1"># A simple wrapper around the *nix cal command.</span>
  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="no">IO</span><span class="p">.</span><span class="nf">popen</span><span class="p">([</span><span class="s2">"cal"</span><span class="p">,</span> <span class="vi">@month</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="vi">@year</span><span class="p">.</span><span class="nf">to_s</span><span class="p">])</span> <span class="p">{</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">read</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="no">Calendar</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2011</span><span class="p">)</span>
</code></pre>
</div>

<p>Given an absolute path to this file, the contents will be loaded and then
executed immediately:</p>

<pre><code class="language-console">&gt;&gt; load "/Users/seacreature/devel/practicing-ruby-2/calendar.rb"
    August 2011
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31
</code></pre>

<p>I can also just specify a path relative to my current working directory and get the same results. That means that if <em>calendar.rb</em> is in the same directory from which I invoked my irb session, I’m able to call <code class="highlighter-rouge">load()</code> in the manner shown here:</p>

<pre><code class="language-console">&gt;&gt; load "./calendar.rb"
    August 2011
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31
</code></pre>

<p>An interesting thing about <code class="highlighter-rouge">load()</code> is that it does not do any checks to see
whether it has already loaded a file and will happily reload and reexecute a
file each time you tell it to. So, in practice, the implementation of <code class="highlighter-rouge">load()</code>
is functionally similar to the code shown here:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fake_load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
  <span class="nb">eval</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
  <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The main benefit of indiscriminately reloading and reexecuting code is that you
can make changes to your files and then <code class="highlighter-rouge">load()</code> them again within a single
session without having to restart the program that’s loading the code. So, for
example, if we changed <em>calendar.rb</em> to output August 2012 instead of August
2011, we could just load it again without restarting irb. But we’d also be
greeted with some warnings in the process:</p>

<pre><code class="language-console">&gt;&gt; load "./calendar.rb"
/Users/seacreature/devel/practicing-ruby-2/calendar.rb:2: 
warning: method redefined; discarding old initialize
/Users/seacreature/devel/practicing-ruby-2/calendar.rb:2: 
warning: previous definition of initialize was here
/Users/seacreature/devel/practicing-ruby-2/calendar.rb:8: 
warning: method redefined; discarding old to_s
/Users/seacreature/devel/practicing-ruby-2/calendar.rb:8:
warning: previous definition of to_s was here
August 2012
Su Mo Tu We Th Fr Sa
      1  2  3  4
5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30 31
</code></pre>

<p>If you remember that Ruby classes and modules are permanently open to
modification, these warnings should make a lot of sense. The first time we
called <code class="highlighter-rouge">load()</code>, it defined the <code class="highlighter-rouge">initialize()</code> and <code class="highlighter-rouge">to_s()</code> methods for the
<code class="highlighter-rouge">Calendar</code> class. The second time we called <code class="highlighter-rouge">load()</code>, that class and its methods
already existed, so it redefined them. This is not necessarily a sign of a bug,
but Ruby warns you of the possibility that it might be.</p>

<p>Ultimately, these warnings are Ruby telling you that there is probably a better
way for you to do what you’re trying to do. One interesting way to get around
the problem is to use <code class="highlighter-rouge">Kernel#load()</code>’s wrap functionality.  Rather than telling
you directly how it works, I’m going to show you by example and see if you can
guess what’s going on.</p>

<p>Suppose we kill our irb session and fire up a new one; we’re now back to a blank
slate. We then run the following code and see the familiar calendar output:</p>

<pre><code class="language-console">&gt;&gt; load "./calendar.rb", true
    August 2012
Su Mo Tu We Th Fr Sa
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30 31
</code></pre>

<p>Then we decide that we want to look a little deeper into the future so that we
know what to plan for in AD 2101. We reload the code using the same command as
before:</p>

<pre><code class="language-console">&gt;&gt; load "./calendar.rb", true
    August 2101
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31
</code></pre>

<p>This time, we don’t see any warnings, so obviously something has changed. Here’s
a clue:</p>

<pre><code class="language-console">&gt;&gt; Calendar
NameError: uninitialized constant Object::Calendar
  from (irb):2
  from /.../.rvm/rubies/ruby-1.9.2-p180/bin/irb:16:in `&lt;main&gt;'
</code></pre>

<p>Surely the <code class="highlighter-rouge">Calendar</code> class must have been defined <em>somewhere</em>, because the
program worked as expected. So what is going on here? Take a look at the
following code; it should give you a clearer picture of what is happening:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fake_load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
  <span class="no">Module</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">module_eval</span><span class="p">(</span><span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
  <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>

<p>In this implementation, our approximation of <code class="highlighter-rouge">load()</code> is evaluating the loaded
code in the context of an anonymous module, which essentially wraps everything
its own namespace. This step prevents any of the constants defined in the loaded
code from being defined within the global namespace, including any class or
module definitions.</p>

<p>The existence of this option is a hint that although <code class="highlighter-rouge">load()</code> is suitable for
code loading, it is geared more to implementing customized runners for Ruby code
than to simply loading the classes and modules in your projects. So if you’ve
been using <code class="highlighter-rouge">load()</code> on a daily basis, you might be using the wrong tool for the
job at least some of the time. It should be clear by the end of this article why
that is the case.</p>

<p>Now that we have looked at the most simple code loading behavior Ruby has to
offer, we will jump straight into the deep end and explore one of its most
complex options: loading code on demand via <code class="highlighter-rouge">Kernel#autoload</code>.</p>

<h3 id="kernelautoload">Kernel#autoload</h3>

<p>Regardless of whether you’ve used it explicitly in your own projects, the
concept of automatically loading code on demand should be familiar to anyone
familiar with Rails. In Rails, none of the classes or modules you define are
loaded until the first time they are referenced in your running program. There
are two main benefits to this design: faster startup time and delayed loading of
optional dependencies.</p>

<p>Rails uses its own customized code to accomplish this result, but the basic idea
is similar to what can be done with Ruby’s <code class="highlighter-rouge">autoload()</code> method. To illustrate
how <code class="highlighter-rouge">autoload()</code> works, let’s revisit our <code class="highlighter-rouge">Calendar</code> class that we began
building while discussing <code class="highlighter-rouge">load()</code>. This time, we have a file called
<em>calendar.rb</em> that contains only the definition of the <code class="highlighter-rouge">Calendar</code> class, not the
code that actually calls methods on it:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Calendar</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">month</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
    <span class="vi">@month</span> <span class="o">=</span> <span class="n">month</span>
    <span class="vi">@year</span>  <span class="o">=</span> <span class="n">year</span>
  <span class="k">end</span>

  <span class="c1"># A simple wrapper around the *nix cal command.</span>
  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="no">IO</span><span class="p">.</span><span class="nf">popen</span><span class="p">([</span><span class="s2">"cal"</span><span class="p">,</span> <span class="vi">@month</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="vi">@year</span><span class="p">.</span><span class="nf">to_s</span><span class="p">])</span> <span class="p">{</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">read</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The following irb session demonstrates the behavior of <code class="highlighter-rouge">autoload()</code>.</p>

<pre><code class="language-console">&gt;&gt; autoload(:Calendar, "./calendar.rb") #1
=&gt; nil
&gt;&gt; defined?(Calendar)                   #2
=&gt; nil
&gt;&gt; puts Calendar.new(8,2011)            #3
    August 2011
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31

=&gt; nil
&gt;&gt; defined?(Calendar)                   #4
=&gt; "constant"
</code></pre>

<p>In our first step, we set up the <code class="highlighter-rouge">autoload()</code> hook, instructing Ruby to load the
file <em>calendar.rb</em> at the time that the first constant lookup happens for the
Calendar constant. In the second step, we check to ensure that <code class="highlighter-rouge">autoload()</code> does
not actually load the file for you automatically by verifying that Calendar has
not yet been defined. Then, in our third step, we build and output our Calendar.
Last, we see that the constant is now defined.</p>

<p>This exposes us to some cool Ruby voodoo while also raising a lot of questions.
It may help to approximate how <code class="highlighter-rouge">autoload()</code> might be implemented in order to
wrap your head around the idea. Although the following code is evil and should
never be used for anything but educational purposes, it simulates the load on
demand behavior nicely.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="vg">$load_hooks</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span>

<span class="k">module</span> <span class="nn">Kernel</span>
  <span class="k">def</span> <span class="nf">fake_autoload</span><span class="p">(</span><span class="n">constant_name</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
    <span class="vg">$load_hooks</span><span class="p">[</span><span class="n">constant_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">Object</span><span class="o">.</span><span class="nf">const_missing</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
  <span class="nb">load</span> <span class="vg">$load_hooks</span><span class="p">[</span><span class="n">constant</span><span class="p">]</span>
  <span class="nb">const_get</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">fake_autoload</span> <span class="ss">:Calendar</span><span class="p">,</span> <span class="s2">"./calendar.rb"</span>
<span class="nb">p</span> <span class="n">defined?</span><span class="p">(</span><span class="no">Calendar</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Calendar</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">2011</span><span class="p">)</span>
<span class="nb">p</span> <span class="n">defined?</span><span class="p">(</span><span class="no">Calendar</span><span class="p">)</span>
</code></pre>
</div>

<p>After reading the previous example code and playing with it a bit, remember the
dependency on <code class="highlighter-rouge">const_missing()</code> and forget pretty much everything else about the
implementation. The real <code class="highlighter-rouge">autoload()</code> handles a lot more cases than this trivial
example gives it credit for.</p>

<p>With the <code class="highlighter-rouge">const_missing()</code> dependency in mind, try to guess what will happen
when the following code is run:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Calendar</span><span class="p">;</span> <span class="k">end</span>

<span class="nb">autoload</span> <span class="ss">:Calendar</span><span class="p">,</span> <span class="s2">"./calendar.rb"</span>
<span class="nb">p</span> <span class="n">defined?</span><span class="p">(</span><span class="no">Calendar</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Calendar</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">2011</span><span class="p">)</span>
<span class="nb">p</span> <span class="n">defined?</span><span class="p">(</span><span class="no">Calendar</span><span class="p">)</span>
</code></pre>
</div>

<p>If you guessed that it didn’t output a nicely formatted calendar, you guessed
correctly. Below you can see that when I run this script, all the code in
<em>calendar.rb</em> never gets loaded, so the default <code class="highlighter-rouge">Object#initialize</code> and
<code class="highlighter-rouge">Object#to_s</code> are being called instead:</p>

<pre><code class="language-console">"constant"
&lt;Calendar:0x0000010086d6b0&gt;
"constant"
</code></pre>

<p>Because <code class="highlighter-rouge">autoload()</code> does not check to see whether a constant is already defined
when it registers its hook, you do not get an indication that the <em>calendar.rb</em>
file was never loaded until you actually try to use functionality defined in
that file. Thus <code class="highlighter-rouge">autoload()</code> is safe to use only when there is a single, uniform
place where a constant is meant to be defined; it cannot be used to
incrementally build up class or module definitions from several different source
files.</p>

<p>This sort of rigidity is frustrating, because unlike load(), which does not care
how or where you define your code, <code class="highlighter-rouge">autoload()</code> is much more opinionated. What
you’ve seen here is a single example of the constraints it puts on you, but it
is easy to imagine other scenarios in which <code class="highlighter-rouge">autoload()</code> can feel like a brittle
way to load code. I’ll leave it up to you to try to figure out some of those
issues, but feel free to ask me for some hints if you get stumped.</p>

<p>In the context of Rails—particularly when working in development mode, in which
the whole environment gets reloaded on every request—some form of automatic
loading makes sense. However, outside of that environment, the drawbacks of
<code class="highlighter-rouge">autoload()</code> tend to outweigh the benefits, so most Ruby projects tend to avoid
it entirely by making heavy use of <code class="highlighter-rouge">require()</code>.</p>

<h3 id="kernelrequire">Kernel#require()</h3>

<p>If you’ve written any code at all outside of Rails, odds are you’ve used
<code class="highlighter-rouge">require()</code> before. It is actually quite similar to <code class="highlighter-rouge">load()</code> but has a few
additional features that come in handy. To illustrate how <code class="highlighter-rouge">require()</code> works,
let’s revisit our original <em>calendar.rb</em> file, the one that had a bit of code to
be executed in the end of it.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Calendar</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">month</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
    <span class="vi">@month</span> <span class="o">=</span> <span class="n">month</span>
    <span class="vi">@year</span>  <span class="o">=</span> <span class="n">year</span>
  <span class="k">end</span>

  <span class="c1"># A simple wrapper around the *nix cal command.</span>
  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="no">IO</span><span class="p">.</span><span class="nf">popen</span><span class="p">([</span><span class="s2">"cal"</span><span class="p">,</span> <span class="vi">@month</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="vi">@year</span><span class="p">.</span><span class="nf">to_s</span><span class="p">])</span> <span class="p">{</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">read</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="no">Calendar</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2011</span><span class="p">)</span>
</code></pre>
</div>

<p>If we attempt to load this code twice via <code class="highlighter-rouge">require()</code>, we immediately see an
important way in which it differs from <code class="highlighter-rouge">load()</code>.</p>

<pre><code class="language-console">&gt;&gt; require "./calendar.rb" #1
    August 2011
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31

=&gt; true
&gt;&gt; require "./calendar.rb" #2
=&gt; false
</code></pre>

<p>When I ran <code class="highlighter-rouge">require()</code> the first time, the familiar calendar output greeted me,
and then the function returned a true value. The second time I ran it, nothing
happened and the function returned false. This is a feature, and not a bug. The
following code is a crude approximation of what is going on under the hood in
<code class="highlighter-rouge">require()</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="vg">$LOADED_BY_FAKE_REQUIRE</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span>

<span class="k">def</span> <span class="nf">fake_require</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
  <span class="n">full_path</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">expand_path</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
  <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="vg">$LOADED_BY_FAKE_REQUIRE</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span>

  <span class="nb">load</span> <span class="n">full_path</span>
  <span class="vg">$LOADED_BY_FAKE_REQUIRE</span> <span class="o">&lt;&lt;</span> <span class="n">full_path</span>

  <span class="k">return</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This behavior ensures that each file loaded by <code class="highlighter-rouge">require()</code> is loaded exactly
once, even if the <code class="highlighter-rouge">require()</code> calls appear in many places. Therefore, updates to
those files will take effect after they have been loaded once. Although this
behavior makes <code class="highlighter-rouge">require()</code> less suitable than <code class="highlighter-rouge">load()</code> for quick exploratory
code loading, it does prevent programs from needlessly reloading the same code
again and again, similar to how <code class="highlighter-rouge">autoload()</code> works once a constant has been
loaded.</p>

<p>Another interesting property of <code class="highlighter-rouge">require()</code> is that you can omit the file
extension when loading your code. Thus <code class="highlighter-rouge">require("./calendar")</code> will work just as
well as <code class="highlighter-rouge">require("./calendar.rb")</code>. Though this may seem like a small feature,
the reason it exists is that Ruby can load more than just Ruby files.
When you omit an extension on a file loaded with <code class="highlighter-rouge">require()</code>, it will attempt to
load the file with the “.rb” extension first, but will then cycle through the
file extensions used by C extensions as well, such as “.so”, “.o”, and “.dll”.
Despite being an obscure property, it’s one that we often take for
granted when we load certain standard libraries or third-party gems. This
behavior is another detail that separates <code class="highlighter-rouge">require()</code> from <code class="highlighter-rouge">load()</code>, as the
latter can work only with explicit file extensions.</p>

<p>The main benefit of using <code class="highlighter-rouge">require()</code> is that it provides the explicit,
predictable loading behavior of <code class="highlighter-rouge">load()</code> with the caching functionality of
<code class="highlighter-rouge">autoload()</code>. It also feels natural for those who use RubyGems, as the standard
way of loading libraries distributed as gems is via the patched version of
<code class="highlighter-rouge">Kernel#require()</code> that RubyGems provides.</p>

<p>Using <code class="highlighter-rouge">require()</code> will take you far, but it suffers from a pretty irritating
problem—shared by <code class="highlighter-rouge">load()</code> and <code class="highlighter-rouge">autoload()</code>—with the way it looks up files. The
<code class="highlighter-rouge">require_relative()</code> is meant to solve that problem, so we’ll take a look at it
now.</p>

<h3 id="kernelrequirerelative">Kernel#require_relative()</h3>

<p>Each time I referenced files using a relative path in the previous examples, I
wrote the path to explicitly reference the current working directory. If you’re
used to using Ruby 1.8, this may come as a surprise to you. If you’ve been using
Ruby 1.9.2, it may or may not appear to be the natural thing to do. However, now
is the time when I confess that it’s almost always the wrong way to go about
things.</p>

<p>Ruby 1.9.2 removes the current working directory from your path by default for
security reasons. So, in our previous example, if we attempted to write
<code class="highlighter-rouge">require("calendar")</code> instead of <code class="highlighter-rouge">require("./calendar")</code>, it would fail on Ruby
1.9.2 even if we invoked irb in the same folder as the <em>calendar.rb</em> file.
Explicitly referencing the current working directory works on both Ruby 1.8.7
and Ruby 1.9.2, which is why this convention was born. Unfortunately, it is an
antipattern, because it forces us to assume that our code will be run from a
particular place on the file system.</p>

<p>Imagine a more typically directory structure, such as this:</p>

<pre><code class="language-console">lib/
  calendar.rb
  calendar/
    month.rb
    year.rb
bin/
  calendar.rb
</code></pre>

<p>We could have a <em>bin/ruby_calendar.rb</em> file that looks like this code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"lib/calendar"</span>

<span class="k">case</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">size</span>
<span class="k">when</span> <span class="mi">2</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Month</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="no">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">when</span> <span class="mi">1</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Year</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">else</span>
  <span class="k">raise</span> <span class="s2">"Invalid arguments"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Similarly, our <em>lib/calendar.rb file</em> might include <code class="highlighter-rouge">require()</code> calls such as
these:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"lib/calendar/year"</span>
<span class="nb">require</span> <span class="s2">"lib/calendar/month"</span>
</code></pre>
</div>

<p>Now if we run <em>bin/ruby_calendar.rb</em> from the project root, things will work as
expected.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>ruby bin/ruby_calendar.rb 2011
<span class="c"># ...</span>
</code></pre>
</div>

<p>But if we ran this file from any other directory, it’d fail to work as expected
because the relative paths would be evaluated relative to wherever you executed
the files from, not relative to where the files live on the file system. That
is, if you execute <em>ruby_calendar.rb</em> in the <em>bin/</em> folder, it would look for a file
called <em>bin/lib/calendar.rb</em>.</p>

<p>One way to solve this problem is to use the same mechanism that the Ruby
standard library and RubyGems uses: modify the loadpath.</p>

<p>In <em>bin/ruby_calendar.rb</em>, we rewrite our code to match this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="vg">$LOAD_PATH</span><span class="p">.</span><span class="nf">unshift</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/../lib"</span><span class="p">)</span>
<span class="nb">require</span> <span class="s2">"calendar"</span>

<span class="k">case</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">size</span>
<span class="k">when</span> <span class="mi">2</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Month</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="no">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">when</span> <span class="mi">1</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Year</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">else</span>
  <span class="k">raise</span> <span class="s2">"Invalid arguments"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Because we’ve added the <em>lib/</em> folder to the lookup path for all <code class="highlighter-rouge">require()</code>
calls in our application, we can modify <em>lib/calendar.rb</em> to match the
following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"calendar/year"</span>
<span class="nb">require</span> <span class="s2">"calendar/month"</span>
</code></pre>
</div>

<p>This approach makes it possible to run the <em>ruby_calendar.rb</em> program from any
location within the file system, as long as we tell ruby where to find it. That
means you can run it directly from within the <em>bin/</em> folder, or even with an
absolute path.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c"># NOTE: this is common in cron jobs.</span>
<span class="gp">$ </span>ruby /Users/seacreature/devel/ruby_calendar/bin/ruby_calendar.rb
</code></pre>
</div>

<p>This approach works, and was quite common in Ruby for some time. Then, people
began to get itchy about it, because it is definitely overkill. It effectively
adds an entire folder to the <code class="highlighter-rouge">$LOAD_PATH</code>, giving Ruby one more place it has to
look on every require and possibly leading to unexpected naming conflicts
between libraries.</p>

<p>The solution to that problem is to not mess with the <code class="highlighter-rouge">$LOAD_PATH</code> in your code.
Therefore, you expect either that the <code class="highlighter-rouge">$LOAD_PATH</code> variable will be properly set
by the <code class="highlighter-rouge">-I</code> flag when you invoke ruby or irb, or that you have to write code
that dynamically determines the proper relative paths to require based on your
current working directory. The latter approach requires less effort from the end
user but makes your code ugly. Below you’ll see what people resorted to on Ruby
1.8 before a better solution came along:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># bin/ruby_calendar.rb</span>
<span class="nb">require</span> <span class="s2">"</span><span class="si">#{</span><span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/../lib/calendar"</span>

<span class="k">case</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">size</span>
<span class="k">when</span> <span class="mi">2</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Month</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="no">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">when</span> <span class="mi">1</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Year</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">else</span>
  <span class="k">raise</span> <span class="s2">"Invalid arguments"</span>
<span class="k">end</span>

<span class="c1"># lib/calendar.rb</span>
<span class="nb">require</span> <span class="s2">"</span><span class="si">#{</span><span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/calendar/year"</span>
<span class="nb">require</span> <span class="s2">"</span><span class="si">#{</span><span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/calendar/month"</span>
</code></pre>
</div>

<p>Using this approach, you do not add anything to the <code class="highlighter-rouge">$LOAD_PATH</code> but instead
dynamically build up relative paths by referencing the <code class="highlighter-rouge">__FILE__</code> variable and
getting a path to the directory it’s in. This code will evaluate to different
values depending on where you run it from, but in the end, the right path will
be produced and things will just work.</p>

<p>Predictably, people took efforts to hide this sort of ugliness behind helper
functions, and one such function was eventually adopted into Ruby 1.9. That
helper is predictably called <code class="highlighter-rouge">require_relative()</code>. Using <code class="highlighter-rouge">require_relative()</code>,
we can simplify our calls significantly while preserving the “don’t touch the
<code class="highlighter-rouge">$LOAD_PATH</code> variable” ethos:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># bin/ruby_calendar.rb</span>
<span class="nb">require_relative</span> <span class="s2">"../lib/calendar"</span>

<span class="k">case</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">size</span>
<span class="k">when</span> <span class="mi">2</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Month</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="no">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">when</span> <span class="mi">1</span>
  <span class="nb">puts</span> <span class="no">Calendar</span><span class="o">::</span><span class="no">Year</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">else</span>
  <span class="k">raise</span> <span class="s2">"Invalid arguments"</span>
<span class="k">end</span>

<span class="c1"># lib/calendar.rb</span>
<span class="nb">require_relative</span> <span class="s2">"calendar/year"</span>
<span class="nb">require_relative</span> <span class="s2">"calendar/month"</span>
</code></pre>
</div>

<p>This code looks and feels like it would work in the way that we’d like to think
<code class="highlighter-rouge">require()</code> would work. The files we reference are relative to the file in which
the actual calls are made, rather than the folder in which the script was
executed in. For this reason, it is a much better approach than pretty much
anything I’ve shown so far.</p>

<p>Of course, it is not a perfect solution. In some cases, it does not work as
expected, such as in Rackup files. Additionally, because it’s a Ruby 1.9
feature, it’s not built into Ruby 1.8.7. The former issue cannot be worked
around, but the latter can be. I’ll go into a bit more detail about both of
these issues in the recommendations section, which is coming up right now.</p>

<h3 id="conventions-and-recommendations">Conventions and Recommendations</h3>

<p>If you remember one thing from this article, it should be that whenever it’s
possible to use <code class="highlighter-rouge">require_relative()</code> and there isn’t an obviously better
solution, it’s probably the right tool to reach for. It has the fewest 
dark corners and pretty much just works.</p>

<p>That said, take my advice with a grain of salt. I no longer actively
maintain any Ruby 1.8 applications, nor do I have to deal with code that must
run on both Ruby 1.8 and 1.9. If I were in those shoes again, I’d weigh
out four different possible ways of approaching things:</p>

<p>1) Explicitly use <code class="highlighter-rouge">require()</code> with the <code class="highlighter-rouge">File.dirname(__FILE__)</code> hack</p>

<p>2) Write my own <code class="highlighter-rouge">require_relative()</code> implementation leaning on the previous
   hack that gets defined only if <code class="highlighter-rouge">require_relative()</code> isn’t already
   implemented</p>

<p>3) Add a dependency for Ruby 1.8 only on the <code class="highlighter-rouge">require_relative</code> gem</p>

<p>4) Assume that <code class="highlighter-rouge">$LOAD_PATH</code> is set for me via the <code class="highlighter-rouge">-I</code> flag on execution,
   or some other means, and then write ordinary require calls 
   relative to the <em>lib/</em> folder in my project.</p>

<p>I can’t give an especially good picture of when I’d pick one of those options
over the other, because it’s been about a year since I’ve last had to think
about it. But any of those four options seem like at least reasonable ideas. I
would <em>not</em> employ the common but painfully ugly
<code class="highlighter-rouge">require("./file_in_the_working_dir.rb")</code> hack in any code that I expected to
use for anything more than a spike or demonstration.</p>

<p>Whether using <code class="highlighter-rouge">require_relative()</code> explicitly, or one of the workarounds listed
above, I like to use some form of relative require whenever I can. Occasionally,
I do use <code class="highlighter-rouge">load()</code>, particularly in spikes where I want to  reload files into an
irb session without restarting irb.  But I don’t think that <code class="highlighter-rouge">load()</code> ends up in
production code of mine unless there is a very good reason to use it. A possible
good reason would be if I were building some sort of script runner, such as what
you could find in Rails when it reloads your development environment or in
autotest. In the autotest case in particular in which your test files are
reloaded each time you make an edit to any of your files in your project, it
seems that using <code class="highlighter-rouge">load()</code> with its obscure second parameter is a good idea. But
these are not tools I’d expect to be building on a daily basis, so <code class="highlighter-rouge">load()</code>
remains somewhat of an obscure tool for me.</p>

<p>I never use <code class="highlighter-rouge">autoload()</code>. I’ve just not run into the issues that some folks in
Rails experience regarding slow startup times of applications in any way that
has mattered to me. I feel like the various gotchas that come along with using
<code class="highlighter-rouge">autoload()</code> and the strict conventions it enforces are not good things to
impose on general-purpose uses of Ruby. I don’t know whether I think that it
makes sense in to context of Rails, but that’s a very different question than
whether it should be used in ordinary Ruby applications and libraries. It makes
at least some sense in Rails, but in most Ruby applications, it does not. The
only time I might think about looking into <code class="highlighter-rouge">autoload()</code> is if I had some sort of
optional dependency that I wanted to be loaded only on demand. I have never
actually run into that issue, and I’ve found that the following hack provides a
way to do optional dependencies that seems to work just fine:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">begin</span>
  <span class="nb">require</span> <span class="s2">"some_external_dependency"</span>
  <span class="nb">require</span> <span class="s2">"my_lib/some_feature_that_depends_on_dependency"</span>
<span class="k">rescue</span> <span class="no">LoadError</span>
  <span class="nb">warn</span> <span class="s2">"Could not load some_external_dependency."</span><span class="o">+</span>
       <span class="s2">" Some features are disabled"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>But really, optional dependencies are things I very rarely need to think about.
There are valid use cases for them, but unless something is very difficult to
install or your project is specifically meant to wrap various mutually exclusive
dependencies, I typically will just load up all my dependencies regardless of
whether the user ends up using them. This policy has not caused me problems,
but your mileage will vary depending on the type of work you are doing.</p>

<p>On a somewhat tangential note, I try to avoid things like dynamic require calls
in which I walk over a file list generated from something like <code class="highlighter-rouge">Dir.glob()</code> or
the like. I also avoid using <code class="highlighter-rouge">Bundler.require()</code>, even when I use bundler. The
reason I avoid these things is because I like to be able control the exact order
in which my files and my dependencies are being loaded. It’s possible to not
have to worry about this sort of thing, but doing so requires a highly
disciplined way of organizing your code so that files can be loaded
independently.</p>

<h3 id="questions--feedback">Questions / Feedback</h3>

<p>I hope this background story about the various ways to load code along with the
few bits of advice I’ve offered in the end here have been useful to you. I am
happy to answer whatever questions you have; just leave a comment below.</p>

  </div>

  <div style="text-align: center">
    <h3><a href="/">Want to keep reading? Check out the archives for more.</a></h3>

    <small>Practicing Ruby is proudly independent, open source, and advertising free.<br/>If you insist on being asked for something in return, check out <a href="/support">how to support my work</a>.</small>
  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Send questions and feedback to:</li>
          <li><a href="mailto:gregory@practicingdeveloper.com">gregory@practicingdeveloper.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/practicingdeveloper"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">practicingdeveloper</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/practicingdev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">practicingdev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The world's largest collection of lessons for experienced Ruby developers.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
